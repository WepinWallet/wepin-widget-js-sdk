var w0 = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var $r = (e, t, r) => (w0(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Aa = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, lr = (e, t, r, i) => (w0(e, t, "write to private field"), i ? i.call(e, r) : t.set(e, r), r);
const m0 = class m0 {
  static closeOverlay(t) {
    const r = document.querySelector(`#${t}`);
    r && r.parentNode && r.parentNode.removeChild(r);
  }
  static openOverlay(t) {
    const r = document.createElement("div");
    r.id = t, r.classList.add(this.CONST.overlayClassName), r.style.zIndex = "2147483647", r.style.display = "flex", r.style.alignItems = "center", r.style.justifyContent = "center", r.style.textAlign = "center", r.style.position = "fixed", r.style.left = "0px", r.style.right = "0px", r.style.top = "0px", r.style.bottom = "0px", r.style.left = "0px", r.style.background = "rgba(0,0,0,0.6)", r.style.color = "white", r.style.border = "2px solid #f1f1f1";
    const i = document.getElementsByClassName(
      this.CONST.overlayClassName
    );
    for (let o = 0; o < i.length; o++) {
      const n = i.item(o);
      n && n.remove();
    }
    document.body.appendChild(r);
  }
};
m0.CONST = {
  overlayClassName: "wepin-widget__overlay"
};
let Lc = m0;
const Og = "ko", Pg = "krw", Ma = "wepin:widget:", Sn = class Sn {
};
Sn.test = console.warn.bind(window.console, "[SDK][test] "), Sn.warn = console.warn.bind(window.console, "[SDK][warn] "), Sn.error = console.error.bind(window.console, "[SDK][error] "), Sn.todo = console.warn.bind(window.console, "[SDK][todo] "), Sn.assert = console.assert.bind(window.console), Sn.debug = () => {
};
let $t = Sn;
function kc(e) {
  this.message = e;
}
kc.prototype = new Error(), kc.prototype.name = "InvalidCharacterError";
var _0 = typeof window < "u" && window.atob && window.atob.bind(window) || function(e) {
  var t = String(e).replace(/=+$/, "");
  if (t.length % 4 == 1)
    throw new kc("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var r, i, o = 0, n = 0, f = ""; i = t.charAt(n++); ~i && (r = o % 4 ? 64 * r + i : i, o++ % 4) ? f += String.fromCharCode(255 & r >> (-2 * o & 6)) : 0)
    i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i);
  return f;
};
function Cg(e) {
  var t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(r) {
      return decodeURIComponent(_0(r).replace(/(.)/g, function(i, o) {
        var n = o.charCodeAt(0).toString(16).toUpperCase();
        return n.length < 2 && (n = "0" + n), "%" + n;
      }));
    }(t);
  } catch {
    return _0(t);
  }
}
function to(e) {
  this.message = e;
}
function Ng(e, t) {
  if (typeof e != "string")
    throw new to("Invalid token specified");
  var r = (t = t || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(Cg(e.split(".")[r]));
  } catch (i) {
    throw new to("Invalid token specified: " + i.message);
  }
}
to.prototype = new Error(), to.prototype.name = "InvalidTokenError";
class Qt {
  static isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }
  static messages(t) {
    return {
      hasValidOrigin: (r) => r.origin === Qt.getUrls(t).wepinWebview
      // hasCorrectCorrelationID(message: MessageEvent,
      //                         correlationID: string | undefined) {
      //     return correlationID && message.data && message.data.correlationID === correlationID;
      // }
    };
  }
  static getUrls(t) {
    switch (t) {
      case "production":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://widget.wepin.io"
        };
      case "test":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://stage-widget.wepin.io"
        };
      case "development":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://dev-widget.wepin.io"
        };
      default:
        throw new Error("Utils.getUrls: invalid mode");
    }
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function(t) {
        const r = Math.random() * 16 | 0;
        return (t == "x" ? r : r & 3 | 8).toString(16);
      }
    );
  }
  static getLocalStorgeEnabled() {
    let t = !1;
    try {
      t = window.localStorage && !0;
    } catch {
      t = !1;
    }
    return t;
  }
  static setLocalStorage(t, r) {
    if (!this.getLocalStorgeEnabled()) {
      $t.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const i = JSON.stringify(r);
    localStorage.setItem(Ma + t, i);
  }
  static getLocalStorage(t) {
    if (!this.getLocalStorgeEnabled()) {
      $t.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    return localStorage.getItem(Ma + t) ? JSON.parse(localStorage.getItem(Ma + t)) : void 0;
  }
  static clearLocalStorage(t) {
    if (!this.getLocalStorgeEnabled()) {
      $t.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(Ma + t);
  }
  static isExpired(t) {
    var i;
    if (!t)
      return !0;
    const r = (i = Ng(t)) == null ? void 0 : i.exp;
    return $t.debug("isExpiredRefreshToken expired", r), $t.debug("Date.now()", Date.now()), $t.debug(
      " Math.floor(Date.now()/1000) + (60*60)",
      Math.floor(Date.now() / 1e3)
    ), r <= Math.floor(Date.now() / 1e3) + 60;
  }
}
const Lg = 1, kg = (e, t, r) => {
  var n, f, u;
  const i = {
    header: {
      response_from: "web",
      response_to: "wepin_widget",
      id: e.header.id
    }
  };
  switch (e.body.command) {
    case "ready_to_widget":
      $t.debug("ready_to_widget"), i.body = {
        command: "ready_to_widget",
        state: "SUCCESS",
        data: {
          appKey: r,
          domain: t.Wepin.wepinDomain,
          platform: Lg,
          attributes: t.Wepin.wepinAppAttributes,
          version: t.Wepin.version.includes("-alpha") ? t.Wepin.version.substring(
            0,
            t.Wepin.version.indexOf("-")
          ) : t.Wepin.version,
          localDate: Qt.getLocalStorage(t.Wepin.wepinAppId) ?? {}
        }
      };
      break;
    case "initialized_widget":
      $t.debug("initialized_widget resulte =>", (n = e.body.parameter) == null ? void 0 : n.result), t.Wepin._isInitialized = (f = e.body.parameter) == null ? void 0 : f.result, i.body = {
        command: "initialized_widget",
        state: "SUCCESS",
        data: ""
      }, t.Wepin.emit("widgetOpened");
      break;
    case "set_accounts":
      t.Wepin.setAccountInfo((u = e.body.parameter) == null ? void 0 : u.accounts), i.body = {
        command: "set_accounts",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "close_wepin_widget":
      t.close();
      break;
    case "dequeue_request":
      t.Wepin.queue[0] ? (o(), i.body = {
        command: e.body.command,
        state: "SUCCESS",
        data: t.Wepin.queue[0]
        // 요청이 실제로 처리된 후 제거하기 때문에 실제 dequeue 하지 않는다.
      }) : i.body = {
        command: e.body.command,
        state: "ERROR",
        data: null
      };
      break;
    case "set_user_info":
      t.Wepin.setUserInfo(e.body.parameter, !0), i.body = {
        command: "set_user_info",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "wepin_logout":
      $t.debug("wepin_logout"), t.Wepin.emit("onLogout", e.body.parameter), i.body = {
        command: "wepin_logout",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "set_local_storage":
      Qt.setLocalStorage(
        t.Wepin.wepinAppId,
        e.body.parameter.data
      ), t.Wepin.setUserInfo(e.body.parameter.data.user_login_info), i.body = {
        command: "set_local_storage",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "set_user_email":
      i.body = {
        command: "set_user_email",
        state: "SUCCESS",
        data: {
          email: t.specifiedEmail
        }
      };
      break;
    default:
      throw new Error(`Command ${e.body.command} is not supported.`);
  }
  t.isOpen && t.response(i);
  function o() {
    if (t.type === "Window") {
      const c = t.Wepin.queue[0].header.id, h = setInterval(() => {
        try {
          if (t.Webview.closed) {
            clearInterval(h), t.close();
            const s = t.Wepin.queue[0];
            s.header.id === c && (t.Wepin.emit(s.header.id.toString(), {
              header: {
                response_from: "wepin_widget",
                response_to: "web",
                id: s.header.id
              },
              body: {
                command: s.body.command,
                state: "ERROR",
                data: "User Cancel"
              }
            }), t.Wepin.queue.shift());
          }
        } catch {
          clearInterval(h), t.close();
        }
      }, 200);
    }
  }
}, jg = (e, t) => {
  $t.debug("Got Response from webview =>", e), t.queue.shift(), t.emit(e.header.id.toString(), e);
}, qg = (e, t) => {
  const r = (i) => !(!(e.url.includes("/wepin-sdk-login") || e.url.includes(i.origin)) && i.origin !== e.url || !Object.prototype.hasOwnProperty.call(i.data, "header") || !Object.prototype.hasOwnProperty.call(i.data, "body"));
  return (i) => {
    r(i) && Dg(
      i.data,
      e,
      t
    );
  };
}, Dg = (e, t, r) => {
  e.header.request_to === "web" ? kg(e, t, r) : e.header.response_to === "web" ? jg(e, t.Wepin) : $t.error("Failed to handle message:", e);
};
class ra extends Lc {
  constructor(t, r, i, o, n, f, u) {
    super(), this.url = t, this.id = `id-${Qt.uuidv4()}`, this.isHide = f, this.specifiedEmail = u, f || ra.openOverlay(this.id), this._wepin = r, this._webview = i, this.type = o, this.EL = qg(this, n), window.addEventListener("message", this.EL), this._open = !0, $t.debug(`Widget(${this.id}) is succefully created. The url is: ${t}`);
  }
  get isOpen() {
    return this._open;
  }
  get Wepin() {
    return this._wepin;
  }
  get Webview() {
    return this._webview;
  }
  clearWebview() {
    this._webview = null;
  }
  close() {
    this.isHide || ra.closeOverlay(this.id), window.removeEventListener("message", this.EL), this.Wepin.removeAllListeners("onAccountSet"), this.Wepin.removeAllListeners("widgetOpened"), this.Wepin.emit("widgetClosed"), this.Wepin.removeAllListeners(), this._open = !1, this._closeWebview();
  }
  response(t) {
    try {
      this._post(t);
    } catch (r) {
      $t.error("Can not response message to the webview", r);
    }
  }
  request(t) {
    try {
      this._post(t);
    } catch (r) {
      $t.error("Can not send message to the webview", r);
    }
  }
}
const $g = (e) => {
  const t = (e == null ? void 0 : e.width) || 375, r = (e == null ? void 0 : e.height) || 604, i = e != null && e.sLeft ? e == null ? void 0 : e.sLeft : window.screenLeft ? window.screenLeft : window.screenX ? window.screenX : 0, o = e != null && e.sTop ? e == null ? void 0 : e.sTop : window.screenTop ? window.screenTop : window.screenY ? window.screenY : 0, n = screen.width / 2 - t / 2 + i, f = screen.height / 2 - r / 2 + o;
  return `width=${t}, height=${r}, left=${n}, top=${f}scrollbars=yes, resizable=1, menubar=no, toolbar=no`;
}, Ug = (e) => {
  const t = document.createElement("iframe");
  return t.classList.add("wepin-sdk-widget-iframe"), t.setAttribute("frameborder", "0"), t.setAttribute("marginwidth", "0"), t.setAttribute("marginheight", "0"), t.style.width = "100%", e && (e != null && e.isHide) ? t.style.height = "0" : t.style.height = "100%", t.style.maxHeight = "100%", t.style.position = "fixed", t.style.bottom = "0", t.style.left = "0", t.style.zIndex = "408888000000", t.title = "wepin sdk webview", t.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", t.allowFullscreen = !0, t;
};
class Fn extends ra {
  constructor({
    url: t,
    wepin: r,
    webview: i,
    wepinAppKey: o,
    isHide: n,
    specifiedEmail: f
  }) {
    super(t, r, i, "Window", o, n, f);
  }
  //: NodeJS.Timer | number
  static async openNew(t, r, i, o, n) {
    const f = $g(o), u = "Wepin_Widget", c = window.open(t, u, f), h = await new Fn({
      url: t,
      wepin: r,
      webview: c,
      wepinAppKey: i,
      isHide: n == null ? void 0 : n.isHide,
      specifiedEmail: n == null ? void 0 : n.specifiedEmail
    });
    if (!c)
      throw h.close(), new Error("popup window blocked");
    return this.timer = setInterval(() => {
      try {
        c && c.closed && (clearInterval(this.timer), h.close());
      } catch {
        clearInterval(this.timer), h.close();
      }
    }, 200), h;
  }
  expand() {
  }
  shrink() {
  }
  _closeWebview() {
    Fn.timer && (clearInterval(Fn.timer), Fn.timer = void 0), this.Webview && this.Webview.close(), this.clearWebview();
  }
  _post(t) {
    this.Webview.postMessage(t, this.url);
  }
}
class zn extends ra {
  // is it necessary ?
  constructor({
    url: t,
    wepin: r,
    frame: i,
    wepinAppKey: o,
    isHide: n,
    specifiedEmail: f
  }) {
    super(t, r, i, "Frame", o, n, f), i.src = t, i.id = this.id;
    const u = document.querySelector("body");
    zn.scrollPosition = window.pageYOffset, u.style.overflow = "hidden", u.style.position = "fixed", u.style.top = `-${zn.scrollPosition}px`, u.style.width = "100%", document.body.appendChild(i);
  }
  static async openNew(t, r, i, o) {
    const n = Ug({ isHide: o == null ? void 0 : o.isHide });
    return new zn({
      url: t,
      wepin: r,
      frame: n,
      wepinAppKey: i,
      isHide: o == null ? void 0 : o.isHide,
      specifiedEmail: o == null ? void 0 : o.specifiedEmail
    });
  }
  expand() {
    this.Webview.style.height = "100%", this.Webview.style.borderRadius = "0";
  }
  shrink() {
    this.Webview.style.height = "604px", this.Webview.style.borderRadius = "12px 12px 0 0 ";
  }
  _closeWebview() {
    const t = setTimeout(() => {
      $t.debug("this.timer", t);
      const r = document.querySelector("body");
      r.style.removeProperty("overflow"), r.style.removeProperty("position"), r.style.removeProperty("top"), r.style.removeProperty("width"), window.scrollTo(0, zn.scrollPosition), document.body.removeChild(this.Webview), this.clearWebview();
    }, 500);
  }
  _post(t) {
    this.Webview.contentWindow.postMessage(
      t,
      this.url
    );
  }
}
var Ze = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yv(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function gv(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var o = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(r, i, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), r;
}
var oh = { exports: {} }, bi = typeof Reflect == "object" ? Reflect : null, x0 = bi && typeof bi.apply == "function" ? bi.apply : function(t, r, i) {
  return Function.prototype.apply.call(t, r, i);
}, Ga;
bi && typeof bi.ownKeys == "function" ? Ga = bi.ownKeys : Object.getOwnPropertySymbols ? Ga = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Ga = function(t) {
  return Object.getOwnPropertyNames(t);
};
function Fg(e) {
  console && console.warn && console.warn(e);
}
var mv = Number.isNaN || function(t) {
  return t !== t;
};
function jt() {
  jt.init.call(this);
}
oh.exports = jt;
oh.exports.once = Wg;
jt.EventEmitter = jt;
jt.prototype._events = void 0;
jt.prototype._eventsCount = 0;
jt.prototype._maxListeners = void 0;
var E0 = 10;
function vo(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(jt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return E0;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || mv(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    E0 = e;
  }
});
jt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
jt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || mv(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function wv(e) {
  return e._maxListeners === void 0 ? jt.defaultMaxListeners : e._maxListeners;
}
jt.prototype.getMaxListeners = function() {
  return wv(this);
};
jt.prototype.emit = function(t) {
  for (var r = [], i = 1; i < arguments.length; i++)
    r.push(arguments[i]);
  var o = t === "error", n = this._events;
  if (n !== void 0)
    o = o && n.error === void 0;
  else if (!o)
    return !1;
  if (o) {
    var f;
    if (r.length > 0 && (f = r[0]), f instanceof Error)
      throw f;
    var u = new Error("Unhandled error." + (f ? " (" + f.message + ")" : ""));
    throw u.context = f, u;
  }
  var c = n[t];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    x0(c, this, r);
  else
    for (var h = c.length, s = Av(c, h), i = 0; i < h; ++i)
      x0(s[i], this, r);
  return !0;
};
function _v(e, t, r, i) {
  var o, n, f;
  if (vo(r), n = e._events, n === void 0 ? (n = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (n.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), n = e._events), f = n[t]), f === void 0)
    f = n[t] = r, ++e._eventsCount;
  else if (typeof f == "function" ? f = n[t] = i ? [r, f] : [f, r] : i ? f.unshift(r) : f.push(r), o = wv(e), o > 0 && f.length > o && !f.warned) {
    f.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + f.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = f.length, Fg(u);
  }
  return e;
}
jt.prototype.addListener = function(t, r) {
  return _v(this, t, r, !1);
};
jt.prototype.on = jt.prototype.addListener;
jt.prototype.prependListener = function(t, r) {
  return _v(this, t, r, !0);
};
function zg() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function xv(e, t, r) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, o = zg.bind(i);
  return o.listener = r, i.wrapFn = o, o;
}
jt.prototype.once = function(t, r) {
  return vo(r), this.on(t, xv(this, t, r)), this;
};
jt.prototype.prependOnceListener = function(t, r) {
  return vo(r), this.prependListener(t, xv(this, t, r)), this;
};
jt.prototype.removeListener = function(t, r) {
  var i, o, n, f, u;
  if (vo(r), o = this._events, o === void 0)
    return this;
  if (i = o[t], i === void 0)
    return this;
  if (i === r || i.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete o[t], o.removeListener && this.emit("removeListener", t, i.listener || r));
  else if (typeof i != "function") {
    for (n = -1, f = i.length - 1; f >= 0; f--)
      if (i[f] === r || i[f].listener === r) {
        u = i[f].listener, n = f;
        break;
      }
    if (n < 0)
      return this;
    n === 0 ? i.shift() : Hg(i, n), i.length === 1 && (o[t] = i[0]), o.removeListener !== void 0 && this.emit("removeListener", t, u || r);
  }
  return this;
};
jt.prototype.off = jt.prototype.removeListener;
jt.prototype.removeAllListeners = function(t) {
  var r, i, o;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var n = Object.keys(i), f;
    for (o = 0; o < n.length; ++o)
      f = n[o], f !== "removeListener" && this.removeAllListeners(f);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = i[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (o = r.length - 1; o >= 0; o--)
      this.removeListener(t, r[o]);
  return this;
};
function Ev(e, t, r) {
  var i = e._events;
  if (i === void 0)
    return [];
  var o = i[t];
  return o === void 0 ? [] : typeof o == "function" ? r ? [o.listener || o] : [o] : r ? Vg(o) : Av(o, o.length);
}
jt.prototype.listeners = function(t) {
  return Ev(this, t, !0);
};
jt.prototype.rawListeners = function(t) {
  return Ev(this, t, !1);
};
jt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Sv.call(e, t);
};
jt.prototype.listenerCount = Sv;
function Sv(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
jt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Ga(this._events) : [];
};
function Av(e, t) {
  for (var r = new Array(t), i = 0; i < t; ++i)
    r[i] = e[i];
  return r;
}
function Hg(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Vg(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function Wg(e, t) {
  return new Promise(function(r, i) {
    function o(f) {
      e.removeListener(t, n), i(f);
    }
    function n() {
      typeof e.removeListener == "function" && e.removeListener("error", o), r([].slice.call(arguments));
    }
    Mv(e, t, n, { once: !0 }), t !== "error" && Kg(e, o, { once: !0 });
  });
}
function Kg(e, t, r) {
  typeof e.on == "function" && Mv(e, "error", t, r);
}
function Mv(e, t, r, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function o(n) {
      i.once && e.removeEventListener(t, o), r(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var Ci = oh.exports;
function S0(e, t, r) {
  try {
    Reflect.apply(e, t, r);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function Zg(e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i += 1)
    r[i] = e[i];
  return r;
}
let Rv = class extends Ci.EventEmitter {
  emit(t, ...r) {
    let i = t === "error";
    const o = this._events;
    if (o !== void 0)
      i = i && o.error === void 0;
    else if (!i)
      return !1;
    if (i) {
      let f;
      if (r.length > 0 && ([f] = r), f instanceof Error)
        throw f;
      const u = new Error(`Unhandled error.${f ? ` (${f.message})` : ""}`);
      throw u.context = f, u;
    }
    const n = o[t];
    if (n === void 0)
      return !1;
    if (typeof n == "function")
      S0(n, this, r);
    else {
      const f = n.length, u = Zg(n);
      for (let c = 0; c < f; c += 1)
        S0(u[c], this, r);
    }
    return !0;
  }
};
const Gg = "@wepin/widget-sdk", Jg = "0.4.4", Xg = "Wepin Widget Javascript SDK for Web", Yg = "./dist/wepin-widget-sdk.umd.js", Qg = "./dist/src/index.d.ts", em = "IoTrust, Co., Ltd.", tm = "https://github.com/WepinWallet/wepin-widget-js-sdk/", rm = [
  "dist"
], nm = {
  type: "git",
  url: "git+https://github.com/WepinWallet/wepin-widget-js-sdk.git"
}, im = {
  "build-ts": "tsc --project tsconfig.json && tsc-alias -p tsconfig.json",
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  start: "npm run bundle && npm run watch",
  test: 'echo "Error: no test specified" && exit 1',
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, am = [
  "wepin",
  "wepinwallet",
  "wallet"
], om = "MIT", fm = {
  "@types/lodash": "^4.14.189",
  "@types/ua-parser-js": "^0.7.36",
  "@typescript-eslint/eslint-plugin": "^5.46.1",
  "@typescript-eslint/parser": "^5.46.1",
  "@wepin/types": "^0.0.11",
  eslint: "^8.29.0",
  "eslint-config-prettier": "^8.5.0",
  "eslint-plugin-prettier": "^4.2.1",
  "node-stdlib-browser": "^1.2.0",
  prettier: "^2.8.1",
  "ts-loader": "^9.4.1",
  "tsc-alias": "^1.8.2",
  typescript: "^4.9.3",
  vite: "^5.0.2",
  "vite-plugin-dts": "^3.6.3",
  "vite-plugin-node-stdlib-browser": "^0.2.1"
}, sm = {
  "eth-json-rpc-middleware": "^9.0.1",
  "json-rpc-engine": "^6.1.0",
  "jwt-decode": "^3.1.2"
}, um = {
  name: Gg,
  version: Jg,
  description: Xg,
  main: Yg,
  types: Qg,
  author: em,
  homepage: tm,
  files: rm,
  repository: nm,
  scripts: im,
  keywords: am,
  license: om,
  devDependencies: fm,
  dependencies: sm
}, cm = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/;
var xr = {}, bo = {}, ca = {};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.getUniqueId = void 0;
const Bv = 4294967295;
let lf = Math.floor(Math.random() * Bv);
function hm() {
  return lf = (lf + 1) % Bv, lf;
}
ca.getUniqueId = hm;
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.createIdRemapMiddleware = void 0;
const lm = ca;
function dm() {
  return (e, t, r, i) => {
    const o = e.id, n = lm.getUniqueId();
    e.id = n, t.id = n, r((f) => {
      e.id = o, t.id = o, f();
    });
  };
}
bo.createIdRemapMiddleware = dm;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.createAsyncMiddleware = void 0;
function pm(e) {
  return async (t, r, i, o) => {
    let n;
    const f = new Promise((s) => {
      n = s;
    });
    let u = null, c = !1;
    const h = async () => {
      c = !0, i((s) => {
        u = s, n();
      }), await f;
    };
    try {
      await e(t, r, h), c ? (await f, u(null)) : o(null);
    } catch (s) {
      u ? u(s) : o(s);
    }
  };
}
yo.createAsyncMiddleware = pm;
var go = {};
Object.defineProperty(go, "__esModule", { value: !0 });
go.createScaffoldMiddleware = void 0;
function vm(e) {
  return (t, r, i, o) => {
    const n = e[t.method];
    return n === void 0 ? i() : typeof n == "function" ? n(t, r, i, o) : (r.result = n, o());
  };
}
go.createScaffoldMiddleware = vm;
var ha = {}, mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
const bm = Ci;
function A0(e, t, r) {
  try {
    Reflect.apply(e, t, r);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function ym(e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i += 1)
    r[i] = e[i];
  return r;
}
class gm extends bm.EventEmitter {
  emit(t, ...r) {
    let i = t === "error";
    const o = this._events;
    if (o !== void 0)
      i = i && o.error === void 0;
    else if (!i)
      return !1;
    if (i) {
      let f;
      if (r.length > 0 && ([f] = r), f instanceof Error)
        throw f;
      const u = new Error(`Unhandled error.${f ? ` (${f.message})` : ""}`);
      throw u.context = f, u;
    }
    const n = o[t];
    if (n === void 0)
      return !1;
    if (typeof n == "function")
      A0(n, this, r);
    else {
      const f = n.length, u = ym(n);
      for (let c = 0; c < f; c += 1)
        A0(u[c], this, r);
    }
    return !0;
  }
}
mo.default = gm;
var Kt = {}, Pn = {}, mm = na;
na.default = na;
na.stable = Ov;
na.stableStringify = Ov;
var ro = "[...]", Iv = "[Circular]", Jn = [], Hn = [];
function Tv() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function na(e, t, r, i) {
  typeof i > "u" && (i = Tv()), jc(e, "", 0, [], void 0, 0, i);
  var o;
  try {
    Hn.length === 0 ? o = JSON.stringify(e, t, r) : o = JSON.stringify(e, Pv(t), r);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Jn.length !== 0; ) {
      var n = Jn.pop();
      n.length === 4 ? Object.defineProperty(n[0], n[1], n[3]) : n[0][n[1]] = n[2];
    }
  }
  return o;
}
function yi(e, t, r, i) {
  var o = Object.getOwnPropertyDescriptor(i, r);
  o.get !== void 0 ? o.configurable ? (Object.defineProperty(i, r, { value: e }), Jn.push([i, r, t, o])) : Hn.push([t, r, e]) : (i[r] = e, Jn.push([i, r, t]));
}
function jc(e, t, r, i, o, n, f) {
  n += 1;
  var u;
  if (typeof e == "object" && e !== null) {
    for (u = 0; u < i.length; u++)
      if (i[u] === e) {
        yi(Iv, e, t, o);
        return;
      }
    if (typeof f.depthLimit < "u" && n > f.depthLimit) {
      yi(ro, e, t, o);
      return;
    }
    if (typeof f.edgesLimit < "u" && r + 1 > f.edgesLimit) {
      yi(ro, e, t, o);
      return;
    }
    if (i.push(e), Array.isArray(e))
      for (u = 0; u < e.length; u++)
        jc(e[u], u, u, i, e, n, f);
    else {
      var c = Object.keys(e);
      for (u = 0; u < c.length; u++) {
        var h = c[u];
        jc(e[h], h, u, i, e, n, f);
      }
    }
    i.pop();
  }
}
function wm(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Ov(e, t, r, i) {
  typeof i > "u" && (i = Tv());
  var o = qc(e, "", 0, [], void 0, 0, i) || e, n;
  try {
    Hn.length === 0 ? n = JSON.stringify(o, t, r) : n = JSON.stringify(o, Pv(t), r);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Jn.length !== 0; ) {
      var f = Jn.pop();
      f.length === 4 ? Object.defineProperty(f[0], f[1], f[3]) : f[0][f[1]] = f[2];
    }
  }
  return n;
}
function qc(e, t, r, i, o, n, f) {
  n += 1;
  var u;
  if (typeof e == "object" && e !== null) {
    for (u = 0; u < i.length; u++)
      if (i[u] === e) {
        yi(Iv, e, t, o);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof f.depthLimit < "u" && n > f.depthLimit) {
      yi(ro, e, t, o);
      return;
    }
    if (typeof f.edgesLimit < "u" && r + 1 > f.edgesLimit) {
      yi(ro, e, t, o);
      return;
    }
    if (i.push(e), Array.isArray(e))
      for (u = 0; u < e.length; u++)
        qc(e[u], u, u, i, e, n, f);
    else {
      var c = {}, h = Object.keys(e).sort(wm);
      for (u = 0; u < h.length; u++) {
        var s = h[u];
        qc(e[s], s, u, i, e, n, f), c[s] = e[s];
      }
      if (typeof o < "u")
        Jn.push([o, t, e]), o[t] = c;
      else
        return c;
    }
    i.pop();
  }
}
function Pv(e) {
  return e = typeof e < "u" ? e : function(t, r) {
    return r;
  }, function(t, r) {
    if (Hn.length > 0)
      for (var i = 0; i < Hn.length; i++) {
        var o = Hn[i];
        if (o[1] === t && o[0] === r) {
          r = o[2], Hn.splice(i, 1);
          break;
        }
      }
    return e.call(this, t, r);
  };
}
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.EthereumProviderError = Pn.EthereumRpcError = void 0;
const _m = mm;
class Cv extends Error {
  constructor(t, r, i) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = t, i !== void 0 && (this.data = i);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return _m.default(this.serialize(), Sm, 2);
  }
}
Pn.EthereumRpcError = Cv;
class xm extends Cv {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, r, i) {
    if (!Em(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, r, i);
  }
}
Pn.EthereumProviderError = xm;
function Em(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function Sm(e, t) {
  if (t !== "[Circular]")
    return t;
}
var fh = {}, Cn = {};
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.errorValues = Cn.errorCodes = void 0;
Cn.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
Cn.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = Cn, r = Pn, i = t.errorCodes.rpc.internal, o = "Unspecified error message. This is a bug, please report it.", n = {
    code: i,
    message: f(i)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function f(p, m = o) {
    if (Number.isInteger(p)) {
      const E = p.toString();
      if (b(t.errorValues, E))
        return t.errorValues[E].message;
      if (h(p))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return m;
  }
  e.getMessageFromCode = f;
  function u(p) {
    if (!Number.isInteger(p))
      return !1;
    const m = p.toString();
    return !!(t.errorValues[m] || h(p));
  }
  e.isValidCode = u;
  function c(p, { fallbackError: m = n, shouldIncludeStack: E = !1 } = {}) {
    var M, I;
    if (!m || !Number.isInteger(m.code) || typeof m.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (p instanceof r.EthereumRpcError)
      return p.serialize();
    const B = {};
    if (p && typeof p == "object" && !Array.isArray(p) && b(p, "code") && u(p.code)) {
      const j = p;
      B.code = j.code, j.message && typeof j.message == "string" ? (B.message = j.message, b(j, "data") && (B.data = j.data)) : (B.message = f(B.code), B.data = { originalError: s(p) });
    } else {
      B.code = m.code;
      const j = (M = p) === null || M === void 0 ? void 0 : M.message;
      B.message = j && typeof j == "string" ? j : m.message, B.data = { originalError: s(p) };
    }
    const T = (I = p) === null || I === void 0 ? void 0 : I.stack;
    return E && p && T && typeof T == "string" && (B.stack = T), B;
  }
  e.serializeError = c;
  function h(p) {
    return p >= -32099 && p <= -32e3;
  }
  function s(p) {
    return p && typeof p == "object" && !Array.isArray(p) ? Object.assign({}, p) : p;
  }
  function b(p, m) {
    return Object.prototype.hasOwnProperty.call(p, m);
  }
})(fh);
var wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.ethErrors = void 0;
const sh = Pn, Nv = fh, dr = Cn;
wo.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => Er(dr.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => Er(dr.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => Er(dr.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => Er(dr.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => Er(dr.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Er(t, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => Er(dr.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => Er(dr.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => Er(dr.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => Er(dr.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => Er(dr.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => Er(dr.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => zi(dr.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => zi(dr.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => zi(dr.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => zi(dr.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => zi(dr.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: r, data: i } = e;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new sh.EthereumProviderError(t, r, i);
    }
  }
};
function Er(e, t) {
  const [r, i] = Lv(t);
  return new sh.EthereumRpcError(e, r || Nv.getMessageFromCode(e), i);
}
function zi(e, t) {
  const [r, i] = Lv(t);
  return new sh.EthereumProviderError(e, r || Nv.getMessageFromCode(e), i);
}
function Lv(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: r } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, r];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = Pn;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  const r = fh;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return r.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return r.getMessageFromCode;
  } });
  const i = wo;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return i.ethErrors;
  } });
  const o = Cn;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return o.errorCodes;
  } });
})(Kt);
var Am = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ha, "__esModule", { value: !0 });
ha.JsonRpcEngine = void 0;
const Mm = Am(mo), Sr = Kt;
class un extends Mm.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, r) {
    if (r && typeof r != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? r ? this._handleBatch(t, r) : this._handleBatch(t) : r ? this._handle(t, r) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, r, i, o) => {
      try {
        const [n, f, u] = await un._runAllMiddleware(t, r, this._middleware);
        return f ? (await un._runReturnHandlers(u), o(n)) : i(async (c) => {
          try {
            await un._runReturnHandlers(u);
          } catch (h) {
            return c(h);
          }
          return c();
        });
      } catch (n) {
        return o(n);
      }
    };
  }
  async _handleBatch(t, r) {
    try {
      const i = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return r ? r(null, i) : i;
    } catch (i) {
      if (r)
        return r(i);
      throw i;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((r) => {
      this._handle(t, (i, o) => {
        r(o);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, r) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const f = new Sr.EthereumRpcError(Sr.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof t}`, { request: t });
      return r(f, { id: void 0, jsonrpc: "2.0", error: f });
    }
    if (typeof t.method != "string") {
      const f = new Sr.EthereumRpcError(Sr.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof t.method}`, { request: t });
      return r(f, { id: t.id, jsonrpc: "2.0", error: f });
    }
    const i = Object.assign({}, t), o = {
      id: i.id,
      jsonrpc: i.jsonrpc
    };
    let n = null;
    try {
      await this._processRequest(i, o);
    } catch (f) {
      n = f;
    }
    return n && (delete o.result, o.error || (o.error = Sr.serializeError(n))), r(n, o);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, r) {
    const [i, o, n] = await un._runAllMiddleware(t, r, this._middleware);
    if (un._checkForCompletion(t, r, o), await un._runReturnHandlers(n), i)
      throw i;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, r, i) {
    const o = [];
    let n = null, f = !1;
    for (const u of i)
      if ([n, f] = await un._runMiddleware(t, r, u, o), f)
        break;
    return [n, f, o.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, r, i, o) {
    return new Promise((n) => {
      const f = (c) => {
        const h = c || r.error;
        h && (r.error = Sr.serializeError(h)), n([h, !0]);
      }, u = (c) => {
        r.error ? f(r.error) : (c && (typeof c != "function" && f(new Sr.EthereumRpcError(Sr.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof c}" for request:
${df(t)}`, { request: t })), o.push(c)), n([null, !1]));
      };
      try {
        i(t, r, u, f);
      } catch (c) {
        f(c);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const r of t)
      await new Promise((i, o) => {
        r((n) => n ? o(n) : i());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, r, i) {
    if (!("result" in r) && !("error" in r))
      throw new Sr.EthereumRpcError(Sr.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${df(t)}`, { request: t });
    if (!i)
      throw new Sr.EthereumRpcError(Sr.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${df(t)}`, { request: t });
  }
}
ha.JsonRpcEngine = un;
function df(e) {
  return JSON.stringify(e, null, 2);
}
var _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.mergeMiddleware = void 0;
const Rm = ha;
function Bm(e) {
  const t = new Rm.JsonRpcEngine();
  return e.forEach((r) => t.push(r)), t.asMiddleware();
}
_o.mergeMiddleware = Bm;
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, o, n, f) {
    f === void 0 && (f = n), Object.defineProperty(i, f, { enumerable: !0, get: function() {
      return o[n];
    } });
  } : function(i, o, n, f) {
    f === void 0 && (f = n), i[f] = o[n];
  }), r = Ze && Ze.__exportStar || function(i, o) {
    for (var n in i)
      n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, i, n);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(bo, e), r(yo, e), r(go, e), r(ca, e), r(ha, e), r(_o, e);
})(xr);
var Im = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var i, o, n;
    if (Array.isArray(t)) {
      if (i = t.length, i != r.length)
        return !1;
      for (o = i; o-- !== 0; )
        if (!e(t[o], r[o]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (n = Object.keys(t), i = n.length, i !== Object.keys(r).length)
      return !1;
    for (o = i; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, n[o]))
        return !1;
    for (o = i; o-- !== 0; ) {
      var f = n[o];
      if (!e(t[f], r[f]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
};
const Tm = /* @__PURE__ */ yv(Im), Om = (e, t, r = !0) => (i, o) => {
  i || o.error ? t(i || o.error) : !r || Array.isArray(o) ? e(o) : e(o.result);
}, uh = (e) => !!e && typeof e == "string" && e.startsWith("0x"), po = class po extends Rv {
  constructor({
    logger: t = console,
    maxEventListeners: r = 100,
    rpcMiddleware: i = []
  } = {}) {
    super(), this.uuid = "wepinprovider", this.name = "Wepin", this._log = t, this.setMaxListeners(r), this._state = {
      ...po._defaultState
    }, this.selectedAddress = null, this.chainId = null, this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const o = new xr.JsonRpcEngine();
    i.forEach((n) => o.push(n)), this._rpcEngine = o;
  }
  async request(t) {
    if (!t || typeof t != "object" || Array.isArray(t))
      throw Kt.ethErrors.rpc.invalidRequest({
        message: "Invalid request arguments",
        data: t
      });
    this._log.debug("[RPC Request]: requesting args", t);
    const { method: r, params: i, id: o = (/* @__PURE__ */ new Date()).getTime() } = t;
    if (typeof r != "string" || r.length === 0)
      throw Kt.ethErrors.rpc.invalidRequest({
        message: "Invalid request methods",
        data: t
      });
    if (i !== void 0 && !Array.isArray(i) && (typeof i != "object" || i === null))
      throw Kt.ethErrors.rpc.invalidRequest({
        message: "Invalid request params",
        data: t
      });
    return new Promise((n, f) => {
      this._rpcRequest(
        { method: r, params: i, id: o },
        Om(n, f)
      );
    });
  }
  /**
   * Initialize provider
   *
   * @param initialState
   */
  _initializeState(t) {
    if (this._state.initialized === !0)
      throw new Error("Provider already initialized.");
    if (t) {
      const { accounts: r, chainId: i, networkVersion: o } = t;
      this._handleConnect(i), this._handleChainChanged({ chainId: i, networkVersion: o }), this._handleAccountsChanged(r);
    }
    this._state.initialized = !0, this.emit("_initialized");
  }
  _rpcRequest(t, r) {
    let i = r;
    return Array.isArray(t) ? this._rpcEngine.handle(t, i) : (t.jsonrpc || (t.jsonrpc = "2.0"), (t.method === "eth_accounts" || t.method === "klay_accounts" || t.method === "eth_requestAccounts" || t.method === "klay_requestAccounts") && (i = (o, n) => {
      this._log.debug("_rpcRequest to handler account changes", o, n), this._handleAccountsChanged(
        n.result || [],
        t.method === "eth_accounts"
      ), r(o, n);
    }), t.method === "wallet_switchEthereumChain" && (i = (o, n) => {
      var f;
      this._log.debug("_rpcRequest to handler chain changes", o, n), (f = n.result) != null && f.chainId && this._handleChainChanged({ chainId: n.result.chainId }), r(o, n);
    }), this._rpcEngine.handle(t, i));
  }
  _handleConnect(t) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", { chainId: t }));
  }
  _handleDisconnect(t, r) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !t) {
      this._state.isConnected = !1;
      let i;
      t ? (i = new Kt.EthereumRpcError(
        1013,
        // Try again later
        r || "Provider diconnected"
      ), this._log.debug(i)) : (i = new Kt.EthereumRpcError(
        1011,
        // Internal error
        r || "Provider permenantly disconnected"
      ), this._log.error(i), this.chainId = null, this._state.accounts = null, this.selectedAddress = null, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", i);
    }
  }
  _handleChainChanged({
    chainId: t
  } = {}) {
    if (!uh(t)) {
      this._log.error("Invalid network params", { chainId: t });
      return;
    }
    this._handleConnect(t), t !== this.chainId && (this.chainId = t, this._state.initialized && this.emit("chainChanged", this.chainId));
  }
  _handleAccountsChanged(t, r = !1) {
    let i = t;
    Array.isArray(t) || (this._log.error(
      "Received invalid accounts parameter. Please report this bug.",
      t
    ), i = []);
    for (const o of t)
      if (typeof o != "string") {
        this._log.error(
          "Received non-string account. Please report this bug.",
          t
        ), i = [];
        break;
      }
    Tm(this._state.accounts, i) || (r && this._state.accounts !== null && this._log.error(
      "'eth_accounts' unexpectedly updated accounts. Please report this bug.",
      i
    ), this._state.accounts = i, this.selectedAddress !== i[0] && (this.selectedAddress = i[0] || null), this._state.initialized && this.emit("accountsChanged", i));
  }
};
po._defaultState = {
  accounts: null,
  isConnected: !1,
  initialized: !1,
  isPermanentlyDisconnected: !1
};
let no = po;
const Dc = ({ wepin: e, network: t }) => (r, i, o, n) => {
  if (!e._isInitialized) {
    n(Kt.ethErrors.provider.unauthorized());
    return;
  }
  let f = !1;
  const u = Array.isArray(r.params) ? r.params[0] : r.params;
  if (Object.values(u).forEach((c) => {
    c && !c.startsWith("0x") && (console.error(`${c} is not start with '0x'`), n(Kt.ethErrors.rpc.invalidParams()), f = !0);
  }), !f) {
    const c = {
      account: {
        address: r.params[0].from,
        network: t
      },
      ...r.params[0]
    };
    Fi({
      wepin: e,
      network: t,
      req: r,
      res: i,
      next: o,
      end: n,
      command: "sign_transaction",
      parameter: c
    });
  }
}, $c = ({ wepin: e, network: t }) => (r, i, o, n) => {
  if (!e._isInitialized) {
    n(Kt.ethErrors.provider.unauthorized());
    return;
  }
  const f = Array.isArray(r.params) ? r.params[0] : r.params;
  let u = !1;
  Object.values(f).forEach((c) => {
    c && !c.startsWith("0x") && (console.error(`${c} is not start with '0x'`), n(Kt.ethErrors.rpc.invalidParams()), u = !0);
  }), u || Fi({
    wepin: e,
    network: t,
    req: r,
    res: i,
    next: o,
    end: n,
    command: "send_transaction",
    parameter: {
      account: {
        address: r.params[0].from,
        network: t
      },
      ...r.params[0]
    }
  });
}, ln = ({
  wepin: e,
  network: t,
  version: r
}) => (i, o, n, f) => {
  if (!e._isInitialized) {
    f(Kt.ethErrors.provider.unauthorized());
    return;
  }
  if (i.params.length !== 2) {
    f(Kt.ethErrors.rpc.invalidParams());
    return;
  }
  const u = {
    account: {
      network: t,
      address: i.params[0]
    },
    data: i.params[1],
    version: r
  };
  Fi({
    wepin: e,
    network: t,
    req: i,
    res: o,
    next: n,
    end: f,
    command: "sign_typed_data",
    parameter: u
  });
}, Xi = ({
  wepin: e,
  network: t,
  isPersonal: r
}) => (i, o, n, f) => {
  if (!e._isInitialized) {
    f(Kt.ethErrors.provider.unauthorized());
    return;
  }
  if (i.params.length !== 2) {
    f(Kt.ethErrors.rpc.invalidParams());
    return;
  }
  const u = {
    account: {
      network: t,
      address: r ? i.params[1] : i.params[0]
    },
    data: r ? i.params[0] : i.params[1]
  };
  Fi({
    wepin: e,
    network: t,
    req: i,
    res: o,
    next: n,
    end: f,
    command: "sign",
    parameter: u
  });
}, wn = {
  Gateway: "https://gateway.wepin.io"
}, ch = (e) => {
  switch (e) {
    case "ethereum":
      return {
        rpcUrl: wn.Gateway + "/alchemy/eth",
        chainId: "0x1"
      };
    case "evmeth-goerli":
      return {
        rpcUrl: wn.Gateway + "/infura/goerli",
        chainId: "0x5"
      };
    case "klaytn":
      return {
        rpcUrl: wn.Gateway + "/klaytn/mainnet",
        chainId: "0x2019"
      };
    case "klaytn-testnet":
      return {
        rpcUrl: wn.Gateway + "/klaytn/testnet",
        chainId: "0x3e9"
      };
    case "evmsongbird":
      return {
        rpcUrl: wn.Gateway + "/songbird/api-portal/mainnet",
        chainId: "0x13"
      };
    case "evmpolygon":
      return {
        rpcUrl: wn.Gateway + "/matic/alchemy/mainnet",
        chainId: "0x89"
      };
    case "evmpolygon-testnet":
      return {
        rpcUrl: wn.Gateway + "/matic/testnet",
        chainId: "0x13881"
      };
    case "evmtime-elizabeth":
      return {
        rpcUrl: wn.Gateway + "/timenetwork/testnet ",
        // rpcUrl: GatewayUrl.Gateway + '/anttime/testnet ',
        chainId: "0xaab"
      };
    default:
      throw new Error(
        `There is No network info about provided network : ${e}`
      );
  }
}, hh = (e) => {
  if (!uh(e))
    throw new Error(`Invalid chain ID: ${e}`);
  return {
    "0x1": "ethereum",
    "0x5": "evmeth-goerli",
    "0x13": "evmsongbird",
    "0x89": "evmpolygon",
    "0x3e9": "klaytn-testnet",
    "0x2019": "klaytn",
    "0x13881": "evmpolygon-testnet",
    "0xaab": "evmtime-elizabeth"
    //'evmtimenetwork-testnet', //'evmanttime-testnet', //
  }[e];
}, kv = ({ wepin: e, network: t }) => (r, i, o, n) => {
  if (!e._isInitialized) {
    n(Kt.ethErrors.provider.unauthorized());
    return;
  }
  const f = Array.isArray(r.params) ? r.params[0] : r.params;
  if (!(f != null && f.chainId) || !(f != null && f.chainId.startsWith("0x"))) {
    n(Kt.ethErrors.rpc.invalidParams());
    return;
  }
  if (!uh(f.chainId))
    return n(Kt.ethErrors.rpc.invalidParams());
  const u = {
    account: {
      address: window.evmproviders.Wepin.selectedAddress,
      network: t
    },
    toNetwork: hh(f.chainId),
    ...r.params[0]
  };
  Fi({
    wepin: e,
    network: t,
    req: r,
    res: i,
    next: o,
    end: n,
    command: "wallet_switchEthereumChain",
    parameter: u
  });
}, Pm = ({
  wepin: e,
  network: t
}) => xr.createScaffoldMiddleware({
  //for web3, ethers
  eth_requestAccounts: vi({ wepin: e, network: t }),
  eth_accounts: vi({ wepin: e, network: t }),
  eth_signTransaction: Dc({ wepin: e, network: t }),
  eth_sendTransaction: $c({ wepin: e, network: t }),
  eth_signTypedData_v1: ln({ wepin: e, network: t, version: "V1" }),
  eth_signTypedData_v3: ln({ wepin: e, network: t, version: "V3" }),
  eth_signTypedData_v4: ln({ wepin: e, network: t, version: "V4" }),
  eth_sign: Xi({ wepin: e, network: t, isPersonal: !1 }),
  //for caver
  klay_requestAccounts: vi({ wepin: e, network: t }),
  klay_accounts: vi({ wepin: e, network: t }),
  klay_signTransaction: Dc({ wepin: e, network: t }),
  klay_sendTransaction: $c({ wepin: e, network: t }),
  klay_signTypedData_v1: ln({ wepin: e, network: t, version: "V1" }),
  klay_signTypedData_v3: ln({ wepin: e, network: t, version: "V3" }),
  klay_signTypedData_v4: ln({ wepin: e, network: t, version: "V4" }),
  klay_sign: Xi({ wepin: e, network: t, isPersonal: !1 }),
  personal_sign: Xi({ wepin: e, network: t, isPersonal: !0 }),
  wallet_switchEthereumChain: kv({ wepin: e, network: t })
});
var lh = {}, xo = {}, Ni = {}, jv = {}, sr = {};
class qv extends TypeError {
  constructor(t, r) {
    let i;
    const { message: o, explanation: n, ...f } = t, { path: u } = t, c = u.length === 0 ? o : `At path: ${u.join(".")} -- ${o}`;
    super(n ?? c), n != null && (this.cause = c), Object.assign(this, f), this.name = this.constructor.name, this.failures = () => i ?? (i = [t, ...r()]);
  }
}
function Cm(e) {
  return jr(e) && typeof e[Symbol.iterator] == "function";
}
function jr(e) {
  return typeof e == "object" && e != null;
}
function M0(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function er(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function Nm(e) {
  const { done: t, value: r } = e.next();
  return t ? void 0 : r;
}
function Lm(e, t, r, i) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: o, branch: n } = t, { type: f } = r, { refinement: u, message: c = `Expected a value of type \`${f}\`${u ? ` with refinement \`${u}\`` : ""}, but received: \`${er(i)}\`` } = e;
  return {
    value: i,
    type: f,
    refinement: u,
    key: o[o.length - 1],
    path: o,
    branch: n,
    ...e,
    message: c
  };
}
function* Uc(e, t, r, i) {
  Cm(e) || (e = [e]);
  for (const o of e) {
    const n = Lm(o, t, r, i);
    n && (yield n);
  }
}
function* dh(e, t, r = {}) {
  const { path: i = [], branch: o = [e], coerce: n = !1, mask: f = !1 } = r, u = { path: i, branch: o };
  if (n && (e = t.coercer(e, u), f && t.type !== "type" && jr(t.schema) && jr(e) && !Array.isArray(e)))
    for (const h in e)
      t.schema[h] === void 0 && delete e[h];
  let c = "valid";
  for (const h of t.validator(e, u))
    h.explanation = r.message, c = "not_valid", yield [h, void 0];
  for (let [h, s, b] of t.entries(e, u)) {
    const p = dh(s, b, {
      path: h === void 0 ? i : [...i, h],
      branch: h === void 0 ? o : [...o, s],
      coerce: n,
      mask: f,
      message: r.message
    });
    for (const m of p)
      m[0] ? (c = m[0].refinement != null ? "not_refined" : "not_valid", yield [m[0], void 0]) : n && (s = m[1], h === void 0 ? e = s : e instanceof Map ? e.set(h, s) : e instanceof Set ? e.add(s) : jr(e) && (s !== void 0 || h in e) && (e[h] = s));
  }
  if (c !== "not_valid")
    for (const h of t.refiner(e, u))
      h.explanation = r.message, c = "not_refined", yield [h, void 0];
  c === "valid" && (yield [void 0, e]);
}
class Gt {
  constructor(t) {
    const { type: r, schema: i, validator: o, refiner: n, coercer: f = (c) => c, entries: u = function* () {
    } } = t;
    this.type = r, this.schema = i, this.entries = u, this.coercer = f, o ? this.validator = (c, h) => {
      const s = o(c, h);
      return Uc(s, h, this, c);
    } : this.validator = () => [], n ? this.refiner = (c, h) => {
      const s = n(c, h);
      return Uc(s, h, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, r) {
    return Dv(t, this, r);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, r) {
    return $v(t, this, r);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return ph(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, r) {
    return Uv(t, this, r);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, r = {}) {
    return Li(t, this, r);
  }
}
function Dv(e, t, r) {
  const i = Li(e, t, { message: r });
  if (i[0])
    throw i[0];
}
function $v(e, t, r) {
  const i = Li(e, t, { coerce: !0, message: r });
  if (i[0])
    throw i[0];
  return i[1];
}
function Uv(e, t, r) {
  const i = Li(e, t, { coerce: !0, mask: !0, message: r });
  if (i[0])
    throw i[0];
  return i[1];
}
function ph(e, t) {
  return !Li(e, t)[0];
}
function Li(e, t, r = {}) {
  const i = dh(e, t, r), o = Nm(i);
  return o[0] ? [new qv(o[0], function* () {
    for (const f of i)
      f[0] && (yield f[0]);
  }), void 0] : [void 0, o[1]];
}
function km(...e) {
  const t = e[0].type === "type", r = e.map((o) => o.schema), i = Object.assign({}, ...r);
  return t ? bh(i) : la(i);
}
function gr(e, t) {
  return new Gt({ type: e, schema: null, validator: t });
}
function jm(e, t) {
  return new Gt({
    ...e,
    refiner: (r, i) => r === void 0 || e.refiner(r, i),
    validator(r, i) {
      return r === void 0 ? !0 : (t(r, i), e.validator(r, i));
    }
  });
}
function qm(e) {
  return new Gt({
    type: "dynamic",
    schema: null,
    *entries(t, r) {
      yield* e(t, r).entries(t, r);
    },
    validator(t, r) {
      return e(t, r).validator(t, r);
    },
    coercer(t, r) {
      return e(t, r).coercer(t, r);
    },
    refiner(t, r) {
      return e(t, r).refiner(t, r);
    }
  });
}
function Dm(e) {
  let t;
  return new Gt({
    type: "lazy",
    schema: null,
    *entries(r, i) {
      t ?? (t = e()), yield* t.entries(r, i);
    },
    validator(r, i) {
      return t ?? (t = e()), t.validator(r, i);
    },
    coercer(r, i) {
      return t ?? (t = e()), t.coercer(r, i);
    },
    refiner(r, i) {
      return t ?? (t = e()), t.refiner(r, i);
    }
  });
}
function $m(e, t) {
  const { schema: r } = e, i = { ...r };
  for (const o of t)
    delete i[o];
  switch (e.type) {
    case "type":
      return bh(i);
    default:
      return la(i);
  }
}
function Um(e) {
  const t = e instanceof Gt ? { ...e.schema } : { ...e };
  for (const r in t)
    t[r] = Fv(t[r]);
  return la(t);
}
function Fm(e, t) {
  const { schema: r } = e, i = {};
  for (const o of t)
    i[o] = r[o];
  return la(i);
}
function zm(e, t) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), gr(e, t);
}
function Hm() {
  return gr("any", () => !0);
}
function Vm(e) {
  return new Gt({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [r, i] of t.entries())
          yield [r, i, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${er(t)}`;
    }
  });
}
function Wm() {
  return gr("bigint", (e) => typeof e == "bigint");
}
function Km() {
  return gr("boolean", (e) => typeof e == "boolean");
}
function Zm() {
  return gr("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${er(e)}`);
}
function Gm(e) {
  const t = {}, r = e.map((i) => er(i)).join();
  for (const i of e)
    t[i] = i;
  return new Gt({
    type: "enums",
    schema: t,
    validator(i) {
      return e.includes(i) || `Expected one of \`${r}\`, but received: ${er(i)}`;
    }
  });
}
function Jm() {
  return gr("func", (e) => typeof e == "function" || `Expected a function, but received: ${er(e)}`);
}
function Xm(e) {
  return gr("instance", (t) => t instanceof e || `Expected a \`${e.name}\` instance, but received: ${er(t)}`);
}
function Ym() {
  return gr("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${er(e)}`);
}
function Qm(e) {
  return new Gt({
    type: "intersection",
    schema: null,
    *entries(t, r) {
      for (const i of e)
        yield* i.entries(t, r);
    },
    *validator(t, r) {
      for (const i of e)
        yield* i.validator(t, r);
    },
    *refiner(t, r) {
      for (const i of e)
        yield* i.refiner(t, r);
    }
  });
}
function e2(e) {
  const t = er(e), r = typeof e;
  return new Gt({
    type: "literal",
    schema: r === "string" || r === "number" || r === "boolean" ? e : null,
    validator(i) {
      return i === e || `Expected the literal \`${t}\`, but received: ${er(i)}`;
    }
  });
}
function t2(e, t) {
  return new Gt({
    type: "map",
    schema: null,
    *entries(r) {
      if (e && t && r instanceof Map)
        for (const [i, o] of r.entries())
          yield [i, i, e], yield [i, o, t];
    },
    coercer(r) {
      return r instanceof Map ? new Map(r) : r;
    },
    validator(r) {
      return r instanceof Map || `Expected a \`Map\` object, but received: ${er(r)}`;
    }
  });
}
function vh() {
  return gr("never", () => !1);
}
function r2(e) {
  return new Gt({
    ...e,
    validator: (t, r) => t === null || e.validator(t, r),
    refiner: (t, r) => t === null || e.refiner(t, r)
  });
}
function n2() {
  return gr("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${er(e)}`);
}
function la(e) {
  const t = e ? Object.keys(e) : [], r = vh();
  return new Gt({
    type: "object",
    schema: e || null,
    *entries(i) {
      if (e && jr(i)) {
        const o = new Set(Object.keys(i));
        for (const n of t)
          o.delete(n), yield [n, i[n], e[n]];
        for (const n of o)
          yield [n, i[n], r];
      }
    },
    validator(i) {
      return jr(i) || `Expected an object, but received: ${er(i)}`;
    },
    coercer(i) {
      return jr(i) ? { ...i } : i;
    }
  });
}
function Fv(e) {
  return new Gt({
    ...e,
    validator: (t, r) => t === void 0 || e.validator(t, r),
    refiner: (t, r) => t === void 0 || e.refiner(t, r)
  });
}
function i2(e, t) {
  return new Gt({
    type: "record",
    schema: null,
    *entries(r) {
      if (jr(r))
        for (const i in r) {
          const o = r[i];
          yield [i, i, e], yield [i, o, t];
        }
    },
    validator(r) {
      return jr(r) || `Expected an object, but received: ${er(r)}`;
    }
  });
}
function a2() {
  return gr("regexp", (e) => e instanceof RegExp);
}
function o2(e) {
  return new Gt({
    type: "set",
    schema: null,
    *entries(t) {
      if (e && t instanceof Set)
        for (const r of t)
          yield [r, r, e];
    },
    coercer(t) {
      return t instanceof Set ? new Set(t) : t;
    },
    validator(t) {
      return t instanceof Set || `Expected a \`Set\` object, but received: ${er(t)}`;
    }
  });
}
function zv() {
  return gr("string", (e) => typeof e == "string" || `Expected a string, but received: ${er(e)}`);
}
function f2(e) {
  const t = vh();
  return new Gt({
    type: "tuple",
    schema: null,
    *entries(r) {
      if (Array.isArray(r)) {
        const i = Math.max(e.length, r.length);
        for (let o = 0; o < i; o++)
          yield [o, r[o], e[o] || t];
      }
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array, but received: ${er(r)}`;
    }
  });
}
function bh(e) {
  const t = Object.keys(e);
  return new Gt({
    type: "type",
    schema: e,
    *entries(r) {
      if (jr(r))
        for (const i of t)
          yield [i, r[i], e[i]];
    },
    validator(r) {
      return jr(r) || `Expected an object, but received: ${er(r)}`;
    },
    coercer(r) {
      return jr(r) ? { ...r } : r;
    }
  });
}
function s2(e) {
  const t = e.map((r) => r.type).join(" | ");
  return new Gt({
    type: "union",
    schema: null,
    coercer(r) {
      for (const i of e) {
        const [o, n] = i.validate(r, { coerce: !0 });
        if (!o)
          return n;
      }
      return r;
    },
    validator(r, i) {
      const o = [];
      for (const n of e) {
        const [...f] = dh(r, n, i), [u] = f;
        if (u[0])
          for (const [c] of f)
            c && o.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${er(r)}`,
        ...o
      ];
    }
  });
}
function Hv() {
  return gr("unknown", () => !0);
}
function yh(e, t, r) {
  return new Gt({
    ...e,
    coercer: (i, o) => ph(i, t) ? e.coercer(r(i, o), o) : e.coercer(i, o)
  });
}
function u2(e, t, r = {}) {
  return yh(e, Hv(), (i) => {
    const o = typeof t == "function" ? t() : t;
    if (i === void 0)
      return o;
    if (!r.strict && M0(i) && M0(o)) {
      const n = { ...i };
      let f = !1;
      for (const u in o)
        n[u] === void 0 && (n[u] = o[u], f = !0);
      if (f)
        return n;
    }
    return i;
  });
}
function c2(e) {
  return yh(e, zv(), (t) => t.trim());
}
function h2(e) {
  return ei(e, "empty", (t) => {
    const r = Vv(t);
    return r === 0 || `Expected an empty ${e.type} but received one with a size of \`${r}\``;
  });
}
function Vv(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function l2(e, t, r = {}) {
  const { exclusive: i } = r;
  return ei(e, "max", (o) => i ? o < t : o <= t || `Expected a ${e.type} less than ${i ? "" : "or equal to "}${t} but received \`${o}\``);
}
function d2(e, t, r = {}) {
  const { exclusive: i } = r;
  return ei(e, "min", (o) => i ? o > t : o >= t || `Expected a ${e.type} greater than ${i ? "" : "or equal to "}${t} but received \`${o}\``);
}
function p2(e) {
  return ei(e, "nonempty", (t) => Vv(t) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function v2(e, t) {
  return ei(e, "pattern", (r) => t.test(r) || `Expected a ${e.type} matching \`/${t.source}/\` but received "${r}"`);
}
function b2(e, t, r = t) {
  const i = `Expected a ${e.type}`, o = t === r ? `of \`${t}\`` : `between \`${t}\` and \`${r}\``;
  return ei(e, "size", (n) => {
    if (typeof n == "number" || n instanceof Date)
      return t <= n && n <= r || `${i} ${o} but received \`${n}\``;
    if (n instanceof Map || n instanceof Set) {
      const { size: f } = n;
      return t <= f && f <= r || `${i} with a size ${o} but received one with a size of \`${f}\``;
    } else {
      const { length: f } = n;
      return t <= f && f <= r || `${i} with a length ${o} but received one with a length of \`${f}\``;
    }
  });
}
function ei(e, t, r) {
  return new Gt({
    ...e,
    *refiner(i, o) {
      yield* e.refiner(i, o);
      const n = r(i, o), f = Uc(n, o, e, i);
      for (const u of f)
        yield { ...u, refinement: t };
    }
  });
}
const y2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: Gt,
  StructError: qv,
  any: Hm,
  array: Vm,
  assert: Dv,
  assign: km,
  bigint: Wm,
  boolean: Km,
  coerce: yh,
  create: $v,
  date: Zm,
  defaulted: u2,
  define: gr,
  deprecated: jm,
  dynamic: qm,
  empty: h2,
  enums: Gm,
  func: Jm,
  instance: Xm,
  integer: Ym,
  intersection: Qm,
  is: ph,
  lazy: Dm,
  literal: e2,
  map: t2,
  mask: Uv,
  max: l2,
  min: d2,
  never: vh,
  nonempty: p2,
  nullable: r2,
  number: n2,
  object: la,
  omit: $m,
  optional: Fv,
  partial: Um,
  pattern: v2,
  pick: Fm,
  record: i2,
  refine: ei,
  regexp: a2,
  set: o2,
  size: b2,
  string: zv,
  struct: zm,
  trimmed: c2,
  tuple: f2,
  type: bh,
  union: s2,
  unknown: Hv,
  validate: Li
}, Symbol.toStringTag, { value: "Module" })), ti = /* @__PURE__ */ gv(y2);
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.assertExhaustive = sr.assertStruct = sr.assert = sr.AssertionError = void 0;
const g2 = ti;
function m2(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function w2(e) {
  var t, r;
  return typeof ((r = (t = e == null ? void 0 : e.prototype) === null || t === void 0 ? void 0 : t.constructor) === null || r === void 0 ? void 0 : r.name) == "string";
}
function _2(e) {
  const t = m2(e) ? e.message : String(e);
  return t.endsWith(".") ? t.slice(0, -1) : t;
}
function Wv(e, t) {
  return w2(e) ? new e({
    message: t
  }) : e({
    message: t
  });
}
class gh extends Error {
  constructor(t) {
    super(t.message), this.code = "ERR_ASSERTION";
  }
}
sr.AssertionError = gh;
function x2(e, t = "Assertion failed.", r = gh) {
  if (!e)
    throw t instanceof Error ? t : Wv(r, t);
}
sr.assert = x2;
function E2(e, t, r = "Assertion failed", i = gh) {
  try {
    (0, g2.assert)(e, t);
  } catch (o) {
    throw Wv(i, `${r}: ${_2(o)}.`);
  }
}
sr.assertStruct = E2;
function S2(e) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
sr.assertExhaustive = S2;
var da = {};
Object.defineProperty(da, "__esModule", { value: !0 });
da.base64 = void 0;
const A2 = ti, M2 = sr, R2 = (e, t = {}) => {
  var r, i;
  const o = (r = t.paddingRequired) !== null && r !== void 0 ? r : !1, n = (i = t.characterSet) !== null && i !== void 0 ? i : "base64";
  let f;
  n === "base64" ? f = String.raw`[A-Za-z0-9+\/]` : ((0, M2.assert)(n === "base64url"), f = String.raw`[-_A-Za-z0-9]`);
  let u;
  return o ? u = new RegExp(`^(?:${f}{4})*(?:${f}{3}=|${f}{2}==)?$`, "u") : u = new RegExp(`^(?:${f}{4})*(?:${f}{2,3}|${f}{3}=|${f}{2}==)?$`, "u"), (0, A2.pattern)(e, u);
};
da.base64 = R2;
var Le = {}, Eo = {};
Eo.byteLength = T2;
Eo.toByteArray = P2;
Eo.fromByteArray = L2;
var tn = [], Tr = [], B2 = typeof Uint8Array < "u" ? Uint8Array : Array, pf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ni = 0, I2 = pf.length; ni < I2; ++ni)
  tn[ni] = pf[ni], Tr[pf.charCodeAt(ni)] = ni;
Tr[45] = 62;
Tr[95] = 63;
function Kv(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var i = r === t ? 0 : 4 - r % 4;
  return [r, i];
}
function T2(e) {
  var t = Kv(e), r = t[0], i = t[1];
  return (r + i) * 3 / 4 - i;
}
function O2(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function P2(e) {
  var t, r = Kv(e), i = r[0], o = r[1], n = new B2(O2(e, i, o)), f = 0, u = o > 0 ? i - 4 : i, c;
  for (c = 0; c < u; c += 4)
    t = Tr[e.charCodeAt(c)] << 18 | Tr[e.charCodeAt(c + 1)] << 12 | Tr[e.charCodeAt(c + 2)] << 6 | Tr[e.charCodeAt(c + 3)], n[f++] = t >> 16 & 255, n[f++] = t >> 8 & 255, n[f++] = t & 255;
  return o === 2 && (t = Tr[e.charCodeAt(c)] << 2 | Tr[e.charCodeAt(c + 1)] >> 4, n[f++] = t & 255), o === 1 && (t = Tr[e.charCodeAt(c)] << 10 | Tr[e.charCodeAt(c + 1)] << 4 | Tr[e.charCodeAt(c + 2)] >> 2, n[f++] = t >> 8 & 255, n[f++] = t & 255), n;
}
function C2(e) {
  return tn[e >> 18 & 63] + tn[e >> 12 & 63] + tn[e >> 6 & 63] + tn[e & 63];
}
function N2(e, t, r) {
  for (var i, o = [], n = t; n < r; n += 3)
    i = (e[n] << 16 & 16711680) + (e[n + 1] << 8 & 65280) + (e[n + 2] & 255), o.push(C2(i));
  return o.join("");
}
function L2(e) {
  for (var t, r = e.length, i = r % 3, o = [], n = 16383, f = 0, u = r - i; f < u; f += n)
    o.push(N2(e, f, f + n > u ? u : f + n));
  return i === 1 ? (t = e[r - 1], o.push(
    tn[t >> 2] + tn[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    tn[t >> 10] + tn[t >> 4 & 63] + tn[t << 2 & 63] + "="
  )), o.join("");
}
var mh = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
mh.read = function(e, t, r, i, o) {
  var n, f, u = o * 8 - i - 1, c = (1 << u) - 1, h = c >> 1, s = -7, b = r ? o - 1 : 0, p = r ? -1 : 1, m = e[t + b];
  for (b += p, n = m & (1 << -s) - 1, m >>= -s, s += u; s > 0; n = n * 256 + e[t + b], b += p, s -= 8)
    ;
  for (f = n & (1 << -s) - 1, n >>= -s, s += i; s > 0; f = f * 256 + e[t + b], b += p, s -= 8)
    ;
  if (n === 0)
    n = 1 - h;
  else {
    if (n === c)
      return f ? NaN : (m ? -1 : 1) * (1 / 0);
    f = f + Math.pow(2, i), n = n - h;
  }
  return (m ? -1 : 1) * f * Math.pow(2, n - i);
};
mh.write = function(e, t, r, i, o, n) {
  var f, u, c, h = n * 8 - o - 1, s = (1 << h) - 1, b = s >> 1, p = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = i ? 0 : n - 1, E = i ? 1 : -1, M = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, f = s) : (f = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -f)) < 1 && (f--, c *= 2), f + b >= 1 ? t += p / c : t += p * Math.pow(2, 1 - b), t * c >= 2 && (f++, c /= 2), f + b >= s ? (u = 0, f = s) : f + b >= 1 ? (u = (t * c - 1) * Math.pow(2, o), f = f + b) : (u = t * Math.pow(2, b - 1) * Math.pow(2, o), f = 0)); o >= 8; e[r + m] = u & 255, m += E, u /= 256, o -= 8)
    ;
  for (f = f << o | u, h += o; h > 0; e[r + m] = f & 255, m += E, f /= 256, h -= 8)
    ;
  e[r + m - E] |= M * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = Eo, r = mh, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = T, e.INSPECT_MAX_BYTES = 50;
  var o = 2147483647;
  e.kMaxLength = o, u.TYPED_ARRAY_SUPPORT = n(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function n() {
    try {
      var ee = new Uint8Array(1), C = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(C, Uint8Array.prototype), Object.setPrototypeOf(ee, C), ee.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(ee) {
    if (ee > o)
      throw new RangeError('The value "' + ee + '" is invalid for option "size"');
    var C = new Uint8Array(ee);
    return Object.setPrototypeOf(C, u.prototype), C;
  }
  function u(ee, C, L) {
    if (typeof ee == "number") {
      if (typeof C == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return b(ee);
    }
    return c(ee, C, L);
  }
  u.poolSize = 8192;
  function c(ee, C, L) {
    if (typeof ee == "string")
      return p(ee, C);
    if (ArrayBuffer.isView(ee))
      return E(ee);
    if (ee == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ee
      );
    if (ce(ee, ArrayBuffer) || ee && ce(ee.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ce(ee, SharedArrayBuffer) || ee && ce(ee.buffer, SharedArrayBuffer)))
      return M(ee, C, L);
    if (typeof ee == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var Z = ee.valueOf && ee.valueOf();
    if (Z != null && Z !== ee)
      return u.from(Z, C, L);
    var de = I(ee);
    if (de)
      return de;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ee[Symbol.toPrimitive] == "function")
      return u.from(
        ee[Symbol.toPrimitive]("string"),
        C,
        L
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ee
    );
  }
  u.from = function(ee, C, L) {
    return c(ee, C, L);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function h(ee) {
    if (typeof ee != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ee < 0)
      throw new RangeError('The value "' + ee + '" is invalid for option "size"');
  }
  function s(ee, C, L) {
    return h(ee), ee <= 0 ? f(ee) : C !== void 0 ? typeof L == "string" ? f(ee).fill(C, L) : f(ee).fill(C) : f(ee);
  }
  u.alloc = function(ee, C, L) {
    return s(ee, C, L);
  };
  function b(ee) {
    return h(ee), f(ee < 0 ? 0 : B(ee) | 0);
  }
  u.allocUnsafe = function(ee) {
    return b(ee);
  }, u.allocUnsafeSlow = function(ee) {
    return b(ee);
  };
  function p(ee, C) {
    if ((typeof C != "string" || C === "") && (C = "utf8"), !u.isEncoding(C))
      throw new TypeError("Unknown encoding: " + C);
    var L = j(ee, C) | 0, Z = f(L), de = Z.write(ee, C);
    return de !== L && (Z = Z.slice(0, de)), Z;
  }
  function m(ee) {
    for (var C = ee.length < 0 ? 0 : B(ee.length) | 0, L = f(C), Z = 0; Z < C; Z += 1)
      L[Z] = ee[Z] & 255;
    return L;
  }
  function E(ee) {
    if (ce(ee, Uint8Array)) {
      var C = new Uint8Array(ee);
      return M(C.buffer, C.byteOffset, C.byteLength);
    }
    return m(ee);
  }
  function M(ee, C, L) {
    if (C < 0 || ee.byteLength < C)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ee.byteLength < C + (L || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var Z;
    return C === void 0 && L === void 0 ? Z = new Uint8Array(ee) : L === void 0 ? Z = new Uint8Array(ee, C) : Z = new Uint8Array(ee, C, L), Object.setPrototypeOf(Z, u.prototype), Z;
  }
  function I(ee) {
    if (u.isBuffer(ee)) {
      var C = B(ee.length) | 0, L = f(C);
      return L.length === 0 || ee.copy(L, 0, 0, C), L;
    }
    if (ee.length !== void 0)
      return typeof ee.length != "number" || ve(ee.length) ? f(0) : m(ee);
    if (ee.type === "Buffer" && Array.isArray(ee.data))
      return m(ee.data);
  }
  function B(ee) {
    if (ee >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return ee | 0;
  }
  function T(ee) {
    return +ee != ee && (ee = 0), u.alloc(+ee);
  }
  u.isBuffer = function(C) {
    return C != null && C._isBuffer === !0 && C !== u.prototype;
  }, u.compare = function(C, L) {
    if (ce(C, Uint8Array) && (C = u.from(C, C.offset, C.byteLength)), ce(L, Uint8Array) && (L = u.from(L, L.offset, L.byteLength)), !u.isBuffer(C) || !u.isBuffer(L))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (C === L)
      return 0;
    for (var Z = C.length, de = L.length, me = 0, Te = Math.min(Z, de); me < Te; ++me)
      if (C[me] !== L[me]) {
        Z = C[me], de = L[me];
        break;
      }
    return Z < de ? -1 : de < Z ? 1 : 0;
  }, u.isEncoding = function(C) {
    switch (String(C).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(C, L) {
    if (!Array.isArray(C))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (C.length === 0)
      return u.alloc(0);
    var Z;
    if (L === void 0)
      for (L = 0, Z = 0; Z < C.length; ++Z)
        L += C[Z].length;
    var de = u.allocUnsafe(L), me = 0;
    for (Z = 0; Z < C.length; ++Z) {
      var Te = C[Z];
      if (ce(Te, Uint8Array))
        me + Te.length > de.length ? u.from(Te).copy(de, me) : Uint8Array.prototype.set.call(
          de,
          Te,
          me
        );
      else if (u.isBuffer(Te))
        Te.copy(de, me);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      me += Te.length;
    }
    return de;
  };
  function j(ee, C) {
    if (u.isBuffer(ee))
      return ee.length;
    if (ArrayBuffer.isView(ee) || ce(ee, ArrayBuffer))
      return ee.byteLength;
    if (typeof ee != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ee
      );
    var L = ee.length, Z = arguments.length > 2 && arguments[2] === !0;
    if (!Z && L === 0)
      return 0;
    for (var de = !1; ; )
      switch (C) {
        case "ascii":
        case "latin1":
        case "binary":
          return L;
        case "utf8":
        case "utf-8":
          return F(ee).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L * 2;
        case "hex":
          return L >>> 1;
        case "base64":
          return K(ee).length;
        default:
          if (de)
            return Z ? -1 : F(ee).length;
          C = ("" + C).toLowerCase(), de = !0;
      }
  }
  u.byteLength = j;
  function N(ee, C, L) {
    var Z = !1;
    if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((L === void 0 || L > this.length) && (L = this.length), L <= 0) || (L >>>= 0, C >>>= 0, L <= C))
      return "";
    for (ee || (ee = "utf8"); ; )
      switch (ee) {
        case "hex":
          return S(this, C, L);
        case "utf8":
        case "utf-8":
          return a(this, C, L);
        case "ascii":
          return x(this, C, L);
        case "latin1":
        case "binary":
          return A(this, C, L);
        case "base64":
          return v(this, C, L);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return g(this, C, L);
        default:
          if (Z)
            throw new TypeError("Unknown encoding: " + ee);
          ee = (ee + "").toLowerCase(), Z = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function k(ee, C, L) {
    var Z = ee[C];
    ee[C] = ee[L], ee[L] = Z;
  }
  u.prototype.swap16 = function() {
    var C = this.length;
    if (C % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var L = 0; L < C; L += 2)
      k(this, L, L + 1);
    return this;
  }, u.prototype.swap32 = function() {
    var C = this.length;
    if (C % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var L = 0; L < C; L += 4)
      k(this, L, L + 3), k(this, L + 1, L + 2);
    return this;
  }, u.prototype.swap64 = function() {
    var C = this.length;
    if (C % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var L = 0; L < C; L += 8)
      k(this, L, L + 7), k(this, L + 1, L + 6), k(this, L + 2, L + 5), k(this, L + 3, L + 4);
    return this;
  }, u.prototype.toString = function() {
    var C = this.length;
    return C === 0 ? "" : arguments.length === 0 ? a(this, 0, C) : N.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(C) {
    if (!u.isBuffer(C))
      throw new TypeError("Argument must be a Buffer");
    return this === C ? !0 : u.compare(this, C) === 0;
  }, u.prototype.inspect = function() {
    var C = "", L = e.INSPECT_MAX_BYTES;
    return C = this.toString("hex", 0, L).replace(/(.{2})/g, "$1 ").trim(), this.length > L && (C += " ... "), "<Buffer " + C + ">";
  }, i && (u.prototype[i] = u.prototype.inspect), u.prototype.compare = function(C, L, Z, de, me) {
    if (ce(C, Uint8Array) && (C = u.from(C, C.offset, C.byteLength)), !u.isBuffer(C))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C
      );
    if (L === void 0 && (L = 0), Z === void 0 && (Z = C ? C.length : 0), de === void 0 && (de = 0), me === void 0 && (me = this.length), L < 0 || Z > C.length || de < 0 || me > this.length)
      throw new RangeError("out of range index");
    if (de >= me && L >= Z)
      return 0;
    if (de >= me)
      return -1;
    if (L >= Z)
      return 1;
    if (L >>>= 0, Z >>>= 0, de >>>= 0, me >>>= 0, this === C)
      return 0;
    for (var Te = me - de, ze = Z - L, z = Math.min(Te, ze), ue = this.slice(de, me), se = C.slice(L, Z), _e = 0; _e < z; ++_e)
      if (ue[_e] !== se[_e]) {
        Te = ue[_e], ze = se[_e];
        break;
      }
    return Te < ze ? -1 : ze < Te ? 1 : 0;
  };
  function q(ee, C, L, Z, de) {
    if (ee.length === 0)
      return -1;
    if (typeof L == "string" ? (Z = L, L = 0) : L > 2147483647 ? L = 2147483647 : L < -2147483648 && (L = -2147483648), L = +L, ve(L) && (L = de ? 0 : ee.length - 1), L < 0 && (L = ee.length + L), L >= ee.length) {
      if (de)
        return -1;
      L = ee.length - 1;
    } else if (L < 0)
      if (de)
        L = 0;
      else
        return -1;
    if (typeof C == "string" && (C = u.from(C, Z)), u.isBuffer(C))
      return C.length === 0 ? -1 : $(ee, C, L, Z, de);
    if (typeof C == "number")
      return C = C & 255, typeof Uint8Array.prototype.indexOf == "function" ? de ? Uint8Array.prototype.indexOf.call(ee, C, L) : Uint8Array.prototype.lastIndexOf.call(ee, C, L) : $(ee, [C], L, Z, de);
    throw new TypeError("val must be string, number or Buffer");
  }
  function $(ee, C, L, Z, de) {
    var me = 1, Te = ee.length, ze = C.length;
    if (Z !== void 0 && (Z = String(Z).toLowerCase(), Z === "ucs2" || Z === "ucs-2" || Z === "utf16le" || Z === "utf-16le")) {
      if (ee.length < 2 || C.length < 2)
        return -1;
      me = 2, Te /= 2, ze /= 2, L /= 2;
    }
    function z(Ve, ke) {
      return me === 1 ? Ve[ke] : Ve.readUInt16BE(ke * me);
    }
    var ue;
    if (de) {
      var se = -1;
      for (ue = L; ue < Te; ue++)
        if (z(ee, ue) === z(C, se === -1 ? 0 : ue - se)) {
          if (se === -1 && (se = ue), ue - se + 1 === ze)
            return se * me;
        } else
          se !== -1 && (ue -= ue - se), se = -1;
    } else
      for (L + ze > Te && (L = Te - ze), ue = L; ue >= 0; ue--) {
        for (var _e = !0, Ce = 0; Ce < ze; Ce++)
          if (z(ee, ue + Ce) !== z(C, Ce)) {
            _e = !1;
            break;
          }
        if (_e)
          return ue;
      }
    return -1;
  }
  u.prototype.includes = function(C, L, Z) {
    return this.indexOf(C, L, Z) !== -1;
  }, u.prototype.indexOf = function(C, L, Z) {
    return q(this, C, L, Z, !0);
  }, u.prototype.lastIndexOf = function(C, L, Z) {
    return q(this, C, L, Z, !1);
  };
  function re(ee, C, L, Z) {
    L = Number(L) || 0;
    var de = ee.length - L;
    Z ? (Z = Number(Z), Z > de && (Z = de)) : Z = de;
    var me = C.length;
    Z > me / 2 && (Z = me / 2);
    for (var Te = 0; Te < Z; ++Te) {
      var ze = parseInt(C.substr(Te * 2, 2), 16);
      if (ve(ze))
        return Te;
      ee[L + Te] = ze;
    }
    return Te;
  }
  function Q(ee, C, L, Z) {
    return W(F(C, ee.length - L), ee, L, Z);
  }
  function fe(ee, C, L, Z) {
    return W(te(C), ee, L, Z);
  }
  function U(ee, C, L, Z) {
    return W(K(C), ee, L, Z);
  }
  function y(ee, C, L, Z) {
    return W(he(C, ee.length - L), ee, L, Z);
  }
  u.prototype.write = function(C, L, Z, de) {
    if (L === void 0)
      de = "utf8", Z = this.length, L = 0;
    else if (Z === void 0 && typeof L == "string")
      de = L, Z = this.length, L = 0;
    else if (isFinite(L))
      L = L >>> 0, isFinite(Z) ? (Z = Z >>> 0, de === void 0 && (de = "utf8")) : (de = Z, Z = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var me = this.length - L;
    if ((Z === void 0 || Z > me) && (Z = me), C.length > 0 && (Z < 0 || L < 0) || L > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    de || (de = "utf8");
    for (var Te = !1; ; )
      switch (de) {
        case "hex":
          return re(this, C, L, Z);
        case "utf8":
        case "utf-8":
          return Q(this, C, L, Z);
        case "ascii":
        case "latin1":
        case "binary":
          return fe(this, C, L, Z);
        case "base64":
          return U(this, C, L, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return y(this, C, L, Z);
        default:
          if (Te)
            throw new TypeError("Unknown encoding: " + de);
          de = ("" + de).toLowerCase(), Te = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function v(ee, C, L) {
    return C === 0 && L === ee.length ? t.fromByteArray(ee) : t.fromByteArray(ee.slice(C, L));
  }
  function a(ee, C, L) {
    L = Math.min(ee.length, L);
    for (var Z = [], de = C; de < L; ) {
      var me = ee[de], Te = null, ze = me > 239 ? 4 : me > 223 ? 3 : me > 191 ? 2 : 1;
      if (de + ze <= L) {
        var z, ue, se, _e;
        switch (ze) {
          case 1:
            me < 128 && (Te = me);
            break;
          case 2:
            z = ee[de + 1], (z & 192) === 128 && (_e = (me & 31) << 6 | z & 63, _e > 127 && (Te = _e));
            break;
          case 3:
            z = ee[de + 1], ue = ee[de + 2], (z & 192) === 128 && (ue & 192) === 128 && (_e = (me & 15) << 12 | (z & 63) << 6 | ue & 63, _e > 2047 && (_e < 55296 || _e > 57343) && (Te = _e));
            break;
          case 4:
            z = ee[de + 1], ue = ee[de + 2], se = ee[de + 3], (z & 192) === 128 && (ue & 192) === 128 && (se & 192) === 128 && (_e = (me & 15) << 18 | (z & 63) << 12 | (ue & 63) << 6 | se & 63, _e > 65535 && _e < 1114112 && (Te = _e));
        }
      }
      Te === null ? (Te = 65533, ze = 1) : Te > 65535 && (Te -= 65536, Z.push(Te >>> 10 & 1023 | 55296), Te = 56320 | Te & 1023), Z.push(Te), de += ze;
    }
    return w(Z);
  }
  var d = 4096;
  function w(ee) {
    var C = ee.length;
    if (C <= d)
      return String.fromCharCode.apply(String, ee);
    for (var L = "", Z = 0; Z < C; )
      L += String.fromCharCode.apply(
        String,
        ee.slice(Z, Z += d)
      );
    return L;
  }
  function x(ee, C, L) {
    var Z = "";
    L = Math.min(ee.length, L);
    for (var de = C; de < L; ++de)
      Z += String.fromCharCode(ee[de] & 127);
    return Z;
  }
  function A(ee, C, L) {
    var Z = "";
    L = Math.min(ee.length, L);
    for (var de = C; de < L; ++de)
      Z += String.fromCharCode(ee[de]);
    return Z;
  }
  function S(ee, C, L) {
    var Z = ee.length;
    (!C || C < 0) && (C = 0), (!L || L < 0 || L > Z) && (L = Z);
    for (var de = "", me = C; me < L; ++me)
      de += Be[ee[me]];
    return de;
  }
  function g(ee, C, L) {
    for (var Z = ee.slice(C, L), de = "", me = 0; me < Z.length - 1; me += 2)
      de += String.fromCharCode(Z[me] + Z[me + 1] * 256);
    return de;
  }
  u.prototype.slice = function(C, L) {
    var Z = this.length;
    C = ~~C, L = L === void 0 ? Z : ~~L, C < 0 ? (C += Z, C < 0 && (C = 0)) : C > Z && (C = Z), L < 0 ? (L += Z, L < 0 && (L = 0)) : L > Z && (L = Z), L < C && (L = C);
    var de = this.subarray(C, L);
    return Object.setPrototypeOf(de, u.prototype), de;
  };
  function _(ee, C, L) {
    if (ee % 1 !== 0 || ee < 0)
      throw new RangeError("offset is not uint");
    if (ee + C > L)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(C, L, Z) {
    C = C >>> 0, L = L >>> 0, Z || _(C, L, this.length);
    for (var de = this[C], me = 1, Te = 0; ++Te < L && (me *= 256); )
      de += this[C + Te] * me;
    return de;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(C, L, Z) {
    C = C >>> 0, L = L >>> 0, Z || _(C, L, this.length);
    for (var de = this[C + --L], me = 1; L > 0 && (me *= 256); )
      de += this[C + --L] * me;
    return de;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(C, L) {
    return C = C >>> 0, L || _(C, 1, this.length), this[C];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(C, L) {
    return C = C >>> 0, L || _(C, 2, this.length), this[C] | this[C + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(C, L) {
    return C = C >>> 0, L || _(C, 2, this.length), this[C] << 8 | this[C + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
  }, u.prototype.readIntLE = function(C, L, Z) {
    C = C >>> 0, L = L >>> 0, Z || _(C, L, this.length);
    for (var de = this[C], me = 1, Te = 0; ++Te < L && (me *= 256); )
      de += this[C + Te] * me;
    return me *= 128, de >= me && (de -= Math.pow(2, 8 * L)), de;
  }, u.prototype.readIntBE = function(C, L, Z) {
    C = C >>> 0, L = L >>> 0, Z || _(C, L, this.length);
    for (var de = L, me = 1, Te = this[C + --de]; de > 0 && (me *= 256); )
      Te += this[C + --de] * me;
    return me *= 128, Te >= me && (Te -= Math.pow(2, 8 * L)), Te;
  }, u.prototype.readInt8 = function(C, L) {
    return C = C >>> 0, L || _(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
  }, u.prototype.readInt16LE = function(C, L) {
    C = C >>> 0, L || _(C, 2, this.length);
    var Z = this[C] | this[C + 1] << 8;
    return Z & 32768 ? Z | 4294901760 : Z;
  }, u.prototype.readInt16BE = function(C, L) {
    C = C >>> 0, L || _(C, 2, this.length);
    var Z = this[C + 1] | this[C] << 8;
    return Z & 32768 ? Z | 4294901760 : Z;
  }, u.prototype.readInt32LE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
  }, u.prototype.readInt32BE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
  }, u.prototype.readFloatLE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), r.read(this, C, !0, 23, 4);
  }, u.prototype.readFloatBE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), r.read(this, C, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(C, L) {
    return C = C >>> 0, L || _(C, 8, this.length), r.read(this, C, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(C, L) {
    return C = C >>> 0, L || _(C, 8, this.length), r.read(this, C, !1, 52, 8);
  };
  function l(ee, C, L, Z, de, me) {
    if (!u.isBuffer(ee))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (C > de || C < me)
      throw new RangeError('"value" argument is out of bounds');
    if (L + Z > ee.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(C, L, Z, de) {
    if (C = +C, L = L >>> 0, Z = Z >>> 0, !de) {
      var me = Math.pow(2, 8 * Z) - 1;
      l(this, C, L, Z, me, 0);
    }
    var Te = 1, ze = 0;
    for (this[L] = C & 255; ++ze < Z && (Te *= 256); )
      this[L + ze] = C / Te & 255;
    return L + Z;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(C, L, Z, de) {
    if (C = +C, L = L >>> 0, Z = Z >>> 0, !de) {
      var me = Math.pow(2, 8 * Z) - 1;
      l(this, C, L, Z, me, 0);
    }
    var Te = Z - 1, ze = 1;
    for (this[L + Te] = C & 255; --Te >= 0 && (ze *= 256); )
      this[L + Te] = C / ze & 255;
    return L + Z;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 1, 255, 0), this[L] = C & 255, L + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 2, 65535, 0), this[L] = C & 255, this[L + 1] = C >>> 8, L + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 2, 65535, 0), this[L] = C >>> 8, this[L + 1] = C & 255, L + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 4, 4294967295, 0), this[L + 3] = C >>> 24, this[L + 2] = C >>> 16, this[L + 1] = C >>> 8, this[L] = C & 255, L + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 4, 4294967295, 0), this[L] = C >>> 24, this[L + 1] = C >>> 16, this[L + 2] = C >>> 8, this[L + 3] = C & 255, L + 4;
  }, u.prototype.writeIntLE = function(C, L, Z, de) {
    if (C = +C, L = L >>> 0, !de) {
      var me = Math.pow(2, 8 * Z - 1);
      l(this, C, L, Z, me - 1, -me);
    }
    var Te = 0, ze = 1, z = 0;
    for (this[L] = C & 255; ++Te < Z && (ze *= 256); )
      C < 0 && z === 0 && this[L + Te - 1] !== 0 && (z = 1), this[L + Te] = (C / ze >> 0) - z & 255;
    return L + Z;
  }, u.prototype.writeIntBE = function(C, L, Z, de) {
    if (C = +C, L = L >>> 0, !de) {
      var me = Math.pow(2, 8 * Z - 1);
      l(this, C, L, Z, me - 1, -me);
    }
    var Te = Z - 1, ze = 1, z = 0;
    for (this[L + Te] = C & 255; --Te >= 0 && (ze *= 256); )
      C < 0 && z === 0 && this[L + Te + 1] !== 0 && (z = 1), this[L + Te] = (C / ze >> 0) - z & 255;
    return L + Z;
  }, u.prototype.writeInt8 = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[L] = C & 255, L + 1;
  }, u.prototype.writeInt16LE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 2, 32767, -32768), this[L] = C & 255, this[L + 1] = C >>> 8, L + 2;
  }, u.prototype.writeInt16BE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 2, 32767, -32768), this[L] = C >>> 8, this[L + 1] = C & 255, L + 2;
  }, u.prototype.writeInt32LE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 4, 2147483647, -2147483648), this[L] = C & 255, this[L + 1] = C >>> 8, this[L + 2] = C >>> 16, this[L + 3] = C >>> 24, L + 4;
  }, u.prototype.writeInt32BE = function(C, L, Z) {
    return C = +C, L = L >>> 0, Z || l(this, C, L, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[L] = C >>> 24, this[L + 1] = C >>> 16, this[L + 2] = C >>> 8, this[L + 3] = C & 255, L + 4;
  };
  function R(ee, C, L, Z, de, me) {
    if (L + Z > ee.length)
      throw new RangeError("Index out of range");
    if (L < 0)
      throw new RangeError("Index out of range");
  }
  function Y(ee, C, L, Z, de) {
    return C = +C, L = L >>> 0, de || R(ee, C, L, 4), r.write(ee, C, L, Z, 23, 4), L + 4;
  }
  u.prototype.writeFloatLE = function(C, L, Z) {
    return Y(this, C, L, !0, Z);
  }, u.prototype.writeFloatBE = function(C, L, Z) {
    return Y(this, C, L, !1, Z);
  };
  function oe(ee, C, L, Z, de) {
    return C = +C, L = L >>> 0, de || R(ee, C, L, 8), r.write(ee, C, L, Z, 52, 8), L + 8;
  }
  u.prototype.writeDoubleLE = function(C, L, Z) {
    return oe(this, C, L, !0, Z);
  }, u.prototype.writeDoubleBE = function(C, L, Z) {
    return oe(this, C, L, !1, Z);
  }, u.prototype.copy = function(C, L, Z, de) {
    if (!u.isBuffer(C))
      throw new TypeError("argument should be a Buffer");
    if (Z || (Z = 0), !de && de !== 0 && (de = this.length), L >= C.length && (L = C.length), L || (L = 0), de > 0 && de < Z && (de = Z), de === Z || C.length === 0 || this.length === 0)
      return 0;
    if (L < 0)
      throw new RangeError("targetStart out of bounds");
    if (Z < 0 || Z >= this.length)
      throw new RangeError("Index out of range");
    if (de < 0)
      throw new RangeError("sourceEnd out of bounds");
    de > this.length && (de = this.length), C.length - L < de - Z && (de = C.length - L + Z);
    var me = de - Z;
    return this === C && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(L, Z, de) : Uint8Array.prototype.set.call(
      C,
      this.subarray(Z, de),
      L
    ), me;
  }, u.prototype.fill = function(C, L, Z, de) {
    if (typeof C == "string") {
      if (typeof L == "string" ? (de = L, L = 0, Z = this.length) : typeof Z == "string" && (de = Z, Z = this.length), de !== void 0 && typeof de != "string")
        throw new TypeError("encoding must be a string");
      if (typeof de == "string" && !u.isEncoding(de))
        throw new TypeError("Unknown encoding: " + de);
      if (C.length === 1) {
        var me = C.charCodeAt(0);
        (de === "utf8" && me < 128 || de === "latin1") && (C = me);
      }
    } else
      typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
    if (L < 0 || this.length < L || this.length < Z)
      throw new RangeError("Out of range index");
    if (Z <= L)
      return this;
    L = L >>> 0, Z = Z === void 0 ? this.length : Z >>> 0, C || (C = 0);
    var Te;
    if (typeof C == "number")
      for (Te = L; Te < Z; ++Te)
        this[Te] = C;
    else {
      var ze = u.isBuffer(C) ? C : u.from(C, de), z = ze.length;
      if (z === 0)
        throw new TypeError('The value "' + C + '" is invalid for argument "value"');
      for (Te = 0; Te < Z - L; ++Te)
        this[Te + L] = ze[Te % z];
    }
    return this;
  };
  var H = /[^+/0-9A-Za-z-_]/g;
  function V(ee) {
    if (ee = ee.split("=")[0], ee = ee.trim().replace(H, ""), ee.length < 2)
      return "";
    for (; ee.length % 4 !== 0; )
      ee = ee + "=";
    return ee;
  }
  function F(ee, C) {
    C = C || 1 / 0;
    for (var L, Z = ee.length, de = null, me = [], Te = 0; Te < Z; ++Te) {
      if (L = ee.charCodeAt(Te), L > 55295 && L < 57344) {
        if (!de) {
          if (L > 56319) {
            (C -= 3) > -1 && me.push(239, 191, 189);
            continue;
          } else if (Te + 1 === Z) {
            (C -= 3) > -1 && me.push(239, 191, 189);
            continue;
          }
          de = L;
          continue;
        }
        if (L < 56320) {
          (C -= 3) > -1 && me.push(239, 191, 189), de = L;
          continue;
        }
        L = (de - 55296 << 10 | L - 56320) + 65536;
      } else
        de && (C -= 3) > -1 && me.push(239, 191, 189);
      if (de = null, L < 128) {
        if ((C -= 1) < 0)
          break;
        me.push(L);
      } else if (L < 2048) {
        if ((C -= 2) < 0)
          break;
        me.push(
          L >> 6 | 192,
          L & 63 | 128
        );
      } else if (L < 65536) {
        if ((C -= 3) < 0)
          break;
        me.push(
          L >> 12 | 224,
          L >> 6 & 63 | 128,
          L & 63 | 128
        );
      } else if (L < 1114112) {
        if ((C -= 4) < 0)
          break;
        me.push(
          L >> 18 | 240,
          L >> 12 & 63 | 128,
          L >> 6 & 63 | 128,
          L & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return me;
  }
  function te(ee) {
    for (var C = [], L = 0; L < ee.length; ++L)
      C.push(ee.charCodeAt(L) & 255);
    return C;
  }
  function he(ee, C) {
    for (var L, Z, de, me = [], Te = 0; Te < ee.length && !((C -= 2) < 0); ++Te)
      L = ee.charCodeAt(Te), Z = L >> 8, de = L % 256, me.push(de), me.push(Z);
    return me;
  }
  function K(ee) {
    return t.toByteArray(V(ee));
  }
  function W(ee, C, L, Z) {
    for (var de = 0; de < Z && !(de + L >= C.length || de >= ee.length); ++de)
      C[de + L] = ee[de];
    return de;
  }
  function ce(ee, C) {
    return ee instanceof C || ee != null && ee.constructor != null && ee.constructor.name != null && ee.constructor.name === C.name;
  }
  function ve(ee) {
    return ee !== ee;
  }
  var Be = function() {
    for (var ee = "0123456789abcdef", C = new Array(256), L = 0; L < 16; ++L)
      for (var Z = L * 16, de = 0; de < 16; ++de)
        C[Z + de] = ee[L] + ee[de];
    return C;
  }();
})(Le);
var Zv = { exports: {} }, Jt = Zv.exports = {}, Qr, en;
function Fc() {
  throw new Error("setTimeout has not been defined");
}
function zc() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Qr = setTimeout : Qr = Fc;
  } catch {
    Qr = Fc;
  }
  try {
    typeof clearTimeout == "function" ? en = clearTimeout : en = zc;
  } catch {
    en = zc;
  }
})();
function Gv(e) {
  if (Qr === setTimeout)
    return setTimeout(e, 0);
  if ((Qr === Fc || !Qr) && setTimeout)
    return Qr = setTimeout, setTimeout(e, 0);
  try {
    return Qr(e, 0);
  } catch {
    try {
      return Qr.call(null, e, 0);
    } catch {
      return Qr.call(this, e, 0);
    }
  }
}
function k2(e) {
  if (en === clearTimeout)
    return clearTimeout(e);
  if ((en === zc || !en) && clearTimeout)
    return en = clearTimeout, clearTimeout(e);
  try {
    return en(e);
  } catch {
    try {
      return en.call(null, e);
    } catch {
      return en.call(this, e);
    }
  }
}
var bn = [], gi = !1, Vn, Ja = -1;
function j2() {
  !gi || !Vn || (gi = !1, Vn.length ? bn = Vn.concat(bn) : Ja = -1, bn.length && Jv());
}
function Jv() {
  if (!gi) {
    var e = Gv(j2);
    gi = !0;
    for (var t = bn.length; t; ) {
      for (Vn = bn, bn = []; ++Ja < t; )
        Vn && Vn[Ja].run();
      Ja = -1, t = bn.length;
    }
    Vn = null, gi = !1, k2(e);
  }
}
Jt.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  bn.push(new Xv(e, t)), bn.length === 1 && !gi && Gv(Jv);
};
function Xv(e, t) {
  this.fun = e, this.array = t;
}
Xv.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Jt.title = "browser";
Jt.browser = !0;
Jt.env = {};
Jt.argv = [];
Jt.version = "";
Jt.versions = {};
function mn() {
}
Jt.on = mn;
Jt.addListener = mn;
Jt.once = mn;
Jt.off = mn;
Jt.removeListener = mn;
Jt.removeAllListeners = mn;
Jt.emit = mn;
Jt.prependListener = mn;
Jt.prependOnceListener = mn;
Jt.listeners = function(e) {
  return [];
};
Jt.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Jt.cwd = function() {
  return "/";
};
Jt.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Jt.umask = function() {
  return 0;
};
var q2 = Zv.exports;
const at = /* @__PURE__ */ yv(q2);
(function(e) {
  function t() {
    var i = this || self;
    return delete e.prototype.__magic__, i;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var r = __magic__;
  return r;
})(Object);
var Ct = {}, pa = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
  const t = ti, r = sr;
  e.HexStruct = (0, t.pattern)((0, t.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, t.pattern)((0, t.string)(), /^0x[0-9a-f]+$/iu);
  function i(h) {
    return (0, t.is)(h, e.HexStruct);
  }
  e.isHexString = i;
  function o(h) {
    return (0, t.is)(h, e.StrictHexStruct);
  }
  e.isStrictHexString = o;
  function n(h) {
    (0, r.assert)(i(h), "Value must be a hexadecimal string.");
  }
  e.assertIsHexString = n;
  function f(h) {
    (0, r.assert)(o(h), 'Value must be a hexadecimal string, starting with "0x".');
  }
  e.assertIsStrictHexString = f;
  function u(h) {
    return h.startsWith("0x") ? h : h.startsWith("0X") ? `0x${h.substring(2)}` : `0x${h}`;
  }
  e.add0x = u;
  function c(h) {
    return h.startsWith("0x") || h.startsWith("0X") ? h.substring(2) : h;
  }
  e.remove0x = c;
})(pa);
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.createDataView = Ct.concatBytes = Ct.valueToBytes = Ct.stringToBytes = Ct.numberToBytes = Ct.signedBigIntToBytes = Ct.bigIntToBytes = Ct.hexToBytes = Ct.bytesToString = Ct.bytesToNumber = Ct.bytesToSignedBigInt = Ct.bytesToBigInt = Ct.bytesToHex = Ct.assertIsBytes = Ct.isBytes = void 0;
const _r = sr, Hc = pa, R0 = 48, B0 = 58, I0 = 87;
function D2() {
  const e = [];
  return () => {
    if (e.length === 0)
      for (let t = 0; t < 256; t++)
        e.push(t.toString(16).padStart(2, "0"));
    return e;
  };
}
const $2 = D2();
function wh(e) {
  return e instanceof Uint8Array;
}
Ct.isBytes = wh;
function ki(e) {
  (0, _r.assert)(wh(e), "Value must be a Uint8Array.");
}
Ct.assertIsBytes = ki;
function Yv(e) {
  if (ki(e), e.length === 0)
    return "0x";
  const t = $2(), r = new Array(e.length);
  for (let i = 0; i < e.length; i++)
    r[i] = t[e[i]];
  return (0, Hc.add0x)(r.join(""));
}
Ct.bytesToHex = Yv;
function Qv(e) {
  ki(e);
  const t = Yv(e);
  return BigInt(t);
}
Ct.bytesToBigInt = Qv;
function U2(e) {
  ki(e);
  let t = BigInt(0);
  for (const r of e)
    t = (t << BigInt(8)) + BigInt(r);
  return BigInt.asIntN(e.length * 8, t);
}
Ct.bytesToSignedBigInt = U2;
function F2(e) {
  ki(e);
  const t = Qv(e);
  return (0, _r.assert)(t <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(t);
}
Ct.bytesToNumber = F2;
function z2(e) {
  return ki(e), new TextDecoder().decode(e);
}
Ct.bytesToString = z2;
function So(e) {
  var t;
  if (((t = e == null ? void 0 : e.toLowerCase) === null || t === void 0 ? void 0 : t.call(e)) === "0x")
    return new Uint8Array();
  (0, Hc.assertIsHexString)(e);
  const r = (0, Hc.remove0x)(e).toLowerCase(), i = r.length % 2 === 0 ? r : `0${r}`, o = new Uint8Array(i.length / 2);
  for (let n = 0; n < o.length; n++) {
    const f = i.charCodeAt(n * 2), u = i.charCodeAt(n * 2 + 1), c = f - (f < B0 ? R0 : I0), h = u - (u < B0 ? R0 : I0);
    o[n] = c * 16 + h;
  }
  return o;
}
Ct.hexToBytes = So;
function eb(e) {
  (0, _r.assert)(typeof e == "bigint", "Value must be a bigint."), (0, _r.assert)(e >= BigInt(0), "Value must be a non-negative bigint.");
  const t = e.toString(16);
  return So(t);
}
Ct.bigIntToBytes = eb;
function H2(e, t) {
  (0, _r.assert)(t > 0);
  const r = e >> BigInt(31);
  return !((~e & r) + (e & ~r) >> BigInt(t * 8 + -1));
}
function V2(e, t) {
  (0, _r.assert)(typeof e == "bigint", "Value must be a bigint."), (0, _r.assert)(typeof t == "number", "Byte length must be a number."), (0, _r.assert)(t > 0, "Byte length must be greater than 0."), (0, _r.assert)(H2(e, t), "Byte length is too small to represent the given value.");
  let r = e;
  const i = new Uint8Array(t);
  for (let o = 0; o < i.length; o++)
    i[o] = Number(BigInt.asUintN(8, r)), r >>= BigInt(8);
  return i.reverse();
}
Ct.signedBigIntToBytes = V2;
function tb(e) {
  (0, _r.assert)(typeof e == "number", "Value must be a number."), (0, _r.assert)(e >= 0, "Value must be a non-negative number."), (0, _r.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const t = e.toString(16);
  return So(t);
}
Ct.numberToBytes = tb;
function rb(e) {
  return (0, _r.assert)(typeof e == "string", "Value must be a string."), new TextEncoder().encode(e);
}
Ct.stringToBytes = rb;
function nb(e) {
  if (typeof e == "bigint")
    return eb(e);
  if (typeof e == "number")
    return tb(e);
  if (typeof e == "string")
    return e.startsWith("0x") ? So(e) : rb(e);
  if (wh(e))
    return e;
  throw new TypeError(`Unsupported value type: "${typeof e}".`);
}
Ct.valueToBytes = nb;
function W2(e) {
  const t = new Array(e.length);
  let r = 0;
  for (let o = 0; o < e.length; o++) {
    const n = nb(e[o]);
    t[o] = n, r += n.length;
  }
  const i = new Uint8Array(r);
  for (let o = 0, n = 0; o < t.length; o++)
    i.set(t[o], n), n += t[o].length;
  return i;
}
Ct.concatBytes = W2;
function K2(e) {
  if (typeof Le.Buffer < "u" && e instanceof Le.Buffer) {
    const t = e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
    return new DataView(t);
  }
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
Ct.createDataView = K2;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.ChecksumStruct = void 0;
const T0 = ti, Z2 = da;
Ao.ChecksumStruct = (0, T0.size)((0, Z2.base64)((0, T0.string)(), { paddingRequired: !0 }), 44, 44);
var rn = {};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.createHex = rn.createBytes = rn.createBigInt = rn.createNumber = void 0;
const Ft = ti, G2 = sr, ib = Ct, Mo = pa, ab = (0, Ft.union)([(0, Ft.number)(), (0, Ft.bigint)(), (0, Ft.string)(), Mo.StrictHexStruct]), J2 = (0, Ft.coerce)((0, Ft.number)(), ab, Number), X2 = (0, Ft.coerce)((0, Ft.bigint)(), ab, BigInt);
(0, Ft.union)([Mo.StrictHexStruct, (0, Ft.instance)(Uint8Array)]);
const Y2 = (0, Ft.coerce)((0, Ft.instance)(Uint8Array), (0, Ft.union)([Mo.StrictHexStruct]), ib.hexToBytes), Q2 = (0, Ft.coerce)(Mo.StrictHexStruct, (0, Ft.instance)(Uint8Array), ib.bytesToHex);
function e6(e) {
  try {
    const t = (0, Ft.create)(e, J2);
    return (0, G2.assert)(Number.isFinite(t), `Expected a number-like value, got "${e}".`), t;
  } catch (t) {
    throw t instanceof Ft.StructError ? new Error(`Expected a number-like value, got "${e}".`) : t;
  }
}
rn.createNumber = e6;
function t6(e) {
  try {
    return (0, Ft.create)(e, X2);
  } catch (t) {
    throw t instanceof Ft.StructError ? new Error(`Expected a number-like value, got "${String(t.value)}".`) : t;
  }
}
rn.createBigInt = t6;
function r6(e) {
  if (typeof e == "string" && e.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, Ft.create)(e, Y2);
  } catch (t) {
    throw t instanceof Ft.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
rn.createBytes = r6;
function n6(e) {
  if (e instanceof Uint8Array && e.length === 0 || typeof e == "string" && e.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, Ft.create)(e, Q2);
  } catch (t) {
    throw t instanceof Ft.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
rn.createHex = n6;
var Si = {}, ob = Ze && Ze.__classPrivateFieldSet || function(e, t, r, i, o) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !o : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? o.call(e, r) : o ? o.value = r : t.set(e, r), r;
}, vr = Ze && Ze.__classPrivateFieldGet || function(e, t, r, i) {
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? i : r === "a" ? i.call(e) : i ? i.value : t.get(e);
}, Ur, Gr;
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.FrozenSet = Si.FrozenMap = void 0;
class _h {
  constructor(t) {
    Ur.set(this, void 0), ob(this, Ur, new Map(t), "f"), Object.freeze(this);
  }
  get size() {
    return vr(this, Ur, "f").size;
  }
  [(Ur = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return vr(this, Ur, "f")[Symbol.iterator]();
  }
  entries() {
    return vr(this, Ur, "f").entries();
  }
  forEach(t, r) {
    return vr(this, Ur, "f").forEach((i, o, n) => t.call(r, i, o, this));
  }
  get(t) {
    return vr(this, Ur, "f").get(t);
  }
  has(t) {
    return vr(this, Ur, "f").has(t);
  }
  keys() {
    return vr(this, Ur, "f").keys();
  }
  values() {
    return vr(this, Ur, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([t, r]) => `${String(t)} => ${String(r)}`).join(", ")} ` : ""}}`;
  }
}
Si.FrozenMap = _h;
class xh {
  constructor(t) {
    Gr.set(this, void 0), ob(this, Gr, new Set(t), "f"), Object.freeze(this);
  }
  get size() {
    return vr(this, Gr, "f").size;
  }
  [(Gr = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return vr(this, Gr, "f")[Symbol.iterator]();
  }
  entries() {
    return vr(this, Gr, "f").entries();
  }
  forEach(t, r) {
    return vr(this, Gr, "f").forEach((i, o, n) => t.call(r, i, o, this));
  }
  has(t) {
    return vr(this, Gr, "f").has(t);
  }
  keys() {
    return vr(this, Gr, "f").keys();
  }
  values() {
    return vr(this, Gr, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((t) => String(t)).join(", ")} ` : ""}}`;
  }
}
Si.FrozenSet = xh;
Object.freeze(_h);
Object.freeze(_h.prototype);
Object.freeze(xh);
Object.freeze(xh.prototype);
var fb = {}, Eh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
  function t(h) {
    return Array.isArray(h) && h.length > 0;
  }
  e.isNonEmptyArray = t;
  function r(h) {
    return h == null;
  }
  e.isNullOrUndefined = r;
  function i(h) {
    return !!h && typeof h == "object" && !Array.isArray(h);
  }
  e.isObject = i;
  const o = (h, s) => Object.hasOwnProperty.call(h, s);
  e.hasProperty = o, function(h) {
    h[h.Null = 4] = "Null", h[h.Comma = 1] = "Comma", h[h.Wrapper = 1] = "Wrapper", h[h.True = 4] = "True", h[h.False = 5] = "False", h[h.Quote = 1] = "Quote", h[h.Colon = 1] = "Colon", h[h.Date = 24] = "Date";
  }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function n(h) {
    if (typeof h != "object" || h === null)
      return !1;
    try {
      let s = h;
      for (; Object.getPrototypeOf(s) !== null; )
        s = Object.getPrototypeOf(s);
      return Object.getPrototypeOf(h) === s;
    } catch {
      return !1;
    }
  }
  e.isPlainObject = n;
  function f(h) {
    return h.charCodeAt(0) <= 127;
  }
  e.isASCII = f;
  function u(h) {
    var s;
    return h.split("").reduce((p, m) => f(m) ? p + 1 : p + 2, 0) + ((s = h.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && s !== void 0 ? s : []).length;
  }
  e.calculateStringSize = u;
  function c(h) {
    return h.toString().length;
  }
  e.calculateNumberSize = c;
})(Eh);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateJsonAndGetSize = e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.isValidJson = e.JsonStruct = void 0;
  const t = ti, r = sr, i = Eh;
  e.JsonStruct = (0, t.define)("Json", (k) => {
    const [q] = N(k, !0);
    return q ? !0 : "Expected a valid JSON-serializable value";
  });
  function o(k) {
    return (0, t.is)(k, e.JsonStruct);
  }
  e.isValidJson = o, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, t.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, t.nullable)((0, t.union)([(0, t.number)(), (0, t.string)()])), e.JsonRpcErrorStruct = (0, t.object)({
    code: (0, t.integer)(),
    message: (0, t.string)(),
    data: (0, t.optional)(e.JsonStruct),
    stack: (0, t.optional)((0, t.string)())
  }), e.JsonRpcParamsStruct = (0, t.optional)((0, t.union)([(0, t.record)((0, t.string)(), e.JsonStruct), (0, t.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    method: (0, t.string)(),
    params: e.JsonRpcParamsStruct
  }), e.JsonRpcNotificationStruct = (0, t.omit)(e.JsonRpcRequestStruct, ["id"]);
  function n(k) {
    return (0, t.is)(k, e.JsonRpcNotificationStruct);
  }
  e.isJsonRpcNotification = n;
  function f(k, q) {
    (0, r.assertStruct)(k, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", q);
  }
  e.assertIsJsonRpcNotification = f;
  function u(k) {
    return (0, t.is)(k, e.JsonRpcRequestStruct);
  }
  e.isJsonRpcRequest = u;
  function c(k, q) {
    (0, r.assertStruct)(k, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", q);
  }
  e.assertIsJsonRpcRequest = c, e.PendingJsonRpcResponseStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: (0, t.optional)((0, t.unknown)()),
    error: (0, t.optional)(e.JsonRpcErrorStruct)
  }), e.JsonRpcSuccessStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: e.JsonStruct
  }), e.JsonRpcFailureStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    error: e.JsonRpcErrorStruct
  }), e.JsonRpcResponseStruct = (0, t.union)([
    e.JsonRpcSuccessStruct,
    e.JsonRpcFailureStruct
  ]);
  function h(k) {
    return (0, t.is)(k, e.PendingJsonRpcResponseStruct);
  }
  e.isPendingJsonRpcResponse = h;
  function s(k, q) {
    (0, r.assertStruct)(k, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", q);
  }
  e.assertIsPendingJsonRpcResponse = s;
  function b(k) {
    return (0, t.is)(k, e.JsonRpcResponseStruct);
  }
  e.isJsonRpcResponse = b;
  function p(k, q) {
    (0, r.assertStruct)(k, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", q);
  }
  e.assertIsJsonRpcResponse = p;
  function m(k) {
    return (0, t.is)(k, e.JsonRpcSuccessStruct);
  }
  e.isJsonRpcSuccess = m;
  function E(k, q) {
    (0, r.assertStruct)(k, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", q);
  }
  e.assertIsJsonRpcSuccess = E;
  function M(k) {
    return (0, t.is)(k, e.JsonRpcFailureStruct);
  }
  e.isJsonRpcFailure = M;
  function I(k, q) {
    (0, r.assertStruct)(k, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", q);
  }
  e.assertIsJsonRpcFailure = I;
  function B(k) {
    return (0, t.is)(k, e.JsonRpcErrorStruct);
  }
  e.isJsonRpcError = B;
  function T(k, q) {
    (0, r.assertStruct)(k, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", q);
  }
  e.assertIsJsonRpcError = T;
  function j(k) {
    const { permitEmptyString: q, permitFractions: $, permitNull: re } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, k);
    return (fe) => !!(typeof fe == "number" && ($ || Number.isInteger(fe)) || typeof fe == "string" && (q || fe.length > 0) || re && fe === null);
  }
  e.getJsonRpcIdValidator = j;
  function N(k, q = !1) {
    const $ = /* @__PURE__ */ new Set();
    function re(Q, fe) {
      if (Q === void 0)
        return [!1, 0];
      if (Q === null)
        return [!0, fe ? 0 : i.JsonSize.Null];
      const U = typeof Q;
      try {
        if (U === "function")
          return [!1, 0];
        if (U === "string" || Q instanceof String)
          return [
            !0,
            fe ? 0 : (0, i.calculateStringSize)(Q) + i.JsonSize.Quote * 2
          ];
        if (U === "boolean" || Q instanceof Boolean)
          return fe ? [!0, 0] : [!0, Q == !0 ? i.JsonSize.True : i.JsonSize.False];
        if (U === "number" || Q instanceof Number)
          return fe ? [!0, 0] : [!0, (0, i.calculateNumberSize)(Q)];
        if (Q instanceof Date)
          return fe ? [!0, 0] : [
            !0,
            // Note: Invalid dates will serialize to null
            isNaN(Q.getDate()) ? i.JsonSize.Null : i.JsonSize.Date + i.JsonSize.Quote * 2
          ];
      } catch {
        return [!1, 0];
      }
      if (!(0, i.isPlainObject)(Q) && !Array.isArray(Q))
        return [!1, 0];
      if ($.has(Q))
        return [!1, 0];
      $.add(Q);
      try {
        return [
          !0,
          Object.entries(Q).reduce(
            (y, [v, a], d, w) => {
              let [x, A] = re(a, fe);
              if (!x)
                throw new Error("JSON validation did not pass. Validation process stopped.");
              if ($.delete(Q), fe)
                return 0;
              const S = Array.isArray(Q) ? 0 : v.length + i.JsonSize.Comma + i.JsonSize.Colon * 2, g = d < w.length - 1 ? i.JsonSize.Comma : 0;
              return y + S + A + g;
            },
            // Starts at 2 because the serialized JSON string data (plain text)
            // will minimally contain {}/[]
            fe ? 0 : i.JsonSize.Wrapper * 2
          )
        ];
      } catch {
        return [!1, 0];
      }
    }
    return re(k, q);
  }
  e.validateJsonAndGetSize = N;
})(fb);
var Ai = {}, Vc = { exports: {} }, vf, O0;
function i6() {
  if (O0)
    return vf;
  O0 = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, o = i * 7, n = i * 365.25;
  vf = function(s, b) {
    b = b || {};
    var p = typeof s;
    if (p === "string" && s.length > 0)
      return f(s);
    if (p === "number" && isFinite(s))
      return b.long ? c(s) : u(s);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(s)
    );
  };
  function f(s) {
    if (s = String(s), !(s.length > 100)) {
      var b = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        s
      );
      if (b) {
        var p = parseFloat(b[1]), m = (b[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * n;
          case "weeks":
          case "week":
          case "w":
            return p * o;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function u(s) {
    var b = Math.abs(s);
    return b >= i ? Math.round(s / i) + "d" : b >= r ? Math.round(s / r) + "h" : b >= t ? Math.round(s / t) + "m" : b >= e ? Math.round(s / e) + "s" : s + "ms";
  }
  function c(s) {
    var b = Math.abs(s);
    return b >= i ? h(s, b, i, "day") : b >= r ? h(s, b, r, "hour") : b >= t ? h(s, b, t, "minute") : b >= e ? h(s, b, e, "second") : s + " ms";
  }
  function h(s, b, p, m) {
    var E = b >= p * 1.5;
    return Math.round(s / p) + " " + m + (E ? "s" : "");
  }
  return vf;
}
function a6(e) {
  r.debug = r, r.default = r, r.coerce = c, r.disable = n, r.enable = o, r.enabled = f, r.humanize = i6(), r.destroy = h, Object.keys(e).forEach((s) => {
    r[s] = e[s];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(s) {
    let b = 0;
    for (let p = 0; p < s.length; p++)
      b = (b << 5) - b + s.charCodeAt(p), b |= 0;
    return r.colors[Math.abs(b) % r.colors.length];
  }
  r.selectColor = t;
  function r(s) {
    let b, p = null, m, E;
    function M(...I) {
      if (!M.enabled)
        return;
      const B = M, T = Number(/* @__PURE__ */ new Date()), j = T - (b || T);
      B.diff = j, B.prev = b, B.curr = T, b = T, I[0] = r.coerce(I[0]), typeof I[0] != "string" && I.unshift("%O");
      let N = 0;
      I[0] = I[0].replace(/%([a-zA-Z%])/g, (q, $) => {
        if (q === "%%")
          return "%";
        N++;
        const re = r.formatters[$];
        if (typeof re == "function") {
          const Q = I[N];
          q = re.call(B, Q), I.splice(N, 1), N--;
        }
        return q;
      }), r.formatArgs.call(B, I), (B.log || r.log).apply(B, I);
    }
    return M.namespace = s, M.useColors = r.useColors(), M.color = r.selectColor(s), M.extend = i, M.destroy = r.destroy, Object.defineProperty(M, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (m !== r.namespaces && (m = r.namespaces, E = r.enabled(s)), E),
      set: (I) => {
        p = I;
      }
    }), typeof r.init == "function" && r.init(M), M;
  }
  function i(s, b) {
    const p = r(this.namespace + (typeof b > "u" ? ":" : b) + s);
    return p.log = this.log, p;
  }
  function o(s) {
    r.save(s), r.namespaces = s, r.names = [], r.skips = [];
    let b;
    const p = (typeof s == "string" ? s : "").split(/[\s,]+/), m = p.length;
    for (b = 0; b < m; b++)
      p[b] && (s = p[b].replace(/\*/g, ".*?"), s[0] === "-" ? r.skips.push(new RegExp("^" + s.slice(1) + "$")) : r.names.push(new RegExp("^" + s + "$")));
  }
  function n() {
    const s = [
      ...r.names.map(u),
      ...r.skips.map(u).map((b) => "-" + b)
    ].join(",");
    return r.enable(""), s;
  }
  function f(s) {
    if (s[s.length - 1] === "*")
      return !0;
    let b, p;
    for (b = 0, p = r.skips.length; b < p; b++)
      if (r.skips[b].test(s))
        return !1;
    for (b = 0, p = r.names.length; b < p; b++)
      if (r.names[b].test(s))
        return !0;
    return !1;
  }
  function u(s) {
    return s.toString().substring(2, s.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(s) {
    return s instanceof Error ? s.stack || s.message : s;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var o6 = a6;
(function(e, t) {
  t.formatArgs = i, t.save = o, t.load = n, t.useColors = r, t.storage = f(), t.destroy = /* @__PURE__ */ (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    c.splice(1, 0, h, "color: inherit");
    let s = 0, b = 0;
    c[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (s++, p === "%c" && (b = s));
    }), c.splice(b, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function o(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function n() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof at < "u" && "env" in at && (c = at.env.DEBUG), c;
  }
  function f() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = o6(t);
  const { formatters: u } = e.exports;
  u.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(Vc, Vc.exports);
var f6 = Vc.exports, s6 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.createModuleLogger = Ai.createProjectLogger = void 0;
const u6 = s6(f6), c6 = (0, u6.default)("metamask");
function h6(e) {
  return c6.extend(e);
}
Ai.createProjectLogger = h6;
function l6(e, t) {
  return e.extend(t);
}
Ai.createModuleLogger = l6;
var nn = {};
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.hexToBigInt = nn.hexToNumber = nn.bigIntToHex = nn.numberToHex = void 0;
const mi = sr, ia = pa, d6 = (e) => ((0, mi.assert)(typeof e == "number", "Value must be a number."), (0, mi.assert)(e >= 0, "Value must be a non-negative number."), (0, mi.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, ia.add0x)(e.toString(16)));
nn.numberToHex = d6;
const p6 = (e) => ((0, mi.assert)(typeof e == "bigint", "Value must be a bigint."), (0, mi.assert)(e >= 0, "Value must be a non-negative bigint."), (0, ia.add0x)(e.toString(16)));
nn.bigIntToHex = p6;
const v6 = (e) => {
  (0, ia.assertIsHexString)(e);
  const t = parseInt(e, 16);
  return (0, mi.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `hexToBigInt` instead."), t;
};
nn.hexToNumber = v6;
const b6 = (e) => ((0, ia.assertIsHexString)(e), BigInt((0, ia.add0x)(e)));
nn.hexToBigInt = b6;
var sb = {};
Object.defineProperty(sb, "__esModule", { value: !0 });
var ub = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(n) {
    n[n.Millisecond = 1] = "Millisecond", n[n.Second = 1e3] = "Second", n[n.Minute = 6e4] = "Minute", n[n.Hour = 36e5] = "Hour", n[n.Day = 864e5] = "Day", n[n.Week = 6048e5] = "Week", n[n.Year = 31536e6] = "Year";
  }(e.Duration || (e.Duration = {}));
  const t = (n) => Number.isInteger(n) && n >= 0, r = (n, f) => {
    if (!t(n))
      throw new Error(`"${f}" must be a non-negative integer. Received: "${n}".`);
  };
  function i(n, f) {
    return r(n, "count"), n * f;
  }
  e.inMilliseconds = i;
  function o(n) {
    return r(n, "timestamp"), Date.now() - n;
  }
  e.timeSince = o;
})(ub);
var cb = {}, Wc = { exports: {} };
const y6 = "2.0.0", hb = 256, g6 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, m6 = 16, w6 = hb - 6, _6 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Ro = {
  MAX_LENGTH: hb,
  MAX_SAFE_COMPONENT_LENGTH: m6,
  MAX_SAFE_BUILD_LENGTH: w6,
  MAX_SAFE_INTEGER: g6,
  RELEASE_TYPES: _6,
  SEMVER_SPEC_VERSION: y6,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const x6 = typeof at == "object" && at.env && at.env.NODE_DEBUG && /\bsemver\b/i.test(at.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Bo = x6;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_LENGTH: o
  } = Ro, n = Bo;
  t = e.exports = {};
  const f = t.re = [], u = t.safeRe = [], c = t.src = [], h = t.t = {};
  let s = 0;
  const b = "[a-zA-Z0-9-]", p = [
    ["\\s", 1],
    ["\\d", o],
    [b, i]
  ], m = (M) => {
    for (const [I, B] of p)
      M = M.split(`${I}*`).join(`${I}{0,${B}}`).split(`${I}+`).join(`${I}{1,${B}}`);
    return M;
  }, E = (M, I, B) => {
    const T = m(I), j = s++;
    n(M, j, I), h[M] = j, c[j] = I, f[j] = new RegExp(I, B ? "g" : void 0), u[j] = new RegExp(T, B ? "g" : void 0);
  };
  E("NUMERICIDENTIFIER", "0|[1-9]\\d*"), E("NUMERICIDENTIFIERLOOSE", "\\d+"), E("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${b}*`), E("MAINVERSION", `(${c[h.NUMERICIDENTIFIER]})\\.(${c[h.NUMERICIDENTIFIER]})\\.(${c[h.NUMERICIDENTIFIER]})`), E("MAINVERSIONLOOSE", `(${c[h.NUMERICIDENTIFIERLOOSE]})\\.(${c[h.NUMERICIDENTIFIERLOOSE]})\\.(${c[h.NUMERICIDENTIFIERLOOSE]})`), E("PRERELEASEIDENTIFIER", `(?:${c[h.NUMERICIDENTIFIER]}|${c[h.NONNUMERICIDENTIFIER]})`), E("PRERELEASEIDENTIFIERLOOSE", `(?:${c[h.NUMERICIDENTIFIERLOOSE]}|${c[h.NONNUMERICIDENTIFIER]})`), E("PRERELEASE", `(?:-(${c[h.PRERELEASEIDENTIFIER]}(?:\\.${c[h.PRERELEASEIDENTIFIER]})*))`), E("PRERELEASELOOSE", `(?:-?(${c[h.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[h.PRERELEASEIDENTIFIERLOOSE]})*))`), E("BUILDIDENTIFIER", `${b}+`), E("BUILD", `(?:\\+(${c[h.BUILDIDENTIFIER]}(?:\\.${c[h.BUILDIDENTIFIER]})*))`), E("FULLPLAIN", `v?${c[h.MAINVERSION]}${c[h.PRERELEASE]}?${c[h.BUILD]}?`), E("FULL", `^${c[h.FULLPLAIN]}$`), E("LOOSEPLAIN", `[v=\\s]*${c[h.MAINVERSIONLOOSE]}${c[h.PRERELEASELOOSE]}?${c[h.BUILD]}?`), E("LOOSE", `^${c[h.LOOSEPLAIN]}$`), E("GTLT", "((?:<|>)?=?)"), E("XRANGEIDENTIFIERLOOSE", `${c[h.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), E("XRANGEIDENTIFIER", `${c[h.NUMERICIDENTIFIER]}|x|X|\\*`), E("XRANGEPLAIN", `[v=\\s]*(${c[h.XRANGEIDENTIFIER]})(?:\\.(${c[h.XRANGEIDENTIFIER]})(?:\\.(${c[h.XRANGEIDENTIFIER]})(?:${c[h.PRERELEASE]})?${c[h.BUILD]}?)?)?`), E("XRANGEPLAINLOOSE", `[v=\\s]*(${c[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[h.XRANGEIDENTIFIERLOOSE]})(?:${c[h.PRERELEASELOOSE]})?${c[h.BUILD]}?)?)?`), E("XRANGE", `^${c[h.GTLT]}\\s*${c[h.XRANGEPLAIN]}$`), E("XRANGELOOSE", `^${c[h.GTLT]}\\s*${c[h.XRANGEPLAINLOOSE]}$`), E("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), E("COERCERTL", c[h.COERCE], !0), E("LONETILDE", "(?:~>?)"), E("TILDETRIM", `(\\s*)${c[h.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", E("TILDE", `^${c[h.LONETILDE]}${c[h.XRANGEPLAIN]}$`), E("TILDELOOSE", `^${c[h.LONETILDE]}${c[h.XRANGEPLAINLOOSE]}$`), E("LONECARET", "(?:\\^)"), E("CARETTRIM", `(\\s*)${c[h.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", E("CARET", `^${c[h.LONECARET]}${c[h.XRANGEPLAIN]}$`), E("CARETLOOSE", `^${c[h.LONECARET]}${c[h.XRANGEPLAINLOOSE]}$`), E("COMPARATORLOOSE", `^${c[h.GTLT]}\\s*(${c[h.LOOSEPLAIN]})$|^$`), E("COMPARATOR", `^${c[h.GTLT]}\\s*(${c[h.FULLPLAIN]})$|^$`), E("COMPARATORTRIM", `(\\s*)${c[h.GTLT]}\\s*(${c[h.LOOSEPLAIN]}|${c[h.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", E("HYPHENRANGE", `^\\s*(${c[h.XRANGEPLAIN]})\\s+-\\s+(${c[h.XRANGEPLAIN]})\\s*$`), E("HYPHENRANGELOOSE", `^\\s*(${c[h.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[h.XRANGEPLAINLOOSE]})\\s*$`), E("STAR", "(<|>)?=?\\s*\\*"), E("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), E("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Wc, Wc.exports);
var va = Wc.exports;
const E6 = Object.freeze({ loose: !0 }), S6 = Object.freeze({}), A6 = (e) => e ? typeof e != "object" ? E6 : e : S6;
var Sh = A6;
const P0 = /^[0-9]+$/, lb = (e, t) => {
  const r = P0.test(e), i = P0.test(t);
  return r && i && (e = +e, t = +t), e === t ? 0 : r && !i ? -1 : i && !r ? 1 : e < t ? -1 : 1;
}, M6 = (e, t) => lb(t, e);
var db = {
  compareIdentifiers: lb,
  rcompareIdentifiers: M6
};
const Ra = Bo, { MAX_LENGTH: C0, MAX_SAFE_INTEGER: Ba } = Ro, { safeRe: N0, t: L0 } = va, R6 = Sh, { compareIdentifiers: ii } = db;
let B6 = class Xr {
  constructor(t, r) {
    if (r = R6(r), t instanceof Xr) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > C0)
      throw new TypeError(
        `version is longer than ${C0} characters`
      );
    Ra("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const i = t.trim().match(r.loose ? N0[L0.LOOSE] : N0[L0.FULL]);
    if (!i)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Ba || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Ba || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Ba || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((o) => {
      if (/^[0-9]+$/.test(o)) {
        const n = +o;
        if (n >= 0 && n < Ba)
          return n;
      }
      return o;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Ra("SemVer.compare", this.version, this.options, t), !(t instanceof Xr)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new Xr(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof Xr || (t = new Xr(t, this.options)), ii(this.major, t.major) || ii(this.minor, t.minor) || ii(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof Xr || (t = new Xr(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const i = this.prerelease[r], o = t.prerelease[r];
      if (Ra("prerelease compare", r, i, o), i === void 0 && o === void 0)
        return 0;
      if (o === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === o)
        continue;
      return ii(i, o);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof Xr || (t = new Xr(t, this.options));
    let r = 0;
    do {
      const i = this.build[r], o = t.build[r];
      if (Ra("prerelease compare", r, i, o), i === void 0 && o === void 0)
        return 0;
      if (o === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === o)
        continue;
      return ii(i, o);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r, i) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, i);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, i);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, i), this.inc("pre", r, i);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, i), this.inc("pre", r, i);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const o = Number(i) ? 1 : 0;
        if (!r && i === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [o];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          if (n === -1) {
            if (r === this.prerelease.join(".") && i === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(o);
          }
        }
        if (r) {
          let n = [r, o];
          i === !1 && (n = [r]), ii(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = n) : this.prerelease = n;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var br = B6;
const k0 = br, I6 = (e, t, r = !1) => {
  if (e instanceof k0)
    return e;
  try {
    return new k0(e, t);
  } catch (i) {
    if (!r)
      return null;
    throw i;
  }
};
var ji = I6;
const T6 = ji, O6 = (e, t) => {
  const r = T6(e, t);
  return r ? r.version : null;
};
var P6 = O6;
const C6 = ji, N6 = (e, t) => {
  const r = C6(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var L6 = N6;
const j0 = br, k6 = (e, t, r, i, o) => {
  typeof r == "string" && (o = i, i = r, r = void 0);
  try {
    return new j0(
      e instanceof j0 ? e.version : e,
      r
    ).inc(t, i, o).version;
  } catch {
    return null;
  }
};
var j6 = k6;
const q0 = ji, q6 = (e, t) => {
  const r = q0(e, null, !0), i = q0(t, null, !0), o = r.compare(i);
  if (o === 0)
    return null;
  const n = o > 0, f = n ? r : i, u = n ? i : r, c = !!f.prerelease.length;
  if (!!u.prerelease.length && !c)
    return !u.patch && !u.minor ? "major" : f.patch ? "patch" : f.minor ? "minor" : "major";
  const s = c ? "pre" : "";
  return r.major !== i.major ? s + "major" : r.minor !== i.minor ? s + "minor" : r.patch !== i.patch ? s + "patch" : "prerelease";
};
var D6 = q6;
const $6 = br, U6 = (e, t) => new $6(e, t).major;
var F6 = U6;
const z6 = br, H6 = (e, t) => new z6(e, t).minor;
var V6 = H6;
const W6 = br, K6 = (e, t) => new W6(e, t).patch;
var Z6 = K6;
const G6 = ji, J6 = (e, t) => {
  const r = G6(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var X6 = J6;
const D0 = br, Y6 = (e, t, r) => new D0(e, r).compare(new D0(t, r));
var Kr = Y6;
const Q6 = Kr, ew = (e, t, r) => Q6(t, e, r);
var tw = ew;
const rw = Kr, nw = (e, t) => rw(e, t, !0);
var iw = nw;
const $0 = br, aw = (e, t, r) => {
  const i = new $0(e, r), o = new $0(t, r);
  return i.compare(o) || i.compareBuild(o);
};
var Ah = aw;
const ow = Ah, fw = (e, t) => e.sort((r, i) => ow(r, i, t));
var sw = fw;
const uw = Ah, cw = (e, t) => e.sort((r, i) => uw(i, r, t));
var hw = cw;
const lw = Kr, dw = (e, t, r) => lw(e, t, r) > 0;
var Io = dw;
const pw = Kr, vw = (e, t, r) => pw(e, t, r) < 0;
var Mh = vw;
const bw = Kr, yw = (e, t, r) => bw(e, t, r) === 0;
var pb = yw;
const gw = Kr, mw = (e, t, r) => gw(e, t, r) !== 0;
var vb = mw;
const ww = Kr, _w = (e, t, r) => ww(e, t, r) >= 0;
var Rh = _w;
const xw = Kr, Ew = (e, t, r) => xw(e, t, r) <= 0;
var Bh = Ew;
const Sw = pb, Aw = vb, Mw = Io, Rw = Rh, Bw = Mh, Iw = Bh, Tw = (e, t, r, i) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return Sw(e, r, i);
    case "!=":
      return Aw(e, r, i);
    case ">":
      return Mw(e, r, i);
    case ">=":
      return Rw(e, r, i);
    case "<":
      return Bw(e, r, i);
    case "<=":
      return Iw(e, r, i);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var bb = Tw;
const Ow = br, Pw = ji, { safeRe: Ia, t: Ta } = va, Cw = (e, t) => {
  if (e instanceof Ow)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
    r = e.match(Ia[Ta.COERCE]);
  else {
    let i;
    for (; (i = Ia[Ta.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || i.index + i[0].length !== r.index + r[0].length) && (r = i), Ia[Ta.COERCERTL].lastIndex = i.index + i[1].length + i[2].length;
    Ia[Ta.COERCERTL].lastIndex = -1;
  }
  return r === null ? null : Pw(`${r[2]}.${r[3] || "0"}.${r[4] || "0"}`, t);
};
var Nw = Cw, bf, U0;
function Lw() {
  return U0 || (U0 = 1, bf = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), bf;
}
var kw = Nt;
Nt.Node = Xn;
Nt.create = Nt;
function Nt(e) {
  var t = this;
  if (t instanceof Nt || (t = new Nt()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(o) {
      t.push(o);
    });
  else if (arguments.length > 0)
    for (var r = 0, i = arguments.length; r < i; r++)
      t.push(arguments[r]);
  return t;
}
Nt.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, r = e.prev;
  return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
Nt.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
Nt.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
Nt.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    qw(this, arguments[e]);
  return this.length;
};
Nt.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    Dw(this, arguments[e]);
  return this.length;
};
Nt.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
Nt.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
Nt.prototype.forEach = function(e, t) {
  t = t || this;
  for (var r = this.head, i = 0; r !== null; i++)
    e.call(t, r.value, i, this), r = r.next;
};
Nt.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var r = this.tail, i = this.length - 1; r !== null; i--)
    e.call(t, r.value, i, this), r = r.prev;
};
Nt.prototype.get = function(e) {
  for (var t = 0, r = this.head; r !== null && t < e; t++)
    r = r.next;
  if (t === e && r !== null)
    return r.value;
};
Nt.prototype.getReverse = function(e) {
  for (var t = 0, r = this.tail; r !== null && t < e; t++)
    r = r.prev;
  if (t === e && r !== null)
    return r.value;
};
Nt.prototype.map = function(e, t) {
  t = t || this;
  for (var r = new Nt(), i = this.head; i !== null; )
    r.push(e.call(t, i.value, this)), i = i.next;
  return r;
};
Nt.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var r = new Nt(), i = this.tail; i !== null; )
    r.push(e.call(t, i.value, this)), i = i.prev;
  return r;
};
Nt.prototype.reduce = function(e, t) {
  var r, i = this.head;
  if (arguments.length > 1)
    r = t;
  else if (this.head)
    i = this.head.next, r = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var o = 0; i !== null; o++)
    r = e(r, i.value, o), i = i.next;
  return r;
};
Nt.prototype.reduceReverse = function(e, t) {
  var r, i = this.tail;
  if (arguments.length > 1)
    r = t;
  else if (this.tail)
    i = this.tail.prev, r = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var o = this.length - 1; i !== null; o--)
    r = e(r, i.value, o), i = i.prev;
  return r;
};
Nt.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
    e[t] = r.value, r = r.next;
  return e;
};
Nt.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
    e[t] = r.value, r = r.prev;
  return e;
};
Nt.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new Nt();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = 0, o = this.head; o !== null && i < e; i++)
    o = o.next;
  for (; o !== null && i < t; i++, o = o.next)
    r.push(o.value);
  return r;
};
Nt.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new Nt();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = this.length, o = this.tail; o !== null && i > t; i--)
    o = o.prev;
  for (; o !== null && i > e; i--, o = o.prev)
    r.push(o.value);
  return r;
};
Nt.prototype.splice = function(e, t, ...r) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var i = 0, o = this.head; o !== null && i < e; i++)
    o = o.next;
  for (var n = [], i = 0; o && i < t; i++)
    n.push(o.value), o = this.removeNode(o);
  o === null && (o = this.tail), o !== this.head && o !== this.tail && (o = o.prev);
  for (var i = 0; i < r.length; i++)
    o = jw(this, o, r[i]);
  return n;
};
Nt.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
    var i = r.prev;
    r.prev = r.next, r.next = i;
  }
  return this.head = t, this.tail = e, this;
};
function jw(e, t, r) {
  var i = t === e.head ? new Xn(r, null, t, e) : new Xn(r, t, t.next, e);
  return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
}
function qw(e, t) {
  e.tail = new Xn(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function Dw(e, t) {
  e.head = new Xn(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function Xn(e, t, r, i) {
  if (!(this instanceof Xn))
    return new Xn(e, t, r, i);
  this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
}
try {
  Lw()(Nt);
} catch {
}
const $w = kw, $n = Symbol("max"), dn = Symbol("length"), ai = Symbol("lengthCalculator"), Yi = Symbol("allowStale"), Wn = Symbol("maxAge"), cn = Symbol("dispose"), F0 = Symbol("noDisposeOnSet"), rr = Symbol("lruList"), Hr = Symbol("cache"), yb = Symbol("updateAgeOnGet"), yf = () => 1;
class Uw {
  constructor(t) {
    if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[$n] = t.max || 1 / 0;
    const r = t.length || yf;
    if (this[ai] = typeof r != "function" ? yf : r, this[Yi] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Wn] = t.maxAge || 0, this[cn] = t.dispose, this[F0] = t.noDisposeOnSet || !1, this[yb] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[$n] = t || 1 / 0, Hi(this);
  }
  get max() {
    return this[$n];
  }
  set allowStale(t) {
    this[Yi] = !!t;
  }
  get allowStale() {
    return this[Yi];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Wn] = t, Hi(this);
  }
  get maxAge() {
    return this[Wn];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = yf), t !== this[ai] && (this[ai] = t, this[dn] = 0, this[rr].forEach((r) => {
      r.length = this[ai](r.value, r.key), this[dn] += r.length;
    })), Hi(this);
  }
  get lengthCalculator() {
    return this[ai];
  }
  get length() {
    return this[dn];
  }
  get itemCount() {
    return this[rr].length;
  }
  rforEach(t, r) {
    r = r || this;
    for (let i = this[rr].tail; i !== null; ) {
      const o = i.prev;
      z0(this, t, i, r), i = o;
    }
  }
  forEach(t, r) {
    r = r || this;
    for (let i = this[rr].head; i !== null; ) {
      const o = i.next;
      z0(this, t, i, r), i = o;
    }
  }
  keys() {
    return this[rr].toArray().map((t) => t.key);
  }
  values() {
    return this[rr].toArray().map((t) => t.value);
  }
  reset() {
    this[cn] && this[rr] && this[rr].length && this[rr].forEach((t) => this[cn](t.key, t.value)), this[Hr] = /* @__PURE__ */ new Map(), this[rr] = new $w(), this[dn] = 0;
  }
  dump() {
    return this[rr].map((t) => io(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[rr];
  }
  set(t, r, i) {
    if (i = i || this[Wn], i && typeof i != "number")
      throw new TypeError("maxAge must be a number");
    const o = i ? Date.now() : 0, n = this[ai](r, t);
    if (this[Hr].has(t)) {
      if (n > this[$n])
        return wi(this, this[Hr].get(t)), !1;
      const c = this[Hr].get(t).value;
      return this[cn] && (this[F0] || this[cn](t, c.value)), c.now = o, c.maxAge = i, c.value = r, this[dn] += n - c.length, c.length = n, this.get(t), Hi(this), !0;
    }
    const f = new Fw(t, r, n, o, i);
    return f.length > this[$n] ? (this[cn] && this[cn](t, r), !1) : (this[dn] += f.length, this[rr].unshift(f), this[Hr].set(t, this[rr].head), Hi(this), !0);
  }
  has(t) {
    if (!this[Hr].has(t))
      return !1;
    const r = this[Hr].get(t).value;
    return !io(this, r);
  }
  get(t) {
    return gf(this, t, !0);
  }
  peek(t) {
    return gf(this, t, !1);
  }
  pop() {
    const t = this[rr].tail;
    return t ? (wi(this, t), t.value) : null;
  }
  del(t) {
    wi(this, this[Hr].get(t));
  }
  load(t) {
    this.reset();
    const r = Date.now();
    for (let i = t.length - 1; i >= 0; i--) {
      const o = t[i], n = o.e || 0;
      if (n === 0)
        this.set(o.k, o.v);
      else {
        const f = n - r;
        f > 0 && this.set(o.k, o.v, f);
      }
    }
  }
  prune() {
    this[Hr].forEach((t, r) => gf(this, r, !1));
  }
}
const gf = (e, t, r) => {
  const i = e[Hr].get(t);
  if (i) {
    const o = i.value;
    if (io(e, o)) {
      if (wi(e, i), !e[Yi])
        return;
    } else
      r && (e[yb] && (i.value.now = Date.now()), e[rr].unshiftNode(i));
    return o.value;
  }
}, io = (e, t) => {
  if (!t || !t.maxAge && !e[Wn])
    return !1;
  const r = Date.now() - t.now;
  return t.maxAge ? r > t.maxAge : e[Wn] && r > e[Wn];
}, Hi = (e) => {
  if (e[dn] > e[$n])
    for (let t = e[rr].tail; e[dn] > e[$n] && t !== null; ) {
      const r = t.prev;
      wi(e, t), t = r;
    }
}, wi = (e, t) => {
  if (t) {
    const r = t.value;
    e[cn] && e[cn](r.key, r.value), e[dn] -= r.length, e[Hr].delete(r.key), e[rr].removeNode(t);
  }
};
class Fw {
  constructor(t, r, i, o, n) {
    this.key = t, this.value = r, this.length = i, this.now = o, this.maxAge = n || 0;
  }
}
const z0 = (e, t, r, i) => {
  let o = r.value;
  io(e, o) && (wi(e, r), e[Yi] || (o = void 0)), o && t.call(i, o.value, o.key, e);
};
var zw = Uw, mf, H0;
function Zr() {
  if (H0)
    return mf;
  H0 = 1;
  class e {
    constructor(a, d) {
      if (d = i(d), a instanceof e)
        return a.loose === !!d.loose && a.includePrerelease === !!d.includePrerelease ? a : new e(a.raw, d);
      if (a instanceof o)
        return this.raw = a.value, this.set = [[a]], this.format(), this;
      if (this.options = d, this.loose = !!d.loose, this.includePrerelease = !!d.includePrerelease, this.raw = a.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((w) => this.parseRange(w.trim())).filter((w) => w.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const w = this.set[0];
        if (this.set = this.set.filter((x) => !E(x[0])), this.set.length === 0)
          this.set = [w];
        else if (this.set.length > 1) {
          for (const x of this.set)
            if (x.length === 1 && M(x[0])) {
              this.set = [x];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((a) => a.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(a) {
      const w = ((this.options.includePrerelease && p) | (this.options.loose && m)) + ":" + a, x = r.get(w);
      if (x)
        return x;
      const A = this.options.loose, S = A ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
      a = a.replace(S, U(this.options.includePrerelease)), n("hyphen replace", a), a = a.replace(u[c.COMPARATORTRIM], h), n("comparator trim", a), a = a.replace(u[c.TILDETRIM], s), n("tilde trim", a), a = a.replace(u[c.CARETTRIM], b), n("caret trim", a);
      let g = a.split(" ").map((Y) => B(Y, this.options)).join(" ").split(/\s+/).map((Y) => fe(Y, this.options));
      A && (g = g.filter((Y) => (n("loose invalid filter", Y, this.options), !!Y.match(u[c.COMPARATORLOOSE])))), n("range list", g);
      const _ = /* @__PURE__ */ new Map(), l = g.map((Y) => new o(Y, this.options));
      for (const Y of l) {
        if (E(Y))
          return [Y];
        _.set(Y.value, Y);
      }
      _.size > 1 && _.has("") && _.delete("");
      const R = [..._.values()];
      return r.set(w, R), R;
    }
    intersects(a, d) {
      if (!(a instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((w) => I(w, d) && a.set.some((x) => I(x, d) && w.every((A) => x.every((S) => A.intersects(S, d)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(a) {
      if (!a)
        return !1;
      if (typeof a == "string")
        try {
          a = new f(a, this.options);
        } catch {
          return !1;
        }
      for (let d = 0; d < this.set.length; d++)
        if (y(this.set[d], a, this.options))
          return !0;
      return !1;
    }
  }
  mf = e;
  const t = zw, r = new t({ max: 1e3 }), i = Sh, o = To(), n = Bo, f = br, {
    safeRe: u,
    t: c,
    comparatorTrimReplace: h,
    tildeTrimReplace: s,
    caretTrimReplace: b
  } = va, { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: m } = Ro, E = (v) => v.value === "<0.0.0-0", M = (v) => v.value === "", I = (v, a) => {
    let d = !0;
    const w = v.slice();
    let x = w.pop();
    for (; d && w.length; )
      d = w.every((A) => x.intersects(A, a)), x = w.pop();
    return d;
  }, B = (v, a) => (n("comp", v, a), v = k(v, a), n("caret", v), v = j(v, a), n("tildes", v), v = $(v, a), n("xrange", v), v = Q(v, a), n("stars", v), v), T = (v) => !v || v.toLowerCase() === "x" || v === "*", j = (v, a) => v.trim().split(/\s+/).map((d) => N(d, a)).join(" "), N = (v, a) => {
    const d = a.loose ? u[c.TILDELOOSE] : u[c.TILDE];
    return v.replace(d, (w, x, A, S, g) => {
      n("tilde", v, w, x, A, S, g);
      let _;
      return T(x) ? _ = "" : T(A) ? _ = `>=${x}.0.0 <${+x + 1}.0.0-0` : T(S) ? _ = `>=${x}.${A}.0 <${x}.${+A + 1}.0-0` : g ? (n("replaceTilde pr", g), _ = `>=${x}.${A}.${S}-${g} <${x}.${+A + 1}.0-0`) : _ = `>=${x}.${A}.${S} <${x}.${+A + 1}.0-0`, n("tilde return", _), _;
    });
  }, k = (v, a) => v.trim().split(/\s+/).map((d) => q(d, a)).join(" "), q = (v, a) => {
    n("caret", v, a);
    const d = a.loose ? u[c.CARETLOOSE] : u[c.CARET], w = a.includePrerelease ? "-0" : "";
    return v.replace(d, (x, A, S, g, _) => {
      n("caret", v, x, A, S, g, _);
      let l;
      return T(A) ? l = "" : T(S) ? l = `>=${A}.0.0${w} <${+A + 1}.0.0-0` : T(g) ? A === "0" ? l = `>=${A}.${S}.0${w} <${A}.${+S + 1}.0-0` : l = `>=${A}.${S}.0${w} <${+A + 1}.0.0-0` : _ ? (n("replaceCaret pr", _), A === "0" ? S === "0" ? l = `>=${A}.${S}.${g}-${_} <${A}.${S}.${+g + 1}-0` : l = `>=${A}.${S}.${g}-${_} <${A}.${+S + 1}.0-0` : l = `>=${A}.${S}.${g}-${_} <${+A + 1}.0.0-0`) : (n("no pr"), A === "0" ? S === "0" ? l = `>=${A}.${S}.${g}${w} <${A}.${S}.${+g + 1}-0` : l = `>=${A}.${S}.${g}${w} <${A}.${+S + 1}.0-0` : l = `>=${A}.${S}.${g} <${+A + 1}.0.0-0`), n("caret return", l), l;
    });
  }, $ = (v, a) => (n("replaceXRanges", v, a), v.split(/\s+/).map((d) => re(d, a)).join(" ")), re = (v, a) => {
    v = v.trim();
    const d = a.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
    return v.replace(d, (w, x, A, S, g, _) => {
      n("xRange", v, w, x, A, S, g, _);
      const l = T(A), R = l || T(S), Y = R || T(g), oe = Y;
      return x === "=" && oe && (x = ""), _ = a.includePrerelease ? "-0" : "", l ? x === ">" || x === "<" ? w = "<0.0.0-0" : w = "*" : x && oe ? (R && (S = 0), g = 0, x === ">" ? (x = ">=", R ? (A = +A + 1, S = 0, g = 0) : (S = +S + 1, g = 0)) : x === "<=" && (x = "<", R ? A = +A + 1 : S = +S + 1), x === "<" && (_ = "-0"), w = `${x + A}.${S}.${g}${_}`) : R ? w = `>=${A}.0.0${_} <${+A + 1}.0.0-0` : Y && (w = `>=${A}.${S}.0${_} <${A}.${+S + 1}.0-0`), n("xRange return", w), w;
    });
  }, Q = (v, a) => (n("replaceStars", v, a), v.trim().replace(u[c.STAR], "")), fe = (v, a) => (n("replaceGTE0", v, a), v.trim().replace(u[a.includePrerelease ? c.GTE0PRE : c.GTE0], "")), U = (v) => (a, d, w, x, A, S, g, _, l, R, Y, oe, H) => (T(w) ? d = "" : T(x) ? d = `>=${w}.0.0${v ? "-0" : ""}` : T(A) ? d = `>=${w}.${x}.0${v ? "-0" : ""}` : S ? d = `>=${d}` : d = `>=${d}${v ? "-0" : ""}`, T(l) ? _ = "" : T(R) ? _ = `<${+l + 1}.0.0-0` : T(Y) ? _ = `<${l}.${+R + 1}.0-0` : oe ? _ = `<=${l}.${R}.${Y}-${oe}` : v ? _ = `<${l}.${R}.${+Y + 1}-0` : _ = `<=${_}`, `${d} ${_}`.trim()), y = (v, a, d) => {
    for (let w = 0; w < v.length; w++)
      if (!v[w].test(a))
        return !1;
    if (a.prerelease.length && !d.includePrerelease) {
      for (let w = 0; w < v.length; w++)
        if (n(v[w].semver), v[w].semver !== o.ANY && v[w].semver.prerelease.length > 0) {
          const x = v[w].semver;
          if (x.major === a.major && x.minor === a.minor && x.patch === a.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return mf;
}
var wf, V0;
function To() {
  if (V0)
    return wf;
  V0 = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(s, b) {
      if (b = r(b), s instanceof t) {
        if (s.loose === !!b.loose)
          return s;
        s = s.value;
      }
      s = s.trim().split(/\s+/).join(" "), f("comparator", s, b), this.options = b, this.loose = !!b.loose, this.parse(s), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, f("comp", this);
    }
    parse(s) {
      const b = this.options.loose ? i[o.COMPARATORLOOSE] : i[o.COMPARATOR], p = s.match(b);
      if (!p)
        throw new TypeError(`Invalid comparator: ${s}`);
      this.operator = p[1] !== void 0 ? p[1] : "", this.operator === "=" && (this.operator = ""), p[2] ? this.semver = new u(p[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(s) {
      if (f("Comparator.test", s, this.options.loose), this.semver === e || s === e)
        return !0;
      if (typeof s == "string")
        try {
          s = new u(s, this.options);
        } catch {
          return !1;
        }
      return n(s, this.operator, this.semver, this.options);
    }
    intersects(s, b) {
      if (!(s instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(s.value, b).test(this.value) : s.operator === "" ? s.value === "" ? !0 : new c(this.value, b).test(s.semver) : (b = r(b), b.includePrerelease && (this.value === "<0.0.0-0" || s.value === "<0.0.0-0") || !b.includePrerelease && (this.value.startsWith("<0.0.0") || s.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && s.operator.startsWith(">") || this.operator.startsWith("<") && s.operator.startsWith("<") || this.semver.version === s.semver.version && this.operator.includes("=") && s.operator.includes("=") || n(this.semver, "<", s.semver, b) && this.operator.startsWith(">") && s.operator.startsWith("<") || n(this.semver, ">", s.semver, b) && this.operator.startsWith("<") && s.operator.startsWith(">")));
    }
  }
  wf = t;
  const r = Sh, { safeRe: i, t: o } = va, n = bb, f = Bo, u = br, c = Zr();
  return wf;
}
const Hw = Zr(), Vw = (e, t, r) => {
  try {
    t = new Hw(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var Oo = Vw;
const Ww = Zr(), Kw = (e, t) => new Ww(e, t).set.map((r) => r.map((i) => i.value).join(" ").trim().split(" "));
var Zw = Kw;
const Gw = br, Jw = Zr(), Xw = (e, t, r) => {
  let i = null, o = null, n = null;
  try {
    n = new Jw(t, r);
  } catch {
    return null;
  }
  return e.forEach((f) => {
    n.test(f) && (!i || o.compare(f) === -1) && (i = f, o = new Gw(i, r));
  }), i;
};
var Yw = Xw;
const Qw = br, e3 = Zr(), t3 = (e, t, r) => {
  let i = null, o = null, n = null;
  try {
    n = new e3(t, r);
  } catch {
    return null;
  }
  return e.forEach((f) => {
    n.test(f) && (!i || o.compare(f) === 1) && (i = f, o = new Qw(i, r));
  }), i;
};
var r3 = t3;
const _f = br, n3 = Zr(), W0 = Io, i3 = (e, t) => {
  e = new n3(e, t);
  let r = new _f("0.0.0");
  if (e.test(r) || (r = new _f("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let i = 0; i < e.set.length; ++i) {
    const o = e.set[i];
    let n = null;
    o.forEach((f) => {
      const u = new _f(f.semver.version);
      switch (f.operator) {
        case ">":
          u.prerelease.length === 0 ? u.patch++ : u.prerelease.push(0), u.raw = u.format();
        case "":
        case ">=":
          (!n || W0(u, n)) && (n = u);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${f.operator}`);
      }
    }), n && (!r || W0(r, n)) && (r = n);
  }
  return r && e.test(r) ? r : null;
};
var a3 = i3;
const o3 = Zr(), f3 = (e, t) => {
  try {
    return new o3(e, t).range || "*";
  } catch {
    return null;
  }
};
var s3 = f3;
const u3 = br, gb = To(), { ANY: c3 } = gb, h3 = Zr(), l3 = Oo, K0 = Io, Z0 = Mh, d3 = Bh, p3 = Rh, v3 = (e, t, r, i) => {
  e = new u3(e, i), t = new h3(t, i);
  let o, n, f, u, c;
  switch (r) {
    case ">":
      o = K0, n = d3, f = Z0, u = ">", c = ">=";
      break;
    case "<":
      o = Z0, n = p3, f = K0, u = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (l3(e, t, i))
    return !1;
  for (let h = 0; h < t.set.length; ++h) {
    const s = t.set[h];
    let b = null, p = null;
    if (s.forEach((m) => {
      m.semver === c3 && (m = new gb(">=0.0.0")), b = b || m, p = p || m, o(m.semver, b.semver, i) ? b = m : f(m.semver, p.semver, i) && (p = m);
    }), b.operator === u || b.operator === c || (!p.operator || p.operator === u) && n(e, p.semver))
      return !1;
    if (p.operator === c && f(e, p.semver))
      return !1;
  }
  return !0;
};
var Ih = v3;
const b3 = Ih, y3 = (e, t, r) => b3(e, t, ">", r);
var g3 = y3;
const m3 = Ih, w3 = (e, t, r) => m3(e, t, "<", r);
var _3 = w3;
const G0 = Zr(), x3 = (e, t, r) => (e = new G0(e, r), t = new G0(t, r), e.intersects(t, r));
var E3 = x3;
const S3 = Oo, A3 = Kr;
var M3 = (e, t, r) => {
  const i = [];
  let o = null, n = null;
  const f = e.sort((s, b) => A3(s, b, r));
  for (const s of f)
    S3(s, t, r) ? (n = s, o || (o = s)) : (n && i.push([o, n]), n = null, o = null);
  o && i.push([o, null]);
  const u = [];
  for (const [s, b] of i)
    s === b ? u.push(s) : !b && s === f[0] ? u.push("*") : b ? s === f[0] ? u.push(`<=${b}`) : u.push(`${s} - ${b}`) : u.push(`>=${s}`);
  const c = u.join(" || "), h = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < h.length ? c : t;
};
const J0 = Zr(), Th = To(), { ANY: xf } = Th, Vi = Oo, Oh = Kr, R3 = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new J0(e, r), t = new J0(t, r);
  let i = !1;
  e:
    for (const o of e.set) {
      for (const n of t.set) {
        const f = I3(o, n, r);
        if (i = i || f !== null, f)
          continue e;
      }
      if (i)
        return !1;
    }
  return !0;
}, B3 = [new Th(">=0.0.0-0")], X0 = [new Th(">=0.0.0")], I3 = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === xf) {
    if (t.length === 1 && t[0].semver === xf)
      return !0;
    r.includePrerelease ? e = B3 : e = X0;
  }
  if (t.length === 1 && t[0].semver === xf) {
    if (r.includePrerelease)
      return !0;
    t = X0;
  }
  const i = /* @__PURE__ */ new Set();
  let o, n;
  for (const m of e)
    m.operator === ">" || m.operator === ">=" ? o = Y0(o, m, r) : m.operator === "<" || m.operator === "<=" ? n = Q0(n, m, r) : i.add(m.semver);
  if (i.size > 1)
    return null;
  let f;
  if (o && n) {
    if (f = Oh(o.semver, n.semver, r), f > 0)
      return null;
    if (f === 0 && (o.operator !== ">=" || n.operator !== "<="))
      return null;
  }
  for (const m of i) {
    if (o && !Vi(m, String(o), r) || n && !Vi(m, String(n), r))
      return null;
    for (const E of t)
      if (!Vi(m, String(E), r))
        return !1;
    return !0;
  }
  let u, c, h, s, b = n && !r.includePrerelease && n.semver.prerelease.length ? n.semver : !1, p = o && !r.includePrerelease && o.semver.prerelease.length ? o.semver : !1;
  b && b.prerelease.length === 1 && n.operator === "<" && b.prerelease[0] === 0 && (b = !1);
  for (const m of t) {
    if (s = s || m.operator === ">" || m.operator === ">=", h = h || m.operator === "<" || m.operator === "<=", o) {
      if (p && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === p.major && m.semver.minor === p.minor && m.semver.patch === p.patch && (p = !1), m.operator === ">" || m.operator === ">=") {
        if (u = Y0(o, m, r), u === m && u !== o)
          return !1;
      } else if (o.operator === ">=" && !Vi(o.semver, String(m), r))
        return !1;
    }
    if (n) {
      if (b && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === b.major && m.semver.minor === b.minor && m.semver.patch === b.patch && (b = !1), m.operator === "<" || m.operator === "<=") {
        if (c = Q0(n, m, r), c === m && c !== n)
          return !1;
      } else if (n.operator === "<=" && !Vi(n.semver, String(m), r))
        return !1;
    }
    if (!m.operator && (n || o) && f !== 0)
      return !1;
  }
  return !(o && h && !n && f !== 0 || n && s && !o && f !== 0 || p || b);
}, Y0 = (e, t, r) => {
  if (!e)
    return t;
  const i = Oh(e.semver, t.semver, r);
  return i > 0 ? e : i < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, Q0 = (e, t, r) => {
  if (!e)
    return t;
  const i = Oh(e.semver, t.semver, r);
  return i < 0 ? e : i > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var T3 = R3;
const Ef = va, el = Ro, O3 = br, tl = db, P3 = ji, C3 = P6, N3 = L6, L3 = j6, k3 = D6, j3 = F6, q3 = V6, D3 = Z6, $3 = X6, U3 = Kr, F3 = tw, z3 = iw, H3 = Ah, V3 = sw, W3 = hw, K3 = Io, Z3 = Mh, G3 = pb, J3 = vb, X3 = Rh, Y3 = Bh, Q3 = bb, e_ = Nw, t_ = To(), r_ = Zr(), n_ = Oo, i_ = Zw, a_ = Yw, o_ = r3, f_ = a3, s_ = s3, u_ = Ih, c_ = g3, h_ = _3, l_ = E3, d_ = M3, p_ = T3;
var v_ = {
  parse: P3,
  valid: C3,
  clean: N3,
  inc: L3,
  diff: k3,
  major: j3,
  minor: q3,
  patch: D3,
  prerelease: $3,
  compare: U3,
  rcompare: F3,
  compareLoose: z3,
  compareBuild: H3,
  sort: V3,
  rsort: W3,
  gt: K3,
  lt: Z3,
  eq: G3,
  neq: J3,
  gte: X3,
  lte: Y3,
  cmp: Q3,
  coerce: e_,
  Comparator: t_,
  Range: r_,
  satisfies: n_,
  toComparators: i_,
  maxSatisfying: a_,
  minSatisfying: o_,
  minVersion: f_,
  validRange: s_,
  outside: u_,
  gtr: c_,
  ltr: h_,
  intersects: l_,
  simplifyRange: d_,
  subset: p_,
  SemVer: O3,
  re: Ef.re,
  src: Ef.src,
  tokens: Ef.t,
  SEMVER_SPEC_VERSION: el.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: el.RELEASE_TYPES,
  compareIdentifiers: tl.compareIdentifiers,
  rcompareIdentifiers: tl.rcompareIdentifiers
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
  const t = v_, r = ti, i = sr;
  e.VersionStruct = (0, r.refine)((0, r.string)(), "Version", (b) => (0, t.valid)(b) === null ? `Expected SemVer version, got "${b}"` : !0), e.VersionRangeStruct = (0, r.refine)((0, r.string)(), "Version range", (b) => (0, t.validRange)(b) === null ? `Expected SemVer range, got "${b}"` : !0);
  function o(b) {
    return (0, r.is)(b, e.VersionStruct);
  }
  e.isValidSemVerVersion = o;
  function n(b) {
    return (0, r.is)(b, e.VersionRangeStruct);
  }
  e.isValidSemVerRange = n;
  function f(b) {
    (0, i.assertStruct)(b, e.VersionStruct);
  }
  e.assertIsSemVerVersion = f;
  function u(b) {
    (0, i.assertStruct)(b, e.VersionRangeStruct);
  }
  e.assertIsSemVerRange = u;
  function c(b, p) {
    return (0, t.gt)(b, p);
  }
  e.gtVersion = c;
  function h(b, p) {
    return (0, t.gtr)(b, p);
  }
  e.gtRange = h;
  function s(b, p) {
    return (0, t.satisfies)(b, p, {
      includePrerelease: !0
    });
  }
  e.satisfiesVersionRange = s;
})(cb);
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, o, n, f) {
    f === void 0 && (f = n);
    var u = Object.getOwnPropertyDescriptor(o, n);
    (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return o[n];
    } }), Object.defineProperty(i, f, u);
  } : function(i, o, n, f) {
    f === void 0 && (f = n), i[f] = o[n];
  }), r = Ze && Ze.__exportStar || function(i, o) {
    for (var n in i)
      n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, i, n);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(sr, e), r(da, e), r(Ct, e), r(Ao, e), r(rn, e), r(Si, e), r(pa, e), r(fb, e), r(Ai, e), r(Eh, e), r(nn, e), r(sb, e), r(ub, e), r(cb, e);
})(jv);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
  const t = jv;
  Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
    return t.createModuleLogger;
  } }), e.projectLogger = t.createProjectLogger("eth-json-rpc-middleware");
})(Ni);
var ir = {}, Oa = {}, Sf, rl;
function b_() {
  if (rl)
    return Sf;
  rl = 1;
  var e, t, r = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, i;
  function o(m) {
    throw {
      name: "SyntaxError",
      message: m,
      at: e,
      text: i
    };
  }
  function n(m) {
    return m && m !== t && o("Expected '" + m + "' instead of '" + t + "'"), t = i.charAt(e), e += 1, t;
  }
  function f() {
    var m, E = "";
    for (t === "-" && (E = "-", n("-")); t >= "0" && t <= "9"; )
      E += t, n();
    if (t === ".")
      for (E += "."; n() && t >= "0" && t <= "9"; )
        E += t;
    if (t === "e" || t === "E")
      for (E += t, n(), (t === "-" || t === "+") && (E += t, n()); t >= "0" && t <= "9"; )
        E += t, n();
    return m = Number(E), isFinite(m) || o("Bad number"), m;
  }
  function u() {
    var m, E, M = "", I;
    if (t === '"')
      for (; n(); ) {
        if (t === '"')
          return n(), M;
        if (t === "\\")
          if (n(), t === "u") {
            for (I = 0, E = 0; E < 4 && (m = parseInt(n(), 16), !!isFinite(m)); E += 1)
              I = I * 16 + m;
            M += String.fromCharCode(I);
          } else if (typeof r[t] == "string")
            M += r[t];
          else
            break;
        else
          M += t;
      }
    o("Bad string");
  }
  function c() {
    for (; t && t <= " "; )
      n();
  }
  function h() {
    switch (t) {
      case "t":
        return n("t"), n("r"), n("u"), n("e"), !0;
      case "f":
        return n("f"), n("a"), n("l"), n("s"), n("e"), !1;
      case "n":
        return n("n"), n("u"), n("l"), n("l"), null;
      default:
        o("Unexpected '" + t + "'");
    }
  }
  function s() {
    var m = [];
    if (t === "[") {
      if (n("["), c(), t === "]")
        return n("]"), m;
      for (; t; ) {
        if (m.push(p()), c(), t === "]")
          return n("]"), m;
        n(","), c();
      }
    }
    o("Bad array");
  }
  function b() {
    var m, E = {};
    if (t === "{") {
      if (n("{"), c(), t === "}")
        return n("}"), E;
      for (; t; ) {
        if (m = u(), c(), n(":"), Object.prototype.hasOwnProperty.call(E, m) && o('Duplicate key "' + m + '"'), E[m] = p(), c(), t === "}")
          return n("}"), E;
        n(","), c();
      }
    }
    o("Bad object");
  }
  function p() {
    switch (c(), t) {
      case "{":
        return b();
      case "[":
        return s();
      case '"':
        return u();
      case "-":
        return f();
      default:
        return t >= "0" && t <= "9" ? f() : h();
    }
  }
  return Sf = function(m, E) {
    var M;
    return i = m, e = 0, t = " ", M = p(), c(), t && o("Syntax error"), typeof E == "function" ? function I(B, T) {
      var j, N, k = B[T];
      if (k && typeof k == "object")
        for (j in p)
          Object.prototype.hasOwnProperty.call(k, j) && (N = I(k, j), typeof N > "u" ? delete k[j] : k[j] = N);
      return E.call(B, T, k);
    }({ "": M }, "") : M;
  }, Sf;
}
var Af, nl;
function y_() {
  if (nl)
    return Af;
  nl = 1;
  var e = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, t, r, i = {
    // table of character substitutions
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  }, o;
  function n(u) {
    return e.lastIndex = 0, e.test(u) ? '"' + u.replace(e, function(c) {
      var h = i[c];
      return typeof h == "string" ? h : "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + u + '"';
  }
  function f(u, c) {
    var h, s, b, p, m = t, E, M = c[u];
    switch (M && typeof M == "object" && typeof M.toJSON == "function" && (M = M.toJSON(u)), typeof o == "function" && (M = o.call(c, u, M)), typeof M) {
      case "string":
        return n(M);
      case "number":
        return isFinite(M) ? String(M) : "null";
      case "boolean":
      case "null":
        return String(M);
      case "object":
        if (!M)
          return "null";
        if (t += r, E = [], Object.prototype.toString.apply(M) === "[object Array]") {
          for (p = M.length, h = 0; h < p; h += 1)
            E[h] = f(h, M) || "null";
          return b = E.length === 0 ? "[]" : t ? `[
` + t + E.join(`,
` + t) + `
` + m + "]" : "[" + E.join(",") + "]", t = m, b;
        }
        if (o && typeof o == "object")
          for (p = o.length, h = 0; h < p; h += 1)
            s = o[h], typeof s == "string" && (b = f(s, M), b && E.push(n(s) + (t ? ": " : ":") + b));
        else
          for (s in M)
            Object.prototype.hasOwnProperty.call(M, s) && (b = f(s, M), b && E.push(n(s) + (t ? ": " : ":") + b));
        return b = E.length === 0 ? "{}" : t ? `{
` + t + E.join(`,
` + t) + `
` + m + "}" : "{" + E.join(",") + "}", t = m, b;
    }
  }
  return Af = function(u, c, h) {
    var s;
    if (t = "", r = "", typeof h == "number")
      for (s = 0; s < h; s += 1)
        r += " ";
    else
      typeof h == "string" && (r = h);
    if (o = c, c && typeof c != "function" && (typeof c != "object" || typeof c.length != "number"))
      throw new Error("JSON.stringify");
    return f("", { "": u });
  }, Af;
}
var il;
function g_() {
  return il || (il = 1, Oa.parse = b_(), Oa.stringify = y_()), Oa;
}
var m_ = {}.toString, w_ = Array.isArray || function(e) {
  return m_.call(e) == "[object Array]";
}, al = Object.prototype.toString, mb = function(t) {
  var r = al.call(t), i = r === "[object Arguments]";
  return i || (i = r !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && al.call(t.callee) === "[object Function]"), i;
}, Mf, ol;
function __() {
  if (ol)
    return Mf;
  ol = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, r = Object.prototype.toString, i = mb, o = Object.prototype.propertyIsEnumerable, n = !o.call({ toString: null }, "toString"), f = o.call(function() {
    }, "prototype"), u = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], c = function(p) {
      var m = p.constructor;
      return m && m.prototype === p;
    }, h = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, s = function() {
      if (typeof window > "u")
        return !1;
      for (var p in window)
        try {
          if (!h["$" + p] && t.call(window, p) && window[p] !== null && typeof window[p] == "object")
            try {
              c(window[p]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), b = function(p) {
      if (typeof window > "u" || !s)
        return c(p);
      try {
        return c(p);
      } catch {
        return !1;
      }
    };
    e = function(m) {
      var E = m !== null && typeof m == "object", M = r.call(m) === "[object Function]", I = i(m), B = E && r.call(m) === "[object String]", T = [];
      if (!E && !M && !I)
        throw new TypeError("Object.keys called on a non-object");
      var j = f && M;
      if (B && m.length > 0 && !t.call(m, 0))
        for (var N = 0; N < m.length; ++N)
          T.push(String(N));
      if (I && m.length > 0)
        for (var k = 0; k < m.length; ++k)
          T.push(String(k));
      else
        for (var q in m)
          !(j && q === "prototype") && t.call(m, q) && T.push(String(q));
      if (n)
        for (var $ = b(m), re = 0; re < u.length; ++re)
          !($ && u[re] === "constructor") && t.call(m, u[re]) && T.push(u[re]);
      return T;
    };
  }
  return Mf = e, Mf;
}
var x_ = Array.prototype.slice, E_ = mb, fl = Object.keys, Xa = fl ? function(t) {
  return fl(t);
} : __(), sl = Object.keys;
Xa.shim = function() {
  if (Object.keys) {
    var t = function() {
      var r = Object.keys(arguments);
      return r && r.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(i) {
      return E_(i) ? sl(x_.call(i)) : sl(i);
    });
  } else
    Object.keys = Xa;
  return Object.keys || Xa;
};
var Ph = Xa, wb = { exports: {} }, S_ = "Function.prototype.bind called on incompatible ", A_ = Object.prototype.toString, M_ = Math.max, R_ = "[object Function]", ul = function(t, r) {
  for (var i = [], o = 0; o < t.length; o += 1)
    i[o] = t[o];
  for (var n = 0; n < r.length; n += 1)
    i[n + t.length] = r[n];
  return i;
}, B_ = function(t, r) {
  for (var i = [], o = r || 0, n = 0; o < t.length; o += 1, n += 1)
    i[n] = t[o];
  return i;
}, I_ = function(e, t) {
  for (var r = "", i = 0; i < e.length; i += 1)
    r += e[i], i + 1 < e.length && (r += t);
  return r;
}, T_ = function(t) {
  var r = this;
  if (typeof r != "function" || A_.apply(r) !== R_)
    throw new TypeError(S_ + r);
  for (var i = B_(arguments, 1), o, n = function() {
    if (this instanceof o) {
      var s = r.apply(
        this,
        ul(i, arguments)
      );
      return Object(s) === s ? s : this;
    }
    return r.apply(
      t,
      ul(i, arguments)
    );
  }, f = M_(0, r.length - i.length), u = [], c = 0; c < f; c++)
    u[c] = "$" + c;
  if (o = Function("binder", "return function (" + I_(u, ",") + "){ return binder.apply(this,arguments); }")(n), r.prototype) {
    var h = function() {
    };
    h.prototype = r.prototype, o.prototype = new h(), h.prototype = null;
  }
  return o;
}, O_ = T_, Ch = Function.prototype.bind || O_, Nh = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, r = Symbol("test"), i = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var o = 42;
  t[r] = o;
  for (r in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var n = Object.getOwnPropertySymbols(t);
  if (n.length !== 1 || n[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var f = Object.getOwnPropertyDescriptor(t, r);
    if (f.value !== o || f.enumerable !== !0)
      return !1;
  }
  return !0;
}, cl = typeof Symbol < "u" && Symbol, P_ = Nh, C_ = function() {
  return typeof cl != "function" || typeof Symbol != "function" || typeof cl("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : P_();
}, hl = {
  foo: {}
}, N_ = Object, L_ = function() {
  return { __proto__: hl }.foo === hl.foo && !({ __proto__: null } instanceof N_);
}, k_ = Function.prototype.call, j_ = Object.prototype.hasOwnProperty, q_ = Ch, D_ = q_.call(k_, j_), Bt, Mi = SyntaxError, _b = Function, _i = TypeError, Rf = function(e) {
  try {
    return _b('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Zn = Object.getOwnPropertyDescriptor;
if (Zn)
  try {
    Zn({}, "");
  } catch {
    Zn = null;
  }
var Bf = function() {
  throw new _i();
}, $_ = Zn ? function() {
  try {
    return arguments.callee, Bf;
  } catch {
    try {
      return Zn(arguments, "callee").get;
    } catch {
      return Bf;
    }
  }
}() : Bf, oi = C_(), U_ = L_(), nr = Object.getPrototypeOf || (U_ ? function(e) {
  return e.__proto__;
} : null), di = {}, F_ = typeof Uint8Array > "u" || !nr ? Bt : nr(Uint8Array), Gn = {
  "%AggregateError%": typeof AggregateError > "u" ? Bt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Bt : ArrayBuffer,
  "%ArrayIteratorPrototype%": oi && nr ? nr([][Symbol.iterator]()) : Bt,
  "%AsyncFromSyncIteratorPrototype%": Bt,
  "%AsyncFunction%": di,
  "%AsyncGenerator%": di,
  "%AsyncGeneratorFunction%": di,
  "%AsyncIteratorPrototype%": di,
  "%Atomics%": typeof Atomics > "u" ? Bt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Bt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Bt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Bt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Bt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? Bt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Bt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Bt : FinalizationRegistry,
  "%Function%": _b,
  "%GeneratorFunction%": di,
  "%Int8Array%": typeof Int8Array > "u" ? Bt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Bt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Bt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": oi && nr ? nr(nr([][Symbol.iterator]())) : Bt,
  "%JSON%": typeof JSON == "object" ? JSON : Bt,
  "%Map%": typeof Map > "u" ? Bt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !oi || !nr ? Bt : nr((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Bt : Promise,
  "%Proxy%": typeof Proxy > "u" ? Bt : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? Bt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Bt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !oi || !nr ? Bt : nr((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Bt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": oi && nr ? nr(""[Symbol.iterator]()) : Bt,
  "%Symbol%": oi ? Symbol : Bt,
  "%SyntaxError%": Mi,
  "%ThrowTypeError%": $_,
  "%TypedArray%": F_,
  "%TypeError%": _i,
  "%Uint8Array%": typeof Uint8Array > "u" ? Bt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Bt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Bt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Bt : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? Bt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Bt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Bt : WeakSet
};
if (nr)
  try {
    null.error;
  } catch (e) {
    var z_ = nr(nr(e));
    Gn["%Error.prototype%"] = z_;
  }
var H_ = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Rf("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Rf("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Rf("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (r = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var o = e("%AsyncGenerator%");
    o && nr && (r = nr(o.prototype));
  }
  return Gn[t] = r, r;
}, ll = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, ba = Ch, ao = D_, V_ = ba.call(Function.call, Array.prototype.concat), W_ = ba.call(Function.apply, Array.prototype.splice), dl = ba.call(Function.call, String.prototype.replace), oo = ba.call(Function.call, String.prototype.slice), K_ = ba.call(Function.call, RegExp.prototype.exec), Z_ = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, G_ = /\\(\\)?/g, J_ = function(t) {
  var r = oo(t, 0, 1), i = oo(t, -1);
  if (r === "%" && i !== "%")
    throw new Mi("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && r !== "%")
    throw new Mi("invalid intrinsic syntax, expected opening `%`");
  var o = [];
  return dl(t, Z_, function(n, f, u, c) {
    o[o.length] = u ? dl(c, G_, "$1") : f || n;
  }), o;
}, X_ = function(t, r) {
  var i = t, o;
  if (ao(ll, i) && (o = ll[i], i = "%" + o[0] + "%"), ao(Gn, i)) {
    var n = Gn[i];
    if (n === di && (n = H_(i)), typeof n > "u" && !r)
      throw new _i("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: o,
      name: i,
      value: n
    };
  }
  throw new Mi("intrinsic " + t + " does not exist!");
}, qi = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new _i("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new _i('"allowMissing" argument must be a boolean');
  if (K_(/^%?[^%]*%?$/, t) === null)
    throw new Mi("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = J_(t), o = i.length > 0 ? i[0] : "", n = X_("%" + o + "%", r), f = n.name, u = n.value, c = !1, h = n.alias;
  h && (o = h[0], W_(i, V_([0, 1], h)));
  for (var s = 1, b = !0; s < i.length; s += 1) {
    var p = i[s], m = oo(p, 0, 1), E = oo(p, -1);
    if ((m === '"' || m === "'" || m === "`" || E === '"' || E === "'" || E === "`") && m !== E)
      throw new Mi("property names with quotes must have matching quotes");
    if ((p === "constructor" || !b) && (c = !0), o += "." + p, f = "%" + o + "%", ao(Gn, f))
      u = Gn[f];
    else if (u != null) {
      if (!(p in u)) {
        if (!r)
          throw new _i("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Zn && s + 1 >= i.length) {
        var M = Zn(u, p);
        b = !!M, b && "get" in M && !("originalValue" in M.get) ? u = M.get : u = u[p];
      } else
        b = ao(u, p), u = u[p];
      b && !c && (Gn[f] = u);
    }
  }
  return u;
}, Y_ = qi, Kc = Y_("%Object.defineProperty%", !0), Zc = function() {
  if (Kc)
    try {
      return Kc({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
Zc.hasArrayLengthDefineBug = function() {
  if (!Zc())
    return null;
  try {
    return Kc([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var Lh = Zc, Q_ = qi, Ya = Q_("%Object.getOwnPropertyDescriptor%", !0);
if (Ya)
  try {
    Ya([], "length");
  } catch {
    Ya = null;
  }
var kh = Ya, e4 = Lh(), jh = qi, Qi = e4 && jh("%Object.defineProperty%", !0);
if (Qi)
  try {
    Qi({}, "a", { value: 1 });
  } catch {
    Qi = !1;
  }
var t4 = jh("%SyntaxError%"), fi = jh("%TypeError%"), pl = kh, xb = function(t, r, i) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new fi("`obj` must be an object or a function`");
  if (typeof r != "string" && typeof r != "symbol")
    throw new fi("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new fi("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new fi("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new fi("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new fi("`loose`, if provided, must be a boolean");
  var o = arguments.length > 3 ? arguments[3] : null, n = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 ? arguments[6] : !1, c = !!pl && pl(t, r);
  if (Qi)
    Qi(t, r, {
      configurable: f === null && c ? c.configurable : !f,
      enumerable: o === null && c ? c.enumerable : !o,
      value: i,
      writable: n === null && c ? c.writable : !n
    });
  else if (u || !o && !n && !f)
    t[r] = i;
  else
    throw new t4("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, Eb = qi, vl = xb, r4 = Lh(), bl = kh, yl = Eb("%TypeError%"), n4 = Eb("%Math.floor%"), i4 = function(t, r) {
  if (typeof t != "function")
    throw new yl("`fn` is not a function");
  if (typeof r != "number" || r < 0 || r > 4294967295 || n4(r) !== r)
    throw new yl("`length` must be a positive 32-bit integer");
  var i = arguments.length > 2 && !!arguments[2], o = !0, n = !0;
  if ("length" in t && bl) {
    var f = bl(t, "length");
    f && !f.configurable && (o = !1), f && !f.writable && (n = !1);
  }
  return (o || n || !i) && (r4 ? vl(t, "length", r, !0, !0) : vl(t, "length", r)), t;
};
(function(e) {
  var t = Ch, r = qi, i = i4, o = r("%TypeError%"), n = r("%Function.prototype.apply%"), f = r("%Function.prototype.call%"), u = r("%Reflect.apply%", !0) || t.call(f, n), c = r("%Object.defineProperty%", !0), h = r("%Math.max%");
  if (c)
    try {
      c({}, "a", { value: 1 });
    } catch {
      c = null;
    }
  e.exports = function(p) {
    if (typeof p != "function")
      throw new o("a function is required");
    var m = u(t, f, arguments);
    return i(
      m,
      1 + h(0, p.length - (arguments.length - 1)),
      !0
    );
  };
  var s = function() {
    return u(t, n, arguments);
  };
  c ? c(e.exports, "apply", { value: s }) : e.exports.apply = s;
})(wb);
var ya = wb.exports, Pa = (typeof JSON < "u" ? JSON : g_()).stringify, a4 = w_, o4 = Ph, f4 = ya, gl = function(t, r) {
  for (var i = "", o = 0; o < t; o += 1)
    i += r;
  return i;
}, s4 = function(e, t, r) {
  return r;
}, u4 = function(t) {
  var r = arguments.length > 1 ? arguments[1] : void 0, i = r && r.space || "";
  typeof i == "number" && (i = gl(i, " "));
  var o = !!r && typeof r.cycles == "boolean" && r.cycles, n = r && r.replacer ? f4(r.replacer) : s4, f = typeof r == "function" ? r : r && r.cmp, u = f && function(h) {
    var s = f.length > 2 && function(p) {
      return h[p];
    };
    return function(b, p) {
      return f(
        { key: b, value: h[b] },
        { key: p, value: h[p] },
        s ? { __proto__: null, get: s } : void 0
      );
    };
  }, c = [];
  return function h(s, b, p, m) {
    var E = i ? `
` + gl(m, i) : "", M = i ? ": " : ":";
    if (p && p.toJSON && typeof p.toJSON == "function" && (p = p.toJSON()), p = n(s, b, p), p !== void 0) {
      if (typeof p != "object" || p === null)
        return Pa(p);
      if (a4(p)) {
        for (var j = "", I = 0; I < p.length; I++) {
          var B = h(p, I, p[I], m + 1) || Pa(null);
          j += E + i + B, I + 1 < p.length && (j += ",");
        }
        return "[" + j + E + "]";
      }
      if (c.indexOf(p) !== -1) {
        if (o)
          return Pa("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      } else
        c.push(p);
      for (var T = o4(p).sort(u && u(p)), j = "", N = !1, I = 0; I < T.length; I++) {
        var b = T[I], k = h(p, b, p[b], m + 1);
        if (k) {
          var q = Pa(b) + M + k;
          j += (N ? "," : "") + E + i + q, N = !0;
        }
      }
      return c.splice(c.indexOf(p), 1), "{" + j + E + "}";
    }
  }({ "": t }, "", t, 0);
}, c4 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.cacheTypeForPayload = ir.blockTagParamIndex = ir.paramsWithoutBlockTag = ir.blockTagForPayload = ir.canCache = ir.cacheIdentifierForPayload = void 0;
const h4 = c4(u4);
function l4(e, t) {
  var r;
  const i = t ? Ab(e) : (r = e.params) !== null && r !== void 0 ? r : [];
  return Sb(e) ? `${e.method}:${h4.default(i)}` : null;
}
ir.cacheIdentifierForPayload = l4;
function Sb(e) {
  return Mb(e) !== "never";
}
ir.canCache = Sb;
function d4(e) {
  if (!e.params)
    return;
  const t = qh(e);
  if (!(t === void 0 || t >= e.params.length))
    return e.params[t];
}
ir.blockTagForPayload = d4;
function Ab(e) {
  if (!e.params)
    return [];
  const t = qh(e);
  return t === void 0 || t >= e.params.length ? e.params : e.method === "eth_getBlockByNumber" ? e.params.slice(1) : e.params.slice(0, t);
}
ir.paramsWithoutBlockTag = Ab;
function qh(e) {
  switch (e.method) {
    case "eth_getStorageAt":
      return 2;
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    case "eth_getBlockByNumber":
      return 0;
    default:
      return;
  }
}
ir.blockTagParamIndex = qh;
function Mb(e) {
  switch (e.method) {
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return "perma";
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return "fork";
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return "block";
    default:
      return "never";
  }
}
ir.cacheTypeForPayload = Mb;
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.createBlockCacheMiddleware = void 0;
const p4 = xr, ml = Ni, pi = ir, si = ml.createModuleLogger(ml.projectLogger, "block-cache"), v4 = [void 0, null, "<nil>"];
class b4 {
  constructor() {
    this.cache = {};
  }
  getBlockCacheForPayload(t, r) {
    const i = Number.parseInt(r, 16);
    let o = this.cache[i];
    if (!o) {
      const n = {};
      this.cache[i] = n, o = n;
    }
    return o;
  }
  async get(t, r) {
    const i = this.getBlockCacheForPayload(t, r), o = pi.cacheIdentifierForPayload(t, !0);
    return o ? i[o] : void 0;
  }
  async set(t, r, i) {
    if (!this.canCacheResult(t, i))
      return;
    const n = pi.cacheIdentifierForPayload(t, !0);
    if (!n)
      return;
    const f = this.getBlockCacheForPayload(t, r);
    f[n] = i;
  }
  canCacheRequest(t) {
    return !(!pi.canCache(t) || pi.blockTagForPayload(t) === "pending");
  }
  canCacheResult(t, r) {
    return !(v4.includes(r) || t.method && ["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(t.method) && (!r || !r.blockHash || r.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000"));
  }
  // removes all block caches with block number lower than `oldBlockHex`
  clearBefore(t) {
    const r = Number.parseInt(t, 16);
    Object.keys(this.cache).map(Number).filter((i) => i < r).forEach((i) => delete this.cache[i]);
  }
}
function y4({ blockTracker: e } = {}) {
  if (!e)
    throw new Error("createBlockCacheMiddleware - No PollingBlockTracker specified");
  const t = new b4(), r = {
    perma: t,
    block: t,
    fork: t
  };
  return p4.createAsyncMiddleware(async (i, o, n) => {
    if (i.skipCache)
      return n();
    const f = pi.cacheTypeForPayload(i), u = r[f];
    if (!u || !u.canCacheRequest(i))
      return n();
    let c = pi.blockTagForPayload(i);
    c || (c = "latest"), si("blockTag = %o, req = %o", c, i);
    let h;
    if (c === "earliest")
      h = "0x00";
    else if (c === "latest") {
      si("Fetching latest block number to determine cache key");
      const b = await e.getLatestBlock();
      si("Clearing values stored under block numbers before %o", b), t.clearBefore(b), h = b;
    } else
      h = c;
    const s = await u.get(i, h);
    s === void 0 ? (si("No cache stored under block number %o, carrying request forward", h), await n(), si("Populating cache with", o), await u.set(i, h, o.result)) : (si("Cache hit, reusing cache result stored under block number %o", h), o.result = s);
  });
}
xo.createBlockCacheMiddleware = y4;
var Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.createBlockRefRewriteMiddleware = void 0;
const g4 = xr, m4 = ir;
function w4({ blockTracker: e } = {}) {
  if (!e)
    throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
  return g4.createAsyncMiddleware(async (t, r, i) => {
    var o;
    const n = m4.blockTagParamIndex(t);
    if (n === void 0)
      return i();
    let f = (o = t.params) === null || o === void 0 ? void 0 : o[n];
    if (f === void 0 && (f = "latest"), f !== "latest")
      return i();
    const u = await e.getLatestBlock();
    return t.params && (t.params[n] = u), i();
  });
}
Po.createBlockRefRewriteMiddleware = w4;
var Co = {}, Rb = { exports: {} };
(function(e) {
  var t = function() {
    function r(p, m) {
      return m != null && p instanceof m;
    }
    var i;
    try {
      i = Map;
    } catch {
      i = function() {
      };
    }
    var o;
    try {
      o = Set;
    } catch {
      o = function() {
      };
    }
    var n;
    try {
      n = Promise;
    } catch {
      n = function() {
      };
    }
    function f(p, m, E, M, I) {
      typeof m == "object" && (E = m.depth, M = m.prototype, I = m.includeNonEnumerable, m = m.circular);
      var B = [], T = [], j = typeof Le.Buffer < "u";
      typeof m > "u" && (m = !0), typeof E > "u" && (E = 1 / 0);
      function N(k, q) {
        if (k === null)
          return null;
        if (q === 0)
          return k;
        var $, re;
        if (typeof k != "object")
          return k;
        if (r(k, i))
          $ = new i();
        else if (r(k, o))
          $ = new o();
        else if (r(k, n))
          $ = new n(function(x, A) {
            k.then(function(S) {
              x(N(S, q - 1));
            }, function(S) {
              A(N(S, q - 1));
            });
          });
        else if (f.__isArray(k))
          $ = [];
        else if (f.__isRegExp(k))
          $ = new RegExp(k.source, b(k)), k.lastIndex && ($.lastIndex = k.lastIndex);
        else if (f.__isDate(k))
          $ = new Date(k.getTime());
        else {
          if (j && Le.Buffer.isBuffer(k))
            return Le.Buffer.allocUnsafe ? $ = Le.Buffer.allocUnsafe(k.length) : $ = new Le.Buffer(k.length), k.copy($), $;
          r(k, Error) ? $ = Object.create(k) : typeof M > "u" ? (re = Object.getPrototypeOf(k), $ = Object.create(re)) : ($ = Object.create(M), re = M);
        }
        if (m) {
          var Q = B.indexOf(k);
          if (Q != -1)
            return T[Q];
          B.push(k), T.push($);
        }
        r(k, i) && k.forEach(function(x, A) {
          var S = N(A, q - 1), g = N(x, q - 1);
          $.set(S, g);
        }), r(k, o) && k.forEach(function(x) {
          var A = N(x, q - 1);
          $.add(A);
        });
        for (var fe in k) {
          var U;
          re && (U = Object.getOwnPropertyDescriptor(re, fe)), !(U && U.set == null) && ($[fe] = N(k[fe], q - 1));
        }
        if (Object.getOwnPropertySymbols)
          for (var y = Object.getOwnPropertySymbols(k), fe = 0; fe < y.length; fe++) {
            var v = y[fe], a = Object.getOwnPropertyDescriptor(k, v);
            a && !a.enumerable && !I || ($[v] = N(k[v], q - 1), a.enumerable || Object.defineProperty($, v, {
              enumerable: !1
            }));
          }
        if (I)
          for (var d = Object.getOwnPropertyNames(k), fe = 0; fe < d.length; fe++) {
            var w = d[fe], a = Object.getOwnPropertyDescriptor(k, w);
            a && a.enumerable || ($[w] = N(k[w], q - 1), Object.defineProperty($, w, {
              enumerable: !1
            }));
          }
        return $;
      }
      return N(p, E);
    }
    f.clonePrototype = function(m) {
      if (m === null)
        return null;
      var E = function() {
      };
      return E.prototype = m, new E();
    };
    function u(p) {
      return Object.prototype.toString.call(p);
    }
    f.__objToStr = u;
    function c(p) {
      return typeof p == "object" && u(p) === "[object Date]";
    }
    f.__isDate = c;
    function h(p) {
      return typeof p == "object" && u(p) === "[object Array]";
    }
    f.__isArray = h;
    function s(p) {
      return typeof p == "object" && u(p) === "[object RegExp]";
    }
    f.__isRegExp = s;
    function b(p) {
      var m = "";
      return p.global && (m += "g"), p.ignoreCase && (m += "i"), p.multiline && (m += "m"), m;
    }
    return f.__getRegExpFlags = b, f;
  }();
  e.exports && (e.exports = t);
})(Rb);
var Dh = Rb.exports;
const wl = (e, t) => function() {
  const r = t.promiseModule, i = new Array(arguments.length);
  for (let o = 0; o < arguments.length; o++)
    i[o] = arguments[o];
  return new r((o, n) => {
    t.errorFirst ? i.push(function(f, u) {
      if (t.multiArgs) {
        const c = new Array(arguments.length - 1);
        for (let h = 1; h < arguments.length; h++)
          c[h - 1] = arguments[h];
        f ? (c.unshift(f), n(c)) : o(c);
      } else
        f ? n(f) : o(u);
    }) : i.push(function(f) {
      if (t.multiArgs) {
        const u = new Array(arguments.length - 1);
        for (let c = 0; c < arguments.length; c++)
          u[c] = arguments[c];
        o(u);
      } else
        o(f);
    }), e.apply(this, i);
  });
};
var Bb = (e, t) => {
  t = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, t);
  const r = (o) => {
    const n = (f) => typeof f == "string" ? o === f : f.test(o);
    return t.include ? t.include.some(n) : !t.exclude.some(n);
  };
  let i;
  typeof e == "function" ? i = function() {
    return t.excludeMain ? e.apply(this, arguments) : wl(e, t).apply(this, arguments);
  } : i = Object.create(Object.getPrototypeOf(e));
  for (const o in e) {
    const n = e[o];
    i[o] = typeof n == "function" && r(o) ? wl(n, t) : n;
  }
  return i;
}, Ib = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.createBlockRefMiddleware = void 0;
const _4 = xr, x4 = Ib(Dh), E4 = Ib(Bb), _l = Ni, S4 = ir, If = _l.createModuleLogger(_l.projectLogger, "block-ref");
function A4({ provider: e, blockTracker: t } = {}) {
  if (!e)
    throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
  if (!t)
    throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
  return _4.createAsyncMiddleware(async (r, i, o) => {
    var n, f;
    const u = S4.blockTagParamIndex(r);
    if (u === void 0)
      return o();
    if (((f = (n = r.params) === null || n === void 0 ? void 0 : n[u]) !== null && f !== void 0 ? f : "latest") !== "latest")
      return If('blockRef is not "latest", carrying request forward'), o();
    const h = await t.getLatestBlock();
    If(`blockRef is "latest", setting param ${u} to latest block ${h}`);
    const s = x4.default(r);
    s.params && (s.params[u] = h), If("Performing another request %o", s);
    const b = await E4.default(e.sendAsync).call(e, s);
    i.result = b.result, i.error = b.error;
  });
}
Co.createBlockRefMiddleware = A4;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.createBlockTrackerInspectorMiddleware = void 0;
const M4 = xr, xl = Ni, El = xl.createModuleLogger(xl.projectLogger, "block-tracker-inspector"), R4 = [
  "eth_getTransactionByHash",
  "eth_getTransactionReceipt"
];
function B4({ blockTracker: e }) {
  return M4.createAsyncMiddleware(async (t, r, i) => {
    var o;
    if (!R4.includes(t.method))
      return i();
    if (await i(), !!(!((o = r.result) === null || o === void 0) && o.blockNumber) && (El("res.result.blockNumber exists, proceeding. res = %o", r), typeof r.result.blockNumber == "string")) {
      const n = Number.parseInt(r.result.blockNumber, 16), f = Number.parseInt(e.getCurrentBlock(), 16);
      n > f && (El("blockNumber from response is greater than current block number, refreshing current block number"), await e.checkForLatestBlock());
    }
  });
}
No.createBlockTrackerInspectorMiddleware = B4;
var Ri = {};
const I4 = {}, T4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: I4
}, Symbol.toStringTag, { value: "Module" })), Tb = /* @__PURE__ */ gv(T4);
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.createFetchConfigFromReq = Ri.createFetchMiddleware = void 0;
const O4 = xr, aa = Kt, P4 = Ze.fetch || Tb, C4 = Ze.btoa || Tb, N4 = [
  // ignore server overload errors
  "Gateway timeout",
  "ETIMEDOUT",
  // ignore server sent html error pages
  // or truncated json responses
  "failed to parse response body",
  // ignore errors where http req failed to establish
  "Failed to fetch"
];
function L4({ rpcUrl: e, originHttpHeaderKey: t }) {
  return O4.createAsyncMiddleware(async (r, i, o) => {
    const { fetchUrl: n, fetchParams: f } = Ob({
      req: r,
      rpcUrl: e,
      originHttpHeaderKey: t
    }), u = 5, c = 1e3;
    for (let h = 0; h < u; h++) {
      try {
        const s = await P4(n, f);
        k4(s);
        const b = await s.text();
        let p;
        try {
          p = JSON.parse(b);
        } catch {
          throw new Error(`FetchMiddleware - failed to parse response body: "${b}"`);
        }
        const m = j4(s, p);
        i.result = m;
        return;
      } catch (s) {
        const b = s.toString();
        if (!N4.some((m) => b.includes(m)))
          throw s;
      }
      await U4(c);
    }
  });
}
Ri.createFetchMiddleware = L4;
function k4(e) {
  switch (e.status) {
    case 405:
      throw aa.ethErrors.rpc.methodNotFound();
    case 418:
      throw D4();
    case 503:
    case 504:
      throw $4();
  }
}
function j4(e, t) {
  if (e.status !== 200)
    throw aa.ethErrors.rpc.internal({
      message: `Non-200 status code: '${e.status}'`,
      data: t
    });
  if (t.error)
    throw aa.ethErrors.rpc.internal({
      data: t.error
    });
  return t.result;
}
function Ob({ req: e, rpcUrl: t, originHttpHeaderKey: r }) {
  const i = new URL(t), o = q4(i), n = {
    id: e.id,
    jsonrpc: e.jsonrpc,
    method: e.method,
    params: e.params
  }, f = e.origin, u = JSON.stringify(n), c = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: u
  };
  if (i.username && i.password) {
    const h = `${i.username}:${i.password}`, s = C4(h);
    c.headers.Authorization = `Basic ${s}`;
  }
  return r && f && (c.headers[r] = f), { fetchUrl: o, fetchParams: c };
}
Ri.createFetchConfigFromReq = Ob;
function q4(e) {
  let t = "";
  return t += e.protocol, t += `//${e.hostname}`, e.port && (t += `:${e.port}`), t += `${e.pathname}`, t += `${e.search}`, t;
}
function D4() {
  return aa.ethErrors.rpc.internal({ message: "Request is being rate limited." });
}
function $4() {
  let e = "Gateway timeout. The request took too long to process. ";
  return e += "This can happen when querying logs over too wide a block range.", aa.ethErrors.rpc.internal({ message: e });
}
function U4(e) {
  return new Promise((t) => setTimeout(t, e));
}
var Lo = {}, F4 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.createInflightCacheMiddleware = void 0;
const Sl = F4(Dh), z4 = xr, Al = Ni, H4 = ir, Ca = Al.createModuleLogger(Al.projectLogger, "inflight-cache");
function V4() {
  const e = {};
  return z4.createAsyncMiddleware(async (i, o, n) => {
    if (i.skipCache)
      return n();
    const f = H4.cacheIdentifierForPayload(i);
    if (!f)
      return Ca("Request is not cacheable, proceeding. req = %o", i), n();
    let u = e[f];
    if (u) {
      Ca("Running %i handler(s) for request %o", u.length, i), await t(o, u);
      return;
    }
    u = [], e[f] = u, Ca("Carrying original request forward %o", i), await n(), delete e[f], Ca("Running %i collected handler(s) for request %o", u.length, i), r(o, u);
  });
  function t(i, o) {
    const { resolve: n, promise: f } = W4();
    return o.push((u) => {
      i.result = Sl.default(u.result), i.error = Sl.default(u.error), n();
    }), f;
  }
  function r(i, o) {
    setTimeout(() => {
      o.forEach((n) => {
        try {
          n(i);
        } catch (f) {
          console.error(f);
        }
      });
    });
  }
}
Lo.createInflightCacheMiddleware = V4;
function W4() {
  let e;
  const t = new Promise((r) => {
    e = r;
  });
  return { resolve: e, promise: t };
}
var Bi = {};
Object.defineProperty(Bi, "__esModule", { value: !0 });
Bi.ethersProviderAsMiddleware = Bi.providerAsMiddleware = void 0;
function K4(e) {
  return (t, r, i, o) => {
    e.sendAsync(t, (n, f) => n instanceof Error ? o(n) : (Object.assign(r, f), o()));
  };
}
Bi.providerAsMiddleware = K4;
function Z4(e) {
  return (t, r, i, o) => {
    e.send(t, (n, f) => n ? o(n) : (Object.assign(r, f), o()));
  };
}
Bi.ethersProviderAsMiddleware = Z4;
var ga = {}, G4 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.providerFromEngine = void 0;
const J4 = G4(mo);
function X4(e) {
  const t = new J4.default();
  return t.sendAsync = (r, i) => {
    e.handle(r, i);
  }, t.send = (r, i) => {
    if (typeof i != "function")
      throw new Error('Must provide callback to "send" method.');
    e.handle(r, i);
  }, e.on && e.on("notification", (r) => {
    t.emit("data", null, r);
  }), t;
}
ga.providerFromEngine = X4;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.providerFromMiddleware = void 0;
const Y4 = xr, Q4 = ga;
function e8(e) {
  const t = new Y4.JsonRpcEngine();
  return t.push(e), Q4.providerFromEngine(t);
}
ko.providerFromMiddleware = e8;
var jo = {}, Pb = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.createRetryOnEmptyMiddleware = void 0;
const t8 = Pb(Dh), r8 = xr, n8 = Pb(Bb), Ml = Ni, i8 = ir, Un = Ml.createModuleLogger(Ml.projectLogger, "retry-on-empty"), a8 = [
  void 0,
  null,
  "<nil>"
];
function o8({ provider: e, blockTracker: t } = {}) {
  if (!e)
    throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
  if (!t)
    throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
  return r8.createAsyncMiddleware(async (r, i, o) => {
    var n;
    const f = i8.blockTagParamIndex(r);
    if (f === void 0)
      return o();
    let u = (n = r.params) === null || n === void 0 ? void 0 : n[f];
    if (u === void 0 && (u = "latest"), ["latest", "pending"].includes(u))
      return o();
    const c = Number.parseInt(u.slice(2), 16);
    if (Number.isNaN(c))
      return o();
    const h = await t.getLatestBlock(), s = Number.parseInt(h.slice(2), 16);
    if (c > s)
      return Un("Requested block number %o is higher than latest block number %o, falling through to original request", c, s), o();
    Un("Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received", c, s);
    const b = t8.default(r), p = await f8(10, async () => {
      Un("Performing request %o", b);
      const m = await n8.default(e.sendAsync).call(e, b);
      if (Un("Response is %o", m), a8.includes(m.result))
        throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(m)}" for request "${JSON.stringify(b)}"`);
      return m;
    });
    Un("Copying result %o and error %o", p.result, p.error), i.result = p.result, i.error = p.error;
  });
}
jo.createRetryOnEmptyMiddleware = o8;
async function f8(e, t) {
  for (let r = 0; r < e; r++)
    try {
      return await t();
    } catch {
      Un("(call %i) Request failed, waiting 1s to retry again...", r + 1), await s8(1e3);
    }
  throw Un("Retries exhausted"), new Error("RetryOnEmptyMiddleware - retries exhausted");
}
function s8(e) {
  return new Promise((t) => setTimeout(t, e));
}
var qo = {}, Cb = {}, Tn = {}, ma = {}, Do = {}, $o = {}, Nb = {}, Ii = {}, Uo = {}, ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.output = ar.exists = ar.hash = ar.bytes = ar.bool = ar.number = void 0;
function fo(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
ar.number = fo;
function Lb(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
ar.bool = Lb;
function $h(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
ar.bytes = $h;
function kb(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  fo(e.outputLen), fo(e.blockLen);
}
ar.hash = kb;
function jb(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
ar.exists = jb;
function qb(e, t) {
  $h(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
ar.output = qb;
const u8 = {
  number: fo,
  bool: Lb,
  bytes: $h,
  hash: kb,
  exists: jb,
  output: qb
};
ar.default = u8;
var yn = {}, Fo = {};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.crypto = void 0;
Fo.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const t = Fo, r = (q) => q instanceof Uint8Array, i = (q) => new Uint8Array(q.buffer, q.byteOffset, q.byteLength);
  e.u8 = i;
  const o = (q) => new Uint32Array(q.buffer, q.byteOffset, Math.floor(q.byteLength / 4));
  e.u32 = o;
  const n = (q) => new DataView(q.buffer, q.byteOffset, q.byteLength);
  e.createView = n;
  const f = (q, $) => q << 32 - $ | q >>> $;
  if (e.rotr = f, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const u = Array.from({ length: 256 }, (q, $) => $.toString(16).padStart(2, "0"));
  function c(q) {
    if (!r(q))
      throw new Error("Uint8Array expected");
    let $ = "";
    for (let re = 0; re < q.length; re++)
      $ += u[q[re]];
    return $;
  }
  e.bytesToHex = c;
  function h(q) {
    if (typeof q != "string")
      throw new Error("hex string expected, got " + typeof q);
    const $ = q.length;
    if ($ % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + $);
    const re = new Uint8Array($ / 2);
    for (let Q = 0; Q < re.length; Q++) {
      const fe = Q * 2, U = q.slice(fe, fe + 2), y = Number.parseInt(U, 16);
      if (Number.isNaN(y) || y < 0)
        throw new Error("Invalid byte sequence");
      re[Q] = y;
    }
    return re;
  }
  e.hexToBytes = h;
  const s = async () => {
  };
  e.nextTick = s;
  async function b(q, $, re) {
    let Q = Date.now();
    for (let fe = 0; fe < q; fe++) {
      re(fe);
      const U = Date.now() - Q;
      U >= 0 && U < $ || (await (0, e.nextTick)(), Q += U);
    }
  }
  e.asyncLoop = b;
  function p(q) {
    if (typeof q != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof q}`);
    return new Uint8Array(new TextEncoder().encode(q));
  }
  e.utf8ToBytes = p;
  function m(q) {
    if (typeof q == "string" && (q = p(q)), !r(q))
      throw new Error(`expected Uint8Array, got ${typeof q}`);
    return q;
  }
  e.toBytes = m;
  function E(...q) {
    const $ = new Uint8Array(q.reduce((Q, fe) => Q + fe.length, 0));
    let re = 0;
    return q.forEach((Q) => {
      if (!r(Q))
        throw new Error("Uint8Array expected");
      $.set(Q, re), re += Q.length;
    }), $;
  }
  e.concatBytes = E;
  class M {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = M;
  const I = (q) => Object.prototype.toString.call(q) === "[object Object]" && q.constructor === Object;
  function B(q, $) {
    if ($ !== void 0 && (typeof $ != "object" || !I($)))
      throw new Error("Options should be object or undefined");
    return Object.assign(q, $);
  }
  e.checkOpts = B;
  function T(q) {
    const $ = (Q) => q().update(m(Q)).digest(), re = q();
    return $.outputLen = re.outputLen, $.blockLen = re.blockLen, $.create = () => q(), $;
  }
  e.wrapConstructor = T;
  function j(q) {
    const $ = (Q, fe) => q(fe).update(m(Q)).digest(), re = q({});
    return $.outputLen = re.outputLen, $.blockLen = re.blockLen, $.create = (Q) => q(Q), $;
  }
  e.wrapConstructorWithOpts = j;
  function N(q) {
    const $ = (Q, fe) => q(fe).update(m(Q)).digest(), re = q({});
    return $.outputLen = re.outputLen, $.blockLen = re.blockLen, $.create = (Q) => q(Q), $;
  }
  e.wrapXOFConstructorWithOpts = N;
  function k(q = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(q));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = k;
})(yn);
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.SHA2 = void 0;
const Tf = ar, Wi = yn;
function c8(e, t, r, i) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, i);
  const o = BigInt(32), n = BigInt(4294967295), f = Number(r >> o & n), u = Number(r & n), c = i ? 4 : 0, h = i ? 0 : 4;
  e.setUint32(t + c, f, i), e.setUint32(t + h, u, i);
}
class h8 extends Wi.Hash {
  constructor(t, r, i, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = i, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, Wi.createView)(this.buffer);
  }
  update(t) {
    Tf.default.exists(this);
    const { view: r, buffer: i, blockLen: o } = this;
    t = (0, Wi.toBytes)(t);
    const n = t.length;
    for (let f = 0; f < n; ) {
      const u = Math.min(o - this.pos, n - f);
      if (u === o) {
        const c = (0, Wi.createView)(t);
        for (; o <= n - f; f += o)
          this.process(c, f);
        continue;
      }
      i.set(t.subarray(f, f + u), this.pos), this.pos += u, f += u, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Tf.default.exists(this), Tf.default.output(t, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: o, isLE: n } = this;
    let { pos: f } = this;
    r[f++] = 128, this.buffer.subarray(f).fill(0), this.padOffset > o - f && (this.process(i, 0), f = 0);
    for (let b = f; b < o; b++)
      r[b] = 0;
    c8(i, o - 8, BigInt(this.length * 8), n), this.process(i, 0);
    const u = (0, Wi.createView)(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const h = c / 4, s = this.get();
    if (h > s.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let b = 0; b < h; b++)
      u.setUint32(4 * b, s[b], n);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: i, length: o, finished: n, destroyed: f, pos: u } = this;
    return t.length = o, t.pos = u, t.finished = n, t.destroyed = f, o % r && t.buffer.set(i), t;
  }
}
Uo.SHA2 = h8;
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.sha224 = Ii.sha256 = void 0;
const l8 = Uo, Ir = yn, d8 = (e, t, r) => e & t ^ ~e & r, p8 = (e, t, r) => e & t ^ e & r ^ t & r, v8 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), _n = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), xn = new Uint32Array(64);
class Db extends l8.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = _n[0] | 0, this.B = _n[1] | 0, this.C = _n[2] | 0, this.D = _n[3] | 0, this.E = _n[4] | 0, this.F = _n[5] | 0, this.G = _n[6] | 0, this.H = _n[7] | 0;
  }
  get() {
    const { A: t, B: r, C: i, D: o, E: n, F: f, G: u, H: c } = this;
    return [t, r, i, o, n, f, u, c];
  }
  // prettier-ignore
  set(t, r, i, o, n, f, u, c) {
    this.A = t | 0, this.B = r | 0, this.C = i | 0, this.D = o | 0, this.E = n | 0, this.F = f | 0, this.G = u | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let b = 0; b < 16; b++, r += 4)
      xn[b] = t.getUint32(r, !1);
    for (let b = 16; b < 64; b++) {
      const p = xn[b - 15], m = xn[b - 2], E = (0, Ir.rotr)(p, 7) ^ (0, Ir.rotr)(p, 18) ^ p >>> 3, M = (0, Ir.rotr)(m, 17) ^ (0, Ir.rotr)(m, 19) ^ m >>> 10;
      xn[b] = M + xn[b - 7] + E + xn[b - 16] | 0;
    }
    let { A: i, B: o, C: n, D: f, E: u, F: c, G: h, H: s } = this;
    for (let b = 0; b < 64; b++) {
      const p = (0, Ir.rotr)(u, 6) ^ (0, Ir.rotr)(u, 11) ^ (0, Ir.rotr)(u, 25), m = s + p + d8(u, c, h) + v8[b] + xn[b] | 0, M = ((0, Ir.rotr)(i, 2) ^ (0, Ir.rotr)(i, 13) ^ (0, Ir.rotr)(i, 22)) + p8(i, o, n) | 0;
      s = h, h = c, c = u, u = f + m | 0, f = n, n = o, o = i, i = m + M | 0;
    }
    i = i + this.A | 0, o = o + this.B | 0, n = n + this.C | 0, f = f + this.D | 0, u = u + this.E | 0, c = c + this.F | 0, h = h + this.G | 0, s = s + this.H | 0, this.set(i, o, n, f, u, c, h, s);
  }
  roundClean() {
    xn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class b8 extends Db {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
Ii.sha256 = (0, Ir.wrapConstructor)(() => new Db());
Ii.sha224 = (0, Ir.wrapConstructor)(() => new b8());
var Mt = {}, gt = {};
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.validateObject = gt.createHmacDrbg = gt.bitMask = gt.bitSet = gt.bitGet = gt.bitLen = gt.utf8ToBytes = gt.equalBytes = gt.concatBytes = gt.ensureBytes = gt.numberToVarBytesBE = gt.numberToBytesLE = gt.numberToBytesBE = gt.bytesToNumberLE = gt.bytesToNumberBE = gt.hexToBytes = gt.hexToNumber = gt.numberToHexUnpadded = gt.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $b = BigInt(0), zo = BigInt(1), y8 = BigInt(2), Ho = (e) => e instanceof Uint8Array, g8 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Uh(e) {
  if (!Ho(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += g8[e[r]];
  return t;
}
gt.bytesToHex = Uh;
function Ub(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
gt.numberToHexUnpadded = Ub;
function Fh(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
gt.hexToNumber = Fh;
function Vo(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(t / 2);
  for (let i = 0; i < r.length; i++) {
    const o = i * 2, n = e.slice(o, o + 2), f = Number.parseInt(n, 16);
    if (Number.isNaN(f) || f < 0)
      throw new Error("Invalid byte sequence");
    r[i] = f;
  }
  return r;
}
gt.hexToBytes = Vo;
function m8(e) {
  return Fh(Uh(e));
}
gt.bytesToNumberBE = m8;
function w8(e) {
  if (!Ho(e))
    throw new Error("Uint8Array expected");
  return Fh(Uh(Uint8Array.from(e).reverse()));
}
gt.bytesToNumberLE = w8;
function Fb(e, t) {
  return Vo(e.toString(16).padStart(t * 2, "0"));
}
gt.numberToBytesBE = Fb;
function _8(e, t) {
  return Fb(e, t).reverse();
}
gt.numberToBytesLE = _8;
function x8(e) {
  return Vo(Ub(e));
}
gt.numberToVarBytesBE = x8;
function E8(e, t, r) {
  let i;
  if (typeof t == "string")
    try {
      i = Vo(t);
    } catch (n) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`);
    }
  else if (Ho(t))
    i = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = i.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return i;
}
gt.ensureBytes = E8;
function zb(...e) {
  const t = new Uint8Array(e.reduce((i, o) => i + o.length, 0));
  let r = 0;
  return e.forEach((i) => {
    if (!Ho(i))
      throw new Error("Uint8Array expected");
    t.set(i, r), r += i.length;
  }), t;
}
gt.concatBytes = zb;
function S8(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
gt.equalBytes = S8;
function A8(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
gt.utf8ToBytes = A8;
function M8(e) {
  let t;
  for (t = 0; e > $b; e >>= zo, t += 1)
    ;
  return t;
}
gt.bitLen = M8;
function R8(e, t) {
  return e >> BigInt(t) & zo;
}
gt.bitGet = R8;
const B8 = (e, t, r) => e | (r ? zo : $b) << BigInt(t);
gt.bitSet = B8;
const I8 = (e) => (y8 << BigInt(e - 1)) - zo;
gt.bitMask = I8;
const Of = (e) => new Uint8Array(e), Rl = (e) => Uint8Array.from(e);
function T8(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = Of(e), o = Of(e), n = 0;
  const f = () => {
    i.fill(1), o.fill(0), n = 0;
  }, u = (...b) => r(o, i, ...b), c = (b = Of()) => {
    o = u(Rl([0]), b), i = u(), b.length !== 0 && (o = u(Rl([1]), b), i = u());
  }, h = () => {
    if (n++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let b = 0;
    const p = [];
    for (; b < t; ) {
      i = u();
      const m = i.slice();
      p.push(m), b += i.length;
    }
    return zb(...p);
  };
  return (b, p) => {
    f(), c(b);
    let m;
    for (; !(m = p(h())); )
      c();
    return f(), m;
  };
}
gt.createHmacDrbg = T8;
const O8 = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function P8(e, t, r = {}) {
  const i = (o, n, f) => {
    const u = O8[n];
    if (typeof u != "function")
      throw new Error(`Invalid validator "${n}", expected function`);
    const c = e[o];
    if (!(f && c === void 0) && !u(c, e))
      throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${n}`);
  };
  for (const [o, n] of Object.entries(t))
    i(o, n, !1);
  for (const [o, n] of Object.entries(r))
    i(o, n, !0);
  return e;
}
gt.validateObject = P8;
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.hashToPrivateScalar = Mt.FpSqrtEven = Mt.FpSqrtOdd = Mt.Field = Mt.nLength = Mt.FpIsSquare = Mt.FpDiv = Mt.FpInvertBatch = Mt.FpPow = Mt.validateField = Mt.isNegativeLE = Mt.FpSqrt = Mt.tonelliShanks = Mt.invert = Mt.pow2 = Mt.pow = Mt.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const vn = gt, or = BigInt(0), Ut = BigInt(1), An = BigInt(2), C8 = BigInt(3), Gc = BigInt(4), Bl = BigInt(5), Il = BigInt(8);
BigInt(9);
BigInt(16);
function Or(e, t) {
  const r = e % t;
  return r >= or ? r : t + r;
}
Mt.mod = Or;
function Hb(e, t, r) {
  if (r <= or || t < or)
    throw new Error("Expected power/modulo > 0");
  if (r === Ut)
    return or;
  let i = Ut;
  for (; t > or; )
    t & Ut && (i = i * e % r), e = e * e % r, t >>= Ut;
  return i;
}
Mt.pow = Hb;
function N8(e, t, r) {
  let i = e;
  for (; t-- > or; )
    i *= i, i %= r;
  return i;
}
Mt.pow2 = N8;
function so(e, t) {
  if (e === or || t <= or)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Or(e, t), i = t, o = or, n = Ut;
  for (; r !== or; ) {
    const u = i / r, c = i % r, h = o - n * u;
    i = r, r = c, o = n, n = h;
  }
  if (i !== Ut)
    throw new Error("invert: does not exist");
  return Or(o, t);
}
Mt.invert = so;
function Vb(e) {
  const t = (e - Ut) / An;
  let r, i, o;
  for (r = e - Ut, i = 0; r % An === or; r /= An, i++)
    ;
  for (o = An; o < e && Hb(o, t, e) !== e - Ut; o++)
    ;
  if (i === 1) {
    const f = (e + Ut) / Gc;
    return function(c, h) {
      const s = c.pow(h, f);
      if (!c.eql(c.sqr(s), h))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  const n = (r + Ut) / An;
  return function(u, c) {
    if (u.pow(c, t) === u.neg(u.ONE))
      throw new Error("Cannot find square root");
    let h = i, s = u.pow(u.mul(u.ONE, o), r), b = u.pow(c, n), p = u.pow(c, r);
    for (; !u.eql(p, u.ONE); ) {
      if (u.eql(p, u.ZERO))
        return u.ZERO;
      let m = 1;
      for (let M = u.sqr(p); m < h && !u.eql(M, u.ONE); m++)
        M = u.sqr(M);
      const E = u.pow(s, Ut << BigInt(h - m - 1));
      s = u.sqr(E), b = u.mul(b, E), p = u.mul(p, s), h = m;
    }
    return b;
  };
}
Mt.tonelliShanks = Vb;
function Wb(e) {
  if (e % Gc === C8) {
    const t = (e + Ut) / Gc;
    return function(i, o) {
      const n = i.pow(o, t);
      if (!i.eql(i.sqr(n), o))
        throw new Error("Cannot find square root");
      return n;
    };
  }
  if (e % Il === Bl) {
    const t = (e - Bl) / Il;
    return function(i, o) {
      const n = i.mul(o, An), f = i.pow(n, t), u = i.mul(o, f), c = i.mul(i.mul(u, An), f), h = i.mul(u, i.sub(c, i.ONE));
      if (!i.eql(i.sqr(h), o))
        throw new Error("Cannot find square root");
      return h;
    };
  }
  return Vb(e);
}
Mt.FpSqrt = Wb;
const L8 = (e, t) => (Or(e, t) & Ut) === Ut;
Mt.isNegativeLE = L8;
const k8 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function j8(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = k8.reduce((i, o) => (i[o] = "function", i), t);
  return (0, vn.validateObject)(e, r);
}
Mt.validateField = j8;
function Kb(e, t, r) {
  if (r < or)
    throw new Error("Expected power > 0");
  if (r === or)
    return e.ONE;
  if (r === Ut)
    return t;
  let i = e.ONE, o = t;
  for (; r > or; )
    r & Ut && (i = e.mul(i, o)), o = e.sqr(o), r >>= Ut;
  return i;
}
Mt.FpPow = Kb;
function Zb(e, t) {
  const r = new Array(t.length), i = t.reduce((n, f, u) => e.is0(f) ? n : (r[u] = n, e.mul(n, f)), e.ONE), o = e.inv(i);
  return t.reduceRight((n, f, u) => e.is0(f) ? n : (r[u] = e.mul(n, r[u]), e.mul(n, f)), o), r;
}
Mt.FpInvertBatch = Zb;
function q8(e, t, r) {
  return e.mul(t, typeof r == "bigint" ? so(r, e.ORDER) : e.inv(r));
}
Mt.FpDiv = q8;
function D8(e) {
  const t = (e.ORDER - Ut) / An;
  return (r) => {
    const i = e.pow(r, t);
    return e.eql(i, e.ZERO) || e.eql(i, e.ONE);
  };
}
Mt.FpIsSquare = D8;
function zh(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
Mt.nLength = zh;
function $8(e, t, r = !1, i = {}) {
  if (e <= or)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: n } = zh(e, t);
  if (n > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const f = Wb(e), u = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: n,
    MASK: (0, vn.bitMask)(o),
    ZERO: or,
    ONE: Ut,
    create: (c) => Or(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return or <= c && c < e;
    },
    is0: (c) => c === or,
    isOdd: (c) => (c & Ut) === Ut,
    neg: (c) => Or(-c, e),
    eql: (c, h) => c === h,
    sqr: (c) => Or(c * c, e),
    add: (c, h) => Or(c + h, e),
    sub: (c, h) => Or(c - h, e),
    mul: (c, h) => Or(c * h, e),
    pow: (c, h) => Kb(u, c, h),
    div: (c, h) => Or(c * so(h, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, h) => c + h,
    subN: (c, h) => c - h,
    mulN: (c, h) => c * h,
    inv: (c) => so(c, e),
    sqrt: i.sqrt || ((c) => f(u, c)),
    invertBatch: (c) => Zb(u, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, h, s) => s ? h : c,
    toBytes: (c) => r ? (0, vn.numberToBytesLE)(c, n) : (0, vn.numberToBytesBE)(c, n),
    fromBytes: (c) => {
      if (c.length !== n)
        throw new Error(`Fp.fromBytes: expected ${n}, got ${c.length}`);
      return r ? (0, vn.bytesToNumberLE)(c) : (0, vn.bytesToNumberBE)(c);
    }
  });
  return Object.freeze(u);
}
Mt.Field = $8;
function U8(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? r : e.neg(r);
}
Mt.FpSqrtOdd = U8;
function F8(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? e.neg(r) : r;
}
Mt.FpSqrtEven = F8;
function z8(e, t, r = !1) {
  e = (0, vn.ensureBytes)("privateHash", e);
  const i = e.length, o = zh(t).nByteLength + 8;
  if (o < 24 || i < o || i > 1024)
    throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${i}`);
  const n = r ? (0, vn.bytesToNumberLE)(e) : (0, vn.bytesToNumberBE)(e);
  return Or(n, t - Ut) + Ut;
}
Mt.hashToPrivateScalar = z8;
var Hh = {}, Ti = {};
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.validateBasic = Ti.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Tl = Mt, H8 = gt, V8 = BigInt(0), Pf = BigInt(1);
function W8(e, t) {
  const r = (o, n) => {
    const f = n.negate();
    return o ? f : n;
  }, i = (o) => {
    const n = Math.ceil(t / o) + 1, f = 2 ** (o - 1);
    return { windows: n, windowSize: f };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, n) {
      let f = e.ZERO, u = o;
      for (; n > V8; )
        n & Pf && (f = f.add(u)), u = u.double(), n >>= Pf;
      return f;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, n) {
      const { windows: f, windowSize: u } = i(n), c = [];
      let h = o, s = h;
      for (let b = 0; b < f; b++) {
        s = h, c.push(s);
        for (let p = 1; p < u; p++)
          s = s.add(h), c.push(s);
        h = s.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, n, f) {
      const { windows: u, windowSize: c } = i(o);
      let h = e.ZERO, s = e.BASE;
      const b = BigInt(2 ** o - 1), p = 2 ** o, m = BigInt(o);
      for (let E = 0; E < u; E++) {
        const M = E * c;
        let I = Number(f & b);
        f >>= m, I > c && (I -= p, f += Pf);
        const B = M, T = M + Math.abs(I) - 1, j = E % 2 !== 0, N = I < 0;
        I === 0 ? s = s.add(r(j, n[B])) : h = h.add(r(N, n[T]));
      }
      return { p: h, f: s };
    },
    wNAFCached(o, n, f, u) {
      const c = o._WINDOW_SIZE || 1;
      let h = n.get(o);
      return h || (h = this.precomputeWindow(o, c), c !== 1 && n.set(o, u(h))), this.wNAF(c, h, f);
    }
  };
}
Ti.wNAF = W8;
function K8(e) {
  return (0, Tl.validateField)(e.Fp), (0, H8.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, Tl.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
Ti.validateBasic = K8;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Mt, r = gt, i = gt, o = Ti;
  function n(T) {
    const j = (0, o.validateBasic)(T);
    r.validateObject(j, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: N, Fp: k, a: q } = j;
    if (N) {
      if (!k.eql(q, k.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof N != "object" || typeof N.beta != "bigint" || typeof N.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...j });
  }
  const { bytesToNumberBE: f, hexToBytes: u } = r;
  e.DER = {
    // asn.1 DER encoding utils
    Err: class extends Error {
      constructor(j = "") {
        super(j);
      }
    },
    _parseInt(T) {
      const { Err: j } = e.DER;
      if (T.length < 2 || T[0] !== 2)
        throw new j("Invalid signature integer tag");
      const N = T[1], k = T.subarray(2, N + 2);
      if (!N || k.length !== N)
        throw new j("Invalid signature integer: wrong length");
      if (k[0] & 128)
        throw new j("Invalid signature integer: negative");
      if (k[0] === 0 && !(k[1] & 128))
        throw new j("Invalid signature integer: unnecessary leading zero");
      return { d: f(k), l: T.subarray(N + 2) };
    },
    toSig(T) {
      const { Err: j } = e.DER, N = typeof T == "string" ? u(T) : T;
      if (!(N instanceof Uint8Array))
        throw new Error("ui8a expected");
      let k = N.length;
      if (k < 2 || N[0] != 48)
        throw new j("Invalid signature tag");
      if (N[1] !== k - 2)
        throw new j("Invalid signature: incorrect length");
      const { d: q, l: $ } = e.DER._parseInt(N.subarray(2)), { d: re, l: Q } = e.DER._parseInt($);
      if (Q.length)
        throw new j("Invalid signature: left bytes after parsing");
      return { r: q, s: re };
    },
    hexFromSig(T) {
      const j = (U) => Number.parseInt(U[0], 16) & 8 ? "00" + U : U, N = (U) => {
        const y = U.toString(16);
        return y.length & 1 ? `0${y}` : y;
      }, k = j(N(T.s)), q = j(N(T.r)), $ = k.length / 2, re = q.length / 2, Q = N($), fe = N(re);
      return `30${N(re + $ + 4)}02${fe}${q}02${Q}${k}`;
    }
  };
  const c = BigInt(0), h = BigInt(1), s = BigInt(2), b = BigInt(3), p = BigInt(4);
  function m(T) {
    const j = n(T), { Fp: N } = j, k = j.toBytes || ((w, x, A) => {
      const S = x.toAffine();
      return r.concatBytes(Uint8Array.from([4]), N.toBytes(S.x), N.toBytes(S.y));
    }), q = j.fromBytes || ((w) => {
      const x = w.subarray(1), A = N.fromBytes(x.subarray(0, N.BYTES)), S = N.fromBytes(x.subarray(N.BYTES, 2 * N.BYTES));
      return { x: A, y: S };
    });
    function $(w) {
      const { a: x, b: A } = j, S = N.sqr(w), g = N.mul(S, w);
      return N.add(N.add(g, N.mul(w, x)), A);
    }
    if (!N.eql(N.sqr(j.Gy), $(j.Gx)))
      throw new Error("bad generator point: equation left != right");
    function re(w) {
      return typeof w == "bigint" && c < w && w < j.n;
    }
    function Q(w) {
      if (!re(w))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function fe(w) {
      const { allowedPrivateKeyLengths: x, nByteLength: A, wrapPrivateKey: S, n: g } = j;
      if (x && typeof w != "bigint") {
        if (w instanceof Uint8Array && (w = r.bytesToHex(w)), typeof w != "string" || !x.includes(w.length))
          throw new Error("Invalid key");
        w = w.padStart(A * 2, "0");
      }
      let _;
      try {
        _ = typeof w == "bigint" ? w : r.bytesToNumberBE((0, i.ensureBytes)("private key", w, A));
      } catch {
        throw new Error(`private key must be ${A} bytes, hex or bigint, not ${typeof w}`);
      }
      return S && (_ = t.mod(_, g)), Q(_), _;
    }
    const U = /* @__PURE__ */ new Map();
    function y(w) {
      if (!(w instanceof v))
        throw new Error("ProjectivePoint expected");
    }
    class v {
      constructor(x, A, S) {
        if (this.px = x, this.py = A, this.pz = S, x == null || !N.isValid(x))
          throw new Error("x required");
        if (A == null || !N.isValid(A))
          throw new Error("y required");
        if (S == null || !N.isValid(S))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(x) {
        const { x: A, y: S } = x || {};
        if (!x || !N.isValid(A) || !N.isValid(S))
          throw new Error("invalid affine point");
        if (x instanceof v)
          throw new Error("projective point not allowed");
        const g = (_) => N.eql(_, N.ZERO);
        return g(A) && g(S) ? v.ZERO : new v(A, S, N.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(x) {
        const A = N.invertBatch(x.map((S) => S.pz));
        return x.map((S, g) => S.toAffine(A[g])).map(v.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(x) {
        const A = v.fromAffine(q((0, i.ensureBytes)("pointHex", x)));
        return A.assertValidity(), A;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(x) {
        return v.BASE.multiply(fe(x));
      }
      // "Private method", don't use it directly
      _setWindowSize(x) {
        this._WINDOW_SIZE = x, U.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (j.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y: A } = this.toAffine();
        if (!N.isValid(x) || !N.isValid(A))
          throw new Error("bad point: x or y not FE");
        const S = N.sqr(A), g = $(x);
        if (!N.eql(S, g))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: x } = this.toAffine();
        if (N.isOdd)
          return !N.isOdd(x);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(x) {
        y(x);
        const { px: A, py: S, pz: g } = this, { px: _, py: l, pz: R } = x, Y = N.eql(N.mul(A, R), N.mul(_, g)), oe = N.eql(N.mul(S, R), N.mul(l, g));
        return Y && oe;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new v(this.px, N.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: x, b: A } = j, S = N.mul(A, b), { px: g, py: _, pz: l } = this;
        let R = N.ZERO, Y = N.ZERO, oe = N.ZERO, H = N.mul(g, g), V = N.mul(_, _), F = N.mul(l, l), te = N.mul(g, _);
        return te = N.add(te, te), oe = N.mul(g, l), oe = N.add(oe, oe), R = N.mul(x, oe), Y = N.mul(S, F), Y = N.add(R, Y), R = N.sub(V, Y), Y = N.add(V, Y), Y = N.mul(R, Y), R = N.mul(te, R), oe = N.mul(S, oe), F = N.mul(x, F), te = N.sub(H, F), te = N.mul(x, te), te = N.add(te, oe), oe = N.add(H, H), H = N.add(oe, H), H = N.add(H, F), H = N.mul(H, te), Y = N.add(Y, H), F = N.mul(_, l), F = N.add(F, F), H = N.mul(F, te), R = N.sub(R, H), oe = N.mul(F, V), oe = N.add(oe, oe), oe = N.add(oe, oe), new v(R, Y, oe);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(x) {
        y(x);
        const { px: A, py: S, pz: g } = this, { px: _, py: l, pz: R } = x;
        let Y = N.ZERO, oe = N.ZERO, H = N.ZERO;
        const V = j.a, F = N.mul(j.b, b);
        let te = N.mul(A, _), he = N.mul(S, l), K = N.mul(g, R), W = N.add(A, S), ce = N.add(_, l);
        W = N.mul(W, ce), ce = N.add(te, he), W = N.sub(W, ce), ce = N.add(A, g);
        let ve = N.add(_, R);
        return ce = N.mul(ce, ve), ve = N.add(te, K), ce = N.sub(ce, ve), ve = N.add(S, g), Y = N.add(l, R), ve = N.mul(ve, Y), Y = N.add(he, K), ve = N.sub(ve, Y), H = N.mul(V, ce), Y = N.mul(F, K), H = N.add(Y, H), Y = N.sub(he, H), H = N.add(he, H), oe = N.mul(Y, H), he = N.add(te, te), he = N.add(he, te), K = N.mul(V, K), ce = N.mul(F, ce), he = N.add(he, K), K = N.sub(te, K), K = N.mul(V, K), ce = N.add(ce, K), te = N.mul(he, ce), oe = N.add(oe, te), te = N.mul(ve, ce), Y = N.mul(W, Y), Y = N.sub(Y, te), te = N.mul(W, he), H = N.mul(ve, H), H = N.add(H, te), new v(Y, oe, H);
      }
      subtract(x) {
        return this.add(x.negate());
      }
      is0() {
        return this.equals(v.ZERO);
      }
      wNAF(x) {
        return d.wNAFCached(this, U, x, (A) => {
          const S = N.invertBatch(A.map((g) => g.pz));
          return A.map((g, _) => g.toAffine(S[_])).map(v.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(x) {
        const A = v.ZERO;
        if (x === c)
          return A;
        if (Q(x), x === h)
          return this;
        const { endo: S } = j;
        if (!S)
          return d.unsafeLadder(this, x);
        let { k1neg: g, k1: _, k2neg: l, k2: R } = S.splitScalar(x), Y = A, oe = A, H = this;
        for (; _ > c || R > c; )
          _ & h && (Y = Y.add(H)), R & h && (oe = oe.add(H)), H = H.double(), _ >>= h, R >>= h;
        return g && (Y = Y.negate()), l && (oe = oe.negate()), oe = new v(N.mul(oe.px, S.beta), oe.py, oe.pz), Y.add(oe);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(x) {
        Q(x);
        let A = x, S, g;
        const { endo: _ } = j;
        if (_) {
          const { k1neg: l, k1: R, k2neg: Y, k2: oe } = _.splitScalar(A);
          let { p: H, f: V } = this.wNAF(R), { p: F, f: te } = this.wNAF(oe);
          H = d.constTimeNegate(l, H), F = d.constTimeNegate(Y, F), F = new v(N.mul(F.px, _.beta), F.py, F.pz), S = H.add(F), g = V.add(te);
        } else {
          const { p: l, f: R } = this.wNAF(A);
          S = l, g = R;
        }
        return v.normalizeZ([S, g])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(x, A, S) {
        const g = v.BASE, _ = (R, Y) => Y === c || Y === h || !R.equals(g) ? R.multiplyUnsafe(Y) : R.multiply(Y), l = _(this, A).add(_(x, S));
        return l.is0() ? void 0 : l;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(x) {
        const { px: A, py: S, pz: g } = this, _ = this.is0();
        x == null && (x = _ ? N.ONE : N.inv(g));
        const l = N.mul(A, x), R = N.mul(S, x), Y = N.mul(g, x);
        if (_)
          return { x: N.ZERO, y: N.ZERO };
        if (!N.eql(Y, N.ONE))
          throw new Error("invZ was invalid");
        return { x: l, y: R };
      }
      isTorsionFree() {
        const { h: x, isTorsionFree: A } = j;
        if (x === h)
          return !0;
        if (A)
          return A(v, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: x, clearCofactor: A } = j;
        return x === h ? this : A ? A(v, this) : this.multiplyUnsafe(j.h);
      }
      toRawBytes(x = !0) {
        return this.assertValidity(), k(v, this, x);
      }
      toHex(x = !0) {
        return r.bytesToHex(this.toRawBytes(x));
      }
    }
    v.BASE = new v(j.Gx, j.Gy, N.ONE), v.ZERO = new v(N.ZERO, N.ONE, N.ZERO);
    const a = j.nBitLength, d = (0, o.wNAF)(v, j.endo ? Math.ceil(a / 2) : a);
    return {
      CURVE: j,
      ProjectivePoint: v,
      normPrivateKeyToScalar: fe,
      weierstrassEquation: $,
      isWithinCurveOrder: re
    };
  }
  e.weierstrassPoints = m;
  function E(T) {
    const j = (0, o.validateBasic)(T);
    return r.validateObject(j, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...j });
  }
  function M(T) {
    const j = E(T), { Fp: N, n: k } = j, q = N.BYTES + 1, $ = 2 * N.BYTES + 1;
    function re(ce) {
      return c < ce && ce < N.ORDER;
    }
    function Q(ce) {
      return t.mod(ce, k);
    }
    function fe(ce) {
      return t.invert(ce, k);
    }
    const { ProjectivePoint: U, normPrivateKeyToScalar: y, weierstrassEquation: v, isWithinCurveOrder: a } = m({
      ...j,
      toBytes(ce, ve, Be) {
        const ee = ve.toAffine(), C = N.toBytes(ee.x), L = r.concatBytes;
        return Be ? L(Uint8Array.from([ve.hasEvenY() ? 2 : 3]), C) : L(Uint8Array.from([4]), C, N.toBytes(ee.y));
      },
      fromBytes(ce) {
        const ve = ce.length, Be = ce[0], ee = ce.subarray(1);
        if (ve === q && (Be === 2 || Be === 3)) {
          const C = r.bytesToNumberBE(ee);
          if (!re(C))
            throw new Error("Point is not on curve");
          const L = v(C);
          let Z = N.sqrt(L);
          const de = (Z & h) === h;
          return (Be & 1) === 1 !== de && (Z = N.neg(Z)), { x: C, y: Z };
        } else if (ve === $ && Be === 4) {
          const C = N.fromBytes(ee.subarray(0, N.BYTES)), L = N.fromBytes(ee.subarray(N.BYTES, 2 * N.BYTES));
          return { x: C, y: L };
        } else
          throw new Error(`Point of length ${ve} was invalid. Expected ${q} compressed bytes or ${$} uncompressed bytes`);
      }
    }), d = (ce) => r.bytesToHex(r.numberToBytesBE(ce, j.nByteLength));
    function w(ce) {
      const ve = k >> h;
      return ce > ve;
    }
    function x(ce) {
      return w(ce) ? Q(-ce) : ce;
    }
    const A = (ce, ve, Be) => r.bytesToNumberBE(ce.slice(ve, Be));
    class S {
      constructor(ve, Be, ee) {
        this.r = ve, this.s = Be, this.recovery = ee, this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(ve) {
        const Be = j.nByteLength;
        return ve = (0, i.ensureBytes)("compactSignature", ve, Be * 2), new S(A(ve, 0, Be), A(ve, Be, 2 * Be));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(ve) {
        const { r: Be, s: ee } = e.DER.toSig((0, i.ensureBytes)("DER", ve));
        return new S(Be, ee);
      }
      assertValidity() {
        if (!a(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!a(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(ve) {
        return new S(this.r, this.s, ve);
      }
      recoverPublicKey(ve) {
        const { r: Be, s: ee, recovery: C } = this, L = oe((0, i.ensureBytes)("msgHash", ve));
        if (C == null || ![0, 1, 2, 3].includes(C))
          throw new Error("recovery id invalid");
        const Z = C === 2 || C === 3 ? Be + j.n : Be;
        if (Z >= N.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const de = C & 1 ? "03" : "02", me = U.fromHex(de + d(Z)), Te = fe(Z), ze = Q(-L * Te), z = Q(ee * Te), ue = U.BASE.multiplyAndAddUnsafe(me, ze, z);
        if (!ue)
          throw new Error("point at infinify");
        return ue.assertValidity(), ue;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return w(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new S(this.r, Q(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return r.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return r.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return d(this.r) + d(this.s);
      }
    }
    const g = {
      isValidPrivateKey(ce) {
        try {
          return y(ce), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: y,
      /**
       * Produces cryptographically secure private key from random of size (nBitLength+64)
       * as per FIPS 186 B.4.1 with modulo bias being neglible.
       */
      randomPrivateKey: () => {
        const ce = j.randomBytes(N.BYTES + 8), ve = t.hashToPrivateScalar(ce, k);
        return r.numberToBytesBE(ve, j.nByteLength);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(ce = 8, ve = U.BASE) {
        return ve._setWindowSize(ce), ve.multiply(BigInt(3)), ve;
      }
    };
    function _(ce, ve = !0) {
      return U.fromPrivateKey(ce).toRawBytes(ve);
    }
    function l(ce) {
      const ve = ce instanceof Uint8Array, Be = typeof ce == "string", ee = (ve || Be) && ce.length;
      return ve ? ee === q || ee === $ : Be ? ee === 2 * q || ee === 2 * $ : ce instanceof U;
    }
    function R(ce, ve, Be = !0) {
      if (l(ce))
        throw new Error("first arg must be private key");
      if (!l(ve))
        throw new Error("second arg must be public key");
      return U.fromHex(ve).multiply(y(ce)).toRawBytes(Be);
    }
    const Y = j.bits2int || function(ce) {
      const ve = r.bytesToNumberBE(ce), Be = ce.length * 8 - j.nBitLength;
      return Be > 0 ? ve >> BigInt(Be) : ve;
    }, oe = j.bits2int_modN || function(ce) {
      return Q(Y(ce));
    }, H = r.bitMask(j.nBitLength);
    function V(ce) {
      if (typeof ce != "bigint")
        throw new Error("bigint expected");
      if (!(c <= ce && ce < H))
        throw new Error(`bigint expected < 2^${j.nBitLength}`);
      return r.numberToBytesBE(ce, j.nByteLength);
    }
    function F(ce, ve, Be = te) {
      if (["recovered", "canonical"].some((_e) => _e in Be))
        throw new Error("sign() legacy options not supported");
      const { hash: ee, randomBytes: C } = j;
      let { lowS: L, prehash: Z, extraEntropy: de } = Be;
      L == null && (L = !0), ce = (0, i.ensureBytes)("msgHash", ce), Z && (ce = (0, i.ensureBytes)("prehashed msgHash", ee(ce)));
      const me = oe(ce), Te = y(ve), ze = [V(Te), V(me)];
      if (de != null) {
        const _e = de === !0 ? C(N.BYTES) : de;
        ze.push((0, i.ensureBytes)("extraEntropy", _e, N.BYTES));
      }
      const z = r.concatBytes(...ze), ue = me;
      function se(_e) {
        const Ce = Y(_e);
        if (!a(Ce))
          return;
        const Ve = fe(Ce), ke = U.BASE.multiply(Ce).toAffine(), X = Q(ke.x);
        if (X === c)
          return;
        const Se = Q(Ve * Q(ue + X * Te));
        if (Se === c)
          return;
        let Ae = (ke.x === X ? 0 : 2) | Number(ke.y & h), qe = Se;
        return L && w(Se) && (qe = x(Se), Ae ^= 1), new S(X, qe, Ae);
      }
      return { seed: z, k2sig: se };
    }
    const te = { lowS: j.lowS, prehash: !1 }, he = { lowS: j.lowS, prehash: !1 };
    function K(ce, ve, Be = te) {
      const { seed: ee, k2sig: C } = F(ce, ve, Be), L = j;
      return r.createHmacDrbg(L.hash.outputLen, L.nByteLength, L.hmac)(ee, C);
    }
    U.BASE._setWindowSize(8);
    function W(ce, ve, Be, ee = he) {
      var ke;
      const C = ce;
      if (ve = (0, i.ensureBytes)("msgHash", ve), Be = (0, i.ensureBytes)("publicKey", Be), "strict" in ee)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: L, prehash: Z } = ee;
      let de, me;
      try {
        if (typeof C == "string" || C instanceof Uint8Array)
          try {
            de = S.fromDER(C);
          } catch (X) {
            if (!(X instanceof e.DER.Err))
              throw X;
            de = S.fromCompact(C);
          }
        else if (typeof C == "object" && typeof C.r == "bigint" && typeof C.s == "bigint") {
          const { r: X, s: Se } = C;
          de = new S(X, Se);
        } else
          throw new Error("PARSE");
        me = U.fromHex(Be);
      } catch (X) {
        if (X.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (L && de.hasHighS())
        return !1;
      Z && (ve = j.hash(ve));
      const { r: Te, s: ze } = de, z = oe(ve), ue = fe(ze), se = Q(z * ue), _e = Q(Te * ue), Ce = (ke = U.BASE.multiplyAndAddUnsafe(me, se, _e)) == null ? void 0 : ke.toAffine();
      return Ce ? Q(Ce.x) === Te : !1;
    }
    return {
      CURVE: j,
      getPublicKey: _,
      getSharedSecret: R,
      sign: K,
      verify: W,
      ProjectivePoint: U,
      Signature: S,
      utils: g
    };
  }
  e.weierstrass = M;
  function I(T, j) {
    const N = T.ORDER;
    let k = c;
    for (let w = N - h; w % s === c; w /= s)
      k += h;
    const q = k, $ = s << q - h - h, re = $ * s, Q = (N - h) / re, fe = (Q - h) / s, U = re - h, y = $, v = T.pow(j, Q), a = T.pow(j, (Q + h) / s);
    let d = (w, x) => {
      let A = v, S = T.pow(x, U), g = T.sqr(S);
      g = T.mul(g, x);
      let _ = T.mul(w, g);
      _ = T.pow(_, fe), _ = T.mul(_, S), S = T.mul(_, x), g = T.mul(_, w);
      let l = T.mul(g, S);
      _ = T.pow(l, y);
      let R = T.eql(_, T.ONE);
      S = T.mul(g, a), _ = T.mul(l, A), g = T.cmov(S, g, R), l = T.cmov(_, l, R);
      for (let Y = q; Y > h; Y--) {
        let oe = Y - s;
        oe = s << oe - h;
        let H = T.pow(l, oe);
        const V = T.eql(H, T.ONE);
        S = T.mul(g, A), A = T.mul(A, A), H = T.mul(l, A), g = T.cmov(S, g, V), l = T.cmov(H, l, V);
      }
      return { isValid: R, value: g };
    };
    if (T.ORDER % p === b) {
      const w = (T.ORDER - b) / p, x = T.sqrt(T.neg(j));
      d = (A, S) => {
        let g = T.sqr(S);
        const _ = T.mul(A, S);
        g = T.mul(g, _);
        let l = T.pow(g, w);
        l = T.mul(l, _);
        const R = T.mul(l, x), Y = T.mul(T.sqr(l), S), oe = T.eql(Y, A);
        let H = T.cmov(R, l, oe);
        return { isValid: oe, value: H };
      };
    }
    return d;
  }
  e.SWUFpSqrtRatio = I;
  function B(T, j) {
    if (t.validateField(T), !T.isValid(j.A) || !T.isValid(j.B) || !T.isValid(j.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const N = I(T, j.Z);
    if (!T.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (k) => {
      let q, $, re, Q, fe, U, y, v;
      q = T.sqr(k), q = T.mul(q, j.Z), $ = T.sqr(q), $ = T.add($, q), re = T.add($, T.ONE), re = T.mul(re, j.B), Q = T.cmov(j.Z, T.neg($), !T.eql($, T.ZERO)), Q = T.mul(Q, j.A), $ = T.sqr(re), U = T.sqr(Q), fe = T.mul(U, j.A), $ = T.add($, fe), $ = T.mul($, re), U = T.mul(U, Q), fe = T.mul(U, j.B), $ = T.add($, fe), y = T.mul(q, re);
      const { isValid: a, value: d } = N($, U);
      v = T.mul(q, k), v = T.mul(v, d), y = T.cmov(y, re, a), v = T.cmov(v, d, a);
      const w = T.isOdd(k) === T.isOdd(v);
      return v = T.cmov(T.neg(v), v, w), y = T.div(y, Q), { x: y, y: v };
    };
  }
  e.mapToCurveSimpleSWU = B;
})(Hh);
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.createHasher = Cr.isogenyMap = Cr.hash_to_field = Cr.expand_message_xof = Cr.expand_message_xmd = void 0;
const Z8 = Mt, Vr = gt;
function G8(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, Vr.utf8ToBytes)(e);
  throw new Error("DST must be Uint8Array or string");
}
const J8 = Vr.bytesToNumberBE;
function En(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let i = t - 1; i >= 0; i--)
    r[i] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function X8(e, t) {
  const r = new Uint8Array(e.length);
  for (let i = 0; i < e.length; i++)
    r[i] = e[i] ^ t[i];
  return r;
}
function oa(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function Vh(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function Gb(e, t, r, i) {
  oa(e), oa(t), Vh(r), t.length > 255 && (t = i((0, Vr.concatBytes)((0, Vr.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: o, blockLen: n } = i, f = Math.ceil(r / o);
  if (f > 255)
    throw new Error("Invalid xmd length");
  const u = (0, Vr.concatBytes)(t, En(t.length, 1)), c = En(0, n), h = En(r, 2), s = new Array(f), b = i((0, Vr.concatBytes)(c, e, h, En(0, 1), u));
  s[0] = i((0, Vr.concatBytes)(b, En(1, 1), u));
  for (let m = 1; m <= f; m++) {
    const E = [X8(b, s[m - 1]), En(m + 1, 1), u];
    s[m] = i((0, Vr.concatBytes)(...E));
  }
  return (0, Vr.concatBytes)(...s).slice(0, r);
}
Cr.expand_message_xmd = Gb;
function Jb(e, t, r, i, o) {
  if (oa(e), oa(t), Vh(r), t.length > 255) {
    const n = Math.ceil(2 * i / 8);
    t = o.create({ dkLen: n }).update((0, Vr.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return o.create({ dkLen: r }).update(e).update(En(r, 2)).update(t).update(En(t.length, 1)).digest();
}
Cr.expand_message_xof = Jb;
function Jc(e, t, r) {
  (0, Vr.validateObject)(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: i, k: o, m: n, hash: f, expand: u, DST: c } = r;
  oa(e), Vh(t);
  const h = G8(c), s = i.toString(2).length, b = Math.ceil((s + o) / 8), p = t * n * b;
  let m;
  if (u === "xmd")
    m = Gb(e, h, p, f);
  else if (u === "xof")
    m = Jb(e, h, p, o, f);
  else if (u === "_internal_pass")
    m = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const E = new Array(t);
  for (let M = 0; M < t; M++) {
    const I = new Array(n);
    for (let B = 0; B < n; B++) {
      const T = b * (B + M * n), j = m.subarray(T, T + b);
      I[B] = (0, Z8.mod)(J8(j), i);
    }
    E[M] = I;
  }
  return E;
}
Cr.hash_to_field = Jc;
function Y8(e, t) {
  const r = t.map((i) => Array.from(i).reverse());
  return (i, o) => {
    const [n, f, u, c] = r.map((h) => h.reduce((s, b) => e.add(e.mul(s, i), b)));
    return i = e.div(n, f), o = e.mul(o, e.div(u, c)), { x: i, y: o };
  };
}
Cr.isogenyMap = Y8;
function Q8(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(i, o) {
      const n = Jc(i, 2, { ...r, DST: r.DST, ...o }), f = e.fromAffine(t(n[0])), u = e.fromAffine(t(n[1])), c = f.add(u).clearCofactor();
      return c.assertValidity(), c;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(i, o) {
      const n = Jc(i, 1, { ...r, DST: r.encodeDST, ...o }), f = e.fromAffine(t(n[0])).clearCofactor();
      return f.assertValidity(), f;
    }
  };
}
Cr.createHasher = Q8;
var Oi = {}, Xb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = ar, r = yn;
  class i extends r.Hash {
    constructor(f, u) {
      super(), this.finished = !1, this.destroyed = !1, t.default.hash(f);
      const c = (0, r.toBytes)(u);
      if (this.iHash = f.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const h = this.blockLen, s = new Uint8Array(h);
      s.set(c.length > h ? f.create().update(c).digest() : c);
      for (let b = 0; b < s.length; b++)
        s[b] ^= 54;
      this.iHash.update(s), this.oHash = f.create();
      for (let b = 0; b < s.length; b++)
        s[b] ^= 106;
      this.oHash.update(s), s.fill(0);
    }
    update(f) {
      return t.default.exists(this), this.iHash.update(f), this;
    }
    digestInto(f) {
      t.default.exists(this), t.default.bytes(f, this.outputLen), this.finished = !0, this.iHash.digestInto(f), this.oHash.update(f), this.oHash.digestInto(f), this.destroy();
    }
    digest() {
      const f = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(f), f;
    }
    _cloneInto(f) {
      f || (f = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: u, iHash: c, finished: h, destroyed: s, blockLen: b, outputLen: p } = this;
      return f = f, f.finished = h, f.destroyed = s, f.blockLen = b, f.outputLen = p, f.oHash = u._cloneInto(f.oHash), f.iHash = c._cloneInto(f.iHash), f;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = i;
  const o = (n, f, u) => new i(n, f).update(u).digest();
  e.hmac = o, e.hmac.create = (n, f) => new i(n, f);
})(Xb);
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.createCurve = Oi.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const e5 = Xb, Ol = yn, t5 = Hh;
function Yb(e) {
  return {
    hash: e,
    hmac: (t, ...r) => (0, e5.hmac)(e, t, (0, Ol.concatBytes)(...r)),
    randomBytes: Ol.randomBytes
  };
}
Oi.getHash = Yb;
function r5(e, t) {
  const r = (i) => (0, t5.weierstrass)({ ...e, ...Yb(i) });
  return Object.freeze({ ...r(t), create: r });
}
Oi.createCurve = r5;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Ii, r = yn, i = Mt, o = Hh, n = gt, f = Cr, u = Oi, c = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), h = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), s = BigInt(1), b = BigInt(2), p = (S, g) => (S + g / b) / g;
  function m(S) {
    const g = c, _ = BigInt(3), l = BigInt(6), R = BigInt(11), Y = BigInt(22), oe = BigInt(23), H = BigInt(44), V = BigInt(88), F = S * S * S % g, te = F * F * S % g, he = (0, i.pow2)(te, _, g) * te % g, K = (0, i.pow2)(he, _, g) * te % g, W = (0, i.pow2)(K, b, g) * F % g, ce = (0, i.pow2)(W, R, g) * W % g, ve = (0, i.pow2)(ce, Y, g) * ce % g, Be = (0, i.pow2)(ve, H, g) * ve % g, ee = (0, i.pow2)(Be, V, g) * Be % g, C = (0, i.pow2)(ee, H, g) * ve % g, L = (0, i.pow2)(C, _, g) * te % g, Z = (0, i.pow2)(L, oe, g) * ce % g, de = (0, i.pow2)(Z, l, g) * F % g, me = (0, i.pow2)(de, b, g);
    if (!E.eql(E.sqr(me), S))
      throw new Error("Cannot find square root");
    return me;
  }
  const E = (0, i.Field)(c, void 0, void 0, { sqrt: m });
  e.secp256k1 = (0, u.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: E,
    n: h,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (S) => {
        const g = h, _ = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), l = -s * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), R = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Y = _, oe = BigInt("0x100000000000000000000000000000000"), H = p(Y * S, g), V = p(-l * S, g);
        let F = (0, i.mod)(S - H * _ - V * R, g), te = (0, i.mod)(-H * l - V * Y, g);
        const he = F > oe, K = te > oe;
        if (he && (F = g - F), K && (te = g - te), F > oe || te > oe)
          throw new Error("splitScalar: Endomorphism failed, k=" + S);
        return { k1neg: he, k1: F, k2neg: K, k2: te };
      }
    }
  }, t.sha256);
  const M = BigInt(0), I = (S) => typeof S == "bigint" && M < S && S < c, B = (S) => typeof S == "bigint" && M < S && S < h, T = {};
  function j(S, ...g) {
    let _ = T[S];
    if (_ === void 0) {
      const l = (0, t.sha256)(Uint8Array.from(S, (R) => R.charCodeAt(0)));
      _ = (0, n.concatBytes)(l, l), T[S] = _;
    }
    return (0, t.sha256)((0, n.concatBytes)(_, ...g));
  }
  const N = (S) => S.toRawBytes(!0).slice(1), k = (S) => (0, n.numberToBytesBE)(S, 32), q = (S) => (0, i.mod)(S, c), $ = (S) => (0, i.mod)(S, h), re = e.secp256k1.ProjectivePoint, Q = (S, g, _) => re.BASE.multiplyAndAddUnsafe(S, g, _);
  function fe(S) {
    let g = e.secp256k1.utils.normPrivateKeyToScalar(S), _ = re.fromPrivateKey(g);
    return { scalar: _.hasEvenY() ? g : $(-g), bytes: N(_) };
  }
  function U(S) {
    if (!I(S))
      throw new Error("bad x: need 0 < x < p");
    const g = q(S * S), _ = q(g * S + BigInt(7));
    let l = m(_);
    l % b !== M && (l = q(-l));
    const R = new re(S, l, s);
    return R.assertValidity(), R;
  }
  function y(...S) {
    return $((0, n.bytesToNumberBE)(j("BIP0340/challenge", ...S)));
  }
  function v(S) {
    return fe(S).bytes;
  }
  function a(S, g, _ = (0, r.randomBytes)(32)) {
    const l = (0, n.ensureBytes)("message", S), { bytes: R, scalar: Y } = fe(g), oe = (0, n.ensureBytes)("auxRand", _, 32), H = k(Y ^ (0, n.bytesToNumberBE)(j("BIP0340/aux", oe))), V = j("BIP0340/nonce", H, R, l), F = $((0, n.bytesToNumberBE)(V));
    if (F === M)
      throw new Error("sign failed: k is zero");
    const { bytes: te, scalar: he } = fe(F), K = y(te, R, l), W = new Uint8Array(64);
    if (W.set(te, 0), W.set(k($(he + K * Y)), 32), !d(W, l, R))
      throw new Error("sign: Invalid signature produced");
    return W;
  }
  function d(S, g, _) {
    const l = (0, n.ensureBytes)("signature", S, 64), R = (0, n.ensureBytes)("message", g), Y = (0, n.ensureBytes)("publicKey", _, 32);
    try {
      const oe = U((0, n.bytesToNumberBE)(Y)), H = (0, n.bytesToNumberBE)(l.subarray(0, 32));
      if (!I(H))
        return !1;
      const V = (0, n.bytesToNumberBE)(l.subarray(32, 64));
      if (!B(V))
        return !1;
      const F = y(k(H), N(oe), R), te = Q(oe, V, $(-F));
      return !(!te || !te.hasEvenY() || te.toAffine().x !== H);
    } catch {
      return !1;
    }
  }
  e.schnorr = {
    getPublicKey: v,
    sign: a,
    verify: d,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: U,
      pointToBytes: N,
      numberToBytesBE: n.numberToBytesBE,
      bytesToNumberBE: n.bytesToNumberBE,
      taggedHash: j,
      mod: i.mod
    }
  };
  const w = (0, f.isogenyMap)(E, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((S) => S.map((g) => BigInt(g)))), x = (0, o.mapToCurveSimpleSWU)(E, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: E.create(BigInt("-11"))
  }), A = (0, f.createHasher)(e.secp256k1.ProjectivePoint, (S) => {
    const { x: g, y: _ } = x(E.create(S[0]));
    return w(g, _);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: E.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: t.sha256
  });
  e.hashToCurve = A.hashToCurve, e.encodeToCurve = A.encodeToCurve;
})(Nb);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.secp256k1 = void 0;
  var t = Nb;
  Object.defineProperty(e, "secp256k1", { enumerable: !0, get: function() {
    return t.secp256k1;
  } });
})($o);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MAX_WITHDRAWALS_PER_PAYLOAD = e.RLP_EMPTY_STRING = e.KECCAK256_RLP = e.KECCAK256_RLP_S = e.KECCAK256_RLP_ARRAY = e.KECCAK256_RLP_ARRAY_S = e.KECCAK256_NULL = e.KECCAK256_NULL_S = e.TWO_POW256 = e.SECP256K1_ORDER_DIV_2 = e.SECP256K1_ORDER = e.MAX_INTEGER_BIGINT = e.MAX_INTEGER = e.MAX_UINT64 = void 0;
  const t = Le, r = $o;
  e.MAX_UINT64 = BigInt("0xffffffffffffffff"), e.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), e.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), e.SECP256K1_ORDER = r.secp256k1.CURVE.n, e.SECP256K1_ORDER_DIV_2 = r.secp256k1.CURVE.n / BigInt(2), e.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), e.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", e.KECCAK256_NULL = t.Buffer.from(e.KECCAK256_NULL_S, "hex"), e.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", e.KECCAK256_RLP_ARRAY = t.Buffer.from(e.KECCAK256_RLP_ARRAY_S, "hex"), e.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", e.KECCAK256_RLP = t.Buffer.from(e.KECCAK256_RLP_S, "hex"), e.RLP_EMPTY_STRING = t.Buffer.from([128]), e.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
})(Do);
var Wo = {};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.GWEI_TO_WEI = void 0;
Wo.GWEI_TO_WEI = BigInt(1e9);
var Wh = {}, an = {};
Object.defineProperty(an, "__esModule", { value: !0 });
an.RLP = an.utils = an.decode = an.encode = void 0;
function Kh(e) {
  if (Array.isArray(e)) {
    const r = [];
    let i = 0;
    for (let o = 0; o < e.length; o++) {
      const n = Kh(e[o]);
      r.push(n), i += n.length;
    }
    return Yc(Cl(i, 192), ...r);
  }
  const t = iy(e);
  return t.length === 1 && t[0] < 128 ? t : Yc(Cl(t.length, 128), t);
}
an.encode = Kh;
function ui(e, t, r) {
  if (r > e.length)
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  return e.slice(t, r);
}
function Pl(e) {
  if (e[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return ty(ey(e));
}
function Cl(e, t) {
  if (e < 56)
    return Uint8Array.from([e + t]);
  const r = Qc(e), i = r.length / 2, o = Qc(t + 55 + i);
  return Uint8Array.from(uo(o + r));
}
function Qb(e, t = !1) {
  if (typeof e > "u" || e === null || e.length === 0)
    return Uint8Array.from([]);
  const r = iy(e), i = Xc(r);
  if (t)
    return i;
  if (i.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return i.data;
}
an.decode = Qb;
function Xc(e) {
  let t, r, i, o, n;
  const f = [], u = e[0];
  if (u <= 127)
    return {
      data: e.slice(0, 1),
      remainder: e.slice(1)
    };
  if (u <= 183) {
    if (t = u - 127, u === 128 ? i = Uint8Array.from([]) : i = ui(e, 1, t), t === 2 && i[0] < 128)
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    return {
      data: i,
      remainder: e.slice(t)
    };
  } else if (u <= 191) {
    if (r = u - 182, e.length - 1 < r)
      throw new Error("invalid RLP: not enough bytes for string length");
    if (t = Pl(ui(e, 1, r)), t <= 55)
      throw new Error("invalid RLP: expected string length to be greater than 55");
    return i = ui(e, r, t + r), {
      data: i,
      remainder: e.slice(t + r)
    };
  } else if (u <= 247) {
    for (t = u - 191, o = ui(e, 1, t); o.length; )
      n = Xc(o), f.push(n.data), o = n.remainder;
    return {
      data: f,
      remainder: e.slice(t)
    };
  } else {
    if (r = u - 246, t = Pl(ui(e, 1, r)), t < 56)
      throw new Error("invalid RLP: encoded list too short");
    const c = r + t;
    if (c > e.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (o = ui(e, r, c); o.length; )
      n = Xc(o), f.push(n.data), o = n.remainder;
    return {
      data: f,
      remainder: e.slice(c)
    };
  }
}
const n5 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ey(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += n5[e[r]];
  return t;
}
function ty(e) {
  const t = Number.parseInt(e, 16);
  if (Number.isNaN(t))
    throw new Error("Invalid byte sequence");
  return t;
}
function uo(e) {
  if (typeof e != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof e);
  if (e.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const i = r * 2;
    t[r] = ty(e.slice(i, i + 2));
  }
  return t;
}
function Yc(...e) {
  if (e.length === 1)
    return e[0];
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  for (let i = 0, o = 0; i < e.length; i++) {
    const n = e[i];
    r.set(n, o), o += n.length;
  }
  return r;
}
function ry(e) {
  return new TextEncoder().encode(e);
}
function Qc(e) {
  if (e < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const t = e.toString(16);
  return t.length % 2 ? `0${t}` : t;
}
function i5(e) {
  return e.length % 2 ? `0${e}` : e;
}
function ny(e) {
  return e.length >= 2 && e[0] === "0" && e[1] === "x";
}
function a5(e) {
  return typeof e != "string" ? e : ny(e) ? e.slice(2) : e;
}
function iy(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return ny(e) ? uo(i5(a5(e))) : ry(e);
  if (typeof e == "number" || typeof e == "bigint")
    return e ? uo(Qc(e)) : Uint8Array.from([]);
  if (e == null)
    return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof e);
}
an.utils = {
  bytesToHex: ey,
  concatBytes: Yc,
  hexToBytes: uo,
  utf8ToBytes: ry
};
an.RLP = { encode: Kh, decode: Qb };
var Lr = {}, qt = {}, ay = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.add = e.toBig = e.split = e.fromBig = void 0;
  const t = BigInt(2 ** 32 - 1), r = BigInt(32);
  function i(fe, U = !1) {
    return U ? { h: Number(fe & t), l: Number(fe >> r & t) } : { h: Number(fe >> r & t) | 0, l: Number(fe & t) | 0 };
  }
  e.fromBig = i;
  function o(fe, U = !1) {
    let y = new Uint32Array(fe.length), v = new Uint32Array(fe.length);
    for (let a = 0; a < fe.length; a++) {
      const { h: d, l: w } = i(fe[a], U);
      [y[a], v[a]] = [d, w];
    }
    return [y, v];
  }
  e.split = o;
  const n = (fe, U) => BigInt(fe >>> 0) << r | BigInt(U >>> 0);
  e.toBig = n;
  const f = (fe, U, y) => fe >>> y, u = (fe, U, y) => fe << 32 - y | U >>> y, c = (fe, U, y) => fe >>> y | U << 32 - y, h = (fe, U, y) => fe << 32 - y | U >>> y, s = (fe, U, y) => fe << 64 - y | U >>> y - 32, b = (fe, U, y) => fe >>> y - 32 | U << 64 - y, p = (fe, U) => U, m = (fe, U) => fe, E = (fe, U, y) => fe << y | U >>> 32 - y, M = (fe, U, y) => U << y | fe >>> 32 - y, I = (fe, U, y) => U << y - 32 | fe >>> 64 - y, B = (fe, U, y) => fe << y - 32 | U >>> 64 - y;
  function T(fe, U, y, v) {
    const a = (U >>> 0) + (v >>> 0);
    return { h: fe + y + (a / 2 ** 32 | 0) | 0, l: a | 0 };
  }
  e.add = T;
  const j = (fe, U, y) => (fe >>> 0) + (U >>> 0) + (y >>> 0), N = (fe, U, y, v) => U + y + v + (fe / 2 ** 32 | 0) | 0, k = (fe, U, y, v) => (fe >>> 0) + (U >>> 0) + (y >>> 0) + (v >>> 0), q = (fe, U, y, v, a) => U + y + v + a + (fe / 2 ** 32 | 0) | 0, $ = (fe, U, y, v, a) => (fe >>> 0) + (U >>> 0) + (y >>> 0) + (v >>> 0) + (a >>> 0), re = (fe, U, y, v, a, d) => U + y + v + a + d + (fe / 2 ** 32 | 0) | 0, Q = {
    fromBig: i,
    split: o,
    toBig: e.toBig,
    shrSH: f,
    shrSL: u,
    rotrSH: c,
    rotrSL: h,
    rotrBH: s,
    rotrBL: b,
    rotr32H: p,
    rotr32L: m,
    rotlSH: E,
    rotlSL: M,
    rotlBH: I,
    rotlBL: B,
    add: T,
    add3L: j,
    add3H: N,
    add4L: k,
    add4H: q,
    add5H: re,
    add5L: $
  };
  e.default = Q;
})(ay);
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.shake256 = qt.shake128 = qt.keccak_512 = qt.keccak_384 = qt.keccak_256 = qt.keccak_224 = qt.sha3_512 = qt.sha3_384 = qt.sha3_256 = qt.sha3_224 = qt.Keccak = qt.keccakP = void 0;
const ci = ar, fa = ay, ea = yn, [oy, fy, sy] = [[], [], []], o5 = BigInt(0), Ki = BigInt(1), f5 = BigInt(2), s5 = BigInt(7), u5 = BigInt(256), c5 = BigInt(113);
for (let e = 0, t = Ki, r = 1, i = 0; e < 24; e++) {
  [r, i] = [i, (2 * r + 3 * i) % 5], oy.push(2 * (5 * i + r)), fy.push((e + 1) * (e + 2) / 2 % 64);
  let o = o5;
  for (let n = 0; n < 7; n++)
    t = (t << Ki ^ (t >> s5) * c5) % u5, t & f5 && (o ^= Ki << (Ki << BigInt(n)) - Ki);
  sy.push(o);
}
const [h5, l5] = fa.default.split(sy, !0), Nl = (e, t, r) => r > 32 ? fa.default.rotlBH(e, t, r) : fa.default.rotlSH(e, t, r), Ll = (e, t, r) => r > 32 ? fa.default.rotlBL(e, t, r) : fa.default.rotlSL(e, t, r);
function uy(e, t = 24) {
  const r = new Uint32Array(10);
  for (let i = 24 - t; i < 24; i++) {
    for (let f = 0; f < 10; f++)
      r[f] = e[f] ^ e[f + 10] ^ e[f + 20] ^ e[f + 30] ^ e[f + 40];
    for (let f = 0; f < 10; f += 2) {
      const u = (f + 8) % 10, c = (f + 2) % 10, h = r[c], s = r[c + 1], b = Nl(h, s, 1) ^ r[u], p = Ll(h, s, 1) ^ r[u + 1];
      for (let m = 0; m < 50; m += 10)
        e[f + m] ^= b, e[f + m + 1] ^= p;
    }
    let o = e[2], n = e[3];
    for (let f = 0; f < 24; f++) {
      const u = fy[f], c = Nl(o, n, u), h = Ll(o, n, u), s = oy[f];
      o = e[s], n = e[s + 1], e[s] = c, e[s + 1] = h;
    }
    for (let f = 0; f < 50; f += 10) {
      for (let u = 0; u < 10; u++)
        r[u] = e[f + u];
      for (let u = 0; u < 10; u++)
        e[f + u] ^= ~r[(u + 2) % 10] & r[(u + 4) % 10];
    }
    e[0] ^= h5[i], e[1] ^= l5[i];
  }
  r.fill(0);
}
qt.keccakP = uy;
class wa extends ea.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, r, i, o = !1, n = 24) {
    if (super(), this.blockLen = t, this.suffix = r, this.outputLen = i, this.enableXOF = o, this.rounds = n, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ci.default.number(i), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = (0, ea.u32)(this.state);
  }
  keccak() {
    uy(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    ci.default.exists(this);
    const { blockLen: r, state: i } = this;
    t = (0, ea.toBytes)(t);
    const o = t.length;
    for (let n = 0; n < o; ) {
      const f = Math.min(r - this.pos, o - n);
      for (let u = 0; u < f; u++)
        i[this.pos++] ^= t[n++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: r, pos: i, blockLen: o } = this;
    t[i] ^= r, r & 128 && i === o - 1 && this.keccak(), t[o - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    ci.default.exists(this, !1), ci.default.bytes(t), this.finish();
    const r = this.state, { blockLen: i } = this;
    for (let o = 0, n = t.length; o < n; ) {
      this.posOut >= i && this.keccak();
      const f = Math.min(i - this.posOut, n - o);
      t.set(r.subarray(this.posOut, this.posOut + f), o), this.posOut += f, o += f;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return ci.default.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (ci.default.output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: r, suffix: i, outputLen: o, rounds: n, enableXOF: f } = this;
    return t || (t = new wa(r, i, o, f, n)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = n, t.suffix = i, t.outputLen = o, t.enableXOF = f, t.destroyed = this.destroyed, t;
  }
}
qt.Keccak = wa;
const Nn = (e, t, r) => (0, ea.wrapConstructor)(() => new wa(t, e, r));
qt.sha3_224 = Nn(6, 144, 224 / 8);
qt.sha3_256 = Nn(6, 136, 256 / 8);
qt.sha3_384 = Nn(6, 104, 384 / 8);
qt.sha3_512 = Nn(6, 72, 512 / 8);
qt.keccak_224 = Nn(1, 144, 224 / 8);
qt.keccak_256 = Nn(1, 136, 256 / 8);
qt.keccak_384 = Nn(1, 104, 384 / 8);
qt.keccak_512 = Nn(1, 72, 512 / 8);
const cy = (e, t, r) => (0, ea.wrapXOFConstructorWithOpts)((i = {}) => new wa(t, e, i.dkLen === void 0 ? r : i.dkLen, !0));
qt.shake128 = cy(31, 168, 128 / 8);
qt.shake256 = cy(31, 136, 256 / 8);
function eh(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var co = { exports: {} };
co.exports;
(function(e, t) {
  var r = Ze && Ze.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;
  const i = r(ar), o = yn, n = i.default.bool;
  t.assertBool = n;
  const f = i.default.bytes;
  t.assertBytes = f;
  var u = yn;
  Object.defineProperty(t, "bytesToHex", { enumerable: !0, get: function() {
    return u.bytesToHex;
  } }), Object.defineProperty(t, "toHex", { enumerable: !0, get: function() {
    return u.bytesToHex;
  } }), Object.defineProperty(t, "concatBytes", { enumerable: !0, get: function() {
    return u.concatBytes;
  } }), Object.defineProperty(t, "createView", { enumerable: !0, get: function() {
    return u.createView;
  } }), Object.defineProperty(t, "utf8ToBytes", { enumerable: !0, get: function() {
    return u.utf8ToBytes;
  } });
  function c(p) {
    if (!(p instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof p}`);
    return new TextDecoder().decode(p);
  }
  t.bytesToUtf8 = c;
  function h(p) {
    const m = p.startsWith("0x") ? p.substring(2) : p;
    return (0, o.hexToBytes)(m);
  }
  t.hexToBytes = h;
  function s(p, m) {
    if (p.length !== m.length)
      return !1;
    for (let E = 0; E < p.length; E++)
      if (p[E] !== m[E])
        return !1;
    return !0;
  }
  t.equalsBytes = s;
  function b(p) {
    return (m) => (i.default.bytes(m), p(m));
  }
  t.wrapHash = b, t.crypto = (() => {
    const p = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, m = typeof eh == "function" && eh.bind(e);
    return {
      node: m && !p ? m("crypto") : void 0,
      web: p
    };
  })();
})(co, co.exports);
var hy = co.exports;
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.keccak512 = Lr.keccak384 = Lr.keccak256 = Lr.keccak224 = void 0;
const sa = qt, Ko = hy;
Lr.keccak224 = (0, Ko.wrapHash)(sa.keccak_224);
Lr.keccak256 = (() => {
  const e = (0, Ko.wrapHash)(sa.keccak_256);
  return e.create = sa.keccak_256.create, e;
})();
Lr.keccak384 = (0, Ko.wrapHash)(sa.keccak_384);
Lr.keccak512 = (0, Ko.wrapHash)(sa.keccak_512);
var ri = {}, kr = {}, Dt = {};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.isHexString = Dt.getKeys = Dt.fromAscii = Dt.fromUtf8 = Dt.toAscii = Dt.arrayContainsArray = Dt.getBinarySize = Dt.padToEven = Dt.stripHexPrefix = Dt.isHexPrefixed = void 0;
function ly(e) {
  if (typeof e != "string")
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);
  return e[0] === "0" && e[1] === "x";
}
Dt.isHexPrefixed = ly;
const d5 = (e) => {
  if (typeof e != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof e}`);
  return ly(e) ? e.slice(2) : e;
};
Dt.stripHexPrefix = d5;
function dy(e) {
  let t = e;
  if (typeof t != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof t}`);
  return t.length % 2 && (t = `0${t}`), t;
}
Dt.padToEven = dy;
function p5(e) {
  if (typeof e != "string")
    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof e}`);
  return Le.Buffer.byteLength(e, "utf8");
}
Dt.getBinarySize = p5;
function v5(e, t, r) {
  if (Array.isArray(e) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e}'`);
  if (Array.isArray(t) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof t}'`);
  return t[r === !0 ? "some" : "every"]((i) => e.indexOf(i) >= 0);
}
Dt.arrayContainsArray = v5;
function b5(e) {
  let t = "", r = 0;
  const i = e.length;
  for (e.substring(0, 2) === "0x" && (r = 2); r < i; r += 2) {
    const o = parseInt(e.substr(r, 2), 16);
    t += String.fromCharCode(o);
  }
  return t;
}
Dt.toAscii = b5;
function y5(e) {
  const t = Le.Buffer.from(e, "utf8");
  return `0x${dy(t.toString("hex")).replace(/^0+|0+$/g, "")}`;
}
Dt.fromUtf8 = y5;
function g5(e) {
  let t = "";
  for (let r = 0; r < e.length; r++) {
    const o = e.charCodeAt(r).toString(16);
    t += o.length < 2 ? `0${o}` : o;
  }
  return `0x${t}`;
}
Dt.fromAscii = g5;
function m5(e, t, r) {
  if (!Array.isArray(e))
    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof e}`);
  if (typeof t != "string")
    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof e}`);
  const i = [];
  for (let o = 0; o < e.length; o++) {
    let n = e[o][t];
    if (r === !0 && !n)
      n = "";
    else if (typeof n != "string")
      throw new Error(`invalid abi - expected type 'string', received ${typeof n}`);
    i.push(n);
  }
  return i;
}
Dt.getKeys = m5;
function w5(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || typeof t < "u" && t > 0 && e.length !== 2 + 2 * t);
}
Dt.isHexString = w5;
Object.defineProperty(kr, "__esModule", { value: !0 });
kr.assertIsString = kr.assertIsArray = kr.assertIsBuffer = kr.assertIsHexString = void 0;
const _5 = Dt, x5 = function(e) {
  if (!(0, _5.isHexString)(e)) {
    const t = `This method only supports 0x-prefixed hex strings but input was: ${e}`;
    throw new Error(t);
  }
};
kr.assertIsHexString = x5;
const E5 = function(e) {
  if (!Le.Buffer.isBuffer(e)) {
    const t = `This method only supports Buffer but input was: ${e}`;
    throw new Error(t);
  }
};
kr.assertIsBuffer = E5;
const S5 = function(e) {
  if (!Array.isArray(e)) {
    const t = `This method only supports number arrays but input was: ${e}`;
    throw new Error(t);
  }
};
kr.assertIsArray = S5;
const A5 = function(e) {
  if (typeof e != "string") {
    const t = `This method only supports strings but input was: ${e}`;
    throw new Error(t);
  }
};
kr.assertIsString = A5;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intToUnpaddedBuffer = e.bigIntToUnpaddedBuffer = e.bigIntToHex = e.bufArrToArr = e.arrToBufArr = e.validateNoLeadingZeroes = e.baToJSON = e.toUtf8 = e.short = e.addHexPrefix = e.toUnsigned = e.fromSigned = e.bufferToInt = e.bigIntToBuffer = e.bufferToBigInt = e.bufferToHex = e.toBuffer = e.unpadHexString = e.unpadArray = e.unpadBuffer = e.setLengthRight = e.setLengthLeft = e.zeros = e.intToBuffer = e.intToHex = void 0;
  const t = kr, r = Dt, i = function(a) {
    if (!Number.isSafeInteger(a) || a < 0)
      throw new Error(`Received an invalid integer type: ${a}`);
    return `0x${a.toString(16)}`;
  };
  e.intToHex = i;
  const o = function(a) {
    const d = (0, e.intToHex)(a);
    return Le.Buffer.from((0, r.padToEven)(d.slice(2)), "hex");
  };
  e.intToBuffer = o;
  const n = function(a) {
    return Le.Buffer.allocUnsafe(a).fill(0);
  };
  e.zeros = n;
  const f = function(a, d, w) {
    const x = (0, e.zeros)(d);
    return w ? a.length < d ? (a.copy(x), x) : a.slice(0, d) : a.length < d ? (a.copy(x, d - a.length), x) : a.slice(-d);
  }, u = function(a, d) {
    return (0, t.assertIsBuffer)(a), f(a, d, !1);
  };
  e.setLengthLeft = u;
  const c = function(a, d) {
    return (0, t.assertIsBuffer)(a), f(a, d, !0);
  };
  e.setLengthRight = c;
  const h = function(a) {
    let d = a[0];
    for (; a.length > 0 && d.toString() === "0"; )
      a = a.slice(1), d = a[0];
    return a;
  }, s = function(a) {
    return (0, t.assertIsBuffer)(a), h(a);
  };
  e.unpadBuffer = s;
  const b = function(a) {
    return (0, t.assertIsArray)(a), h(a);
  };
  e.unpadArray = b;
  const p = function(a) {
    return (0, t.assertIsHexString)(a), a = (0, r.stripHexPrefix)(a), "0x" + h(a);
  };
  e.unpadHexString = p;
  const m = function(a) {
    if (a == null)
      return Le.Buffer.allocUnsafe(0);
    if (Le.Buffer.isBuffer(a) || Array.isArray(a) || a instanceof Uint8Array)
      return Le.Buffer.from(a);
    if (typeof a == "string") {
      if (!(0, r.isHexString)(a))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${a}`);
      return Le.Buffer.from((0, r.padToEven)((0, r.stripHexPrefix)(a)), "hex");
    }
    if (typeof a == "number")
      return (0, e.intToBuffer)(a);
    if (typeof a == "bigint") {
      if (a < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${a}`);
      let d = a.toString(16);
      return d.length % 2 && (d = "0" + d), Le.Buffer.from(d, "hex");
    }
    if (a.toArray)
      return Le.Buffer.from(a.toArray());
    if (a.toBuffer)
      return Le.Buffer.from(a.toBuffer());
    throw new Error("invalid type");
  };
  e.toBuffer = m;
  const E = function(a) {
    return a = (0, e.toBuffer)(a), "0x" + a.toString("hex");
  };
  e.bufferToHex = E;
  function M(a) {
    const d = (0, e.bufferToHex)(a);
    return BigInt(d === "0x" ? 0 : d);
  }
  e.bufferToBigInt = M;
  function I(a) {
    return (0, e.toBuffer)("0x" + a.toString(16));
  }
  e.bigIntToBuffer = I;
  const B = function(a) {
    const d = Number(M(a));
    if (!Number.isSafeInteger(d))
      throw new Error("Number exceeds 53 bits");
    return d;
  };
  e.bufferToInt = B;
  const T = function(a) {
    return BigInt.asIntN(256, M(a));
  };
  e.fromSigned = T;
  const j = function(a) {
    return I(BigInt.asUintN(256, a));
  };
  e.toUnsigned = j;
  const N = function(a) {
    return typeof a != "string" || (0, r.isHexPrefixed)(a) ? a : "0x" + a;
  };
  e.addHexPrefix = N;
  function k(a, d = 50) {
    const w = Le.Buffer.isBuffer(a) ? a.toString("hex") : a;
    return w.length <= d ? w : w.slice(0, d) + "…";
  }
  e.short = k;
  const q = function(a) {
    const d = /^(00)+|(00)+$/g;
    if (a = (0, r.stripHexPrefix)(a), a.length % 2 !== 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return Le.Buffer.from(a.replace(d, ""), "hex").toString("utf8");
  };
  e.toUtf8 = q;
  const $ = function(a) {
    if (Le.Buffer.isBuffer(a))
      return `0x${a.toString("hex")}`;
    if (a instanceof Array) {
      const d = [];
      for (let w = 0; w < a.length; w++)
        d.push((0, e.baToJSON)(a[w]));
      return d;
    }
  };
  e.baToJSON = $;
  const re = function(a) {
    for (const [d, w] of Object.entries(a))
      if (w !== void 0 && w.length > 0 && w[0] === 0)
        throw new Error(`${d} cannot have leading zeroes, received: ${w.toString("hex")}`);
  };
  e.validateNoLeadingZeroes = re;
  function Q(a) {
    return Array.isArray(a) ? a.map((d) => Q(d)) : Le.Buffer.from(a);
  }
  e.arrToBufArr = Q;
  function fe(a) {
    return Array.isArray(a) ? a.map((d) => fe(d)) : Uint8Array.from(a ?? []);
  }
  e.bufArrToArr = fe;
  const U = (a) => "0x" + a.toString(16);
  e.bigIntToHex = U;
  function y(a) {
    return (0, e.unpadBuffer)(I(a));
  }
  e.bigIntToUnpaddedBuffer = y;
  function v(a) {
    return (0, e.unpadBuffer)((0, e.intToBuffer)(a));
  }
  e.intToUnpaddedBuffer = v;
})(ri);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.accountBodyToRLP = e.accountBodyToSlim = e.accountBodyFromSlim = e.isZeroAddress = e.zeroAddress = e.importPublic = e.privateToAddress = e.privateToPublic = e.publicToAddress = e.pubToAddress = e.isValidPublic = e.isValidPrivate = e.generateAddress2 = e.generateAddress = e.isValidChecksumAddress = e.toChecksumAddress = e.isValidAddress = e.Account = void 0;
  const t = an, r = Lr, i = $o, o = hy, n = ri, f = Do, u = kr, c = Dt, h = BigInt(0);
  class s {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    constructor(v = h, a = h, d = f.KECCAK256_RLP, w = f.KECCAK256_NULL) {
      this.nonce = v, this.balance = a, this.storageRoot = d, this.codeHash = w, this._validate();
    }
    static fromAccountData(v) {
      const { nonce: a, balance: d, storageRoot: w, codeHash: x } = v;
      return new s(a !== void 0 ? (0, n.bufferToBigInt)((0, n.toBuffer)(a)) : void 0, d !== void 0 ? (0, n.bufferToBigInt)((0, n.toBuffer)(d)) : void 0, w !== void 0 ? (0, n.toBuffer)(w) : void 0, x !== void 0 ? (0, n.toBuffer)(x) : void 0);
    }
    static fromRlpSerializedAccount(v) {
      const a = (0, n.arrToBufArr)(t.RLP.decode(Uint8Array.from(v)));
      if (!Array.isArray(a))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray(a);
    }
    static fromValuesArray(v) {
      const [a, d, w, x] = v;
      return new s((0, n.bufferToBigInt)(a), (0, n.bufferToBigInt)(d), w, x);
    }
    _validate() {
      if (this.nonce < h)
        throw new Error("nonce must be greater than zero");
      if (this.balance < h)
        throw new Error("balance must be greater than zero");
      if (this.storageRoot.length !== 32)
        throw new Error("storageRoot must have a length of 32");
      if (this.codeHash.length !== 32)
        throw new Error("codeHash must have a length of 32");
    }
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    raw() {
      return [
        (0, n.bigIntToUnpaddedBuffer)(this.nonce),
        (0, n.bigIntToUnpaddedBuffer)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    serialize() {
      return Le.Buffer.from(t.RLP.encode((0, n.bufArrToArr)(this.raw())));
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      return !this.codeHash.equals(f.KECCAK256_NULL);
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      return this.balance === h && this.nonce === h && this.codeHash.equals(f.KECCAK256_NULL);
    }
  }
  e.Account = s;
  const b = function(y) {
    try {
      (0, u.assertIsString)(y);
    } catch {
      return !1;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(y);
  };
  e.isValidAddress = b;
  const p = function(y, v) {
    (0, u.assertIsHexString)(y);
    const a = (0, c.stripHexPrefix)(y).toLowerCase();
    let d = "";
    v !== void 0 && (d = (0, n.bufferToBigInt)((0, n.toBuffer)(v)).toString() + "0x");
    const w = Le.Buffer.from(d + a, "utf8"), x = (0, o.bytesToHex)((0, r.keccak256)(w));
    let A = "0x";
    for (let S = 0; S < a.length; S++)
      parseInt(x[S], 16) >= 8 ? A += a[S].toUpperCase() : A += a[S];
    return A;
  };
  e.toChecksumAddress = p;
  const m = function(y, v) {
    return (0, e.isValidAddress)(y) && (0, e.toChecksumAddress)(y, v) === y;
  };
  e.isValidChecksumAddress = m;
  const E = function(y, v) {
    return (0, u.assertIsBuffer)(y), (0, u.assertIsBuffer)(v), (0, n.bufferToBigInt)(v) === BigInt(0) ? Le.Buffer.from((0, r.keccak256)(t.RLP.encode((0, n.bufArrToArr)([y, null])))).slice(-20) : Le.Buffer.from((0, r.keccak256)(t.RLP.encode((0, n.bufArrToArr)([y, v])))).slice(-20);
  };
  e.generateAddress = E;
  const M = function(y, v, a) {
    if ((0, u.assertIsBuffer)(y), (0, u.assertIsBuffer)(v), (0, u.assertIsBuffer)(a), y.length !== 20)
      throw new Error("Expected from to be of length 20");
    if (v.length !== 32)
      throw new Error("Expected salt to be of length 32");
    const d = (0, r.keccak256)(Le.Buffer.concat([Le.Buffer.from("ff", "hex"), y, v, (0, r.keccak256)(a)]));
    return (0, n.toBuffer)(d).slice(-20);
  };
  e.generateAddress2 = M;
  const I = function(y) {
    return i.secp256k1.utils.isValidPrivateKey(y);
  };
  e.isValidPrivate = I;
  const B = function(y, v = !1) {
    if ((0, u.assertIsBuffer)(y), y.length === 64)
      try {
        return i.secp256k1.ProjectivePoint.fromHex(Le.Buffer.concat([Le.Buffer.from([4]), y])), !0;
      } catch {
        return !1;
      }
    if (!v)
      return !1;
    try {
      return i.secp256k1.ProjectivePoint.fromHex(y), !0;
    } catch {
      return !1;
    }
  };
  e.isValidPublic = B;
  const T = function(y, v = !1) {
    if ((0, u.assertIsBuffer)(y), v && y.length !== 64 && (y = Le.Buffer.from(i.secp256k1.ProjectivePoint.fromHex(y).toRawBytes(!1).slice(1))), y.length !== 64)
      throw new Error("Expected pubKey to be of length 64");
    return Le.Buffer.from((0, r.keccak256)(y)).slice(-20);
  };
  e.pubToAddress = T, e.publicToAddress = e.pubToAddress;
  const j = function(y) {
    return (0, u.assertIsBuffer)(y), Le.Buffer.from(i.secp256k1.ProjectivePoint.fromPrivateKey(y).toRawBytes(!1).slice(1));
  };
  e.privateToPublic = j;
  const N = function(y) {
    return (0, e.publicToAddress)((0, e.privateToPublic)(y));
  };
  e.privateToAddress = N;
  const k = function(y) {
    return (0, u.assertIsBuffer)(y), y.length !== 64 && (y = Le.Buffer.from(i.secp256k1.ProjectivePoint.fromHex(y).toRawBytes(!1).slice(1))), y;
  };
  e.importPublic = k;
  const q = function() {
    const v = (0, n.zeros)(20);
    return (0, n.bufferToHex)(v);
  };
  e.zeroAddress = q;
  const $ = function(y) {
    try {
      (0, u.assertIsString)(y);
    } catch {
      return !1;
    }
    return (0, e.zeroAddress)() === y;
  };
  e.isZeroAddress = $;
  function re(y) {
    const [v, a, d, w] = y;
    return [
      v,
      a,
      (0, n.arrToBufArr)(d).length === 0 ? f.KECCAK256_RLP : d,
      (0, n.arrToBufArr)(w).length === 0 ? f.KECCAK256_NULL : w
    ];
  }
  e.accountBodyFromSlim = re;
  const Q = new Uint8Array(0);
  function fe(y) {
    const [v, a, d, w] = y;
    return [
      v,
      a,
      (0, n.arrToBufArr)(d).equals(f.KECCAK256_RLP) ? Q : d,
      (0, n.arrToBufArr)(w).equals(f.KECCAK256_NULL) ? Q : w
    ];
  }
  e.accountBodyToSlim = fe;
  function U(y, v = !0) {
    const a = v ? re(y) : y;
    return (0, n.arrToBufArr)(t.RLP.encode(a));
  }
  e.accountBodyToRLP = U;
})(Wh);
var _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.Address = void 0;
const Zi = Wh, Na = ri;
class hn {
  constructor(t) {
    if (t.length !== 20)
      throw new Error("Invalid address length");
    this.buf = t;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new hn((0, Na.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(t) {
    if (!(0, Zi.isValidAddress)(t))
      throw new Error("Invalid address");
    return new hn((0, Na.toBuffer)(t));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(t) {
    if (!Le.Buffer.isBuffer(t))
      throw new Error("Public key should be Buffer");
    const r = (0, Zi.pubToAddress)(t);
    return new hn(r);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(t) {
    if (!Le.Buffer.isBuffer(t))
      throw new Error("Private key should be Buffer");
    const r = (0, Zi.privateToAddress)(t);
    return new hn(r);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(t, r) {
    if (typeof r != "bigint")
      throw new Error("Expected nonce to be a bigint");
    return new hn((0, Zi.generateAddress)(t.buf, (0, Na.bigIntToBuffer)(r)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(t, r, i) {
    if (!Le.Buffer.isBuffer(r))
      throw new Error("Expected salt to be a Buffer");
    if (!Le.Buffer.isBuffer(i))
      throw new Error("Expected initCode to be a Buffer");
    return new hn((0, Zi.generateAddress2)(t.buf, r, i));
  }
  /**
   * Is address equal to another.
   */
  equals(t) {
    return this.buf.equals(t.buf);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(hn.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const t = (0, Na.bufferToBigInt)(this.buf), r = BigInt(0), i = BigInt("0xffff");
    return t >= r && t <= i;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return "0x" + this.buf.toString("hex");
  }
  /**
   * Returns Buffer representation of address.
   */
  toBuffer() {
    return Le.Buffer.from(this.buf);
  }
}
_a.Address = hn;
var Zo = {}, Zh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toType = e.TypeOutput = void 0;
  const t = ri, r = Dt;
  var i;
  (function(n) {
    n[n.Number = 0] = "Number", n[n.BigInt = 1] = "BigInt", n[n.Buffer = 2] = "Buffer", n[n.PrefixedHexString = 3] = "PrefixedHexString";
  })(i = e.TypeOutput || (e.TypeOutput = {}));
  function o(n, f) {
    if (n === null)
      return null;
    if (n === void 0)
      return;
    if (typeof n == "string" && !(0, r.isHexString)(n))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${n}`);
    if (typeof n == "number" && !Number.isSafeInteger(n))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const u = (0, t.toBuffer)(n);
    switch (f) {
      case i.Buffer:
        return u;
      case i.BigInt:
        return (0, t.bufferToBigInt)(u);
      case i.Number: {
        const c = (0, t.bufferToBigInt)(u);
        if (c > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(c);
      }
      case i.PrefixedHexString:
        return (0, t.bufferToHex)(u);
      default:
        throw new Error("unknown outputType");
    }
  }
  e.toType = o;
})(Zh);
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.Withdrawal = void 0;
const kl = _a, Cf = ri, Wt = Zh;
class ta {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(t, r, i, o) {
    this.index = t, this.validatorIndex = r, this.address = i, this.amount = o;
  }
  static fromWithdrawalData(t) {
    const { index: r, validatorIndex: i, address: o, amount: n } = t, f = (0, Wt.toType)(r, Wt.TypeOutput.BigInt), u = (0, Wt.toType)(i, Wt.TypeOutput.BigInt), c = new kl.Address((0, Wt.toType)(o, Wt.TypeOutput.Buffer)), h = (0, Wt.toType)(n, Wt.TypeOutput.BigInt);
    return new ta(f, u, c, h);
  }
  static fromValuesArray(t) {
    if (t.length !== 4)
      throw Error(`Invalid withdrawalArray length expected=4 actual=${t.length}`);
    const [r, i, o, n] = t;
    return ta.fromWithdrawalData({ index: r, validatorIndex: i, address: o, amount: n });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBufferArray(t) {
    const { index: r, validatorIndex: i, address: o, amount: n } = t, f = (0, Wt.toType)(r, Wt.TypeOutput.BigInt) === BigInt(0) ? Le.Buffer.alloc(0) : (0, Wt.toType)(r, Wt.TypeOutput.Buffer), u = (0, Wt.toType)(i, Wt.TypeOutput.BigInt) === BigInt(0) ? Le.Buffer.alloc(0) : (0, Wt.toType)(i, Wt.TypeOutput.Buffer);
    let c;
    o instanceof kl.Address ? c = o.buf : c = (0, Wt.toType)(o, Wt.TypeOutput.Buffer);
    const h = (0, Wt.toType)(n, Wt.TypeOutput.BigInt) === BigInt(0) ? Le.Buffer.alloc(0) : (0, Wt.toType)(n, Wt.TypeOutput.Buffer);
    return [f, u, c, h];
  }
  raw() {
    return ta.toBufferArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.buf,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, Cf.bigIntToHex)(this.index),
      validatorIndex: (0, Cf.bigIntToHex)(this.validatorIndex),
      address: "0x" + this.address.buf.toString("hex"),
      amount: (0, Cf.bigIntToHex)(this.amount)
    };
  }
}
Zo.Withdrawal = ta;
var pr = {};
Object.defineProperty(pr, "__esModule", { value: !0 });
pr.hashPersonalMessage = pr.isValidSignature = pr.fromRpcSig = pr.toCompactSig = pr.toRpcSig = pr.ecrecover = pr.ecsign = void 0;
const M5 = Lr, py = $o, yr = ri, Nf = Do, R5 = kr;
function B5(e, t, r) {
  const i = py.secp256k1.sign(e, t), o = i.toCompactRawBytes(), n = Le.Buffer.from(o.slice(0, 32)), f = Le.Buffer.from(o.slice(32, 64)), u = r === void 0 ? BigInt(i.recovery + 27) : BigInt(i.recovery + 35) + BigInt(r) * BigInt(2);
  return { r: n, s: f, v: u };
}
pr.ecsign = B5;
function Go(e, t) {
  return e === BigInt(0) || e === BigInt(1) ? e : t === void 0 ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35));
}
function Jo(e) {
  return e === BigInt(0) || e === BigInt(1);
}
const I5 = function(e, t, r, i, o) {
  const n = Le.Buffer.concat([(0, yr.setLengthLeft)(r, 32), (0, yr.setLengthLeft)(i, 32)], 64), f = Go(t, o);
  if (!Jo(f))
    throw new Error("Invalid signature v value");
  const c = py.secp256k1.Signature.fromCompact(n).addRecoveryBit(Number(f)).recoverPublicKey(e);
  return Le.Buffer.from(c.toRawBytes(!1).slice(1));
};
pr.ecrecover = I5;
const T5 = function(e, t, r, i) {
  const o = Go(e, i);
  if (!Jo(o))
    throw new Error("Invalid signature v value");
  return (0, yr.bufferToHex)(Le.Buffer.concat([(0, yr.setLengthLeft)(t, 32), (0, yr.setLengthLeft)(r, 32), (0, yr.toBuffer)(e)]));
};
pr.toRpcSig = T5;
const O5 = function(e, t, r, i) {
  const o = Go(e, i);
  if (!Jo(o))
    throw new Error("Invalid signature v value");
  let n = r;
  return (e > BigInt(28) && e % BigInt(2) === BigInt(1) || e === BigInt(1) || e === BigInt(28)) && (n = Le.Buffer.from(r), n[0] |= 128), (0, yr.bufferToHex)(Le.Buffer.concat([(0, yr.setLengthLeft)(t, 32), (0, yr.setLengthLeft)(n, 32)]));
};
pr.toCompactSig = O5;
const P5 = function(e) {
  const t = (0, yr.toBuffer)(e);
  let r, i, o;
  if (t.length >= 65)
    r = t.slice(0, 32), i = t.slice(32, 64), o = (0, yr.bufferToBigInt)(t.slice(64));
  else if (t.length === 64)
    r = t.slice(0, 32), i = t.slice(32, 64), o = BigInt((0, yr.bufferToInt)(t.slice(32, 33)) >> 7), i[0] &= 127;
  else
    throw new Error("Invalid signature length");
  return o < 27 && (o = o + BigInt(27)), {
    v: o,
    r,
    s: i
  };
};
pr.fromRpcSig = P5;
const C5 = function(e, t, r, i = !0, o) {
  if (t.length !== 32 || r.length !== 32 || !Jo(Go(e, o)))
    return !1;
  const n = (0, yr.bufferToBigInt)(t), f = (0, yr.bufferToBigInt)(r);
  return !(n === BigInt(0) || n >= Nf.SECP256K1_ORDER || f === BigInt(0) || f >= Nf.SECP256K1_ORDER || i && f >= Nf.SECP256K1_ORDER_DIV_2);
};
pr.isValidSignature = C5;
const N5 = function(e) {
  (0, R5.assertIsBuffer)(e);
  const t = Le.Buffer.from(`Ethereum Signed Message:
${e.length}`, "utf-8");
  return Le.Buffer.from((0, M5.keccak256)(Le.Buffer.concat([t, e])));
};
pr.hashPersonalMessage = N5;
var vy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.compactBytesToNibbles = e.bytesToNibbles = e.nibblesToCompactBytes = e.nibblesToBytes = e.hasTerminator = void 0;
  const t = (f) => f.length > 0 && f[f.length - 1] === 16;
  e.hasTerminator = t;
  const r = (f, u) => {
    for (let c = 0, h = 0; h < f.length; c += 1, h += 2)
      u[c] = f[h] << 4 | f[h + 1];
  };
  e.nibblesToBytes = r;
  const i = (f) => {
    let u = 0;
    (0, e.hasTerminator)(f) && (u = 1, f = f.subarray(0, f.length - 1));
    const c = new Uint8Array(f.length / 2 + 1);
    return c[0] = u << 5, (f.length & 1) === 1 && (c[0] |= 16, c[0] |= f[0], f = f.subarray(1)), (0, e.nibblesToBytes)(f, c.subarray(1)), c;
  };
  e.nibblesToCompactBytes = i;
  const o = (f) => {
    const u = f.length * 2 + 1, c = new Uint8Array(u);
    for (let h = 0; h < f.length; h++) {
      const s = f[h];
      c[h * 2] = s / 16, c[h * 2 + 1] = s % 16;
    }
    return c[u - 1] = 16, c;
  };
  e.bytesToNibbles = o;
  const n = (f) => {
    if (f.length === 0)
      return f;
    let u = (0, e.bytesToNibbles)(f);
    u[0] < 2 && (u = u.subarray(0, u.length - 1));
    const c = 2 - (u[0] & 1);
    return u.subarray(c);
  };
  e.compactBytesToNibbles = n;
})(vy);
var Xo = {};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.AsyncEventEmitter = void 0;
const L5 = Ci;
async function k5(e, t, r) {
  let i;
  for await (const o of t)
    try {
      o.length < 2 ? o.call(e, r) : await new Promise((n, f) => {
        o.call(e, r, (u) => {
          u ? f(u) : n();
        });
      });
    } catch (n) {
      i = n;
    }
  if (i)
    throw i;
}
class j5 extends L5.EventEmitter {
  emit(t, ...r) {
    let [i, o] = r;
    const n = this;
    let f = n._events[t] ?? [];
    return o === void 0 && typeof i == "function" && (o = i, i = void 0), (t === "newListener" || t === "removeListener") && (i = {
      event: i,
      fn: o
    }, o = void 0), f = Array.isArray(f) ? f : [f], k5(n, f.slice(), i).then(o).catch(o), n.listenerCount(t) > 0;
  }
  once(t, r) {
    const i = this;
    let o;
    if (typeof r != "function")
      throw new TypeError("listener must be a function");
    return r.length >= 2 ? o = function(n, f) {
      i.removeListener(t, o), r(n, f);
    } : o = function(n) {
      i.removeListener(t, o), r(n, o);
    }, i.on(t, o), i;
  }
  first(t, r) {
    let i = this._events[t] ?? [];
    if (typeof r != "function")
      throw new TypeError("listener must be a function");
    return Array.isArray(i) || (this._events[t] = i = [i]), i.unshift(r), this;
  }
  before(t, r, i) {
    return this.beforeOrAfter(t, r, i);
  }
  after(t, r, i) {
    return this.beforeOrAfter(t, r, i, "after");
  }
  beforeOrAfter(t, r, i, o) {
    let n = this._events[t] ?? [], f, u;
    const c = o === "after" ? 1 : 0;
    if (typeof i != "function")
      throw new TypeError("listener must be a function");
    if (typeof r != "function")
      throw new TypeError("target must be a function");
    for (Array.isArray(n) || (this._events[t] = n = [n]), u = n.length, f = n.length; f--; )
      if (n[f] === r) {
        u = f + c;
        break;
      }
    return n.splice(u, 0, i), this;
  }
  on(t, r) {
    return super.on(t, r);
  }
  addListener(t, r) {
    return super.addListener(t, r);
  }
  prependListener(t, r) {
    return super.prependListener(t, r);
  }
  prependOnceListener(t, r) {
    return super.prependOnceListener(t, r);
  }
  removeAllListeners(t) {
    return super.removeAllListeners(t);
  }
  removeListener(t, r) {
    return super.removeListener(t, r);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(t) {
    return super.listeners(t);
  }
  listenerCount(t) {
    return super.listenerCount(t);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(t) {
    return super.setMaxListeners(t);
  }
}
Xo.AsyncEventEmitter = j5;
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.Lock = void 0;
class q5 {
  constructor() {
    this.permits = 1, this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise((t) => this.promiseResolverQueue.push(t));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const t = this.promiseResolverQueue.shift();
      t && t(!0);
    }
  }
}
Yo.Lock = q5;
var Pi = {}, Yn = {}, Lf = {}, kf = { exports: {} }, jf = {}, jl;
function by() {
  return jl || (jl = 1, function(e) {
    e.fetch = o(Ze.fetch) && o(Ze.ReadableStream), e.writableStream = o(Ze.WritableStream), e.abortController = o(Ze.AbortController);
    var t;
    function r() {
      if (t !== void 0)
        return t;
      if (Ze.XMLHttpRequest) {
        t = new Ze.XMLHttpRequest();
        try {
          t.open("GET", Ze.XDomainRequest ? "/" : "https://example.com");
        } catch {
          t = null;
        }
      } else
        t = null;
      return t;
    }
    function i(n) {
      var f = r();
      if (!f)
        return !1;
      try {
        return f.responseType = n, f.responseType === n;
      } catch {
      }
      return !1;
    }
    e.arraybuffer = e.fetch || i("arraybuffer"), e.msstream = !e.fetch && i("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && i("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (r() ? o(r().overrideMimeType) : !1);
    function o(n) {
      return typeof n == "function";
    }
    t = null;
  }(jf)), jf;
}
var La = { exports: {} }, ql;
function _t() {
  return ql || (ql = 1, typeof Object.create == "function" ? La.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : La.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var i = function() {
      };
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  }), La.exports;
}
var ka = {}, ja = { exports: {} }, qf, Dl;
function yy() {
  return Dl || (Dl = 1, qf = Ci.EventEmitter), qf;
}
var Df = {}, $f = {}, Uf, $l;
function Gh() {
  if ($l)
    return Uf;
  $l = 1;
  var e = Nh;
  return Uf = function() {
    return e() && !!Symbol.toStringTag;
  }, Uf;
}
var Ff, Ul;
function Qo() {
  if (Ul)
    return Ff;
  Ul = 1;
  var e = qi, t = ya, r = t(e("String.prototype.indexOf"));
  return Ff = function(o, n) {
    var f = e(o, !!n);
    return typeof f == "function" && r(o, ".prototype.") > -1 ? t(f) : f;
  }, Ff;
}
var zf, Fl;
function D5() {
  if (Fl)
    return zf;
  Fl = 1;
  var e = Gh()(), t = Qo(), r = t("Object.prototype.toString"), i = function(u) {
    return e && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : r(u) === "[object Arguments]";
  }, o = function(u) {
    return i(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && r(u) !== "[object Array]" && r(u.callee) === "[object Function]";
  }, n = function() {
    return i(arguments);
  }();
  return i.isLegacyArguments = o, zf = n ? i : o, zf;
}
var Hf, zl;
function $5() {
  if (zl)
    return Hf;
  zl = 1;
  var e = Object.prototype.toString, t = Function.prototype.toString, r = /^\s*(?:function)?\*/, i = Gh()(), o = Object.getPrototypeOf, n = function() {
    if (!i)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, f;
  return Hf = function(c) {
    if (typeof c != "function")
      return !1;
    if (r.test(t.call(c)))
      return !0;
    if (!i) {
      var h = e.call(c);
      return h === "[object GeneratorFunction]";
    }
    if (!o)
      return !1;
    if (typeof f > "u") {
      var s = n();
      f = s ? o(s) : !1;
    }
    return o(c) === f;
  }, Hf;
}
var Vf, Hl;
function U5() {
  if (Hl)
    return Vf;
  Hl = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, i;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw i;
        }
      }), i = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (T) {
      T !== i && (t = null);
    }
  else
    t = null;
  var o = /^\s*class\b/, n = function(j) {
    try {
      var N = e.call(j);
      return o.test(N);
    } catch {
      return !1;
    }
  }, f = function(j) {
    try {
      return n(j) ? !1 : (e.call(j), !0);
    } catch {
      return !1;
    }
  }, u = Object.prototype.toString, c = "[object Object]", h = "[object Function]", s = "[object GeneratorFunction]", b = "[object HTMLAllCollection]", p = "[object HTML document.all class]", m = "[object HTMLCollection]", E = typeof Symbol == "function" && !!Symbol.toStringTag, M = !(0 in [,]), I = function() {
    return !1;
  };
  if (typeof document == "object") {
    var B = document.all;
    u.call(B) === u.call(document.all) && (I = function(j) {
      if ((M || !j) && (typeof j > "u" || typeof j == "object"))
        try {
          var N = u.call(j);
          return (N === b || N === p || N === m || N === c) && j("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Vf = t ? function(j) {
    if (I(j))
      return !0;
    if (!j || typeof j != "function" && typeof j != "object")
      return !1;
    try {
      t(j, null, r);
    } catch (N) {
      if (N !== i)
        return !1;
    }
    return !n(j) && f(j);
  } : function(j) {
    if (I(j))
      return !0;
    if (!j || typeof j != "function" && typeof j != "object")
      return !1;
    if (E)
      return f(j);
    if (n(j))
      return !1;
    var N = u.call(j);
    return N !== h && N !== s && !/^\[object HTML/.test(N) ? !1 : f(j);
  }, Vf;
}
var Wf, Vl;
function F5() {
  if (Vl)
    return Wf;
  Vl = 1;
  var e = U5(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, i = function(c, h, s) {
    for (var b = 0, p = c.length; b < p; b++)
      r.call(c, b) && (s == null ? h(c[b], b, c) : h.call(s, c[b], b, c));
  }, o = function(c, h, s) {
    for (var b = 0, p = c.length; b < p; b++)
      s == null ? h(c.charAt(b), b, c) : h.call(s, c.charAt(b), b, c);
  }, n = function(c, h, s) {
    for (var b in c)
      r.call(c, b) && (s == null ? h(c[b], b, c) : h.call(s, c[b], b, c));
  }, f = function(c, h, s) {
    if (!e(h))
      throw new TypeError("iterator must be a function");
    var b;
    arguments.length >= 3 && (b = s), t.call(c) === "[object Array]" ? i(c, h, b) : typeof c == "string" ? o(c, h, b) : n(c, h, b);
  };
  return Wf = f, Wf;
}
var Kf, Wl;
function z5() {
  if (Wl)
    return Kf;
  Wl = 1;
  var e = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ], t = typeof globalThis > "u" ? Ze : globalThis;
  return Kf = function() {
    for (var i = [], o = 0; o < e.length; o++)
      typeof t[e[o]] == "function" && (i[i.length] = e[o]);
    return i;
  }, Kf;
}
var Zf, Kl;
function gy() {
  if (Kl)
    return Zf;
  Kl = 1;
  var e = F5(), t = z5(), r = ya, i = Qo(), o = kh, n = i("Object.prototype.toString"), f = Gh()(), u = typeof globalThis > "u" ? Ze : globalThis, c = t(), h = i("String.prototype.slice"), s = Object.getPrototypeOf, b = i("Array.prototype.indexOf", !0) || function(I, B) {
    for (var T = 0; T < I.length; T += 1)
      if (I[T] === B)
        return T;
    return -1;
  }, p = { __proto__: null };
  f && o && s ? e(c, function(M) {
    var I = new u[M]();
    if (Symbol.toStringTag in I) {
      var B = s(I), T = o(B, Symbol.toStringTag);
      if (!T) {
        var j = s(B);
        T = o(j, Symbol.toStringTag);
      }
      p["$" + M] = r(T.get);
    }
  }) : e(c, function(M) {
    var I = new u[M](), B = I.slice || I.set;
    B && (p["$" + M] = r(B));
  });
  var m = function(I) {
    var B = !1;
    return e(p, function(T, j) {
      if (!B)
        try {
          "$" + T(I) === j && (B = h(j, 1));
        } catch {
        }
    }), B;
  }, E = function(I) {
    var B = !1;
    return e(p, function(T, j) {
      if (!B)
        try {
          T(I), B = h(j, 1);
        } catch {
        }
    }), B;
  };
  return Zf = function(I) {
    if (!I || typeof I != "object")
      return !1;
    if (!f) {
      var B = h(n(I), 8, -1);
      return b(c, B) > -1 ? B : B !== "Object" ? !1 : E(I);
    }
    return o ? m(I) : null;
  }, Zf;
}
var Gf, Zl;
function H5() {
  if (Zl)
    return Gf;
  Zl = 1;
  var e = gy();
  return Gf = function(r) {
    return !!e(r);
  }, Gf;
}
var Gl;
function V5() {
  return Gl || (Gl = 1, function(e) {
    var t = D5(), r = $5(), i = gy(), o = H5();
    function n(Z) {
      return Z.call.bind(Z);
    }
    var f = typeof BigInt < "u", u = typeof Symbol < "u", c = n(Object.prototype.toString), h = n(Number.prototype.valueOf), s = n(String.prototype.valueOf), b = n(Boolean.prototype.valueOf);
    if (f)
      var p = n(BigInt.prototype.valueOf);
    if (u)
      var m = n(Symbol.prototype.valueOf);
    function E(Z, de) {
      if (typeof Z != "object")
        return !1;
      try {
        return de(Z), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = o;
    function M(Z) {
      return typeof Promise < "u" && Z instanceof Promise || Z !== null && typeof Z == "object" && typeof Z.then == "function" && typeof Z.catch == "function";
    }
    e.isPromise = M;
    function I(Z) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Z) : o(Z) || R(Z);
    }
    e.isArrayBufferView = I;
    function B(Z) {
      return i(Z) === "Uint8Array";
    }
    e.isUint8Array = B;
    function T(Z) {
      return i(Z) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = T;
    function j(Z) {
      return i(Z) === "Uint16Array";
    }
    e.isUint16Array = j;
    function N(Z) {
      return i(Z) === "Uint32Array";
    }
    e.isUint32Array = N;
    function k(Z) {
      return i(Z) === "Int8Array";
    }
    e.isInt8Array = k;
    function q(Z) {
      return i(Z) === "Int16Array";
    }
    e.isInt16Array = q;
    function $(Z) {
      return i(Z) === "Int32Array";
    }
    e.isInt32Array = $;
    function re(Z) {
      return i(Z) === "Float32Array";
    }
    e.isFloat32Array = re;
    function Q(Z) {
      return i(Z) === "Float64Array";
    }
    e.isFloat64Array = Q;
    function fe(Z) {
      return i(Z) === "BigInt64Array";
    }
    e.isBigInt64Array = fe;
    function U(Z) {
      return i(Z) === "BigUint64Array";
    }
    e.isBigUint64Array = U;
    function y(Z) {
      return c(Z) === "[object Map]";
    }
    y.working = typeof Map < "u" && y(/* @__PURE__ */ new Map());
    function v(Z) {
      return typeof Map > "u" ? !1 : y.working ? y(Z) : Z instanceof Map;
    }
    e.isMap = v;
    function a(Z) {
      return c(Z) === "[object Set]";
    }
    a.working = typeof Set < "u" && a(/* @__PURE__ */ new Set());
    function d(Z) {
      return typeof Set > "u" ? !1 : a.working ? a(Z) : Z instanceof Set;
    }
    e.isSet = d;
    function w(Z) {
      return c(Z) === "[object WeakMap]";
    }
    w.working = typeof WeakMap < "u" && w(/* @__PURE__ */ new WeakMap());
    function x(Z) {
      return typeof WeakMap > "u" ? !1 : w.working ? w(Z) : Z instanceof WeakMap;
    }
    e.isWeakMap = x;
    function A(Z) {
      return c(Z) === "[object WeakSet]";
    }
    A.working = typeof WeakSet < "u" && A(/* @__PURE__ */ new WeakSet());
    function S(Z) {
      return A(Z);
    }
    e.isWeakSet = S;
    function g(Z) {
      return c(Z) === "[object ArrayBuffer]";
    }
    g.working = typeof ArrayBuffer < "u" && g(new ArrayBuffer());
    function _(Z) {
      return typeof ArrayBuffer > "u" ? !1 : g.working ? g(Z) : Z instanceof ArrayBuffer;
    }
    e.isArrayBuffer = _;
    function l(Z) {
      return c(Z) === "[object DataView]";
    }
    l.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && l(new DataView(new ArrayBuffer(1), 0, 1));
    function R(Z) {
      return typeof DataView > "u" ? !1 : l.working ? l(Z) : Z instanceof DataView;
    }
    e.isDataView = R;
    var Y = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function oe(Z) {
      return c(Z) === "[object SharedArrayBuffer]";
    }
    function H(Z) {
      return typeof Y > "u" ? !1 : (typeof oe.working > "u" && (oe.working = oe(new Y())), oe.working ? oe(Z) : Z instanceof Y);
    }
    e.isSharedArrayBuffer = H;
    function V(Z) {
      return c(Z) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = V;
    function F(Z) {
      return c(Z) === "[object Map Iterator]";
    }
    e.isMapIterator = F;
    function te(Z) {
      return c(Z) === "[object Set Iterator]";
    }
    e.isSetIterator = te;
    function he(Z) {
      return c(Z) === "[object Generator]";
    }
    e.isGeneratorObject = he;
    function K(Z) {
      return c(Z) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = K;
    function W(Z) {
      return E(Z, h);
    }
    e.isNumberObject = W;
    function ce(Z) {
      return E(Z, s);
    }
    e.isStringObject = ce;
    function ve(Z) {
      return E(Z, b);
    }
    e.isBooleanObject = ve;
    function Be(Z) {
      return f && E(Z, p);
    }
    e.isBigIntObject = Be;
    function ee(Z) {
      return u && E(Z, m);
    }
    e.isSymbolObject = ee;
    function C(Z) {
      return W(Z) || ce(Z) || ve(Z) || Be(Z) || ee(Z);
    }
    e.isBoxedPrimitive = C;
    function L(Z) {
      return typeof Uint8Array < "u" && (_(Z) || H(Z));
    }
    e.isAnyArrayBuffer = L, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Z) {
      Object.defineProperty(e, Z, {
        enumerable: !1,
        value: function() {
          throw new Error(Z + " is not supported in userland");
        }
      });
    });
  }($f)), $f;
}
var Jf, Jl;
function W5() {
  return Jl || (Jl = 1, Jf = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), Jf;
}
var Xl;
function gn() {
  return Xl || (Xl = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(R) {
      for (var Y = Object.keys(R), oe = {}, H = 0; H < Y.length; H++)
        oe[Y[H]] = Object.getOwnPropertyDescriptor(R, Y[H]);
      return oe;
    }, r = /%[sdj%]/g;
    e.format = function(l) {
      if (!k(l)) {
        for (var R = [], Y = 0; Y < arguments.length; Y++)
          R.push(f(arguments[Y]));
        return R.join(" ");
      }
      for (var Y = 1, oe = arguments, H = oe.length, V = String(l).replace(r, function(te) {
        if (te === "%%")
          return "%";
        if (Y >= H)
          return te;
        switch (te) {
          case "%s":
            return String(oe[Y++]);
          case "%d":
            return Number(oe[Y++]);
          case "%j":
            try {
              return JSON.stringify(oe[Y++]);
            } catch {
              return "[Circular]";
            }
          default:
            return te;
        }
      }), F = oe[Y]; Y < H; F = oe[++Y])
        T(F) || !Q(F) ? V += " " + F : V += " " + f(F);
      return V;
    }, e.deprecate = function(l, R) {
      if (typeof at < "u" && at.noDeprecation === !0)
        return l;
      if (typeof at > "u")
        return function() {
          return e.deprecate(l, R).apply(this, arguments);
        };
      var Y = !1;
      function oe() {
        if (!Y) {
          if (at.throwDeprecation)
            throw new Error(R);
          at.traceDeprecation ? console.trace(R) : console.error(R), Y = !0;
        }
        return l.apply(this, arguments);
      }
      return oe;
    };
    var i = {}, o = /^$/;
    if (at.env.NODE_DEBUG) {
      var n = at.env.NODE_DEBUG;
      n = n.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o = new RegExp("^" + n + "$", "i");
    }
    e.debuglog = function(l) {
      if (l = l.toUpperCase(), !i[l])
        if (o.test(l)) {
          var R = at.pid;
          i[l] = function() {
            var Y = e.format.apply(e, arguments);
            console.error("%s %d: %s", l, R, Y);
          };
        } else
          i[l] = function() {
          };
      return i[l];
    };
    function f(l, R) {
      var Y = {
        seen: [],
        stylize: c
      };
      return arguments.length >= 3 && (Y.depth = arguments[2]), arguments.length >= 4 && (Y.colors = arguments[3]), B(R) ? Y.showHidden = R : R && e._extend(Y, R), $(Y.showHidden) && (Y.showHidden = !1), $(Y.depth) && (Y.depth = 2), $(Y.colors) && (Y.colors = !1), $(Y.customInspect) && (Y.customInspect = !0), Y.colors && (Y.stylize = u), s(Y, l, Y.depth);
    }
    e.inspect = f, f.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, f.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function u(l, R) {
      var Y = f.styles[R];
      return Y ? "\x1B[" + f.colors[Y][0] + "m" + l + "\x1B[" + f.colors[Y][1] + "m" : l;
    }
    function c(l, R) {
      return l;
    }
    function h(l) {
      var R = {};
      return l.forEach(function(Y, oe) {
        R[Y] = !0;
      }), R;
    }
    function s(l, R, Y) {
      if (l.customInspect && R && y(R.inspect) && // Filter out the util module, it's inspect function is special
      R.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(R.constructor && R.constructor.prototype === R)) {
        var oe = R.inspect(Y, l);
        return k(oe) || (oe = s(l, oe, Y)), oe;
      }
      var H = b(l, R);
      if (H)
        return H;
      var V = Object.keys(R), F = h(V);
      if (l.showHidden && (V = Object.getOwnPropertyNames(R)), U(R) && (V.indexOf("message") >= 0 || V.indexOf("description") >= 0))
        return p(R);
      if (V.length === 0) {
        if (y(R)) {
          var te = R.name ? ": " + R.name : "";
          return l.stylize("[Function" + te + "]", "special");
        }
        if (re(R))
          return l.stylize(RegExp.prototype.toString.call(R), "regexp");
        if (fe(R))
          return l.stylize(Date.prototype.toString.call(R), "date");
        if (U(R))
          return p(R);
      }
      var he = "", K = !1, W = ["{", "}"];
      if (I(R) && (K = !0, W = ["[", "]"]), y(R)) {
        var ce = R.name ? ": " + R.name : "";
        he = " [Function" + ce + "]";
      }
      if (re(R) && (he = " " + RegExp.prototype.toString.call(R)), fe(R) && (he = " " + Date.prototype.toUTCString.call(R)), U(R) && (he = " " + p(R)), V.length === 0 && (!K || R.length == 0))
        return W[0] + he + W[1];
      if (Y < 0)
        return re(R) ? l.stylize(RegExp.prototype.toString.call(R), "regexp") : l.stylize("[Object]", "special");
      l.seen.push(R);
      var ve;
      return K ? ve = m(l, R, Y, F, V) : ve = V.map(function(Be) {
        return E(l, R, Y, F, Be, K);
      }), l.seen.pop(), M(ve, he, W);
    }
    function b(l, R) {
      if ($(R))
        return l.stylize("undefined", "undefined");
      if (k(R)) {
        var Y = "'" + JSON.stringify(R).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return l.stylize(Y, "string");
      }
      if (N(R))
        return l.stylize("" + R, "number");
      if (B(R))
        return l.stylize("" + R, "boolean");
      if (T(R))
        return l.stylize("null", "null");
    }
    function p(l) {
      return "[" + Error.prototype.toString.call(l) + "]";
    }
    function m(l, R, Y, oe, H) {
      for (var V = [], F = 0, te = R.length; F < te; ++F)
        A(R, String(F)) ? V.push(E(
          l,
          R,
          Y,
          oe,
          String(F),
          !0
        )) : V.push("");
      return H.forEach(function(he) {
        he.match(/^\d+$/) || V.push(E(
          l,
          R,
          Y,
          oe,
          he,
          !0
        ));
      }), V;
    }
    function E(l, R, Y, oe, H, V) {
      var F, te, he;
      if (he = Object.getOwnPropertyDescriptor(R, H) || { value: R[H] }, he.get ? he.set ? te = l.stylize("[Getter/Setter]", "special") : te = l.stylize("[Getter]", "special") : he.set && (te = l.stylize("[Setter]", "special")), A(oe, H) || (F = "[" + H + "]"), te || (l.seen.indexOf(he.value) < 0 ? (T(Y) ? te = s(l, he.value, null) : te = s(l, he.value, Y - 1), te.indexOf(`
`) > -1 && (V ? te = te.split(`
`).map(function(K) {
        return "  " + K;
      }).join(`
`).slice(2) : te = `
` + te.split(`
`).map(function(K) {
        return "   " + K;
      }).join(`
`))) : te = l.stylize("[Circular]", "special")), $(F)) {
        if (V && H.match(/^\d+$/))
          return te;
        F = JSON.stringify("" + H), F.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (F = F.slice(1, -1), F = l.stylize(F, "name")) : (F = F.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), F = l.stylize(F, "string"));
      }
      return F + ": " + te;
    }
    function M(l, R, Y) {
      var oe = l.reduce(function(H, V) {
        return V.indexOf(`
`) >= 0, H + V.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return oe > 60 ? Y[0] + (R === "" ? "" : R + `
 `) + " " + l.join(`,
  `) + " " + Y[1] : Y[0] + R + " " + l.join(", ") + " " + Y[1];
    }
    e.types = V5();
    function I(l) {
      return Array.isArray(l);
    }
    e.isArray = I;
    function B(l) {
      return typeof l == "boolean";
    }
    e.isBoolean = B;
    function T(l) {
      return l === null;
    }
    e.isNull = T;
    function j(l) {
      return l == null;
    }
    e.isNullOrUndefined = j;
    function N(l) {
      return typeof l == "number";
    }
    e.isNumber = N;
    function k(l) {
      return typeof l == "string";
    }
    e.isString = k;
    function q(l) {
      return typeof l == "symbol";
    }
    e.isSymbol = q;
    function $(l) {
      return l === void 0;
    }
    e.isUndefined = $;
    function re(l) {
      return Q(l) && a(l) === "[object RegExp]";
    }
    e.isRegExp = re, e.types.isRegExp = re;
    function Q(l) {
      return typeof l == "object" && l !== null;
    }
    e.isObject = Q;
    function fe(l) {
      return Q(l) && a(l) === "[object Date]";
    }
    e.isDate = fe, e.types.isDate = fe;
    function U(l) {
      return Q(l) && (a(l) === "[object Error]" || l instanceof Error);
    }
    e.isError = U, e.types.isNativeError = U;
    function y(l) {
      return typeof l == "function";
    }
    e.isFunction = y;
    function v(l) {
      return l === null || typeof l == "boolean" || typeof l == "number" || typeof l == "string" || typeof l == "symbol" || // ES6 symbol
      typeof l > "u";
    }
    e.isPrimitive = v, e.isBuffer = W5();
    function a(l) {
      return Object.prototype.toString.call(l);
    }
    function d(l) {
      return l < 10 ? "0" + l.toString(10) : l.toString(10);
    }
    var w = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function x() {
      var l = /* @__PURE__ */ new Date(), R = [
        d(l.getHours()),
        d(l.getMinutes()),
        d(l.getSeconds())
      ].join(":");
      return [l.getDate(), w[l.getMonth()], R].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", x(), e.format.apply(e, arguments));
    }, e.inherits = _t(), e._extend = function(l, R) {
      if (!R || !Q(R))
        return l;
      for (var Y = Object.keys(R), oe = Y.length; oe--; )
        l[Y[oe]] = R[Y[oe]];
      return l;
    };
    function A(l, R) {
      return Object.prototype.hasOwnProperty.call(l, R);
    }
    var S = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(R) {
      if (typeof R != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (S && R[S]) {
        var Y = R[S];
        if (typeof Y != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(Y, S, {
          value: Y,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), Y;
      }
      function Y() {
        for (var oe, H, V = new Promise(function(he, K) {
          oe = he, H = K;
        }), F = [], te = 0; te < arguments.length; te++)
          F.push(arguments[te]);
        F.push(function(he, K) {
          he ? H(he) : oe(K);
        });
        try {
          R.apply(this, F);
        } catch (he) {
          H(he);
        }
        return V;
      }
      return Object.setPrototypeOf(Y, Object.getPrototypeOf(R)), S && Object.defineProperty(Y, S, {
        value: Y,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        Y,
        t(R)
      );
    }, e.promisify.custom = S;
    function g(l, R) {
      if (!l) {
        var Y = new Error("Promise was rejected with a falsy value");
        Y.reason = l, l = Y;
      }
      return R(l);
    }
    function _(l) {
      if (typeof l != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function R() {
        for (var Y = [], oe = 0; oe < arguments.length; oe++)
          Y.push(arguments[oe]);
        var H = Y.pop();
        if (typeof H != "function")
          throw new TypeError("The last argument must be of type Function");
        var V = this, F = function() {
          return H.apply(V, arguments);
        };
        l.apply(this, Y).then(
          function(te) {
            at.nextTick(F.bind(null, null, te));
          },
          function(te) {
            at.nextTick(g.bind(null, te, F));
          }
        );
      }
      return Object.setPrototypeOf(R, Object.getPrototypeOf(l)), Object.defineProperties(
        R,
        t(l)
      ), R;
    }
    e.callbackify = _;
  }(Df)), Df;
}
var Xf, Yl;
function K5() {
  if (Yl)
    return Xf;
  Yl = 1;
  function e(E, M) {
    var I = Object.keys(E);
    if (Object.getOwnPropertySymbols) {
      var B = Object.getOwnPropertySymbols(E);
      M && (B = B.filter(function(T) {
        return Object.getOwnPropertyDescriptor(E, T).enumerable;
      })), I.push.apply(I, B);
    }
    return I;
  }
  function t(E) {
    for (var M = 1; M < arguments.length; M++) {
      var I = arguments[M] != null ? arguments[M] : {};
      M % 2 ? e(Object(I), !0).forEach(function(B) {
        r(E, B, I[B]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors(I)) : e(Object(I)).forEach(function(B) {
        Object.defineProperty(E, B, Object.getOwnPropertyDescriptor(I, B));
      });
    }
    return E;
  }
  function r(E, M, I) {
    return M = f(M), M in E ? Object.defineProperty(E, M, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : E[M] = I, E;
  }
  function i(E, M) {
    if (!(E instanceof M))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(E, M) {
    for (var I = 0; I < M.length; I++) {
      var B = M[I];
      B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(E, f(B.key), B);
    }
  }
  function n(E, M, I) {
    return M && o(E.prototype, M), I && o(E, I), Object.defineProperty(E, "prototype", { writable: !1 }), E;
  }
  function f(E) {
    var M = u(E, "string");
    return typeof M == "symbol" ? M : String(M);
  }
  function u(E, M) {
    if (typeof E != "object" || E === null)
      return E;
    var I = E[Symbol.toPrimitive];
    if (I !== void 0) {
      var B = I.call(E, M || "default");
      if (typeof B != "object")
        return B;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (M === "string" ? String : Number)(E);
  }
  var c = Le, h = c.Buffer, s = gn(), b = s.inspect, p = b && b.custom || "inspect";
  function m(E, M, I) {
    h.prototype.copy.call(E, M, I);
  }
  return Xf = /* @__PURE__ */ function() {
    function E() {
      i(this, E), this.head = null, this.tail = null, this.length = 0;
    }
    return n(E, [{
      key: "push",
      value: function(I) {
        var B = {
          data: I,
          next: null
        };
        this.length > 0 ? this.tail.next = B : this.head = B, this.tail = B, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(I) {
        var B = {
          data: I,
          next: this.head
        };
        this.length === 0 && (this.tail = B), this.head = B, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var I = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, I;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(I) {
        if (this.length === 0)
          return "";
        for (var B = this.head, T = "" + B.data; B = B.next; )
          T += I + B.data;
        return T;
      }
    }, {
      key: "concat",
      value: function(I) {
        if (this.length === 0)
          return h.alloc(0);
        for (var B = h.allocUnsafe(I >>> 0), T = this.head, j = 0; T; )
          m(T.data, B, j), j += T.data.length, T = T.next;
        return B;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(I, B) {
        var T;
        return I < this.head.data.length ? (T = this.head.data.slice(0, I), this.head.data = this.head.data.slice(I)) : I === this.head.data.length ? T = this.shift() : T = B ? this._getString(I) : this._getBuffer(I), T;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(I) {
        var B = this.head, T = 1, j = B.data;
        for (I -= j.length; B = B.next; ) {
          var N = B.data, k = I > N.length ? N.length : I;
          if (k === N.length ? j += N : j += N.slice(0, I), I -= k, I === 0) {
            k === N.length ? (++T, B.next ? this.head = B.next : this.head = this.tail = null) : (this.head = B, B.data = N.slice(k));
            break;
          }
          ++T;
        }
        return this.length -= T, j;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(I) {
        var B = h.allocUnsafe(I), T = this.head, j = 1;
        for (T.data.copy(B), I -= T.data.length; T = T.next; ) {
          var N = T.data, k = I > N.length ? N.length : I;
          if (N.copy(B, B.length - I, 0, k), I -= k, I === 0) {
            k === N.length ? (++j, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = N.slice(k));
            break;
          }
          ++j;
        }
        return this.length -= j, B;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: p,
      value: function(I, B) {
        return b(this, t(t({}, B), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), E;
  }(), Xf;
}
var Yf, Ql;
function my() {
  if (Ql)
    return Yf;
  Ql = 1;
  function e(f, u) {
    var c = this, h = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return h || s ? (u ? u(f) : f && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, at.nextTick(o, this, f)) : at.nextTick(o, this, f)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(f || null, function(b) {
      !u && b ? c._writableState ? c._writableState.errorEmitted ? at.nextTick(r, c) : (c._writableState.errorEmitted = !0, at.nextTick(t, c, b)) : at.nextTick(t, c, b) : u ? (at.nextTick(r, c), u(b)) : at.nextTick(r, c);
    }), this);
  }
  function t(f, u) {
    o(f, u), r(f);
  }
  function r(f) {
    f._writableState && !f._writableState.emitClose || f._readableState && !f._readableState.emitClose || f.emit("close");
  }
  function i() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function o(f, u) {
    f.emit("error", u);
  }
  function n(f, u) {
    var c = f._readableState, h = f._writableState;
    c && c.autoDestroy || h && h.autoDestroy ? f.destroy(u) : f.emit("error", u);
  }
  return Yf = {
    destroy: e,
    undestroy: i,
    errorOrDestroy: n
  }, Yf;
}
var Qf = {}, ed;
function Di() {
  if (ed)
    return Qf;
  ed = 1;
  function e(u, c) {
    u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.__proto__ = c;
  }
  var t = {};
  function r(u, c, h) {
    h || (h = Error);
    function s(p, m, E) {
      return typeof c == "string" ? c : c(p, m, E);
    }
    var b = /* @__PURE__ */ function(p) {
      e(m, p);
      function m(E, M, I) {
        return p.call(this, s(E, M, I)) || this;
      }
      return m;
    }(h);
    b.prototype.name = h.name, b.prototype.code = u, t[u] = b;
  }
  function i(u, c) {
    if (Array.isArray(u)) {
      var h = u.length;
      return u = u.map(function(s) {
        return String(s);
      }), h > 2 ? "one of ".concat(c, " ").concat(u.slice(0, h - 1).join(", "), ", or ") + u[h - 1] : h === 2 ? "one of ".concat(c, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(c, " ").concat(u[0]);
    } else
      return "of ".concat(c, " ").concat(String(u));
  }
  function o(u, c, h) {
    return u.substr(!h || h < 0 ? 0 : +h, c.length) === c;
  }
  function n(u, c, h) {
    return (h === void 0 || h > u.length) && (h = u.length), u.substring(h - c.length, h) === c;
  }
  function f(u, c, h) {
    return typeof h != "number" && (h = 0), h + c.length > u.length ? !1 : u.indexOf(c, h) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(u, c) {
    return 'The value "' + c + '" is invalid for option "' + u + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(u, c, h) {
    var s;
    typeof c == "string" && o(c, "not ") ? (s = "must not be", c = c.replace(/^not /, "")) : s = "must be";
    var b;
    if (n(u, " argument"))
      b = "The ".concat(u, " ").concat(s, " ").concat(i(c, "type"));
    else {
      var p = f(u, ".") ? "property" : "argument";
      b = 'The "'.concat(u, '" ').concat(p, " ").concat(s, " ").concat(i(c, "type"));
    }
    return b += ". Received type ".concat(typeof h), b;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
    return "The " + u + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(u) {
    return "Cannot call " + u + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(u) {
    return "Unknown encoding: " + u;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Qf.codes = t, Qf;
}
var es, td;
function wy() {
  if (td)
    return es;
  td = 1;
  var e = Di().codes.ERR_INVALID_OPT_VALUE;
  function t(i, o, n) {
    return i.highWaterMark != null ? i.highWaterMark : o ? i[n] : null;
  }
  function r(i, o, n, f) {
    var u = t(o, f, n);
    if (u != null) {
      if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
        var c = f ? n : "highWaterMark";
        throw new e(c, u);
      }
      return Math.floor(u);
    }
    return i.objectMode ? 16 : 16 * 1024;
  }
  return es = {
    getHighWaterMark: r
  }, es;
}
var ts, rd;
function Z5() {
  if (rd)
    return ts;
  rd = 1, ts = e;
  function e(r, i) {
    if (t("noDeprecation"))
      return r;
    var o = !1;
    function n() {
      if (!o) {
        if (t("throwDeprecation"))
          throw new Error(i);
        t("traceDeprecation") ? console.trace(i) : console.warn(i), o = !0;
      }
      return r.apply(this, arguments);
    }
    return n;
  }
  function t(r) {
    try {
      if (!Ze.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var i = Ze.localStorage[r];
    return i == null ? !1 : String(i).toLowerCase() === "true";
  }
  return ts;
}
var rs, nd;
function Jh() {
  if (nd)
    return rs;
  nd = 1, rs = re;
  function e(H) {
    var V = this;
    this.next = null, this.entry = null, this.finish = function() {
      oe(V, H);
    };
  }
  var t;
  re.WritableState = q;
  var r = {
    deprecate: Z5()
  }, i = yy(), o = Le.Buffer, n = (typeof Ze < "u" ? Ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(H) {
    return o.from(H);
  }
  function u(H) {
    return o.isBuffer(H) || H instanceof n;
  }
  var c = my(), h = wy(), s = h.getHighWaterMark, b = Di().codes, p = b.ERR_INVALID_ARG_TYPE, m = b.ERR_METHOD_NOT_IMPLEMENTED, E = b.ERR_MULTIPLE_CALLBACK, M = b.ERR_STREAM_CANNOT_PIPE, I = b.ERR_STREAM_DESTROYED, B = b.ERR_STREAM_NULL_VALUES, T = b.ERR_STREAM_WRITE_AFTER_END, j = b.ERR_UNKNOWN_ENCODING, N = c.errorOrDestroy;
  _t()(re, i);
  function k() {
  }
  function q(H, V, F) {
    t = t || Qn(), H = H || {}, typeof F != "boolean" && (F = V instanceof t), this.objectMode = !!H.objectMode, F && (this.objectMode = this.objectMode || !!H.writableObjectMode), this.highWaterMark = s(this, H, "writableHighWaterMark", F), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var te = H.decodeStrings === !1;
    this.decodeStrings = !te, this.defaultEncoding = H.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(he) {
      w(V, he);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = H.emitClose !== !1, this.autoDestroy = !!H.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  q.prototype.getBuffer = function() {
    for (var V = this.bufferedRequest, F = []; V; )
      F.push(V), V = V.next;
    return F;
  }, function() {
    try {
      Object.defineProperty(q.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var $;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? ($ = Function.prototype[Symbol.hasInstance], Object.defineProperty(re, Symbol.hasInstance, {
    value: function(V) {
      return $.call(this, V) ? !0 : this !== re ? !1 : V && V._writableState instanceof q;
    }
  })) : $ = function(V) {
    return V instanceof this;
  };
  function re(H) {
    t = t || Qn();
    var V = this instanceof t;
    if (!V && !$.call(re, this))
      return new re(H);
    this._writableState = new q(H, this, V), this.writable = !0, H && (typeof H.write == "function" && (this._write = H.write), typeof H.writev == "function" && (this._writev = H.writev), typeof H.destroy == "function" && (this._destroy = H.destroy), typeof H.final == "function" && (this._final = H.final)), i.call(this);
  }
  re.prototype.pipe = function() {
    N(this, new M());
  };
  function Q(H, V) {
    var F = new T();
    N(H, F), at.nextTick(V, F);
  }
  function fe(H, V, F, te) {
    var he;
    return F === null ? he = new B() : typeof F != "string" && !V.objectMode && (he = new p("chunk", ["string", "Buffer"], F)), he ? (N(H, he), at.nextTick(te, he), !1) : !0;
  }
  re.prototype.write = function(H, V, F) {
    var te = this._writableState, he = !1, K = !te.objectMode && u(H);
    return K && !o.isBuffer(H) && (H = f(H)), typeof V == "function" && (F = V, V = null), K ? V = "buffer" : V || (V = te.defaultEncoding), typeof F != "function" && (F = k), te.ending ? Q(this, F) : (K || fe(this, te, H, F)) && (te.pendingcb++, he = y(this, te, K, H, V, F)), he;
  }, re.prototype.cork = function() {
    this._writableState.corked++;
  }, re.prototype.uncork = function() {
    var H = this._writableState;
    H.corked && (H.corked--, !H.writing && !H.corked && !H.bufferProcessing && H.bufferedRequest && S(this, H));
  }, re.prototype.setDefaultEncoding = function(V) {
    if (typeof V == "string" && (V = V.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((V + "").toLowerCase()) > -1))
      throw new j(V);
    return this._writableState.defaultEncoding = V, this;
  }, Object.defineProperty(re.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function U(H, V, F) {
    return !H.objectMode && H.decodeStrings !== !1 && typeof V == "string" && (V = o.from(V, F)), V;
  }
  Object.defineProperty(re.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function y(H, V, F, te, he, K) {
    if (!F) {
      var W = U(V, te, he);
      te !== W && (F = !0, he = "buffer", te = W);
    }
    var ce = V.objectMode ? 1 : te.length;
    V.length += ce;
    var ve = V.length < V.highWaterMark;
    if (ve || (V.needDrain = !0), V.writing || V.corked) {
      var Be = V.lastBufferedRequest;
      V.lastBufferedRequest = {
        chunk: te,
        encoding: he,
        isBuf: F,
        callback: K,
        next: null
      }, Be ? Be.next = V.lastBufferedRequest : V.bufferedRequest = V.lastBufferedRequest, V.bufferedRequestCount += 1;
    } else
      v(H, V, !1, ce, te, he, K);
    return ve;
  }
  function v(H, V, F, te, he, K, W) {
    V.writelen = te, V.writecb = W, V.writing = !0, V.sync = !0, V.destroyed ? V.onwrite(new I("write")) : F ? H._writev(he, V.onwrite) : H._write(he, K, V.onwrite), V.sync = !1;
  }
  function a(H, V, F, te, he) {
    --V.pendingcb, F ? (at.nextTick(he, te), at.nextTick(R, H, V), H._writableState.errorEmitted = !0, N(H, te)) : (he(te), H._writableState.errorEmitted = !0, N(H, te), R(H, V));
  }
  function d(H) {
    H.writing = !1, H.writecb = null, H.length -= H.writelen, H.writelen = 0;
  }
  function w(H, V) {
    var F = H._writableState, te = F.sync, he = F.writecb;
    if (typeof he != "function")
      throw new E();
    if (d(F), V)
      a(H, F, te, V, he);
    else {
      var K = g(F) || H.destroyed;
      !K && !F.corked && !F.bufferProcessing && F.bufferedRequest && S(H, F), te ? at.nextTick(x, H, F, K, he) : x(H, F, K, he);
    }
  }
  function x(H, V, F, te) {
    F || A(H, V), V.pendingcb--, te(), R(H, V);
  }
  function A(H, V) {
    V.length === 0 && V.needDrain && (V.needDrain = !1, H.emit("drain"));
  }
  function S(H, V) {
    V.bufferProcessing = !0;
    var F = V.bufferedRequest;
    if (H._writev && F && F.next) {
      var te = V.bufferedRequestCount, he = new Array(te), K = V.corkedRequestsFree;
      K.entry = F;
      for (var W = 0, ce = !0; F; )
        he[W] = F, F.isBuf || (ce = !1), F = F.next, W += 1;
      he.allBuffers = ce, v(H, V, !0, V.length, he, "", K.finish), V.pendingcb++, V.lastBufferedRequest = null, K.next ? (V.corkedRequestsFree = K.next, K.next = null) : V.corkedRequestsFree = new e(V), V.bufferedRequestCount = 0;
    } else {
      for (; F; ) {
        var ve = F.chunk, Be = F.encoding, ee = F.callback, C = V.objectMode ? 1 : ve.length;
        if (v(H, V, !1, C, ve, Be, ee), F = F.next, V.bufferedRequestCount--, V.writing)
          break;
      }
      F === null && (V.lastBufferedRequest = null);
    }
    V.bufferedRequest = F, V.bufferProcessing = !1;
  }
  re.prototype._write = function(H, V, F) {
    F(new m("_write()"));
  }, re.prototype._writev = null, re.prototype.end = function(H, V, F) {
    var te = this._writableState;
    return typeof H == "function" ? (F = H, H = null, V = null) : typeof V == "function" && (F = V, V = null), H != null && this.write(H, V), te.corked && (te.corked = 1, this.uncork()), te.ending || Y(this, te, F), this;
  }, Object.defineProperty(re.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function g(H) {
    return H.ending && H.length === 0 && H.bufferedRequest === null && !H.finished && !H.writing;
  }
  function _(H, V) {
    H._final(function(F) {
      V.pendingcb--, F && N(H, F), V.prefinished = !0, H.emit("prefinish"), R(H, V);
    });
  }
  function l(H, V) {
    !V.prefinished && !V.finalCalled && (typeof H._final == "function" && !V.destroyed ? (V.pendingcb++, V.finalCalled = !0, at.nextTick(_, H, V)) : (V.prefinished = !0, H.emit("prefinish")));
  }
  function R(H, V) {
    var F = g(V);
    if (F && (l(H, V), V.pendingcb === 0 && (V.finished = !0, H.emit("finish"), V.autoDestroy))) {
      var te = H._readableState;
      (!te || te.autoDestroy && te.endEmitted) && H.destroy();
    }
    return F;
  }
  function Y(H, V, F) {
    V.ending = !0, R(H, V), F && (V.finished ? at.nextTick(F) : H.once("finish", F)), V.ended = !0, H.writable = !1;
  }
  function oe(H, V, F) {
    var te = H.entry;
    for (H.entry = null; te; ) {
      var he = te.callback;
      V.pendingcb--, he(F), te = te.next;
    }
    V.corkedRequestsFree.next = H;
  }
  return Object.defineProperty(re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(V) {
      this._writableState && (this._writableState.destroyed = V);
    }
  }), re.prototype.destroy = c.destroy, re.prototype._undestroy = c.undestroy, re.prototype._destroy = function(H, V) {
    V(H);
  }, rs;
}
var ns, id;
function Qn() {
  if (id)
    return ns;
  id = 1;
  var e = Object.keys || function(h) {
    var s = [];
    for (var b in h)
      s.push(b);
    return s;
  };
  ns = f;
  var t = Xh(), r = Jh();
  _t()(f, t);
  for (var i = e(r.prototype), o = 0; o < i.length; o++) {
    var n = i[o];
    f.prototype[n] || (f.prototype[n] = r.prototype[n]);
  }
  function f(h) {
    if (!(this instanceof f))
      return new f(h);
    t.call(this, h), r.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(f.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(f.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || at.nextTick(c, this);
  }
  function c(h) {
    h.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(s) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = s, this._writableState.destroyed = s);
    }
  }), ns;
}
var is = {}, qa = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var ad;
function Rt() {
  return ad || (ad = 1, function(e, t) {
    var r = Le, i = r.Buffer;
    function o(f, u) {
      for (var c in f)
        u[c] = f[c];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = n);
    function n(f, u, c) {
      return i(f, u, c);
    }
    n.prototype = Object.create(i.prototype), o(i, n), n.from = function(f, u, c) {
      if (typeof f == "number")
        throw new TypeError("Argument must not be a number");
      return i(f, u, c);
    }, n.alloc = function(f, u, c) {
      if (typeof f != "number")
        throw new TypeError("Argument must be a number");
      var h = i(f);
      return u !== void 0 ? typeof c == "string" ? h.fill(u, c) : h.fill(u) : h.fill(0), h;
    }, n.allocUnsafe = function(f) {
      if (typeof f != "number")
        throw new TypeError("Argument must be a number");
      return i(f);
    }, n.allocUnsafeSlow = function(f) {
      if (typeof f != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(f);
    };
  }(qa, qa.exports)), qa.exports;
}
var od;
function th() {
  if (od)
    return is;
  od = 1;
  var e = Rt().Buffer, t = e.isEncoding || function(B) {
    switch (B = "" + B, B && B.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(B) {
    if (!B)
      return "utf8";
    for (var T; ; )
      switch (B) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return B;
        default:
          if (T)
            return;
          B = ("" + B).toLowerCase(), T = !0;
      }
  }
  function i(B) {
    var T = r(B);
    if (typeof T != "string" && (e.isEncoding === t || !t(B)))
      throw new Error("Unknown encoding: " + B);
    return T || B;
  }
  is.StringDecoder = o;
  function o(B) {
    this.encoding = i(B);
    var T;
    switch (this.encoding) {
      case "utf16le":
        this.text = b, this.end = p, T = 4;
        break;
      case "utf8":
        this.fillLast = c, T = 4;
        break;
      case "base64":
        this.text = m, this.end = E, T = 3;
        break;
      default:
        this.write = M, this.end = I;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(T);
  }
  o.prototype.write = function(B) {
    if (B.length === 0)
      return "";
    var T, j;
    if (this.lastNeed) {
      if (T = this.fillLast(B), T === void 0)
        return "";
      j = this.lastNeed, this.lastNeed = 0;
    } else
      j = 0;
    return j < B.length ? T ? T + this.text(B, j) : this.text(B, j) : T || "";
  }, o.prototype.end = s, o.prototype.text = h, o.prototype.fillLast = function(B) {
    if (this.lastNeed <= B.length)
      return B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, B.length), this.lastNeed -= B.length;
  };
  function n(B) {
    return B <= 127 ? 0 : B >> 5 === 6 ? 2 : B >> 4 === 14 ? 3 : B >> 3 === 30 ? 4 : B >> 6 === 2 ? -1 : -2;
  }
  function f(B, T, j) {
    var N = T.length - 1;
    if (N < j)
      return 0;
    var k = n(T[N]);
    return k >= 0 ? (k > 0 && (B.lastNeed = k - 1), k) : --N < j || k === -2 ? 0 : (k = n(T[N]), k >= 0 ? (k > 0 && (B.lastNeed = k - 2), k) : --N < j || k === -2 ? 0 : (k = n(T[N]), k >= 0 ? (k > 0 && (k === 2 ? k = 0 : B.lastNeed = k - 3), k) : 0));
  }
  function u(B, T, j) {
    if ((T[0] & 192) !== 128)
      return B.lastNeed = 0, "�";
    if (B.lastNeed > 1 && T.length > 1) {
      if ((T[1] & 192) !== 128)
        return B.lastNeed = 1, "�";
      if (B.lastNeed > 2 && T.length > 2 && (T[2] & 192) !== 128)
        return B.lastNeed = 2, "�";
    }
  }
  function c(B) {
    var T = this.lastTotal - this.lastNeed, j = u(this, B);
    if (j !== void 0)
      return j;
    if (this.lastNeed <= B.length)
      return B.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    B.copy(this.lastChar, T, 0, B.length), this.lastNeed -= B.length;
  }
  function h(B, T) {
    var j = f(this, B, T);
    if (!this.lastNeed)
      return B.toString("utf8", T);
    this.lastTotal = j;
    var N = B.length - (j - this.lastNeed);
    return B.copy(this.lastChar, 0, N), B.toString("utf8", T, N);
  }
  function s(B) {
    var T = B && B.length ? this.write(B) : "";
    return this.lastNeed ? T + "�" : T;
  }
  function b(B, T) {
    if ((B.length - T) % 2 === 0) {
      var j = B.toString("utf16le", T);
      if (j) {
        var N = j.charCodeAt(j.length - 1);
        if (N >= 55296 && N <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1], j.slice(0, -1);
      }
      return j;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = B[B.length - 1], B.toString("utf16le", T, B.length - 1);
  }
  function p(B) {
    var T = B && B.length ? this.write(B) : "";
    if (this.lastNeed) {
      var j = this.lastTotal - this.lastNeed;
      return T + this.lastChar.toString("utf16le", 0, j);
    }
    return T;
  }
  function m(B, T) {
    var j = (B.length - T) % 3;
    return j === 0 ? B.toString("base64", T) : (this.lastNeed = 3 - j, this.lastTotal = 3, j === 1 ? this.lastChar[0] = B[B.length - 1] : (this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1]), B.toString("base64", T, B.length - j));
  }
  function E(B) {
    var T = B && B.length ? this.write(B) : "";
    return this.lastNeed ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : T;
  }
  function M(B) {
    return B.toString(this.encoding);
  }
  function I(B) {
    return B && B.length ? this.write(B) : "";
  }
  return is;
}
var as, fd;
function ef() {
  if (fd)
    return as;
  fd = 1;
  var e = Di().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(n) {
    var f = !1;
    return function() {
      if (!f) {
        f = !0;
        for (var u = arguments.length, c = new Array(u), h = 0; h < u; h++)
          c[h] = arguments[h];
        n.apply(this, c);
      }
    };
  }
  function r() {
  }
  function i(n) {
    return n.setHeader && typeof n.abort == "function";
  }
  function o(n, f, u) {
    if (typeof f == "function")
      return o(n, null, f);
    f || (f = {}), u = t(u || r);
    var c = f.readable || f.readable !== !1 && n.readable, h = f.writable || f.writable !== !1 && n.writable, s = function() {
      n.writable || p();
    }, b = n._writableState && n._writableState.finished, p = function() {
      h = !1, b = !0, c || u.call(n);
    }, m = n._readableState && n._readableState.endEmitted, E = function() {
      c = !1, m = !0, h || u.call(n);
    }, M = function(j) {
      u.call(n, j);
    }, I = function() {
      var j;
      if (c && !m)
        return (!n._readableState || !n._readableState.ended) && (j = new e()), u.call(n, j);
      if (h && !b)
        return (!n._writableState || !n._writableState.ended) && (j = new e()), u.call(n, j);
    }, B = function() {
      n.req.on("finish", p);
    };
    return i(n) ? (n.on("complete", p), n.on("abort", I), n.req ? B() : n.on("request", B)) : h && !n._writableState && (n.on("end", s), n.on("close", s)), n.on("end", E), n.on("finish", p), f.error !== !1 && n.on("error", M), n.on("close", I), function() {
      n.removeListener("complete", p), n.removeListener("abort", I), n.removeListener("request", B), n.req && n.req.removeListener("finish", p), n.removeListener("end", s), n.removeListener("close", s), n.removeListener("finish", p), n.removeListener("end", E), n.removeListener("error", M), n.removeListener("close", I);
    };
  }
  return as = o, as;
}
var os, sd;
function G5() {
  if (sd)
    return os;
  sd = 1;
  var e;
  function t(j, N, k) {
    return N = r(N), N in j ? Object.defineProperty(j, N, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : j[N] = k, j;
  }
  function r(j) {
    var N = i(j, "string");
    return typeof N == "symbol" ? N : String(N);
  }
  function i(j, N) {
    if (typeof j != "object" || j === null)
      return j;
    var k = j[Symbol.toPrimitive];
    if (k !== void 0) {
      var q = k.call(j, N || "default");
      if (typeof q != "object")
        return q;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (N === "string" ? String : Number)(j);
  }
  var o = ef(), n = Symbol("lastResolve"), f = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), h = Symbol("lastPromise"), s = Symbol("handlePromise"), b = Symbol("stream");
  function p(j, N) {
    return {
      value: j,
      done: N
    };
  }
  function m(j) {
    var N = j[n];
    if (N !== null) {
      var k = j[b].read();
      k !== null && (j[h] = null, j[n] = null, j[f] = null, N(p(k, !1)));
    }
  }
  function E(j) {
    at.nextTick(m, j);
  }
  function M(j, N) {
    return function(k, q) {
      j.then(function() {
        if (N[c]) {
          k(p(void 0, !0));
          return;
        }
        N[s](k, q);
      }, q);
    };
  }
  var I = Object.getPrototypeOf(function() {
  }), B = Object.setPrototypeOf((e = {
    get stream() {
      return this[b];
    },
    next: function() {
      var N = this, k = this[u];
      if (k !== null)
        return Promise.reject(k);
      if (this[c])
        return Promise.resolve(p(void 0, !0));
      if (this[b].destroyed)
        return new Promise(function(Q, fe) {
          at.nextTick(function() {
            N[u] ? fe(N[u]) : Q(p(void 0, !0));
          });
        });
      var q = this[h], $;
      if (q)
        $ = new Promise(M(q, this));
      else {
        var re = this[b].read();
        if (re !== null)
          return Promise.resolve(p(re, !1));
        $ = new Promise(this[s]);
      }
      return this[h] = $, $;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var N = this;
    return new Promise(function(k, q) {
      N[b].destroy(null, function($) {
        if ($) {
          q($);
          return;
        }
        k(p(void 0, !0));
      });
    });
  }), e), I), T = function(N) {
    var k, q = Object.create(B, (k = {}, t(k, b, {
      value: N,
      writable: !0
    }), t(k, n, {
      value: null,
      writable: !0
    }), t(k, f, {
      value: null,
      writable: !0
    }), t(k, u, {
      value: null,
      writable: !0
    }), t(k, c, {
      value: N._readableState.endEmitted,
      writable: !0
    }), t(k, s, {
      value: function(re, Q) {
        var fe = q[b].read();
        fe ? (q[h] = null, q[n] = null, q[f] = null, re(p(fe, !1))) : (q[n] = re, q[f] = Q);
      },
      writable: !0
    }), k));
    return q[h] = null, o(N, function($) {
      if ($ && $.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var re = q[f];
        re !== null && (q[h] = null, q[n] = null, q[f] = null, re($)), q[u] = $;
        return;
      }
      var Q = q[n];
      Q !== null && (q[h] = null, q[n] = null, q[f] = null, Q(p(void 0, !0))), q[c] = !0;
    }), N.on("readable", E.bind(null, q)), q;
  };
  return os = T, os;
}
var fs, ud;
function J5() {
  return ud || (ud = 1, fs = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fs;
}
var ss, cd;
function Xh() {
  if (cd)
    return ss;
  cd = 1, ss = Q;
  var e;
  Q.ReadableState = re, Ci.EventEmitter;
  var t = function(W, ce) {
    return W.listeners(ce).length;
  }, r = yy(), i = Le.Buffer, o = (typeof Ze < "u" ? Ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function n(K) {
    return i.from(K);
  }
  function f(K) {
    return i.isBuffer(K) || K instanceof o;
  }
  var u = gn(), c;
  u && u.debuglog ? c = u.debuglog("stream") : c = function() {
  };
  var h = K5(), s = my(), b = wy(), p = b.getHighWaterMark, m = Di().codes, E = m.ERR_INVALID_ARG_TYPE, M = m.ERR_STREAM_PUSH_AFTER_EOF, I = m.ERR_METHOD_NOT_IMPLEMENTED, B = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, T, j, N;
  _t()(Q, r);
  var k = s.errorOrDestroy, q = ["error", "close", "destroy", "pause", "resume"];
  function $(K, W, ce) {
    if (typeof K.prependListener == "function")
      return K.prependListener(W, ce);
    !K._events || !K._events[W] ? K.on(W, ce) : Array.isArray(K._events[W]) ? K._events[W].unshift(ce) : K._events[W] = [ce, K._events[W]];
  }
  function re(K, W, ce) {
    e = e || Qn(), K = K || {}, typeof ce != "boolean" && (ce = W instanceof e), this.objectMode = !!K.objectMode, ce && (this.objectMode = this.objectMode || !!K.readableObjectMode), this.highWaterMark = p(this, K, "readableHighWaterMark", ce), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = K.emitClose !== !1, this.autoDestroy = !!K.autoDestroy, this.destroyed = !1, this.defaultEncoding = K.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, K.encoding && (T || (T = th().StringDecoder), this.decoder = new T(K.encoding), this.encoding = K.encoding);
  }
  function Q(K) {
    if (e = e || Qn(), !(this instanceof Q))
      return new Q(K);
    var W = this instanceof e;
    this._readableState = new re(K, this, W), this.readable = !0, K && (typeof K.read == "function" && (this._read = K.read), typeof K.destroy == "function" && (this._destroy = K.destroy)), r.call(this);
  }
  Object.defineProperty(Q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(W) {
      this._readableState && (this._readableState.destroyed = W);
    }
  }), Q.prototype.destroy = s.destroy, Q.prototype._undestroy = s.undestroy, Q.prototype._destroy = function(K, W) {
    W(K);
  }, Q.prototype.push = function(K, W) {
    var ce = this._readableState, ve;
    return ce.objectMode ? ve = !0 : typeof K == "string" && (W = W || ce.defaultEncoding, W !== ce.encoding && (K = i.from(K, W), W = ""), ve = !0), fe(this, K, W, !1, ve);
  }, Q.prototype.unshift = function(K) {
    return fe(this, K, null, !0, !1);
  };
  function fe(K, W, ce, ve, Be) {
    c("readableAddChunk", W);
    var ee = K._readableState;
    if (W === null)
      ee.reading = !1, w(K, ee);
    else {
      var C;
      if (Be || (C = y(ee, W)), C)
        k(K, C);
      else if (ee.objectMode || W && W.length > 0)
        if (typeof W != "string" && !ee.objectMode && Object.getPrototypeOf(W) !== i.prototype && (W = n(W)), ve)
          ee.endEmitted ? k(K, new B()) : U(K, ee, W, !0);
        else if (ee.ended)
          k(K, new M());
        else {
          if (ee.destroyed)
            return !1;
          ee.reading = !1, ee.decoder && !ce ? (W = ee.decoder.write(W), ee.objectMode || W.length !== 0 ? U(K, ee, W, !1) : S(K, ee)) : U(K, ee, W, !1);
        }
      else
        ve || (ee.reading = !1, S(K, ee));
    }
    return !ee.ended && (ee.length < ee.highWaterMark || ee.length === 0);
  }
  function U(K, W, ce, ve) {
    W.flowing && W.length === 0 && !W.sync ? (W.awaitDrain = 0, K.emit("data", ce)) : (W.length += W.objectMode ? 1 : ce.length, ve ? W.buffer.unshift(ce) : W.buffer.push(ce), W.needReadable && x(K)), S(K, W);
  }
  function y(K, W) {
    var ce;
    return !f(W) && typeof W != "string" && W !== void 0 && !K.objectMode && (ce = new E("chunk", ["string", "Buffer", "Uint8Array"], W)), ce;
  }
  Q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Q.prototype.setEncoding = function(K) {
    T || (T = th().StringDecoder);
    var W = new T(K);
    this._readableState.decoder = W, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ce = this._readableState.buffer.head, ve = ""; ce !== null; )
      ve += W.write(ce.data), ce = ce.next;
    return this._readableState.buffer.clear(), ve !== "" && this._readableState.buffer.push(ve), this._readableState.length = ve.length, this;
  };
  var v = 1073741824;
  function a(K) {
    return K >= v ? K = v : (K--, K |= K >>> 1, K |= K >>> 2, K |= K >>> 4, K |= K >>> 8, K |= K >>> 16, K++), K;
  }
  function d(K, W) {
    return K <= 0 || W.length === 0 && W.ended ? 0 : W.objectMode ? 1 : K !== K ? W.flowing && W.length ? W.buffer.head.data.length : W.length : (K > W.highWaterMark && (W.highWaterMark = a(K)), K <= W.length ? K : W.ended ? W.length : (W.needReadable = !0, 0));
  }
  Q.prototype.read = function(K) {
    c("read", K), K = parseInt(K, 10);
    var W = this._readableState, ce = K;
    if (K !== 0 && (W.emittedReadable = !1), K === 0 && W.needReadable && ((W.highWaterMark !== 0 ? W.length >= W.highWaterMark : W.length > 0) || W.ended))
      return c("read: emitReadable", W.length, W.ended), W.length === 0 && W.ended ? F(this) : x(this), null;
    if (K = d(K, W), K === 0 && W.ended)
      return W.length === 0 && F(this), null;
    var ve = W.needReadable;
    c("need readable", ve), (W.length === 0 || W.length - K < W.highWaterMark) && (ve = !0, c("length less than watermark", ve)), W.ended || W.reading ? (ve = !1, c("reading or ended", ve)) : ve && (c("do read"), W.reading = !0, W.sync = !0, W.length === 0 && (W.needReadable = !0), this._read(W.highWaterMark), W.sync = !1, W.reading || (K = d(ce, W)));
    var Be;
    return K > 0 ? Be = V(K, W) : Be = null, Be === null ? (W.needReadable = W.length <= W.highWaterMark, K = 0) : (W.length -= K, W.awaitDrain = 0), W.length === 0 && (W.ended || (W.needReadable = !0), ce !== K && W.ended && F(this)), Be !== null && this.emit("data", Be), Be;
  };
  function w(K, W) {
    if (c("onEofChunk"), !W.ended) {
      if (W.decoder) {
        var ce = W.decoder.end();
        ce && ce.length && (W.buffer.push(ce), W.length += W.objectMode ? 1 : ce.length);
      }
      W.ended = !0, W.sync ? x(K) : (W.needReadable = !1, W.emittedReadable || (W.emittedReadable = !0, A(K)));
    }
  }
  function x(K) {
    var W = K._readableState;
    c("emitReadable", W.needReadable, W.emittedReadable), W.needReadable = !1, W.emittedReadable || (c("emitReadable", W.flowing), W.emittedReadable = !0, at.nextTick(A, K));
  }
  function A(K) {
    var W = K._readableState;
    c("emitReadable_", W.destroyed, W.length, W.ended), !W.destroyed && (W.length || W.ended) && (K.emit("readable"), W.emittedReadable = !1), W.needReadable = !W.flowing && !W.ended && W.length <= W.highWaterMark, H(K);
  }
  function S(K, W) {
    W.readingMore || (W.readingMore = !0, at.nextTick(g, K, W));
  }
  function g(K, W) {
    for (; !W.reading && !W.ended && (W.length < W.highWaterMark || W.flowing && W.length === 0); ) {
      var ce = W.length;
      if (c("maybeReadMore read 0"), K.read(0), ce === W.length)
        break;
    }
    W.readingMore = !1;
  }
  Q.prototype._read = function(K) {
    k(this, new I("_read()"));
  }, Q.prototype.pipe = function(K, W) {
    var ce = this, ve = this._readableState;
    switch (ve.pipesCount) {
      case 0:
        ve.pipes = K;
        break;
      case 1:
        ve.pipes = [ve.pipes, K];
        break;
      default:
        ve.pipes.push(K);
        break;
    }
    ve.pipesCount += 1, c("pipe count=%d opts=%j", ve.pipesCount, W);
    var Be = (!W || W.end !== !1) && K !== at.stdout && K !== at.stderr, ee = Be ? L : se;
    ve.endEmitted ? at.nextTick(ee) : ce.once("end", ee), K.on("unpipe", C);
    function C(_e, Ce) {
      c("onunpipe"), _e === ce && Ce && Ce.hasUnpiped === !1 && (Ce.hasUnpiped = !0, me());
    }
    function L() {
      c("onend"), K.end();
    }
    var Z = _(ce);
    K.on("drain", Z);
    var de = !1;
    function me() {
      c("cleanup"), K.removeListener("close", z), K.removeListener("finish", ue), K.removeListener("drain", Z), K.removeListener("error", ze), K.removeListener("unpipe", C), ce.removeListener("end", L), ce.removeListener("end", se), ce.removeListener("data", Te), de = !0, ve.awaitDrain && (!K._writableState || K._writableState.needDrain) && Z();
    }
    ce.on("data", Te);
    function Te(_e) {
      c("ondata");
      var Ce = K.write(_e);
      c("dest.write", Ce), Ce === !1 && ((ve.pipesCount === 1 && ve.pipes === K || ve.pipesCount > 1 && he(ve.pipes, K) !== -1) && !de && (c("false write response, pause", ve.awaitDrain), ve.awaitDrain++), ce.pause());
    }
    function ze(_e) {
      c("onerror", _e), se(), K.removeListener("error", ze), t(K, "error") === 0 && k(K, _e);
    }
    $(K, "error", ze);
    function z() {
      K.removeListener("finish", ue), se();
    }
    K.once("close", z);
    function ue() {
      c("onfinish"), K.removeListener("close", z), se();
    }
    K.once("finish", ue);
    function se() {
      c("unpipe"), ce.unpipe(K);
    }
    return K.emit("pipe", ce), ve.flowing || (c("pipe resume"), ce.resume()), K;
  };
  function _(K) {
    return function() {
      var ce = K._readableState;
      c("pipeOnDrain", ce.awaitDrain), ce.awaitDrain && ce.awaitDrain--, ce.awaitDrain === 0 && t(K, "data") && (ce.flowing = !0, H(K));
    };
  }
  Q.prototype.unpipe = function(K) {
    var W = this._readableState, ce = {
      hasUnpiped: !1
    };
    if (W.pipesCount === 0)
      return this;
    if (W.pipesCount === 1)
      return K && K !== W.pipes ? this : (K || (K = W.pipes), W.pipes = null, W.pipesCount = 0, W.flowing = !1, K && K.emit("unpipe", this, ce), this);
    if (!K) {
      var ve = W.pipes, Be = W.pipesCount;
      W.pipes = null, W.pipesCount = 0, W.flowing = !1;
      for (var ee = 0; ee < Be; ee++)
        ve[ee].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var C = he(W.pipes, K);
    return C === -1 ? this : (W.pipes.splice(C, 1), W.pipesCount -= 1, W.pipesCount === 1 && (W.pipes = W.pipes[0]), K.emit("unpipe", this, ce), this);
  }, Q.prototype.on = function(K, W) {
    var ce = r.prototype.on.call(this, K, W), ve = this._readableState;
    return K === "data" ? (ve.readableListening = this.listenerCount("readable") > 0, ve.flowing !== !1 && this.resume()) : K === "readable" && !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.flowing = !1, ve.emittedReadable = !1, c("on readable", ve.length, ve.reading), ve.length ? x(this) : ve.reading || at.nextTick(R, this)), ce;
  }, Q.prototype.addListener = Q.prototype.on, Q.prototype.removeListener = function(K, W) {
    var ce = r.prototype.removeListener.call(this, K, W);
    return K === "readable" && at.nextTick(l, this), ce;
  }, Q.prototype.removeAllListeners = function(K) {
    var W = r.prototype.removeAllListeners.apply(this, arguments);
    return (K === "readable" || K === void 0) && at.nextTick(l, this), W;
  };
  function l(K) {
    var W = K._readableState;
    W.readableListening = K.listenerCount("readable") > 0, W.resumeScheduled && !W.paused ? W.flowing = !0 : K.listenerCount("data") > 0 && K.resume();
  }
  function R(K) {
    c("readable nexttick read 0"), K.read(0);
  }
  Q.prototype.resume = function() {
    var K = this._readableState;
    return K.flowing || (c("resume"), K.flowing = !K.readableListening, Y(this, K)), K.paused = !1, this;
  };
  function Y(K, W) {
    W.resumeScheduled || (W.resumeScheduled = !0, at.nextTick(oe, K, W));
  }
  function oe(K, W) {
    c("resume", W.reading), W.reading || K.read(0), W.resumeScheduled = !1, K.emit("resume"), H(K), W.flowing && !W.reading && K.read(0);
  }
  Q.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function H(K) {
    var W = K._readableState;
    for (c("flow", W.flowing); W.flowing && K.read() !== null; )
      ;
  }
  Q.prototype.wrap = function(K) {
    var W = this, ce = this._readableState, ve = !1;
    K.on("end", function() {
      if (c("wrapped end"), ce.decoder && !ce.ended) {
        var C = ce.decoder.end();
        C && C.length && W.push(C);
      }
      W.push(null);
    }), K.on("data", function(C) {
      if (c("wrapped data"), ce.decoder && (C = ce.decoder.write(C)), !(ce.objectMode && C == null) && !(!ce.objectMode && (!C || !C.length))) {
        var L = W.push(C);
        L || (ve = !0, K.pause());
      }
    });
    for (var Be in K)
      this[Be] === void 0 && typeof K[Be] == "function" && (this[Be] = /* @__PURE__ */ function(L) {
        return function() {
          return K[L].apply(K, arguments);
        };
      }(Be));
    for (var ee = 0; ee < q.length; ee++)
      K.on(q[ee], this.emit.bind(this, q[ee]));
    return this._read = function(C) {
      c("wrapped _read", C), ve && (ve = !1, K.resume());
    }, this;
  }, typeof Symbol == "function" && (Q.prototype[Symbol.asyncIterator] = function() {
    return j === void 0 && (j = G5()), j(this);
  }), Object.defineProperty(Q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(W) {
      this._readableState && (this._readableState.flowing = W);
    }
  }), Q._fromList = V, Object.defineProperty(Q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function V(K, W) {
    if (W.length === 0)
      return null;
    var ce;
    return W.objectMode ? ce = W.buffer.shift() : !K || K >= W.length ? (W.decoder ? ce = W.buffer.join("") : W.buffer.length === 1 ? ce = W.buffer.first() : ce = W.buffer.concat(W.length), W.buffer.clear()) : ce = W.buffer.consume(K, W.decoder), ce;
  }
  function F(K) {
    var W = K._readableState;
    c("endReadable", W.endEmitted), W.endEmitted || (W.ended = !0, at.nextTick(te, W, K));
  }
  function te(K, W) {
    if (c("endReadableNT", K.endEmitted, K.length), !K.endEmitted && K.length === 0 && (K.endEmitted = !0, W.readable = !1, W.emit("end"), K.autoDestroy)) {
      var ce = W._writableState;
      (!ce || ce.autoDestroy && ce.finished) && W.destroy();
    }
  }
  typeof Symbol == "function" && (Q.from = function(K, W) {
    return N === void 0 && (N = J5()), N(Q, K, W);
  });
  function he(K, W) {
    for (var ce = 0, ve = K.length; ce < ve; ce++)
      if (K[ce] === W)
        return ce;
    return -1;
  }
  return ss;
}
var us, hd;
function Yh() {
  if (hd)
    return us;
  hd = 1, us = u;
  var e = Di().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, r = e.ERR_MULTIPLE_CALLBACK, i = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, o = e.ERR_TRANSFORM_WITH_LENGTH_0, n = Qn();
  _t()(u, n);
  function f(s, b) {
    var p = this._transformState;
    p.transforming = !1;
    var m = p.writecb;
    if (m === null)
      return this.emit("error", new r());
    p.writechunk = null, p.writecb = null, b != null && this.push(b), m(s);
    var E = this._readableState;
    E.reading = !1, (E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
  }
  function u(s) {
    if (!(this instanceof u))
      return new u(s);
    n.call(this, s), this._transformState = {
      afterTransform: f.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", c);
  }
  function c() {
    var s = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(b, p) {
      h(s, b, p);
    }) : h(this, null, null);
  }
  u.prototype.push = function(s, b) {
    return this._transformState.needTransform = !1, n.prototype.push.call(this, s, b);
  }, u.prototype._transform = function(s, b, p) {
    p(new t("_transform()"));
  }, u.prototype._write = function(s, b, p) {
    var m = this._transformState;
    if (m.writecb = p, m.writechunk = s, m.writeencoding = b, !m.transforming) {
      var E = this._readableState;
      (m.needTransform || E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
    }
  }, u.prototype._read = function(s) {
    var b = this._transformState;
    b.writechunk !== null && !b.transforming ? (b.transforming = !0, this._transform(b.writechunk, b.writeencoding, b.afterTransform)) : b.needTransform = !0;
  }, u.prototype._destroy = function(s, b) {
    n.prototype._destroy.call(this, s, function(p) {
      b(p);
    });
  };
  function h(s, b, p) {
    if (b)
      return s.emit("error", b);
    if (p != null && s.push(p), s._writableState.length)
      throw new o();
    if (s._transformState.transforming)
      throw new i();
    return s.push(null);
  }
  return us;
}
var cs, ld;
function _y() {
  if (ld)
    return cs;
  ld = 1, cs = t;
  var e = Yh();
  _t()(t, e);
  function t(r) {
    if (!(this instanceof t))
      return new t(r);
    e.call(this, r);
  }
  return t.prototype._transform = function(r, i, o) {
    o(null, r);
  }, cs;
}
var hs, dd;
function xy() {
  if (dd)
    return hs;
  dd = 1;
  var e;
  function t(p) {
    var m = !1;
    return function() {
      m || (m = !0, p.apply(void 0, arguments));
    };
  }
  var r = Di().codes, i = r.ERR_MISSING_ARGS, o = r.ERR_STREAM_DESTROYED;
  function n(p) {
    if (p)
      throw p;
  }
  function f(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function u(p, m, E, M) {
    M = t(M);
    var I = !1;
    p.on("close", function() {
      I = !0;
    }), e === void 0 && (e = ef()), e(p, {
      readable: m,
      writable: E
    }, function(T) {
      if (T)
        return M(T);
      I = !0, M();
    });
    var B = !1;
    return function(T) {
      if (!I && !B) {
        if (B = !0, f(p))
          return p.abort();
        if (typeof p.destroy == "function")
          return p.destroy();
        M(T || new o("pipe"));
      }
    };
  }
  function c(p) {
    p();
  }
  function h(p, m) {
    return p.pipe(m);
  }
  function s(p) {
    return !p.length || typeof p[p.length - 1] != "function" ? n : p.pop();
  }
  function b() {
    for (var p = arguments.length, m = new Array(p), E = 0; E < p; E++)
      m[E] = arguments[E];
    var M = s(m);
    if (Array.isArray(m[0]) && (m = m[0]), m.length < 2)
      throw new i("streams");
    var I, B = m.map(function(T, j) {
      var N = j < m.length - 1, k = j > 0;
      return u(T, N, k, function(q) {
        I || (I = q), q && B.forEach(c), !N && (B.forEach(c), M(I));
      });
    });
    return m.reduce(h);
  }
  return hs = b, hs;
}
var pd;
function tf() {
  return pd || (pd = 1, function(e, t) {
    t = e.exports = Xh(), t.Stream = t, t.Readable = t, t.Writable = Jh(), t.Duplex = Qn(), t.Transform = Yh(), t.PassThrough = _y(), t.finished = ef(), t.pipeline = xy();
  }(ja, ja.exports)), ja.exports;
}
var vd;
function Ey() {
  if (vd)
    return ka;
  vd = 1;
  var e = by(), t = _t(), r = tf(), i = ka.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  }, o = ka.IncomingMessage = function(n, f, u, c) {
    var h = this;
    if (r.Readable.call(h), h._mode = u, h.headers = {}, h.rawHeaders = [], h.trailers = {}, h.rawTrailers = [], h.on("end", function() {
      at.nextTick(function() {
        h.emit("close");
      });
    }), u === "fetch") {
      let M = function() {
        b.read().then(function(I) {
          if (!h._destroyed) {
            if (c(I.done), I.done) {
              h.push(null);
              return;
            }
            h.push(Le.Buffer.from(I.value)), M();
          }
        }).catch(function(I) {
          c(!0), h._destroyed || h.emit("error", I);
        });
      };
      if (h._fetchResponse = f, h.url = f.url, h.statusCode = f.status, h.statusMessage = f.statusText, f.headers.forEach(function(I, B) {
        h.headers[B.toLowerCase()] = I, h.rawHeaders.push(B, I);
      }), e.writableStream) {
        var s = new WritableStream({
          write: function(I) {
            return c(!1), new Promise(function(B, T) {
              h._destroyed ? T() : h.push(Le.Buffer.from(I)) ? B() : h._resumeFetch = B;
            });
          },
          close: function() {
            c(!0), h._destroyed || h.push(null);
          },
          abort: function(I) {
            c(!0), h._destroyed || h.emit("error", I);
          }
        });
        try {
          f.body.pipeTo(s).catch(function(I) {
            c(!0), h._destroyed || h.emit("error", I);
          });
          return;
        } catch {
        }
      }
      var b = f.body.getReader();
      M();
    } else {
      h._xhr = n, h._pos = 0, h.url = n.responseURL, h.statusCode = n.status, h.statusMessage = n.statusText;
      var p = n.getAllResponseHeaders().split(/\r?\n/);
      if (p.forEach(function(M) {
        var I = M.match(/^([^:]+):\s*(.*)/);
        if (I) {
          var B = I[1].toLowerCase();
          B === "set-cookie" ? (h.headers[B] === void 0 && (h.headers[B] = []), h.headers[B].push(I[2])) : h.headers[B] !== void 0 ? h.headers[B] += ", " + I[2] : h.headers[B] = I[2], h.rawHeaders.push(I[1], I[2]);
        }
      }), h._charset = "x-user-defined", !e.overrideMimeType) {
        var m = h.rawHeaders["mime-type"];
        if (m) {
          var E = m.match(/;\s*charset=([^;])(;|$)/);
          E && (h._charset = E[1].toLowerCase());
        }
        h._charset || (h._charset = "utf-8");
      }
    }
  };
  return t(o, r.Readable), o.prototype._read = function() {
    var n = this, f = n._resumeFetch;
    f && (n._resumeFetch = null, f());
  }, o.prototype._onXHRProgress = function(n) {
    var f = this, u = f._xhr, c = null;
    switch (f._mode) {
      case "text":
        if (c = u.responseText, c.length > f._pos) {
          var h = c.substr(f._pos);
          if (f._charset === "x-user-defined") {
            for (var s = Le.Buffer.alloc(h.length), b = 0; b < h.length; b++)
              s[b] = h.charCodeAt(b) & 255;
            f.push(s);
          } else
            f.push(h, f._charset);
          f._pos = c.length;
        }
        break;
      case "arraybuffer":
        if (u.readyState !== i.DONE || !u.response)
          break;
        c = u.response, f.push(Le.Buffer.from(new Uint8Array(c)));
        break;
      case "moz-chunked-arraybuffer":
        if (c = u.response, u.readyState !== i.LOADING || !c)
          break;
        f.push(Le.Buffer.from(new Uint8Array(c)));
        break;
      case "ms-stream":
        if (c = u.response, u.readyState !== i.LOADING)
          break;
        var p = new Ze.MSStreamReader();
        p.onprogress = function() {
          p.result.byteLength > f._pos && (f.push(Le.Buffer.from(new Uint8Array(p.result.slice(f._pos)))), f._pos = p.result.byteLength);
        }, p.onload = function() {
          n(!0), f.push(null);
        }, p.readAsArrayBuffer(c);
        break;
    }
    f._xhr.readyState === i.DONE && f._mode !== "ms-stream" && (n(!0), f.push(null));
  }, ka;
}
var bd;
function X5() {
  if (bd)
    return kf.exports;
  bd = 1;
  var e = by(), t = _t(), r = Ey(), i = tf(), o = r.IncomingMessage, n = r.readyStates;
  function f(s, b) {
    return e.fetch && b ? "fetch" : e.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : e.msstream ? "ms-stream" : e.arraybuffer && s ? "arraybuffer" : "text";
  }
  var u = kf.exports = function(s) {
    var b = this;
    i.Writable.call(b), b._opts = s, b._body = [], b._headers = {}, s.auth && b.setHeader("Authorization", "Basic " + Le.Buffer.from(s.auth).toString("base64")), Object.keys(s.headers).forEach(function(E) {
      b.setHeader(E, s.headers[E]);
    });
    var p, m = !0;
    if (s.mode === "disable-fetch" || "requestTimeout" in s && !e.abortController)
      m = !1, p = !0;
    else if (s.mode === "prefer-streaming")
      p = !1;
    else if (s.mode === "allow-wrong-content-type")
      p = !e.overrideMimeType;
    else if (!s.mode || s.mode === "default" || s.mode === "prefer-fast")
      p = !0;
    else
      throw new Error("Invalid value for opts.mode");
    b._mode = f(p, m), b._fetchTimer = null, b._socketTimeout = null, b._socketTimer = null, b.on("finish", function() {
      b._onFinish();
    });
  };
  t(u, i.Writable), u.prototype.setHeader = function(s, b) {
    var p = this, m = s.toLowerCase();
    h.indexOf(m) === -1 && (p._headers[m] = {
      name: s,
      value: b
    });
  }, u.prototype.getHeader = function(s) {
    var b = this._headers[s.toLowerCase()];
    return b ? b.value : null;
  }, u.prototype.removeHeader = function(s) {
    var b = this;
    delete b._headers[s.toLowerCase()];
  }, u.prototype._onFinish = function() {
    var s = this;
    if (!s._destroyed) {
      var b = s._opts;
      "timeout" in b && b.timeout !== 0 && s.setTimeout(b.timeout);
      var p = s._headers, m = null;
      b.method !== "GET" && b.method !== "HEAD" && (m = new Blob(s._body, {
        type: (p["content-type"] || {}).value || ""
      }));
      var E = [];
      if (Object.keys(p).forEach(function(T) {
        var j = p[T].name, N = p[T].value;
        Array.isArray(N) ? N.forEach(function(k) {
          E.push([j, k]);
        }) : E.push([j, N]);
      }), s._mode === "fetch") {
        var M = null;
        if (e.abortController) {
          var I = new AbortController();
          M = I.signal, s._fetchAbortController = I, "requestTimeout" in b && b.requestTimeout !== 0 && (s._fetchTimer = Ze.setTimeout(function() {
            s.emit("requestTimeout"), s._fetchAbortController && s._fetchAbortController.abort();
          }, b.requestTimeout));
        }
        Ze.fetch(s._opts.url, {
          method: s._opts.method,
          headers: E,
          body: m || void 0,
          mode: "cors",
          credentials: b.withCredentials ? "include" : "same-origin",
          signal: M
        }).then(function(T) {
          s._fetchResponse = T, s._resetTimers(!1), s._connect();
        }, function(T) {
          s._resetTimers(!0), s._destroyed || s.emit("error", T);
        });
      } else {
        var B = s._xhr = new Ze.XMLHttpRequest();
        try {
          B.open(s._opts.method, s._opts.url, !0);
        } catch (T) {
          at.nextTick(function() {
            s.emit("error", T);
          });
          return;
        }
        "responseType" in B && (B.responseType = s._mode), "withCredentials" in B && (B.withCredentials = !!b.withCredentials), s._mode === "text" && "overrideMimeType" in B && B.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in b && (B.timeout = b.requestTimeout, B.ontimeout = function() {
          s.emit("requestTimeout");
        }), E.forEach(function(T) {
          B.setRequestHeader(T[0], T[1]);
        }), s._response = null, B.onreadystatechange = function() {
          switch (B.readyState) {
            case n.LOADING:
            case n.DONE:
              s._onXHRProgress();
              break;
          }
        }, s._mode === "moz-chunked-arraybuffer" && (B.onprogress = function() {
          s._onXHRProgress();
        }), B.onerror = function() {
          s._destroyed || (s._resetTimers(!0), s.emit("error", new Error("XHR error")));
        };
        try {
          B.send(m);
        } catch (T) {
          at.nextTick(function() {
            s.emit("error", T);
          });
          return;
        }
      }
    }
  };
  function c(s) {
    try {
      var b = s.status;
      return b !== null && b !== 0;
    } catch {
      return !1;
    }
  }
  u.prototype._onXHRProgress = function() {
    var s = this;
    s._resetTimers(!1), !(!c(s._xhr) || s._destroyed) && (s._response || s._connect(), s._response._onXHRProgress(s._resetTimers.bind(s)));
  }, u.prototype._connect = function() {
    var s = this;
    s._destroyed || (s._response = new o(s._xhr, s._fetchResponse, s._mode, s._resetTimers.bind(s)), s._response.on("error", function(b) {
      s.emit("error", b);
    }), s.emit("response", s._response));
  }, u.prototype._write = function(s, b, p) {
    var m = this;
    m._body.push(s), p();
  }, u.prototype._resetTimers = function(s) {
    var b = this;
    Ze.clearTimeout(b._socketTimer), b._socketTimer = null, s ? (Ze.clearTimeout(b._fetchTimer), b._fetchTimer = null) : b._socketTimeout && (b._socketTimer = Ze.setTimeout(function() {
      b.emit("timeout");
    }, b._socketTimeout));
  }, u.prototype.abort = u.prototype.destroy = function(s) {
    var b = this;
    b._destroyed = !0, b._resetTimers(!0), b._response && (b._response._destroyed = !0), b._xhr ? b._xhr.abort() : b._fetchAbortController && b._fetchAbortController.abort(), s && b.emit("error", s);
  }, u.prototype.end = function(s, b, p) {
    var m = this;
    typeof s == "function" && (p = s, s = void 0), i.Writable.prototype.end.call(m, s, b, p);
  }, u.prototype.setTimeout = function(s, b) {
    var p = this;
    b && p.once("timeout", b), p._socketTimeout = s, p._resetTimers(!1);
  }, u.prototype.flushHeaders = function() {
  }, u.prototype.setNoDelay = function() {
  }, u.prototype.setSocketKeepAlive = function() {
  };
  var h = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];
  return kf.exports;
}
var ls, yd;
function Y5() {
  if (yd)
    return ls;
  yd = 1, ls = t;
  var e = Object.prototype.hasOwnProperty;
  function t() {
    for (var r = {}, i = 0; i < arguments.length; i++) {
      var o = arguments[i];
      for (var n in o)
        e.call(o, n) && (r[n] = o[n]);
    }
    return r;
  }
  return ls;
}
var ds, gd;
function Q5() {
  return gd || (gd = 1, ds = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Unordered Collection",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    511: "Network Authentication Required"
  }), ds;
}
var Da = { exports: {} }, Ji = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
Ji.exports;
var md;
function ex() {
  return md || (md = 1, function(e, t) {
    (function(r) {
      var i = t && !t.nodeType && t, o = e && !e.nodeType && e, n = typeof Ze == "object" && Ze;
      (n.global === n || n.window === n || n.self === n) && (r = n);
      var f, u = 2147483647, c = 36, h = 1, s = 26, b = 38, p = 700, m = 72, E = 128, M = "-", I = /^xn--/, B = /[^\x20-\x7E]/, T = /[\x2E\u3002\uFF0E\uFF61]/g, j = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, N = c - h, k = Math.floor, q = String.fromCharCode, $;
      function re(g) {
        throw new RangeError(j[g]);
      }
      function Q(g, _) {
        for (var l = g.length, R = []; l--; )
          R[l] = _(g[l]);
        return R;
      }
      function fe(g, _) {
        var l = g.split("@"), R = "";
        l.length > 1 && (R = l[0] + "@", g = l[1]), g = g.replace(T, ".");
        var Y = g.split("."), oe = Q(Y, _).join(".");
        return R + oe;
      }
      function U(g) {
        for (var _ = [], l = 0, R = g.length, Y, oe; l < R; )
          Y = g.charCodeAt(l++), Y >= 55296 && Y <= 56319 && l < R ? (oe = g.charCodeAt(l++), (oe & 64512) == 56320 ? _.push(((Y & 1023) << 10) + (oe & 1023) + 65536) : (_.push(Y), l--)) : _.push(Y);
        return _;
      }
      function y(g) {
        return Q(g, function(_) {
          var l = "";
          return _ > 65535 && (_ -= 65536, l += q(_ >>> 10 & 1023 | 55296), _ = 56320 | _ & 1023), l += q(_), l;
        }).join("");
      }
      function v(g) {
        return g - 48 < 10 ? g - 22 : g - 65 < 26 ? g - 65 : g - 97 < 26 ? g - 97 : c;
      }
      function a(g, _) {
        return g + 22 + 75 * (g < 26) - ((_ != 0) << 5);
      }
      function d(g, _, l) {
        var R = 0;
        for (g = l ? k(g / p) : g >> 1, g += k(g / _); g > N * s >> 1; R += c)
          g = k(g / N);
        return k(R + (N + 1) * g / (g + b));
      }
      function w(g) {
        var _ = [], l = g.length, R, Y = 0, oe = E, H = m, V, F, te, he, K, W, ce, ve, Be;
        for (V = g.lastIndexOf(M), V < 0 && (V = 0), F = 0; F < V; ++F)
          g.charCodeAt(F) >= 128 && re("not-basic"), _.push(g.charCodeAt(F));
        for (te = V > 0 ? V + 1 : 0; te < l; ) {
          for (he = Y, K = 1, W = c; te >= l && re("invalid-input"), ce = v(g.charCodeAt(te++)), (ce >= c || ce > k((u - Y) / K)) && re("overflow"), Y += ce * K, ve = W <= H ? h : W >= H + s ? s : W - H, !(ce < ve); W += c)
            Be = c - ve, K > k(u / Be) && re("overflow"), K *= Be;
          R = _.length + 1, H = d(Y - he, R, he == 0), k(Y / R) > u - oe && re("overflow"), oe += k(Y / R), Y %= R, _.splice(Y++, 0, oe);
        }
        return y(_);
      }
      function x(g) {
        var _, l, R, Y, oe, H, V, F, te, he, K, W = [], ce, ve, Be, ee;
        for (g = U(g), ce = g.length, _ = E, l = 0, oe = m, H = 0; H < ce; ++H)
          K = g[H], K < 128 && W.push(q(K));
        for (R = Y = W.length, Y && W.push(M); R < ce; ) {
          for (V = u, H = 0; H < ce; ++H)
            K = g[H], K >= _ && K < V && (V = K);
          for (ve = R + 1, V - _ > k((u - l) / ve) && re("overflow"), l += (V - _) * ve, _ = V, H = 0; H < ce; ++H)
            if (K = g[H], K < _ && ++l > u && re("overflow"), K == _) {
              for (F = l, te = c; he = te <= oe ? h : te >= oe + s ? s : te - oe, !(F < he); te += c)
                ee = F - he, Be = c - he, W.push(
                  q(a(he + ee % Be, 0))
                ), F = k(ee / Be);
              W.push(q(a(F, 0))), oe = d(l, ve, R == Y), l = 0, ++R;
            }
          ++l, ++_;
        }
        return W.join("");
      }
      function A(g) {
        return fe(g, function(_) {
          return I.test(_) ? w(_.slice(4).toLowerCase()) : _;
        });
      }
      function S(g) {
        return fe(g, function(_) {
          return B.test(_) ? "xn--" + x(_) : _;
        });
      }
      if (f = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: U,
          encode: y
        },
        decode: w,
        encode: x,
        toASCII: S,
        toUnicode: A
      }, i && o)
        if (e.exports == i)
          o.exports = f;
        else
          for ($ in f)
            f.hasOwnProperty($) && (i[$] = f[$]);
      else
        r.punycode = f;
    })(Ze);
  }(Ji, Ji.exports)), Ji.exports;
}
var $a = { exports: {} }, hi = {}, ps, wd;
function tx() {
  if (wd)
    return ps;
  wd = 1;
  function e(r, i) {
    return Object.prototype.hasOwnProperty.call(r, i);
  }
  ps = function(r, i, o, n) {
    i = i || "&", o = o || "=";
    var f = {};
    if (typeof r != "string" || r.length === 0)
      return f;
    var u = /\+/g;
    r = r.split(i);
    var c = 1e3;
    n && typeof n.maxKeys == "number" && (c = n.maxKeys);
    var h = r.length;
    c > 0 && h > c && (h = c);
    for (var s = 0; s < h; ++s) {
      var b = r[s].replace(u, "%20"), p = b.indexOf(o), m, E, M, I;
      p >= 0 ? (m = b.substr(0, p), E = b.substr(p + 1)) : (m = b, E = ""), M = decodeURIComponent(m), I = decodeURIComponent(E), e(f, M) ? t(f[M]) ? f[M].push(I) : f[M] = [f[M], I] : f[M] = I;
    }
    return f;
  };
  var t = Array.isArray || function(r) {
    return Object.prototype.toString.call(r) === "[object Array]";
  };
  return ps;
}
var vs, _d;
function rx() {
  if (_d)
    return vs;
  _d = 1;
  var e = function(o) {
    switch (typeof o) {
      case "string":
        return o;
      case "boolean":
        return o ? "true" : "false";
      case "number":
        return isFinite(o) ? o : "";
      default:
        return "";
    }
  };
  vs = function(o, n, f, u) {
    return n = n || "&", f = f || "=", o === null && (o = void 0), typeof o == "object" ? r(i(o), function(c) {
      var h = encodeURIComponent(e(c)) + f;
      return t(o[c]) ? r(o[c], function(s) {
        return h + encodeURIComponent(e(s));
      }).join(n) : h + encodeURIComponent(e(o[c]));
    }).join(n) : u ? encodeURIComponent(e(u)) + f + encodeURIComponent(e(o)) : "";
  };
  var t = Array.isArray || function(o) {
    return Object.prototype.toString.call(o) === "[object Array]";
  };
  function r(o, n) {
    if (o.map)
      return o.map(n);
    for (var f = [], u = 0; u < o.length; u++)
      f.push(n(o[u], u));
    return f;
  }
  var i = Object.keys || function(o) {
    var n = [];
    for (var f in o)
      Object.prototype.hasOwnProperty.call(o, f) && n.push(f);
    return n;
  };
  return vs;
}
var xd;
function nx() {
  return xd || (xd = 1, hi.decode = hi.parse = tx(), hi.encode = hi.stringify = rx()), hi;
}
var Ed;
function ix() {
  return Ed || (Ed = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var r = nx();
    function i(f) {
      return encodeURIComponent(f);
    }
    function o(f) {
      return decodeURIComponent(f);
    }
    var n = {
      decode: r.decode,
      encode: r.encode,
      parse: r.parse,
      stringify: r.stringify,
      escape: i,
      unescape: o
    };
    Object.defineProperty(t, "decode", {
      enumerable: !0,
      get: function() {
        return r.decode;
      }
    }), Object.defineProperty(t, "encode", {
      enumerable: !0,
      get: function() {
        return r.encode;
      }
    }), Object.defineProperty(t, "parse", {
      enumerable: !0,
      get: function() {
        return r.parse;
      }
    }), Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function() {
        return r.stringify;
      }
    }), t.default = n, t.escape = i, t.unescape = o, t = e.exports = n;
  }($a, $a.exports)), $a.exports;
}
var Sd;
function Qh() {
  return Sd || (Sd = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var r = ex(), i = ix();
    function o(z) {
      return z && typeof z == "object" && "default" in z ? z : { default: z };
    }
    var n = /* @__PURE__ */ o(r), f = /* @__PURE__ */ o(i), u = {
      isString: function(z) {
        return typeof z == "string";
      },
      isObject: function(z) {
        return typeof z == "object" && z !== null;
      },
      isNull: function(z) {
        return z === null;
      },
      isNullOrUndefined: function(z) {
        return z == null;
      }
    }, c = n.default, h = u, s = d, b = x, p = A, m = w, E = M;
    function M() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var I = /^([a-z0-9.+-]+:)/i, B = /:[0-9]*$/, T = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, j = ["<", ">", '"', "`", " ", "\r", `
`, "	"], N = ["{", "}", "|", "\\", "^", "`"].concat(j), k = ["'"].concat(N), q = ["%", "/", "?", ";", "#"].concat(k), $ = ["/", "?", "#"], re = 255, Q = /^[+a-z0-9A-Z_-]{0,63}$/, fe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, U = {
      javascript: !0,
      "javascript:": !0
    }, y = {
      javascript: !0,
      "javascript:": !0
    }, v = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0
    }, a = f.default;
    function d(z, ue, se) {
      if (z && h.isObject(z) && z instanceof M)
        return z;
      var _e = new M();
      return _e.parse(z, ue, se), _e;
    }
    M.prototype.parse = function(z, ue, se) {
      if (!h.isString(z))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof z);
      var _e = z.indexOf("?"), Ce = _e !== -1 && _e < z.indexOf("#") ? "?" : "#", Ve = z.split(Ce), ke = /\\/g;
      Ve[0] = Ve[0].replace(ke, "/"), z = Ve.join(Ce);
      var X = z;
      if (X = X.trim(), !se && z.split("#").length === 1) {
        var Se = T.exec(X);
        if (Se)
          return this.path = X, this.href = X, this.pathname = Se[1], Se[2] ? (this.search = Se[2], ue ? this.query = a.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : ue && (this.search = "", this.query = {}), this;
      }
      var Ae = I.exec(X);
      if (Ae) {
        Ae = Ae[0];
        var qe = Ae.toLowerCase();
        this.protocol = qe, X = X.substr(Ae.length);
      }
      if (se || Ae || X.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var pe = X.substr(0, 2) === "//";
        pe && !(Ae && y[Ae]) && (X = X.substr(2), this.slashes = !0);
      }
      if (!y[Ae] && (pe || Ae && !v[Ae])) {
        for (var Ee = -1, G = 0; G < $.length; G++) {
          var Ie = X.indexOf($[G]);
          Ie !== -1 && (Ee === -1 || Ie < Ee) && (Ee = Ie);
        }
        var je, P;
        Ee === -1 ? P = X.lastIndexOf("@") : P = X.lastIndexOf("@", Ee), P !== -1 && (je = X.slice(0, P), X = X.slice(P + 1), this.auth = decodeURIComponent(je)), Ee = -1;
        for (var G = 0; G < q.length; G++) {
          var Ie = X.indexOf(q[G]);
          Ie !== -1 && (Ee === -1 || Ie < Ee) && (Ee = Ie);
        }
        Ee === -1 && (Ee = X.length), this.host = X.slice(0, Ee), X = X.slice(Ee), this.parseHost(), this.hostname = this.hostname || "";
        var Me = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!Me)
          for (var be = this.hostname.split(/\./), G = 0, ie = be.length; G < ie; G++) {
            var le = be[G];
            if (le && !le.match(Q)) {
              for (var ge = "", Ge = 0, $e = le.length; Ge < $e; Ge++)
                le.charCodeAt(Ge) > 127 ? ge += "x" : ge += le[Ge];
              if (!ge.match(Q)) {
                var Ne = be.slice(0, G), nt = be.slice(G + 1), st = le.match(fe);
                st && (Ne.push(st[1]), nt.unshift(st[2])), nt.length && (X = "/" + nt.join(".") + X), this.hostname = Ne.join(".");
                break;
              }
            }
          }
        this.hostname.length > re ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Me || (this.hostname = c.toASCII(this.hostname));
        var Je = this.port ? ":" + this.port : "", ft = this.hostname || "";
        this.host = ft + Je, this.href += this.host, Me && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), X[0] !== "/" && (X = "/" + X));
      }
      if (!U[qe])
        for (var G = 0, ie = k.length; G < ie; G++) {
          var D = k[G];
          if (X.indexOf(D) !== -1) {
            var J = encodeURIComponent(D);
            J === D && (J = escape(D)), X = X.split(D).join(J);
          }
        }
      var ne = X.indexOf("#");
      ne !== -1 && (this.hash = X.substr(ne), X = X.slice(0, ne));
      var O = X.indexOf("?");
      if (O !== -1 ? (this.search = X.substr(O), this.query = X.substr(O + 1), ue && (this.query = a.parse(this.query)), X = X.slice(0, O)) : ue && (this.search = "", this.query = {}), X && (this.pathname = X), v[qe] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Je = this.pathname || "", ae = this.search || "";
        this.path = Je + ae;
      }
      return this.href = this.format(), this;
    };
    function w(z) {
      return h.isString(z) && (z = d(z)), z instanceof M ? z.format() : M.prototype.format.call(z);
    }
    M.prototype.format = function() {
      var z = this.auth || "";
      z && (z = encodeURIComponent(z), z = z.replace(/%3A/i, ":"), z += "@");
      var ue = this.protocol || "", se = this.pathname || "", _e = this.hash || "", Ce = !1, Ve = "";
      this.host ? Ce = z + this.host : this.hostname && (Ce = z + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Ce += ":" + this.port)), this.query && h.isObject(this.query) && Object.keys(this.query).length && (Ve = a.stringify(this.query));
      var ke = this.search || Ve && "?" + Ve || "";
      return ue && ue.substr(-1) !== ":" && (ue += ":"), this.slashes || (!ue || v[ue]) && Ce !== !1 ? (Ce = "//" + (Ce || ""), se && se.charAt(0) !== "/" && (se = "/" + se)) : Ce || (Ce = ""), _e && _e.charAt(0) !== "#" && (_e = "#" + _e), ke && ke.charAt(0) !== "?" && (ke = "?" + ke), se = se.replace(/[?#]/g, function(X) {
        return encodeURIComponent(X);
      }), ke = ke.replace("#", "%23"), ue + Ce + se + ke + _e;
    };
    function x(z, ue) {
      return d(z, !1, !0).resolve(ue);
    }
    M.prototype.resolve = function(z) {
      return this.resolveObject(d(z, !1, !0)).format();
    };
    function A(z, ue) {
      return z ? d(z, !1, !0).resolveObject(ue) : ue;
    }
    M.prototype.resolveObject = function(z) {
      if (h.isString(z)) {
        var ue = new M();
        ue.parse(z, !1, !0), z = ue;
      }
      for (var se = new M(), _e = Object.keys(this), Ce = 0; Ce < _e.length; Ce++) {
        var Ve = _e[Ce];
        se[Ve] = this[Ve];
      }
      if (se.hash = z.hash, z.href === "")
        return se.href = se.format(), se;
      if (z.slashes && !z.protocol) {
        for (var ke = Object.keys(z), X = 0; X < ke.length; X++) {
          var Se = ke[X];
          Se !== "protocol" && (se[Se] = z[Se]);
        }
        return v[se.protocol] && se.hostname && !se.pathname && (se.path = se.pathname = "/"), se.href = se.format(), se;
      }
      if (z.protocol && z.protocol !== se.protocol) {
        if (!v[z.protocol]) {
          for (var Ae = Object.keys(z), qe = 0; qe < Ae.length; qe++) {
            var pe = Ae[qe];
            se[pe] = z[pe];
          }
          return se.href = se.format(), se;
        }
        if (se.protocol = z.protocol, !z.host && !y[z.protocol]) {
          for (var ie = (z.pathname || "").split("/"); ie.length && !(z.host = ie.shift()); )
            ;
          z.host || (z.host = ""), z.hostname || (z.hostname = ""), ie[0] !== "" && ie.unshift(""), ie.length < 2 && ie.unshift(""), se.pathname = ie.join("/");
        } else
          se.pathname = z.pathname;
        if (se.search = z.search, se.query = z.query, se.host = z.host || "", se.auth = z.auth, se.hostname = z.hostname || z.host, se.port = z.port, se.pathname || se.search) {
          var Ee = se.pathname || "", G = se.search || "";
          se.path = Ee + G;
        }
        return se.slashes = se.slashes || z.slashes, se.href = se.format(), se;
      }
      var Ie = se.pathname && se.pathname.charAt(0) === "/", je = z.host || z.pathname && z.pathname.charAt(0) === "/", P = je || Ie || se.host && z.pathname, Me = P, be = se.pathname && se.pathname.split("/") || [], ie = z.pathname && z.pathname.split("/") || [], le = se.protocol && !v[se.protocol];
      if (le && (se.hostname = "", se.port = null, se.host && (be[0] === "" ? be[0] = se.host : be.unshift(se.host)), se.host = "", z.protocol && (z.hostname = null, z.port = null, z.host && (ie[0] === "" ? ie[0] = z.host : ie.unshift(z.host)), z.host = null), P = P && (ie[0] === "" || be[0] === "")), je)
        se.host = z.host || z.host === "" ? z.host : se.host, se.hostname = z.hostname || z.hostname === "" ? z.hostname : se.hostname, se.search = z.search, se.query = z.query, be = ie;
      else if (ie.length)
        be || (be = []), be.pop(), be = be.concat(ie), se.search = z.search, se.query = z.query;
      else if (!h.isNullOrUndefined(z.search)) {
        if (le) {
          se.hostname = se.host = be.shift();
          var ge = se.host && se.host.indexOf("@") > 0 ? se.host.split("@") : !1;
          ge && (se.auth = ge.shift(), se.host = se.hostname = ge.shift());
        }
        return se.search = z.search, se.query = z.query, (!h.isNull(se.pathname) || !h.isNull(se.search)) && (se.path = (se.pathname ? se.pathname : "") + (se.search ? se.search : "")), se.href = se.format(), se;
      }
      if (!be.length)
        return se.pathname = null, se.search ? se.path = "/" + se.search : se.path = null, se.href = se.format(), se;
      for (var Ge = be.slice(-1)[0], $e = (se.host || z.host || be.length > 1) && (Ge === "." || Ge === "..") || Ge === "", Ne = 0, nt = be.length; nt >= 0; nt--)
        Ge = be[nt], Ge === "." ? be.splice(nt, 1) : Ge === ".." ? (be.splice(nt, 1), Ne++) : Ne && (be.splice(nt, 1), Ne--);
      if (!P && !Me)
        for (; Ne--; Ne)
          be.unshift("..");
      P && be[0] !== "" && (!be[0] || be[0].charAt(0) !== "/") && be.unshift(""), $e && be.join("/").substr(-1) !== "/" && be.push("");
      var st = be[0] === "" || be[0] && be[0].charAt(0) === "/";
      if (le) {
        se.hostname = se.host = st ? "" : be.length ? be.shift() : "";
        var ge = se.host && se.host.indexOf("@") > 0 ? se.host.split("@") : !1;
        ge && (se.auth = ge.shift(), se.host = se.hostname = ge.shift());
      }
      return P = P || se.host && be.length, P && !st && be.unshift(""), be.length ? se.pathname = be.join("/") : (se.pathname = null, se.path = null), (!h.isNull(se.pathname) || !h.isNull(se.search)) && (se.path = (se.pathname ? se.pathname : "") + (se.search ? se.search : "")), se.auth = z.auth || se.auth, se.slashes = se.slashes || z.slashes, se.href = se.format(), se;
    }, M.prototype.parseHost = function() {
      var z = this.host, ue = B.exec(z);
      ue && (ue = ue[0], ue !== ":" && (this.port = ue.substr(1)), z = z.substr(0, z.length - ue.length)), z && (this.hostname = z);
    };
    function S(z, ue) {
      for (var se = 0, _e = z.length - 1; _e >= 0; _e--) {
        var Ce = z[_e];
        Ce === "." ? z.splice(_e, 1) : Ce === ".." ? (z.splice(_e, 1), se++) : se && (z.splice(_e, 1), se--);
      }
      if (ue)
        for (; se--; se)
          z.unshift("..");
      return z;
    }
    function g() {
      for (var z = "", ue = !1, se = arguments.length - 1; se >= -1 && !ue; se--) {
        var _e = se >= 0 ? arguments[se] : "/";
        if (typeof _e != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!_e)
          continue;
        z = _e + "/" + z, ue = _e.charAt(0) === "/";
      }
      return z = S(_(z.split("/"), function(Ce) {
        return !!Ce;
      }), !ue).join("/"), (ue ? "/" : "") + z || ".";
    }
    function _(z, ue) {
      if (z.filter)
        return z.filter(ue);
      for (var se = [], _e = 0; _e < z.length; _e++)
        ue(z[_e], _e, z) && se.push(z[_e]);
      return se;
    }
    var l = function(z) {
      function ue() {
        var _e = this || self;
        return delete z.prototype.__magic__, _e;
      }
      if (typeof globalThis == "object")
        return globalThis;
      if (this)
        return ue();
      z.defineProperty(z.prototype, "__magic__", {
        configurable: !0,
        get: ue
      });
      var se = __magic__;
      return se;
    }(Object), R = (
      /** @type {formatImport}*/
      m
    ), Y = (
      /** @type {parseImport}*/
      s
    ), oe = (
      /** @type {resolveImport}*/
      b
    ), H = (
      /** @type {UrlImport}*/
      E
    ), V = l.URL, F = l.URLSearchParams, te = /%/g, he = /\\/g, K = /\n/g, W = /\r/g, ce = /\t/g, ve = 47;
    function Be(z) {
      var ue = (
        /** @type {URL|null} */
        z ?? null
      );
      return !!(ue !== null && (ue != null && ue.href) && (ue != null && ue.origin));
    }
    function ee(z) {
      if (z.hostname !== "")
        throw new TypeError('File URL host must be "localhost" or empty on browser');
      for (var ue = z.pathname, se = 0; se < ue.length; se++)
        if (ue[se] === "%") {
          var _e = ue.codePointAt(se + 2) | 32;
          if (ue[se + 1] === "2" && _e === 102)
            throw new TypeError("File URL path must not include encoded / characters");
        }
      return decodeURIComponent(ue);
    }
    function C(z) {
      return z.includes("%") && (z = z.replace(te, "%25")), z.includes("\\") && (z = z.replace(he, "%5C")), z.includes(`
`) && (z = z.replace(K, "%0A")), z.includes("\r") && (z = z.replace(W, "%0D")), z.includes("	") && (z = z.replace(ce, "%09")), z;
    }
    var L = (
      /**
       * @type {domainToASCII}
       */
      function(ue) {
        if (typeof ue > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new V("http://" + ue).hostname;
      }
    ), Z = (
      /**
       * @type {domainToUnicode}
       */
      function(ue) {
        if (typeof ue > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new V("http://" + ue).hostname;
      }
    ), de = (
      /**
       * @type {(url: string) => URL}
       */
      function(ue) {
        var se = new V("file://"), _e = g(ue), Ce = ue.charCodeAt(ue.length - 1);
        return Ce === ve && _e[_e.length - 1] !== "/" && (_e += "/"), se.pathname = C(_e), se;
      }
    ), me = (
      /**
       * @type {fileURLToPath & ((path: string | URL) => string)}
       */
      function(ue) {
        if (!Be(ue) && typeof ue != "string")
          throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof ue + " (" + ue + ")");
        var se = new V(ue);
        if (se.protocol !== "file:")
          throw new TypeError("The URL must be of scheme file");
        return ee(se);
      }
    ), Te = (
      /**
       * @type {(
       *   ((urlObject: URL, options?: URLFormatOptions) => string) &
       *   ((urlObject: UrlObject | string, options?: never) => string)
       * )}
       */
      function(ue, se) {
        var _e, Ce, Ve;
        if (se === void 0 && (se = {}), !(ue instanceof V))
          return R(ue);
        if (typeof se != "object" || se === null)
          throw new TypeError('The "options" argument must be of type object.');
        var ke = (_e = se.auth) != null ? _e : !0, X = (Ce = se.fragment) != null ? Ce : !0, Se = (Ve = se.search) != null ? Ve : !0, Ae = new V(ue.toString());
        return ke || (Ae.username = "", Ae.password = ""), X || (Ae.hash = ""), Se || (Ae.search = ""), Ae.toString();
      }
    ), ze = {
      format: Te,
      parse: Y,
      resolve: oe,
      resolveObject: p,
      Url: H,
      URL: V,
      URLSearchParams: F,
      domainToASCII: L,
      domainToUnicode: Z,
      pathToFileURL: de,
      fileURLToPath: me
    };
    t.URL = V, t.URLSearchParams = F, t.Url = H, t.default = ze, t.domainToASCII = L, t.domainToUnicode = Z, t.fileURLToPath = me, t.format = Te, t.parse = Y, t.pathToFileURL = de, t.resolve = oe, t.resolveObject = p, t = e.exports = ze;
  }(Da, Da.exports)), Da.exports;
}
var Ad;
function Sy() {
  return Ad || (Ad = 1, function(e) {
    var t = X5(), r = Ey(), i = Y5(), o = Q5(), n = Qh(), f = e;
    f.request = function(u, c) {
      typeof u == "string" ? u = n.parse(u) : u = i(u);
      var h = Ze.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", s = u.protocol || h, b = u.hostname || u.host, p = u.port, m = u.path || "/";
      b && b.indexOf(":") !== -1 && (b = "[" + b + "]"), u.url = (b ? s + "//" + b : "") + (p ? ":" + p : "") + m, u.method = (u.method || "GET").toUpperCase(), u.headers = u.headers || {};
      var E = new t(u);
      return c && E.on("response", c), E;
    }, f.get = function(c, h) {
      var s = f.request(c, h);
      return s.end(), s;
    }, f.ClientRequest = t, f.IncomingMessage = r.IncomingMessage, f.Agent = function() {
    }, f.Agent.defaultMaxSockets = 4, f.globalAgent = new f.Agent(), f.STATUS_CODES = o, f.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }(Lf)), Lf;
}
var bs = { exports: {} }, Md;
function ax() {
  return Md || (Md = 1, function(e) {
    var t = Sy(), r = Qh(), i = e.exports;
    for (var o in t)
      t.hasOwnProperty(o) && (i[o] = t[o]);
    i.request = function(f, u) {
      return f = n(f), t.request.call(this, f, u);
    }, i.get = function(f, u) {
      return f = n(f), t.get.call(this, f, u);
    };
    function n(f) {
      if (typeof f == "string" && (f = r.parse(f)), f.protocol || (f.protocol = "https:"), f.protocol !== "https:")
        throw new Error('Protocol "' + f.protocol + '" not supported. Expected "https:"');
      return f;
    }
  }(bs)), bs.exports;
}
var ys = {}, gs, Rd;
function Ay() {
  if (Rd)
    return gs;
  Rd = 1, gs = r;
  var e = Ci.EventEmitter, t = _t();
  t(r, e), r.Readable = Xh(), r.Writable = Jh(), r.Duplex = Qn(), r.Transform = Yh(), r.PassThrough = _y(), r.finished = ef(), r.pipeline = xy(), r.Stream = r;
  function r() {
    e.call(this);
  }
  return r.prototype.pipe = function(i, o) {
    var n = this;
    function f(m) {
      i.writable && i.write(m) === !1 && n.pause && n.pause();
    }
    n.on("data", f);
    function u() {
      n.readable && n.resume && n.resume();
    }
    i.on("drain", u), !i._isStdio && (!o || o.end !== !1) && (n.on("end", h), n.on("close", s));
    var c = !1;
    function h() {
      c || (c = !0, i.end());
    }
    function s() {
      c || (c = !0, typeof i.destroy == "function" && i.destroy());
    }
    function b(m) {
      if (p(), e.listenerCount(this, "error") === 0)
        throw m;
    }
    n.on("error", b), i.on("error", b);
    function p() {
      n.removeListener("data", f), i.removeListener("drain", u), n.removeListener("end", h), n.removeListener("close", s), n.removeListener("error", b), i.removeListener("error", b), n.removeListener("end", p), n.removeListener("close", p), i.removeListener("close", p);
    }
    return n.on("end", p), n.on("close", p), i.on("close", p), i.emit("pipe", n), i;
  }, gs;
}
var ms = {}, ws = { exports: {} }, _s = {}, Bd;
function My() {
  if (Bd)
    return _s;
  Bd = 1;
  function e(k) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(q) {
      return typeof q;
    } : function(q) {
      return q && typeof Symbol == "function" && q.constructor === Symbol && q !== Symbol.prototype ? "symbol" : typeof q;
    }, e(k);
  }
  function t(k, q) {
    for (var $ = 0; $ < q.length; $++) {
      var re = q[$];
      re.enumerable = re.enumerable || !1, re.configurable = !0, "value" in re && (re.writable = !0), Object.defineProperty(k, i(re.key), re);
    }
  }
  function r(k, q, $) {
    return q && t(k.prototype, q), $ && t(k, $), Object.defineProperty(k, "prototype", { writable: !1 }), k;
  }
  function i(k) {
    var q = o(k, "string");
    return e(q) === "symbol" ? q : String(q);
  }
  function o(k, q) {
    if (e(k) !== "object" || k === null)
      return k;
    var $ = k[Symbol.toPrimitive];
    if ($ !== void 0) {
      var re = $.call(k, q || "default");
      if (e(re) !== "object")
        return re;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (q === "string" ? String : Number)(k);
  }
  function n(k, q) {
    if (!(k instanceof q))
      throw new TypeError("Cannot call a class as a function");
  }
  function f(k, q) {
    if (typeof q != "function" && q !== null)
      throw new TypeError("Super expression must either be null or a function");
    k.prototype = Object.create(q && q.prototype, { constructor: { value: k, writable: !0, configurable: !0 } }), Object.defineProperty(k, "prototype", { writable: !1 }), q && u(k, q);
  }
  function u(k, q) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(re, Q) {
      return re.__proto__ = Q, re;
    }, u(k, q);
  }
  function c(k) {
    var q = b();
    return function() {
      var re = p(k), Q;
      if (q) {
        var fe = p(this).constructor;
        Q = Reflect.construct(re, arguments, fe);
      } else
        Q = re.apply(this, arguments);
      return h(this, Q);
    };
  }
  function h(k, q) {
    if (q && (e(q) === "object" || typeof q == "function"))
      return q;
    if (q !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return s(k);
  }
  function s(k) {
    if (k === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return k;
  }
  function b() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function p(k) {
    return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function($) {
      return $.__proto__ || Object.getPrototypeOf($);
    }, p(k);
  }
  var m = {}, E, M;
  function I(k, q, $) {
    $ || ($ = Error);
    function re(fe, U, y) {
      return typeof q == "string" ? q : q(fe, U, y);
    }
    var Q = /* @__PURE__ */ function(fe) {
      f(y, fe);
      var U = c(y);
      function y(v, a, d) {
        var w;
        return n(this, y), w = U.call(this, re(v, a, d)), w.code = k, w;
      }
      return r(y);
    }($);
    m[k] = Q;
  }
  function B(k, q) {
    if (Array.isArray(k)) {
      var $ = k.length;
      return k = k.map(function(re) {
        return String(re);
      }), $ > 2 ? "one of ".concat(q, " ").concat(k.slice(0, $ - 1).join(", "), ", or ") + k[$ - 1] : $ === 2 ? "one of ".concat(q, " ").concat(k[0], " or ").concat(k[1]) : "of ".concat(q, " ").concat(k[0]);
    } else
      return "of ".concat(q, " ").concat(String(k));
  }
  function T(k, q, $) {
    return k.substr(!$ || $ < 0 ? 0 : +$, q.length) === q;
  }
  function j(k, q, $) {
    return ($ === void 0 || $ > k.length) && ($ = k.length), k.substring($ - q.length, $) === q;
  }
  function N(k, q, $) {
    return typeof $ != "number" && ($ = 0), $ + q.length > k.length ? !1 : k.indexOf(q, $) !== -1;
  }
  return I("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), I("ERR_INVALID_ARG_TYPE", function(k, q, $) {
    E === void 0 && (E = ho()), E(typeof k == "string", "'name' must be a string");
    var re;
    typeof q == "string" && T(q, "not ") ? (re = "must not be", q = q.replace(/^not /, "")) : re = "must be";
    var Q;
    if (j(k, " argument"))
      Q = "The ".concat(k, " ").concat(re, " ").concat(B(q, "type"));
    else {
      var fe = N(k, ".") ? "property" : "argument";
      Q = 'The "'.concat(k, '" ').concat(fe, " ").concat(re, " ").concat(B(q, "type"));
    }
    return Q += ". Received type ".concat(e($)), Q;
  }, TypeError), I("ERR_INVALID_ARG_VALUE", function(k, q) {
    var $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    M === void 0 && (M = gn());
    var re = M.inspect(q);
    return re.length > 128 && (re = "".concat(re.slice(0, 128), "...")), "The argument '".concat(k, "' ").concat($, ". Received ").concat(re);
  }, TypeError), I("ERR_INVALID_RETURN_VALUE", function(k, q, $) {
    var re;
    return $ && $.constructor && $.constructor.name ? re = "instance of ".concat($.constructor.name) : re = "type ".concat(e($)), "Expected ".concat(k, ' to be returned from the "').concat(q, '"') + " function but got ".concat(re, ".");
  }, TypeError), I("ERR_MISSING_ARGS", function() {
    for (var k = arguments.length, q = new Array(k), $ = 0; $ < k; $++)
      q[$] = arguments[$];
    E === void 0 && (E = ho()), E(q.length > 0, "At least one arg needs to be specified");
    var re = "The ", Q = q.length;
    switch (q = q.map(function(fe) {
      return '"'.concat(fe, '"');
    }), Q) {
      case 1:
        re += "".concat(q[0], " argument");
        break;
      case 2:
        re += "".concat(q[0], " and ").concat(q[1], " arguments");
        break;
      default:
        re += q.slice(0, Q - 1).join(", "), re += ", and ".concat(q[Q - 1], " arguments");
        break;
    }
    return "".concat(re, " must be specified");
  }, TypeError), _s.codes = m, _s;
}
var xs, Id;
function ox() {
  if (Id)
    return xs;
  Id = 1;
  function e(S, g) {
    var _ = Object.keys(S);
    if (Object.getOwnPropertySymbols) {
      var l = Object.getOwnPropertySymbols(S);
      g && (l = l.filter(function(R) {
        return Object.getOwnPropertyDescriptor(S, R).enumerable;
      })), _.push.apply(_, l);
    }
    return _;
  }
  function t(S) {
    for (var g = 1; g < arguments.length; g++) {
      var _ = arguments[g] != null ? arguments[g] : {};
      g % 2 ? e(Object(_), !0).forEach(function(l) {
        r(S, l, _[l]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(_)) : e(Object(_)).forEach(function(l) {
        Object.defineProperty(S, l, Object.getOwnPropertyDescriptor(_, l));
      });
    }
    return S;
  }
  function r(S, g, _) {
    return g = f(g), g in S ? Object.defineProperty(S, g, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : S[g] = _, S;
  }
  function i(S, g) {
    if (!(S instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(S, g) {
    for (var _ = 0; _ < g.length; _++) {
      var l = g[_];
      l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(S, f(l.key), l);
    }
  }
  function n(S, g, _) {
    return g && o(S.prototype, g), _ && o(S, _), Object.defineProperty(S, "prototype", { writable: !1 }), S;
  }
  function f(S) {
    var g = u(S, "string");
    return T(g) === "symbol" ? g : String(g);
  }
  function u(S, g) {
    if (T(S) !== "object" || S === null)
      return S;
    var _ = S[Symbol.toPrimitive];
    if (_ !== void 0) {
      var l = _.call(S, g || "default");
      if (T(l) !== "object")
        return l;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(S);
  }
  function c(S, g) {
    if (typeof g != "function" && g !== null)
      throw new TypeError("Super expression must either be null or a function");
    S.prototype = Object.create(g && g.prototype, { constructor: { value: S, writable: !0, configurable: !0 } }), Object.defineProperty(S, "prototype", { writable: !1 }), g && I(S, g);
  }
  function h(S) {
    var g = E();
    return function() {
      var l = B(S), R;
      if (g) {
        var Y = B(this).constructor;
        R = Reflect.construct(l, arguments, Y);
      } else
        R = l.apply(this, arguments);
      return s(this, R);
    };
  }
  function s(S, g) {
    if (g && (T(g) === "object" || typeof g == "function"))
      return g;
    if (g !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return b(S);
  }
  function b(S) {
    if (S === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return S;
  }
  function p(S) {
    var g = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return p = function(l) {
      if (l === null || !M(l))
        return l;
      if (typeof l != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof g < "u") {
        if (g.has(l))
          return g.get(l);
        g.set(l, R);
      }
      function R() {
        return m(l, arguments, B(this).constructor);
      }
      return R.prototype = Object.create(l.prototype, { constructor: { value: R, enumerable: !1, writable: !0, configurable: !0 } }), I(R, l);
    }, p(S);
  }
  function m(S, g, _) {
    return E() ? m = Reflect.construct.bind() : m = function(R, Y, oe) {
      var H = [null];
      H.push.apply(H, Y);
      var V = Function.bind.apply(R, H), F = new V();
      return oe && I(F, oe.prototype), F;
    }, m.apply(null, arguments);
  }
  function E() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function M(S) {
    return Function.toString.call(S).indexOf("[native code]") !== -1;
  }
  function I(S, g) {
    return I = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, R) {
      return l.__proto__ = R, l;
    }, I(S, g);
  }
  function B(S) {
    return B = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(_) {
      return _.__proto__ || Object.getPrototypeOf(_);
    }, B(S);
  }
  function T(S) {
    "@babel/helpers - typeof";
    return T = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
      return typeof g;
    } : function(g) {
      return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
    }, T(S);
  }
  var j = gn(), N = j.inspect, k = My(), q = k.codes.ERR_INVALID_ARG_TYPE;
  function $(S, g, _) {
    return (_ === void 0 || _ > S.length) && (_ = S.length), S.substring(_ - g.length, _) === g;
  }
  function re(S, g) {
    if (g = Math.floor(g), S.length == 0 || g == 0)
      return "";
    var _ = S.length * g;
    for (g = Math.floor(Math.log(g) / Math.log(2)); g; )
      S += S, g--;
    return S += S.substring(0, _ - S.length), S;
  }
  var Q = "", fe = "", U = "", y = "", v = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, a = 10;
  function d(S) {
    var g = Object.keys(S), _ = Object.create(Object.getPrototypeOf(S));
    return g.forEach(function(l) {
      _[l] = S[l];
    }), Object.defineProperty(_, "message", {
      value: S.message
    }), _;
  }
  function w(S) {
    return N(S, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function x(S, g, _) {
    var l = "", R = "", Y = 0, oe = "", H = !1, V = w(S), F = V.split(`
`), te = w(g).split(`
`), he = 0, K = "";
    if (_ === "strictEqual" && T(S) === "object" && T(g) === "object" && S !== null && g !== null && (_ = "strictEqualObject"), F.length === 1 && te.length === 1 && F[0] !== te[0]) {
      var W = F[0].length + te[0].length;
      if (W <= a) {
        if ((T(S) !== "object" || S === null) && (T(g) !== "object" || g === null) && (S !== 0 || g !== 0))
          return "".concat(v[_], `

`) + "".concat(F[0], " !== ").concat(te[0], `
`);
      } else if (_ !== "strictEqualObject") {
        var ce = at.stderr && at.stderr.isTTY ? at.stderr.columns : 80;
        if (W < ce) {
          for (; F[0][he] === te[0][he]; )
            he++;
          he > 2 && (K = `
  `.concat(re(" ", he), "^"), he = 0);
        }
      }
    }
    for (var ve = F[F.length - 1], Be = te[te.length - 1]; ve === Be && (he++ < 2 ? oe = `
  `.concat(ve).concat(oe) : l = ve, F.pop(), te.pop(), !(F.length === 0 || te.length === 0)); )
      ve = F[F.length - 1], Be = te[te.length - 1];
    var ee = Math.max(F.length, te.length);
    if (ee === 0) {
      var C = V.split(`
`);
      if (C.length > 30)
        for (C[26] = "".concat(Q, "...").concat(y); C.length > 27; )
          C.pop();
      return "".concat(v.notIdentical, `

`).concat(C.join(`
`), `
`);
    }
    he > 3 && (oe = `
`.concat(Q, "...").concat(y).concat(oe), H = !0), l !== "" && (oe = `
  `.concat(l).concat(oe), l = "");
    var L = 0, Z = v[_] + `
`.concat(fe, "+ actual").concat(y, " ").concat(U, "- expected").concat(y), de = " ".concat(Q, "...").concat(y, " Lines skipped");
    for (he = 0; he < ee; he++) {
      var me = he - Y;
      if (F.length < he + 1)
        me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(Q, "...").concat(y), H = !0) : me > 3 && (R += `
  `.concat(te[he - 2]), L++), R += `
  `.concat(te[he - 1]), L++), Y = he, l += `
`.concat(U, "-").concat(y, " ").concat(te[he]), L++;
      else if (te.length < he + 1)
        me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(Q, "...").concat(y), H = !0) : me > 3 && (R += `
  `.concat(F[he - 2]), L++), R += `
  `.concat(F[he - 1]), L++), Y = he, R += `
`.concat(fe, "+").concat(y, " ").concat(F[he]), L++;
      else {
        var Te = te[he], ze = F[he], z = ze !== Te && (!$(ze, ",") || ze.slice(0, -1) !== Te);
        z && $(Te, ",") && Te.slice(0, -1) === ze && (z = !1, ze += ","), z ? (me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(Q, "...").concat(y), H = !0) : me > 3 && (R += `
  `.concat(F[he - 2]), L++), R += `
  `.concat(F[he - 1]), L++), Y = he, R += `
`.concat(fe, "+").concat(y, " ").concat(ze), l += `
`.concat(U, "-").concat(y, " ").concat(Te), L += 2) : (R += l, l = "", (me === 1 || he === 0) && (R += `
  `.concat(ze), L++));
      }
      if (L > 20 && he < ee - 2)
        return "".concat(Z).concat(de, `
`).concat(R, `
`).concat(Q, "...").concat(y).concat(l, `
`) + "".concat(Q, "...").concat(y);
    }
    return "".concat(Z).concat(H ? de : "", `
`).concat(R).concat(l).concat(oe).concat(K);
  }
  var A = /* @__PURE__ */ function(S, g) {
    c(l, S);
    var _ = h(l);
    function l(R) {
      var Y;
      if (i(this, l), T(R) !== "object" || R === null)
        throw new q("options", "Object", R);
      var oe = R.message, H = R.operator, V = R.stackStartFn, F = R.actual, te = R.expected, he = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, oe != null)
        Y = _.call(this, String(oe));
      else if (at.stderr && at.stderr.isTTY && (at.stderr && at.stderr.getColorDepth && at.stderr.getColorDepth() !== 1 ? (Q = "\x1B[34m", fe = "\x1B[32m", y = "\x1B[39m", U = "\x1B[31m") : (Q = "", fe = "", y = "", U = "")), T(F) === "object" && F !== null && T(te) === "object" && te !== null && "stack" in F && F instanceof Error && "stack" in te && te instanceof Error && (F = d(F), te = d(te)), H === "deepStrictEqual" || H === "strictEqual")
        Y = _.call(this, x(F, te, H));
      else if (H === "notDeepStrictEqual" || H === "notStrictEqual") {
        var K = v[H], W = w(F).split(`
`);
        if (H === "notStrictEqual" && T(F) === "object" && F !== null && (K = v.notStrictEqualObject), W.length > 30)
          for (W[26] = "".concat(Q, "...").concat(y); W.length > 27; )
            W.pop();
        W.length === 1 ? Y = _.call(this, "".concat(K, " ").concat(W[0])) : Y = _.call(this, "".concat(K, `

`).concat(W.join(`
`), `
`));
      } else {
        var ce = w(F), ve = "", Be = v[H];
        H === "notDeepEqual" || H === "notEqual" ? (ce = "".concat(v[H], `

`).concat(ce), ce.length > 1024 && (ce = "".concat(ce.slice(0, 1021), "..."))) : (ve = "".concat(w(te)), ce.length > 512 && (ce = "".concat(ce.slice(0, 509), "...")), ve.length > 512 && (ve = "".concat(ve.slice(0, 509), "...")), H === "deepEqual" || H === "equal" ? ce = "".concat(Be, `

`).concat(ce, `

should equal

`) : ve = " ".concat(H, " ").concat(ve)), Y = _.call(this, "".concat(ce).concat(ve));
      }
      return Error.stackTraceLimit = he, Y.generatedMessage = !oe, Object.defineProperty(b(Y), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), Y.code = "ERR_ASSERTION", Y.actual = F, Y.expected = te, Y.operator = H, Error.captureStackTrace && Error.captureStackTrace(b(Y), V), Y.stack, Y.name = "AssertionError", s(Y);
    }
    return n(l, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: g,
      value: function(Y, oe) {
        return N(this, t(t({}, oe), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), l;
  }(/* @__PURE__ */ p(Error), N.custom);
  return xs = A, xs;
}
var Es, Td;
function fx() {
  if (Td)
    return Es;
  Td = 1;
  var e = Ph, t = Nh(), r = Qo(), i = Object, o = r("Array.prototype.push"), n = r("Object.prototype.propertyIsEnumerable"), f = t ? Object.getOwnPropertySymbols : null;
  return Es = function(c, h) {
    if (c == null)
      throw new TypeError("target must be an object");
    var s = i(c);
    if (arguments.length === 1)
      return s;
    for (var b = 1; b < arguments.length; ++b) {
      var p = i(arguments[b]), m = e(p), E = t && (Object.getOwnPropertySymbols || f);
      if (E)
        for (var M = E(p), I = 0; I < M.length; ++I) {
          var B = M[I];
          n(p, B) && o(m, B);
        }
      for (var T = 0; T < m.length; ++T) {
        var j = m[T];
        if (n(p, j)) {
          var N = p[j];
          s[j] = N;
        }
      }
    }
    return s;
  }, Es;
}
var Ss, Od;
function sx() {
  if (Od)
    return Ss;
  Od = 1;
  var e = fx(), t = function() {
    if (!Object.assign)
      return !1;
    for (var i = "abcdefghijklmnopqrst", o = i.split(""), n = {}, f = 0; f < o.length; ++f)
      n[o[f]] = o[f];
    var u = Object.assign({}, n), c = "";
    for (var h in u)
      c += h;
    return i !== c;
  }, r = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var i = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(i, "xy");
    } catch {
      return i[1] === "y";
    }
    return !1;
  };
  return Ss = function() {
    return !Object.assign || t() || r() ? e : Object.assign;
  }, Ss;
}
var As, Pd;
function Ry() {
  if (Pd)
    return As;
  Pd = 1;
  var e = function(t) {
    return t !== t;
  };
  return As = function(r, i) {
    return r === 0 && i === 0 ? 1 / r === 1 / i : !!(r === i || e(r) && e(i));
  }, As;
}
var Ms, Cd;
function e0() {
  if (Cd)
    return Ms;
  Cd = 1;
  var e = Ry();
  return Ms = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, Ms;
}
var Rs, Nd;
function rf() {
  if (Nd)
    return Rs;
  Nd = 1;
  var e = Ph, t = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", r = Object.prototype.toString, i = Array.prototype.concat, o = xb, n = function(h) {
    return typeof h == "function" && r.call(h) === "[object Function]";
  }, f = Lh(), u = function(h, s, b, p) {
    if (s in h) {
      if (p === !0) {
        if (h[s] === b)
          return;
      } else if (!n(p) || !p())
        return;
    }
    f ? o(h, s, b, !0) : o(h, s, b);
  }, c = function(h, s) {
    var b = arguments.length > 2 ? arguments[2] : {}, p = e(s);
    t && (p = i.call(p, Object.getOwnPropertySymbols(s)));
    for (var m = 0; m < p.length; m += 1)
      u(h, p[m], s[p[m]], b[p[m]]);
  };
  return c.supportsDescriptors = !!f, Rs = c, Rs;
}
var Bs, Ld;
function ux() {
  if (Ld)
    return Bs;
  Ld = 1;
  var e = e0(), t = rf();
  return Bs = function() {
    var i = e();
    return t(Object, { is: i }, {
      is: function() {
        return Object.is !== i;
      }
    }), i;
  }, Bs;
}
var Is, kd;
function cx() {
  if (kd)
    return Is;
  kd = 1;
  var e = rf(), t = ya, r = Ry(), i = e0(), o = ux(), n = t(i(), Object);
  return e(n, {
    getPolyfill: i,
    implementation: r,
    shim: o
  }), Is = n, Is;
}
var Ts, jd;
function By() {
  return jd || (jd = 1, Ts = function(t) {
    return t !== t;
  }), Ts;
}
var Os, qd;
function Iy() {
  if (qd)
    return Os;
  qd = 1;
  var e = By();
  return Os = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, Os;
}
var Ps, Dd;
function hx() {
  if (Dd)
    return Ps;
  Dd = 1;
  var e = rf(), t = Iy();
  return Ps = function() {
    var i = t();
    return e(Number, { isNaN: i }, {
      isNaN: function() {
        return Number.isNaN !== i;
      }
    }), i;
  }, Ps;
}
var Cs, $d;
function lx() {
  if ($d)
    return Cs;
  $d = 1;
  var e = ya, t = rf(), r = By(), i = Iy(), o = hx(), n = e(i(), Number);
  return t(n, {
    getPolyfill: i,
    implementation: r,
    shim: o
  }), Cs = n, Cs;
}
var Ns, Ud;
function dx() {
  if (Ud)
    return Ns;
  Ud = 1;
  function e(z, ue) {
    return n(z) || o(z, ue) || r(z, ue) || t();
  }
  function t() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function r(z, ue) {
    if (z) {
      if (typeof z == "string")
        return i(z, ue);
      var se = Object.prototype.toString.call(z).slice(8, -1);
      if (se === "Object" && z.constructor && (se = z.constructor.name), se === "Map" || se === "Set")
        return Array.from(z);
      if (se === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(se))
        return i(z, ue);
    }
  }
  function i(z, ue) {
    (ue == null || ue > z.length) && (ue = z.length);
    for (var se = 0, _e = new Array(ue); se < ue; se++)
      _e[se] = z[se];
    return _e;
  }
  function o(z, ue) {
    var se = z == null ? null : typeof Symbol < "u" && z[Symbol.iterator] || z["@@iterator"];
    if (se != null) {
      var _e, Ce, Ve, ke, X = [], Se = !0, Ae = !1;
      try {
        if (Ve = (se = se.call(z)).next, ue === 0) {
          if (Object(se) !== se)
            return;
          Se = !1;
        } else
          for (; !(Se = (_e = Ve.call(se)).done) && (X.push(_e.value), X.length !== ue); Se = !0)
            ;
      } catch (qe) {
        Ae = !0, Ce = qe;
      } finally {
        try {
          if (!Se && se.return != null && (ke = se.return(), Object(ke) !== ke))
            return;
        } finally {
          if (Ae)
            throw Ce;
        }
      }
      return X;
    }
  }
  function n(z) {
    if (Array.isArray(z))
      return z;
  }
  function f(z) {
    "@babel/helpers - typeof";
    return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
      return typeof ue;
    } : function(ue) {
      return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
    }, f(z);
  }
  var u = /a/g.flags !== void 0, c = function(ue) {
    var se = [];
    return ue.forEach(function(_e) {
      return se.push(_e);
    }), se;
  }, h = function(ue) {
    var se = [];
    return ue.forEach(function(_e, Ce) {
      return se.push([Ce, _e]);
    }), se;
  }, s = Object.is ? Object.is : cx(), b = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, p = Number.isNaN ? Number.isNaN : lx();
  function m(z) {
    return z.call.bind(z);
  }
  var E = m(Object.prototype.hasOwnProperty), M = m(Object.prototype.propertyIsEnumerable), I = m(Object.prototype.toString), B = gn().types, T = B.isAnyArrayBuffer, j = B.isArrayBufferView, N = B.isDate, k = B.isMap, q = B.isRegExp, $ = B.isSet, re = B.isNativeError, Q = B.isBoxedPrimitive, fe = B.isNumberObject, U = B.isStringObject, y = B.isBooleanObject, v = B.isBigIntObject, a = B.isSymbolObject, d = B.isFloat32Array, w = B.isFloat64Array;
  function x(z) {
    if (z.length === 0 || z.length > 10)
      return !0;
    for (var ue = 0; ue < z.length; ue++) {
      var se = z.charCodeAt(ue);
      if (se < 48 || se > 57)
        return !0;
    }
    return z.length === 10 && z >= Math.pow(2, 32);
  }
  function A(z) {
    return Object.keys(z).filter(x).concat(b(z).filter(Object.prototype.propertyIsEnumerable.bind(z)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function S(z, ue) {
    if (z === ue)
      return 0;
    for (var se = z.length, _e = ue.length, Ce = 0, Ve = Math.min(se, _e); Ce < Ve; ++Ce)
      if (z[Ce] !== ue[Ce]) {
        se = z[Ce], _e = ue[Ce];
        break;
      }
    return se < _e ? -1 : _e < se ? 1 : 0;
  }
  var g = !0, _ = !1, l = 0, R = 1, Y = 2, oe = 3;
  function H(z, ue) {
    return u ? z.source === ue.source && z.flags === ue.flags : RegExp.prototype.toString.call(z) === RegExp.prototype.toString.call(ue);
  }
  function V(z, ue) {
    if (z.byteLength !== ue.byteLength)
      return !1;
    for (var se = 0; se < z.byteLength; se++)
      if (z[se] !== ue[se])
        return !1;
    return !0;
  }
  function F(z, ue) {
    return z.byteLength !== ue.byteLength ? !1 : S(new Uint8Array(z.buffer, z.byteOffset, z.byteLength), new Uint8Array(ue.buffer, ue.byteOffset, ue.byteLength)) === 0;
  }
  function te(z, ue) {
    return z.byteLength === ue.byteLength && S(new Uint8Array(z), new Uint8Array(ue)) === 0;
  }
  function he(z, ue) {
    return fe(z) ? fe(ue) && s(Number.prototype.valueOf.call(z), Number.prototype.valueOf.call(ue)) : U(z) ? U(ue) && String.prototype.valueOf.call(z) === String.prototype.valueOf.call(ue) : y(z) ? y(ue) && Boolean.prototype.valueOf.call(z) === Boolean.prototype.valueOf.call(ue) : v(z) ? v(ue) && BigInt.prototype.valueOf.call(z) === BigInt.prototype.valueOf.call(ue) : a(ue) && Symbol.prototype.valueOf.call(z) === Symbol.prototype.valueOf.call(ue);
  }
  function K(z, ue, se, _e) {
    if (z === ue)
      return z !== 0 ? !0 : se ? s(z, ue) : !0;
    if (se) {
      if (f(z) !== "object")
        return typeof z == "number" && p(z) && p(ue);
      if (f(ue) !== "object" || z === null || ue === null || Object.getPrototypeOf(z) !== Object.getPrototypeOf(ue))
        return !1;
    } else {
      if (z === null || f(z) !== "object")
        return ue === null || f(ue) !== "object" ? z == ue : !1;
      if (ue === null || f(ue) !== "object")
        return !1;
    }
    var Ce = I(z), Ve = I(ue);
    if (Ce !== Ve)
      return !1;
    if (Array.isArray(z)) {
      if (z.length !== ue.length)
        return !1;
      var ke = A(z), X = A(ue);
      return ke.length !== X.length ? !1 : ce(z, ue, se, _e, R, ke);
    }
    if (Ce === "[object Object]" && (!k(z) && k(ue) || !$(z) && $(ue)))
      return !1;
    if (N(z)) {
      if (!N(ue) || Date.prototype.getTime.call(z) !== Date.prototype.getTime.call(ue))
        return !1;
    } else if (q(z)) {
      if (!q(ue) || !H(z, ue))
        return !1;
    } else if (re(z) || z instanceof Error) {
      if (z.message !== ue.message || z.name !== ue.name)
        return !1;
    } else if (j(z)) {
      if (!se && (d(z) || w(z))) {
        if (!V(z, ue))
          return !1;
      } else if (!F(z, ue))
        return !1;
      var Se = A(z), Ae = A(ue);
      return Se.length !== Ae.length ? !1 : ce(z, ue, se, _e, l, Se);
    } else {
      if ($(z))
        return !$(ue) || z.size !== ue.size ? !1 : ce(z, ue, se, _e, Y);
      if (k(z))
        return !k(ue) || z.size !== ue.size ? !1 : ce(z, ue, se, _e, oe);
      if (T(z)) {
        if (!te(z, ue))
          return !1;
      } else if (Q(z) && !he(z, ue))
        return !1;
    }
    return ce(z, ue, se, _e, l);
  }
  function W(z, ue) {
    return ue.filter(function(se) {
      return M(z, se);
    });
  }
  function ce(z, ue, se, _e, Ce, Ve) {
    if (arguments.length === 5) {
      Ve = Object.keys(z);
      var ke = Object.keys(ue);
      if (Ve.length !== ke.length)
        return !1;
    }
    for (var X = 0; X < Ve.length; X++)
      if (!E(ue, Ve[X]))
        return !1;
    if (se && arguments.length === 5) {
      var Se = b(z);
      if (Se.length !== 0) {
        var Ae = 0;
        for (X = 0; X < Se.length; X++) {
          var qe = Se[X];
          if (M(z, qe)) {
            if (!M(ue, qe))
              return !1;
            Ve.push(qe), Ae++;
          } else if (M(ue, qe))
            return !1;
        }
        var pe = b(ue);
        if (Se.length !== pe.length && W(ue, pe).length !== Ae)
          return !1;
      } else {
        var Ee = b(ue);
        if (Ee.length !== 0 && W(ue, Ee).length !== 0)
          return !1;
      }
    }
    if (Ve.length === 0 && (Ce === l || Ce === R && z.length === 0 || z.size === 0))
      return !0;
    if (_e === void 0)
      _e = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var G = _e.val1.get(z);
      if (G !== void 0) {
        var Ie = _e.val2.get(ue);
        if (Ie !== void 0)
          return G === Ie;
      }
      _e.position++;
    }
    _e.val1.set(z, _e.position), _e.val2.set(ue, _e.position);
    var je = me(z, ue, se, Ve, _e, Ce);
    return _e.val1.delete(z), _e.val2.delete(ue), je;
  }
  function ve(z, ue, se, _e) {
    for (var Ce = c(z), Ve = 0; Ve < Ce.length; Ve++) {
      var ke = Ce[Ve];
      if (K(ue, ke, se, _e))
        return z.delete(ke), !0;
    }
    return !1;
  }
  function Be(z) {
    switch (f(z)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        z = +z;
      case "number":
        if (p(z))
          return !1;
    }
    return !0;
  }
  function ee(z, ue, se) {
    var _e = Be(se);
    return _e ?? (ue.has(_e) && !z.has(_e));
  }
  function C(z, ue, se, _e, Ce) {
    var Ve = Be(se);
    if (Ve != null)
      return Ve;
    var ke = ue.get(Ve);
    return ke === void 0 && !ue.has(Ve) || !K(_e, ke, !1, Ce) ? !1 : !z.has(Ve) && K(_e, ke, !1, Ce);
  }
  function L(z, ue, se, _e) {
    for (var Ce = null, Ve = c(z), ke = 0; ke < Ve.length; ke++) {
      var X = Ve[ke];
      if (f(X) === "object" && X !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(X);
      else if (!ue.has(X)) {
        if (se || !ee(z, ue, X))
          return !1;
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(X);
      }
    }
    if (Ce !== null) {
      for (var Se = c(ue), Ae = 0; Ae < Se.length; Ae++) {
        var qe = Se[Ae];
        if (f(qe) === "object" && qe !== null) {
          if (!ve(Ce, qe, se, _e))
            return !1;
        } else if (!se && !z.has(qe) && !ve(Ce, qe, se, _e))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function Z(z, ue, se, _e, Ce, Ve) {
    for (var ke = c(z), X = 0; X < ke.length; X++) {
      var Se = ke[X];
      if (K(se, Se, Ce, Ve) && K(_e, ue.get(Se), Ce, Ve))
        return z.delete(Se), !0;
    }
    return !1;
  }
  function de(z, ue, se, _e) {
    for (var Ce = null, Ve = h(z), ke = 0; ke < Ve.length; ke++) {
      var X = e(Ve[ke], 2), Se = X[0], Ae = X[1];
      if (f(Se) === "object" && Se !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Se);
      else {
        var qe = ue.get(Se);
        if (qe === void 0 && !ue.has(Se) || !K(Ae, qe, se, _e)) {
          if (se || !C(z, ue, Se, Ae, _e))
            return !1;
          Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Se);
        }
      }
    }
    if (Ce !== null) {
      for (var pe = h(ue), Ee = 0; Ee < pe.length; Ee++) {
        var G = e(pe[Ee], 2), Ie = G[0], je = G[1];
        if (f(Ie) === "object" && Ie !== null) {
          if (!Z(Ce, z, Ie, je, se, _e))
            return !1;
        } else if (!se && (!z.has(Ie) || !K(z.get(Ie), je, !1, _e)) && !Z(Ce, z, Ie, je, !1, _e))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function me(z, ue, se, _e, Ce, Ve) {
    var ke = 0;
    if (Ve === Y) {
      if (!L(z, ue, se, Ce))
        return !1;
    } else if (Ve === oe) {
      if (!de(z, ue, se, Ce))
        return !1;
    } else if (Ve === R)
      for (; ke < z.length; ke++)
        if (E(z, ke)) {
          if (!E(ue, ke) || !K(z[ke], ue[ke], se, Ce))
            return !1;
        } else {
          if (E(ue, ke))
            return !1;
          for (var X = Object.keys(z); ke < X.length; ke++) {
            var Se = X[ke];
            if (!E(ue, Se) || !K(z[Se], ue[Se], se, Ce))
              return !1;
          }
          return X.length === Object.keys(ue).length;
        }
    for (ke = 0; ke < _e.length; ke++) {
      var Ae = _e[ke];
      if (!K(z[Ae], ue[Ae], se, Ce))
        return !1;
    }
    return !0;
  }
  function Te(z, ue) {
    return K(z, ue, _);
  }
  function ze(z, ue) {
    return K(z, ue, g);
  }
  return Ns = {
    isDeepEqual: Te,
    isDeepStrictEqual: ze
  }, Ns;
}
var Fd;
function ho() {
  if (Fd)
    return ws.exports;
  Fd = 1;
  function e(V) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
      return typeof F;
    } : function(F) {
      return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
    }, e(V);
  }
  function t(V, F) {
    for (var te = 0; te < F.length; te++) {
      var he = F[te];
      he.enumerable = he.enumerable || !1, he.configurable = !0, "value" in he && (he.writable = !0), Object.defineProperty(V, i(he.key), he);
    }
  }
  function r(V, F, te) {
    return F && t(V.prototype, F), te && t(V, te), Object.defineProperty(V, "prototype", { writable: !1 }), V;
  }
  function i(V) {
    var F = o(V, "string");
    return e(F) === "symbol" ? F : String(F);
  }
  function o(V, F) {
    if (e(V) !== "object" || V === null)
      return V;
    var te = V[Symbol.toPrimitive];
    if (te !== void 0) {
      var he = te.call(V, F || "default");
      if (e(he) !== "object")
        return he;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (F === "string" ? String : Number)(V);
  }
  function n(V, F) {
    if (!(V instanceof F))
      throw new TypeError("Cannot call a class as a function");
  }
  var f = My(), u = f.codes, c = u.ERR_AMBIGUOUS_ARGUMENT, h = u.ERR_INVALID_ARG_TYPE, s = u.ERR_INVALID_ARG_VALUE, b = u.ERR_INVALID_RETURN_VALUE, p = u.ERR_MISSING_ARGS, m = ox(), E = gn(), M = E.inspect, I = gn().types, B = I.isPromise, T = I.isRegExp, j = sx()(), N = e0()(), k = Qo()("RegExp.prototype.test"), q, $;
  function re() {
    var V = dx();
    q = V.isDeepEqual, $ = V.isDeepStrictEqual;
  }
  var Q = !1, fe = ws.exports = d, U = {};
  function y(V) {
    throw V.message instanceof Error ? V.message : new m(V);
  }
  function v(V, F, te, he, K) {
    var W = arguments.length, ce;
    if (W === 0)
      ce = "Failed";
    else if (W === 1)
      te = V, V = void 0;
    else {
      if (Q === !1) {
        Q = !0;
        var ve = at.emitWarning ? at.emitWarning : console.warn.bind(console);
        ve("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      W === 2 && (he = "!=");
    }
    if (te instanceof Error)
      throw te;
    var Be = {
      actual: V,
      expected: F,
      operator: he === void 0 ? "fail" : he,
      stackStartFn: K || v
    };
    te !== void 0 && (Be.message = te);
    var ee = new m(Be);
    throw ce && (ee.message = ce, ee.generatedMessage = !0), ee;
  }
  fe.fail = v, fe.AssertionError = m;
  function a(V, F, te, he) {
    if (!te) {
      var K = !1;
      if (F === 0)
        K = !0, he = "No value argument passed to `assert.ok()`";
      else if (he instanceof Error)
        throw he;
      var W = new m({
        actual: te,
        expected: !0,
        message: he,
        operator: "==",
        stackStartFn: V
      });
      throw W.generatedMessage = K, W;
    }
  }
  function d() {
    for (var V = arguments.length, F = new Array(V), te = 0; te < V; te++)
      F[te] = arguments[te];
    a.apply(void 0, [d, F.length].concat(F));
  }
  fe.ok = d, fe.equal = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    F != te && y({
      actual: F,
      expected: te,
      message: he,
      operator: "==",
      stackStartFn: V
    });
  }, fe.notEqual = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    F == te && y({
      actual: F,
      expected: te,
      message: he,
      operator: "!=",
      stackStartFn: V
    });
  }, fe.deepEqual = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    q === void 0 && re(), q(F, te) || y({
      actual: F,
      expected: te,
      message: he,
      operator: "deepEqual",
      stackStartFn: V
    });
  }, fe.notDeepEqual = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    q === void 0 && re(), q(F, te) && y({
      actual: F,
      expected: te,
      message: he,
      operator: "notDeepEqual",
      stackStartFn: V
    });
  }, fe.deepStrictEqual = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    q === void 0 && re(), $(F, te) || y({
      actual: F,
      expected: te,
      message: he,
      operator: "deepStrictEqual",
      stackStartFn: V
    });
  }, fe.notDeepStrictEqual = w;
  function w(V, F, te) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    q === void 0 && re(), $(V, F) && y({
      actual: V,
      expected: F,
      message: te,
      operator: "notDeepStrictEqual",
      stackStartFn: w
    });
  }
  fe.strictEqual = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    N(F, te) || y({
      actual: F,
      expected: te,
      message: he,
      operator: "strictEqual",
      stackStartFn: V
    });
  }, fe.notStrictEqual = function V(F, te, he) {
    if (arguments.length < 2)
      throw new p("actual", "expected");
    N(F, te) && y({
      actual: F,
      expected: te,
      message: he,
      operator: "notStrictEqual",
      stackStartFn: V
    });
  };
  var x = /* @__PURE__ */ r(function V(F, te, he) {
    var K = this;
    n(this, V), te.forEach(function(W) {
      W in F && (he !== void 0 && typeof he[W] == "string" && T(F[W]) && k(F[W], he[W]) ? K[W] = he[W] : K[W] = F[W]);
    });
  });
  function A(V, F, te, he, K, W) {
    if (!(te in V) || !$(V[te], F[te])) {
      if (!he) {
        var ce = new x(V, K), ve = new x(F, K, V), Be = new m({
          actual: ce,
          expected: ve,
          operator: "deepStrictEqual",
          stackStartFn: W
        });
        throw Be.actual = V, Be.expected = F, Be.operator = W.name, Be;
      }
      y({
        actual: V,
        expected: F,
        message: he,
        operator: W.name,
        stackStartFn: W
      });
    }
  }
  function S(V, F, te, he) {
    if (typeof F != "function") {
      if (T(F))
        return k(F, V);
      if (arguments.length === 2)
        throw new h("expected", ["Function", "RegExp"], F);
      if (e(V) !== "object" || V === null) {
        var K = new m({
          actual: V,
          expected: F,
          message: te,
          operator: "deepStrictEqual",
          stackStartFn: he
        });
        throw K.operator = he.name, K;
      }
      var W = Object.keys(F);
      if (F instanceof Error)
        W.push("name", "message");
      else if (W.length === 0)
        throw new s("error", F, "may not be an empty object");
      return q === void 0 && re(), W.forEach(function(ce) {
        typeof V[ce] == "string" && T(F[ce]) && k(F[ce], V[ce]) || A(V, F, ce, te, W, he);
      }), !0;
    }
    return F.prototype !== void 0 && V instanceof F ? !0 : Error.isPrototypeOf(F) ? !1 : F.call({}, V) === !0;
  }
  function g(V) {
    if (typeof V != "function")
      throw new h("fn", "Function", V);
    try {
      V();
    } catch (F) {
      return F;
    }
    return U;
  }
  function _(V) {
    return B(V) || V !== null && e(V) === "object" && typeof V.then == "function" && typeof V.catch == "function";
  }
  function l(V) {
    return Promise.resolve().then(function() {
      var F;
      if (typeof V == "function") {
        if (F = V(), !_(F))
          throw new b("instance of Promise", "promiseFn", F);
      } else if (_(V))
        F = V;
      else
        throw new h("promiseFn", ["Function", "Promise"], V);
      return Promise.resolve().then(function() {
        return F;
      }).then(function() {
        return U;
      }).catch(function(te) {
        return te;
      });
    });
  }
  function R(V, F, te, he) {
    if (typeof te == "string") {
      if (arguments.length === 4)
        throw new h("error", ["Object", "Error", "Function", "RegExp"], te);
      if (e(F) === "object" && F !== null) {
        if (F.message === te)
          throw new c("error/message", 'The error message "'.concat(F.message, '" is identical to the message.'));
      } else if (F === te)
        throw new c("error/message", 'The error "'.concat(F, '" is identical to the message.'));
      he = te, te = void 0;
    } else if (te != null && e(te) !== "object" && typeof te != "function")
      throw new h("error", ["Object", "Error", "Function", "RegExp"], te);
    if (F === U) {
      var K = "";
      te && te.name && (K += " (".concat(te.name, ")")), K += he ? ": ".concat(he) : ".";
      var W = V.name === "rejects" ? "rejection" : "exception";
      y({
        actual: void 0,
        expected: te,
        operator: V.name,
        message: "Missing expected ".concat(W).concat(K),
        stackStartFn: V
      });
    }
    if (te && !S(F, te, he, V))
      throw F;
  }
  function Y(V, F, te, he) {
    if (F !== U) {
      if (typeof te == "string" && (he = te, te = void 0), !te || S(F, te)) {
        var K = he ? ": ".concat(he) : ".", W = V.name === "doesNotReject" ? "rejection" : "exception";
        y({
          actual: F,
          expected: te,
          operator: V.name,
          message: "Got unwanted ".concat(W).concat(K, `
`) + 'Actual message: "'.concat(F && F.message, '"'),
          stackStartFn: V
        });
      }
      throw F;
    }
  }
  fe.throws = function V(F) {
    for (var te = arguments.length, he = new Array(te > 1 ? te - 1 : 0), K = 1; K < te; K++)
      he[K - 1] = arguments[K];
    R.apply(void 0, [V, g(F)].concat(he));
  }, fe.rejects = function V(F) {
    for (var te = arguments.length, he = new Array(te > 1 ? te - 1 : 0), K = 1; K < te; K++)
      he[K - 1] = arguments[K];
    return l(F).then(function(W) {
      return R.apply(void 0, [V, W].concat(he));
    });
  }, fe.doesNotThrow = function V(F) {
    for (var te = arguments.length, he = new Array(te > 1 ? te - 1 : 0), K = 1; K < te; K++)
      he[K - 1] = arguments[K];
    Y.apply(void 0, [V, g(F)].concat(he));
  }, fe.doesNotReject = function V(F) {
    for (var te = arguments.length, he = new Array(te > 1 ? te - 1 : 0), K = 1; K < te; K++)
      he[K - 1] = arguments[K];
    return l(F).then(function(W) {
      return Y.apply(void 0, [V, W].concat(he));
    });
  }, fe.ifError = function V(F) {
    if (F != null) {
      var te = "ifError got unwanted exception: ";
      e(F) === "object" && typeof F.message == "string" ? F.message.length === 0 && F.constructor ? te += F.constructor.name : te += F.message : te += M(F);
      var he = new m({
        actual: F,
        expected: null,
        operator: "ifError",
        message: te,
        stackStartFn: V
      }), K = F.stack;
      if (typeof K == "string") {
        var W = K.split(`
`);
        W.shift();
        for (var ce = he.stack.split(`
`), ve = 0; ve < W.length; ve++) {
          var Be = ce.indexOf(W[ve]);
          if (Be !== -1) {
            ce = ce.slice(0, Be);
            break;
          }
        }
        he.stack = "".concat(ce.join(`
`), `
`).concat(W.join(`
`));
      }
      throw he;
    }
  };
  function oe(V, F, te, he, K) {
    if (!T(F))
      throw new h("regexp", "RegExp", F);
    var W = K === "match";
    if (typeof V != "string" || k(F, V) !== W) {
      if (te instanceof Error)
        throw te;
      var ce = !te;
      te = te || (typeof V != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(V), " (").concat(M(V), ")") : (W ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(M(F), `. Input:

`).concat(M(V), `
`));
      var ve = new m({
        actual: V,
        expected: F,
        message: te,
        operator: K,
        stackStartFn: he
      });
      throw ve.generatedMessage = ce, ve;
    }
  }
  fe.match = function V(F, te, he) {
    oe(F, te, he, V, "match");
  }, fe.doesNotMatch = function V(F, te, he) {
    oe(F, te, he, V, "doesNotMatch");
  };
  function H() {
    for (var V = arguments.length, F = new Array(V), te = 0; te < V; te++)
      F[te] = arguments[te];
    a.apply(void 0, [H, F.length].concat(F));
  }
  return fe.strict = j(H, fe, {
    equal: fe.strictEqual,
    deepEqual: fe.deepStrictEqual,
    notEqual: fe.notStrictEqual,
    notDeepEqual: fe.notDeepStrictEqual
  }), fe.strict.strict = fe.strict, ws.exports;
}
var Ls, zd;
function px() {
  if (zd)
    return Ls;
  zd = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return Ls = e, Ls;
}
var Fr = {}, ks = {}, Hd;
function nf() {
  return Hd || (Hd = 1, function(e) {
    var t = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function r(n, f) {
      return Object.prototype.hasOwnProperty.call(n, f);
    }
    e.assign = function(n) {
      for (var f = Array.prototype.slice.call(arguments, 1); f.length; ) {
        var u = f.shift();
        if (u) {
          if (typeof u != "object")
            throw new TypeError(u + "must be non-object");
          for (var c in u)
            r(u, c) && (n[c] = u[c]);
        }
      }
      return n;
    }, e.shrinkBuf = function(n, f) {
      return n.length === f ? n : n.subarray ? n.subarray(0, f) : (n.length = f, n);
    };
    var i = {
      arraySet: function(n, f, u, c, h) {
        if (f.subarray && n.subarray) {
          n.set(f.subarray(u, u + c), h);
          return;
        }
        for (var s = 0; s < c; s++)
          n[h + s] = f[u + s];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        var f, u, c, h, s, b;
        for (c = 0, f = 0, u = n.length; f < u; f++)
          c += n[f].length;
        for (b = new Uint8Array(c), h = 0, f = 0, u = n.length; f < u; f++)
          s = n[f], b.set(s, h), h += s.length;
        return b;
      }
    }, o = {
      arraySet: function(n, f, u, c, h) {
        for (var s = 0; s < c; s++)
          n[h + s] = f[u + s];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        return [].concat.apply([], n);
      }
    };
    e.setTyped = function(n) {
      n ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, o));
    }, e.setTyped(t);
  }(ks)), ks;
}
var kn = {}, Vd;
function vx() {
  if (Vd)
    return kn;
  Vd = 1;
  var e = nf(), t = 4, r = 0, i = 1, o = 2;
  function n(X) {
    for (var Se = X.length; --Se >= 0; )
      X[Se] = 0;
  }
  var f = 0, u = 1, c = 2, h = 3, s = 258, b = 29, p = 256, m = p + 1 + b, E = 30, M = 19, I = 2 * m + 1, B = 15, T = 16, j = 7, N = 256, k = 16, q = 17, $ = 18, re = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), Q = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), fe = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), U = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], y = 512, v = new Array((m + 2) * 2);
  n(v);
  var a = new Array(E * 2);
  n(a);
  var d = new Array(y);
  n(d);
  var w = new Array(s - h + 1);
  n(w);
  var x = new Array(b);
  n(x);
  var A = new Array(E);
  n(A);
  function S(X, Se, Ae, qe, pe) {
    this.static_tree = X, this.extra_bits = Se, this.extra_base = Ae, this.elems = qe, this.max_length = pe, this.has_stree = X && X.length;
  }
  var g, _, l;
  function R(X, Se) {
    this.dyn_tree = X, this.max_code = 0, this.stat_desc = Se;
  }
  function Y(X) {
    return X < 256 ? d[X] : d[256 + (X >>> 7)];
  }
  function oe(X, Se) {
    X.pending_buf[X.pending++] = Se & 255, X.pending_buf[X.pending++] = Se >>> 8 & 255;
  }
  function H(X, Se, Ae) {
    X.bi_valid > T - Ae ? (X.bi_buf |= Se << X.bi_valid & 65535, oe(X, X.bi_buf), X.bi_buf = Se >> T - X.bi_valid, X.bi_valid += Ae - T) : (X.bi_buf |= Se << X.bi_valid & 65535, X.bi_valid += Ae);
  }
  function V(X, Se, Ae) {
    H(
      X,
      Ae[Se * 2],
      Ae[Se * 2 + 1]
      /*.Len*/
    );
  }
  function F(X, Se) {
    var Ae = 0;
    do
      Ae |= X & 1, X >>>= 1, Ae <<= 1;
    while (--Se > 0);
    return Ae >>> 1;
  }
  function te(X) {
    X.bi_valid === 16 ? (oe(X, X.bi_buf), X.bi_buf = 0, X.bi_valid = 0) : X.bi_valid >= 8 && (X.pending_buf[X.pending++] = X.bi_buf & 255, X.bi_buf >>= 8, X.bi_valid -= 8);
  }
  function he(X, Se) {
    var Ae = Se.dyn_tree, qe = Se.max_code, pe = Se.stat_desc.static_tree, Ee = Se.stat_desc.has_stree, G = Se.stat_desc.extra_bits, Ie = Se.stat_desc.extra_base, je = Se.stat_desc.max_length, P, Me, be, ie, le, ge, Ge = 0;
    for (ie = 0; ie <= B; ie++)
      X.bl_count[ie] = 0;
    for (Ae[X.heap[X.heap_max] * 2 + 1] = 0, P = X.heap_max + 1; P < I; P++)
      Me = X.heap[P], ie = Ae[Ae[Me * 2 + 1] * 2 + 1] + 1, ie > je && (ie = je, Ge++), Ae[Me * 2 + 1] = ie, !(Me > qe) && (X.bl_count[ie]++, le = 0, Me >= Ie && (le = G[Me - Ie]), ge = Ae[Me * 2], X.opt_len += ge * (ie + le), Ee && (X.static_len += ge * (pe[Me * 2 + 1] + le)));
    if (Ge !== 0) {
      do {
        for (ie = je - 1; X.bl_count[ie] === 0; )
          ie--;
        X.bl_count[ie]--, X.bl_count[ie + 1] += 2, X.bl_count[je]--, Ge -= 2;
      } while (Ge > 0);
      for (ie = je; ie !== 0; ie--)
        for (Me = X.bl_count[ie]; Me !== 0; )
          be = X.heap[--P], !(be > qe) && (Ae[be * 2 + 1] !== ie && (X.opt_len += (ie - Ae[be * 2 + 1]) * Ae[be * 2], Ae[be * 2 + 1] = ie), Me--);
    }
  }
  function K(X, Se, Ae) {
    var qe = new Array(B + 1), pe = 0, Ee, G;
    for (Ee = 1; Ee <= B; Ee++)
      qe[Ee] = pe = pe + Ae[Ee - 1] << 1;
    for (G = 0; G <= Se; G++) {
      var Ie = X[G * 2 + 1];
      Ie !== 0 && (X[G * 2] = F(qe[Ie]++, Ie));
    }
  }
  function W() {
    var X, Se, Ae, qe, pe, Ee = new Array(B + 1);
    for (Ae = 0, qe = 0; qe < b - 1; qe++)
      for (x[qe] = Ae, X = 0; X < 1 << re[qe]; X++)
        w[Ae++] = qe;
    for (w[Ae - 1] = qe, pe = 0, qe = 0; qe < 16; qe++)
      for (A[qe] = pe, X = 0; X < 1 << Q[qe]; X++)
        d[pe++] = qe;
    for (pe >>= 7; qe < E; qe++)
      for (A[qe] = pe << 7, X = 0; X < 1 << Q[qe] - 7; X++)
        d[256 + pe++] = qe;
    for (Se = 0; Se <= B; Se++)
      Ee[Se] = 0;
    for (X = 0; X <= 143; )
      v[X * 2 + 1] = 8, X++, Ee[8]++;
    for (; X <= 255; )
      v[X * 2 + 1] = 9, X++, Ee[9]++;
    for (; X <= 279; )
      v[X * 2 + 1] = 7, X++, Ee[7]++;
    for (; X <= 287; )
      v[X * 2 + 1] = 8, X++, Ee[8]++;
    for (K(v, m + 1, Ee), X = 0; X < E; X++)
      a[X * 2 + 1] = 5, a[X * 2] = F(X, 5);
    g = new S(v, re, p + 1, m, B), _ = new S(a, Q, 0, E, B), l = new S(new Array(0), fe, 0, M, j);
  }
  function ce(X) {
    var Se;
    for (Se = 0; Se < m; Se++)
      X.dyn_ltree[Se * 2] = 0;
    for (Se = 0; Se < E; Se++)
      X.dyn_dtree[Se * 2] = 0;
    for (Se = 0; Se < M; Se++)
      X.bl_tree[Se * 2] = 0;
    X.dyn_ltree[N * 2] = 1, X.opt_len = X.static_len = 0, X.last_lit = X.matches = 0;
  }
  function ve(X) {
    X.bi_valid > 8 ? oe(X, X.bi_buf) : X.bi_valid > 0 && (X.pending_buf[X.pending++] = X.bi_buf), X.bi_buf = 0, X.bi_valid = 0;
  }
  function Be(X, Se, Ae, qe) {
    ve(X), qe && (oe(X, Ae), oe(X, ~Ae)), e.arraySet(X.pending_buf, X.window, Se, Ae, X.pending), X.pending += Ae;
  }
  function ee(X, Se, Ae, qe) {
    var pe = Se * 2, Ee = Ae * 2;
    return X[pe] < X[Ee] || X[pe] === X[Ee] && qe[Se] <= qe[Ae];
  }
  function C(X, Se, Ae) {
    for (var qe = X.heap[Ae], pe = Ae << 1; pe <= X.heap_len && (pe < X.heap_len && ee(Se, X.heap[pe + 1], X.heap[pe], X.depth) && pe++, !ee(Se, qe, X.heap[pe], X.depth)); )
      X.heap[Ae] = X.heap[pe], Ae = pe, pe <<= 1;
    X.heap[Ae] = qe;
  }
  function L(X, Se, Ae) {
    var qe, pe, Ee = 0, G, Ie;
    if (X.last_lit !== 0)
      do
        qe = X.pending_buf[X.d_buf + Ee * 2] << 8 | X.pending_buf[X.d_buf + Ee * 2 + 1], pe = X.pending_buf[X.l_buf + Ee], Ee++, qe === 0 ? V(X, pe, Se) : (G = w[pe], V(X, G + p + 1, Se), Ie = re[G], Ie !== 0 && (pe -= x[G], H(X, pe, Ie)), qe--, G = Y(qe), V(X, G, Ae), Ie = Q[G], Ie !== 0 && (qe -= A[G], H(X, qe, Ie)));
      while (Ee < X.last_lit);
    V(X, N, Se);
  }
  function Z(X, Se) {
    var Ae = Se.dyn_tree, qe = Se.stat_desc.static_tree, pe = Se.stat_desc.has_stree, Ee = Se.stat_desc.elems, G, Ie, je = -1, P;
    for (X.heap_len = 0, X.heap_max = I, G = 0; G < Ee; G++)
      Ae[G * 2] !== 0 ? (X.heap[++X.heap_len] = je = G, X.depth[G] = 0) : Ae[G * 2 + 1] = 0;
    for (; X.heap_len < 2; )
      P = X.heap[++X.heap_len] = je < 2 ? ++je : 0, Ae[P * 2] = 1, X.depth[P] = 0, X.opt_len--, pe && (X.static_len -= qe[P * 2 + 1]);
    for (Se.max_code = je, G = X.heap_len >> 1; G >= 1; G--)
      C(X, Ae, G);
    P = Ee;
    do
      G = X.heap[
        1
        /*SMALLEST*/
      ], X.heap[
        1
        /*SMALLEST*/
      ] = X.heap[X.heap_len--], C(
        X,
        Ae,
        1
        /*SMALLEST*/
      ), Ie = X.heap[
        1
        /*SMALLEST*/
      ], X.heap[--X.heap_max] = G, X.heap[--X.heap_max] = Ie, Ae[P * 2] = Ae[G * 2] + Ae[Ie * 2], X.depth[P] = (X.depth[G] >= X.depth[Ie] ? X.depth[G] : X.depth[Ie]) + 1, Ae[G * 2 + 1] = Ae[Ie * 2 + 1] = P, X.heap[
        1
        /*SMALLEST*/
      ] = P++, C(
        X,
        Ae,
        1
        /*SMALLEST*/
      );
    while (X.heap_len >= 2);
    X.heap[--X.heap_max] = X.heap[
      1
      /*SMALLEST*/
    ], he(X, Se), K(Ae, je, X.bl_count);
  }
  function de(X, Se, Ae) {
    var qe, pe = -1, Ee, G = Se[0 * 2 + 1], Ie = 0, je = 7, P = 4;
    for (G === 0 && (je = 138, P = 3), Se[(Ae + 1) * 2 + 1] = 65535, qe = 0; qe <= Ae; qe++)
      Ee = G, G = Se[(qe + 1) * 2 + 1], !(++Ie < je && Ee === G) && (Ie < P ? X.bl_tree[Ee * 2] += Ie : Ee !== 0 ? (Ee !== pe && X.bl_tree[Ee * 2]++, X.bl_tree[k * 2]++) : Ie <= 10 ? X.bl_tree[q * 2]++ : X.bl_tree[$ * 2]++, Ie = 0, pe = Ee, G === 0 ? (je = 138, P = 3) : Ee === G ? (je = 6, P = 3) : (je = 7, P = 4));
  }
  function me(X, Se, Ae) {
    var qe, pe = -1, Ee, G = Se[0 * 2 + 1], Ie = 0, je = 7, P = 4;
    for (G === 0 && (je = 138, P = 3), qe = 0; qe <= Ae; qe++)
      if (Ee = G, G = Se[(qe + 1) * 2 + 1], !(++Ie < je && Ee === G)) {
        if (Ie < P)
          do
            V(X, Ee, X.bl_tree);
          while (--Ie !== 0);
        else
          Ee !== 0 ? (Ee !== pe && (V(X, Ee, X.bl_tree), Ie--), V(X, k, X.bl_tree), H(X, Ie - 3, 2)) : Ie <= 10 ? (V(X, q, X.bl_tree), H(X, Ie - 3, 3)) : (V(X, $, X.bl_tree), H(X, Ie - 11, 7));
        Ie = 0, pe = Ee, G === 0 ? (je = 138, P = 3) : Ee === G ? (je = 6, P = 3) : (je = 7, P = 4);
      }
  }
  function Te(X) {
    var Se;
    for (de(X, X.dyn_ltree, X.l_desc.max_code), de(X, X.dyn_dtree, X.d_desc.max_code), Z(X, X.bl_desc), Se = M - 1; Se >= 3 && X.bl_tree[U[Se] * 2 + 1] === 0; Se--)
      ;
    return X.opt_len += 3 * (Se + 1) + 5 + 5 + 4, Se;
  }
  function ze(X, Se, Ae, qe) {
    var pe;
    for (H(X, Se - 257, 5), H(X, Ae - 1, 5), H(X, qe - 4, 4), pe = 0; pe < qe; pe++)
      H(X, X.bl_tree[U[pe] * 2 + 1], 3);
    me(X, X.dyn_ltree, Se - 1), me(X, X.dyn_dtree, Ae - 1);
  }
  function z(X) {
    var Se = 4093624447, Ae;
    for (Ae = 0; Ae <= 31; Ae++, Se >>>= 1)
      if (Se & 1 && X.dyn_ltree[Ae * 2] !== 0)
        return r;
    if (X.dyn_ltree[9 * 2] !== 0 || X.dyn_ltree[10 * 2] !== 0 || X.dyn_ltree[13 * 2] !== 0)
      return i;
    for (Ae = 32; Ae < p; Ae++)
      if (X.dyn_ltree[Ae * 2] !== 0)
        return i;
    return r;
  }
  var ue = !1;
  function se(X) {
    ue || (W(), ue = !0), X.l_desc = new R(X.dyn_ltree, g), X.d_desc = new R(X.dyn_dtree, _), X.bl_desc = new R(X.bl_tree, l), X.bi_buf = 0, X.bi_valid = 0, ce(X);
  }
  function _e(X, Se, Ae, qe) {
    H(X, (f << 1) + (qe ? 1 : 0), 3), Be(X, Se, Ae, !0);
  }
  function Ce(X) {
    H(X, u << 1, 3), V(X, N, v), te(X);
  }
  function Ve(X, Se, Ae, qe) {
    var pe, Ee, G = 0;
    X.level > 0 ? (X.strm.data_type === o && (X.strm.data_type = z(X)), Z(X, X.l_desc), Z(X, X.d_desc), G = Te(X), pe = X.opt_len + 3 + 7 >>> 3, Ee = X.static_len + 3 + 7 >>> 3, Ee <= pe && (pe = Ee)) : pe = Ee = Ae + 5, Ae + 4 <= pe && Se !== -1 ? _e(X, Se, Ae, qe) : X.strategy === t || Ee === pe ? (H(X, (u << 1) + (qe ? 1 : 0), 3), L(X, v, a)) : (H(X, (c << 1) + (qe ? 1 : 0), 3), ze(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, G + 1), L(X, X.dyn_ltree, X.dyn_dtree)), ce(X), qe && ve(X);
  }
  function ke(X, Se, Ae) {
    return X.pending_buf[X.d_buf + X.last_lit * 2] = Se >>> 8 & 255, X.pending_buf[X.d_buf + X.last_lit * 2 + 1] = Se & 255, X.pending_buf[X.l_buf + X.last_lit] = Ae & 255, X.last_lit++, Se === 0 ? X.dyn_ltree[Ae * 2]++ : (X.matches++, Se--, X.dyn_ltree[(w[Ae] + p + 1) * 2]++, X.dyn_dtree[Y(Se) * 2]++), X.last_lit === X.lit_bufsize - 1;
  }
  return kn._tr_init = se, kn._tr_stored_block = _e, kn._tr_flush_block = Ve, kn._tr_tally = ke, kn._tr_align = Ce, kn;
}
var js, Wd;
function Ty() {
  if (Wd)
    return js;
  Wd = 1;
  function e(t, r, i, o) {
    for (var n = t & 65535 | 0, f = t >>> 16 & 65535 | 0, u = 0; i !== 0; ) {
      u = i > 2e3 ? 2e3 : i, i -= u;
      do
        n = n + r[o++] | 0, f = f + n | 0;
      while (--u);
      n %= 65521, f %= 65521;
    }
    return n | f << 16 | 0;
  }
  return js = e, js;
}
var qs, Kd;
function Oy() {
  if (Kd)
    return qs;
  Kd = 1;
  function e() {
    for (var i, o = [], n = 0; n < 256; n++) {
      i = n;
      for (var f = 0; f < 8; f++)
        i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
      o[n] = i;
    }
    return o;
  }
  var t = e();
  function r(i, o, n, f) {
    var u = t, c = f + n;
    i ^= -1;
    for (var h = f; h < c; h++)
      i = i >>> 8 ^ u[(i ^ o[h]) & 255];
    return i ^ -1;
  }
  return qs = r, qs;
}
var Ds, Zd;
function bx() {
  return Zd || (Zd = 1, Ds = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), Ds;
}
var Gd;
function yx() {
  if (Gd)
    return Fr;
  Gd = 1;
  var e = nf(), t = vx(), r = Ty(), i = Oy(), o = bx(), n = 0, f = 1, u = 3, c = 4, h = 5, s = 0, b = 1, p = -2, m = -3, E = -5, M = -1, I = 1, B = 2, T = 3, j = 4, N = 0, k = 2, q = 8, $ = 9, re = 15, Q = 8, fe = 29, U = 256, y = U + 1 + fe, v = 30, a = 19, d = 2 * y + 1, w = 15, x = 3, A = 258, S = A + x + 1, g = 32, _ = 42, l = 69, R = 73, Y = 91, oe = 103, H = 113, V = 666, F = 1, te = 2, he = 3, K = 4, W = 3;
  function ce(P, Me) {
    return P.msg = o[Me], Me;
  }
  function ve(P) {
    return (P << 1) - (P > 4 ? 9 : 0);
  }
  function Be(P) {
    for (var Me = P.length; --Me >= 0; )
      P[Me] = 0;
  }
  function ee(P) {
    var Me = P.state, be = Me.pending;
    be > P.avail_out && (be = P.avail_out), be !== 0 && (e.arraySet(P.output, Me.pending_buf, Me.pending_out, be, P.next_out), P.next_out += be, Me.pending_out += be, P.total_out += be, P.avail_out -= be, Me.pending -= be, Me.pending === 0 && (Me.pending_out = 0));
  }
  function C(P, Me) {
    t._tr_flush_block(P, P.block_start >= 0 ? P.block_start : -1, P.strstart - P.block_start, Me), P.block_start = P.strstart, ee(P.strm);
  }
  function L(P, Me) {
    P.pending_buf[P.pending++] = Me;
  }
  function Z(P, Me) {
    P.pending_buf[P.pending++] = Me >>> 8 & 255, P.pending_buf[P.pending++] = Me & 255;
  }
  function de(P, Me, be, ie) {
    var le = P.avail_in;
    return le > ie && (le = ie), le === 0 ? 0 : (P.avail_in -= le, e.arraySet(Me, P.input, P.next_in, le, be), P.state.wrap === 1 ? P.adler = r(P.adler, Me, le, be) : P.state.wrap === 2 && (P.adler = i(P.adler, Me, le, be)), P.next_in += le, P.total_in += le, le);
  }
  function me(P, Me) {
    var be = P.max_chain_length, ie = P.strstart, le, ge, Ge = P.prev_length, $e = P.nice_match, Ne = P.strstart > P.w_size - S ? P.strstart - (P.w_size - S) : 0, nt = P.window, st = P.w_mask, Je = P.prev, ft = P.strstart + A, D = nt[ie + Ge - 1], J = nt[ie + Ge];
    P.prev_length >= P.good_match && (be >>= 2), $e > P.lookahead && ($e = P.lookahead);
    do
      if (le = Me, !(nt[le + Ge] !== J || nt[le + Ge - 1] !== D || nt[le] !== nt[ie] || nt[++le] !== nt[ie + 1])) {
        ie += 2, le++;
        do
          ;
        while (nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && ie < ft);
        if (ge = A - (ft - ie), ie = ft - A, ge > Ge) {
          if (P.match_start = Me, Ge = ge, ge >= $e)
            break;
          D = nt[ie + Ge - 1], J = nt[ie + Ge];
        }
      }
    while ((Me = Je[Me & st]) > Ne && --be !== 0);
    return Ge <= P.lookahead ? Ge : P.lookahead;
  }
  function Te(P) {
    var Me = P.w_size, be, ie, le, ge, Ge;
    do {
      if (ge = P.window_size - P.lookahead - P.strstart, P.strstart >= Me + (Me - S)) {
        e.arraySet(P.window, P.window, Me, Me, 0), P.match_start -= Me, P.strstart -= Me, P.block_start -= Me, ie = P.hash_size, be = ie;
        do
          le = P.head[--be], P.head[be] = le >= Me ? le - Me : 0;
        while (--ie);
        ie = Me, be = ie;
        do
          le = P.prev[--be], P.prev[be] = le >= Me ? le - Me : 0;
        while (--ie);
        ge += Me;
      }
      if (P.strm.avail_in === 0)
        break;
      if (ie = de(P.strm, P.window, P.strstart + P.lookahead, ge), P.lookahead += ie, P.lookahead + P.insert >= x)
        for (Ge = P.strstart - P.insert, P.ins_h = P.window[Ge], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Ge + 1]) & P.hash_mask; P.insert && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Ge + x - 1]) & P.hash_mask, P.prev[Ge & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = Ge, Ge++, P.insert--, !(P.lookahead + P.insert < x)); )
          ;
    } while (P.lookahead < S && P.strm.avail_in !== 0);
  }
  function ze(P, Me) {
    var be = 65535;
    for (be > P.pending_buf_size - 5 && (be = P.pending_buf_size - 5); ; ) {
      if (P.lookahead <= 1) {
        if (Te(P), P.lookahead === 0 && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      P.strstart += P.lookahead, P.lookahead = 0;
      var ie = P.block_start + be;
      if ((P.strstart === 0 || P.strstart >= ie) && (P.lookahead = P.strstart - ie, P.strstart = ie, C(P, !1), P.strm.avail_out === 0) || P.strstart - P.block_start >= P.w_size - S && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : K) : (P.strstart > P.block_start && (C(P, !1), P.strm.avail_out === 0), F);
  }
  function z(P, Me) {
    for (var be, ie; ; ) {
      if (P.lookahead < S) {
        if (Te(P), P.lookahead < S && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (be = 0, P.lookahead >= x && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), be !== 0 && P.strstart - be <= P.w_size - S && (P.match_length = me(P, be)), P.match_length >= x)
        if (ie = t._tr_tally(P, P.strstart - P.match_start, P.match_length - x), P.lookahead -= P.match_length, P.match_length <= P.max_lazy_match && P.lookahead >= x) {
          P.match_length--;
          do
            P.strstart++, P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart;
          while (--P.match_length !== 0);
          P.strstart++;
        } else
          P.strstart += P.match_length, P.match_length = 0, P.ins_h = P.window[P.strstart], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + 1]) & P.hash_mask;
      else
        ie = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++;
      if (ie && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = P.strstart < x - 1 ? P.strstart : x - 1, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : K) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : te;
  }
  function ue(P, Me) {
    for (var be, ie, le; ; ) {
      if (P.lookahead < S) {
        if (Te(P), P.lookahead < S && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (be = 0, P.lookahead >= x && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), P.prev_length = P.match_length, P.prev_match = P.match_start, P.match_length = x - 1, be !== 0 && P.prev_length < P.max_lazy_match && P.strstart - be <= P.w_size - S && (P.match_length = me(P, be), P.match_length <= 5 && (P.strategy === I || P.match_length === x && P.strstart - P.match_start > 4096) && (P.match_length = x - 1)), P.prev_length >= x && P.match_length <= P.prev_length) {
        le = P.strstart + P.lookahead - x, ie = t._tr_tally(P, P.strstart - 1 - P.prev_match, P.prev_length - x), P.lookahead -= P.prev_length - 1, P.prev_length -= 2;
        do
          ++P.strstart <= le && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart);
        while (--P.prev_length !== 0);
        if (P.match_available = 0, P.match_length = x - 1, P.strstart++, ie && (C(P, !1), P.strm.avail_out === 0))
          return F;
      } else if (P.match_available) {
        if (ie = t._tr_tally(P, 0, P.window[P.strstart - 1]), ie && C(P, !1), P.strstart++, P.lookahead--, P.strm.avail_out === 0)
          return F;
      } else
        P.match_available = 1, P.strstart++, P.lookahead--;
    }
    return P.match_available && (ie = t._tr_tally(P, 0, P.window[P.strstart - 1]), P.match_available = 0), P.insert = P.strstart < x - 1 ? P.strstart : x - 1, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : K) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : te;
  }
  function se(P, Me) {
    for (var be, ie, le, ge, Ge = P.window; ; ) {
      if (P.lookahead <= A) {
        if (Te(P), P.lookahead <= A && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (P.match_length = 0, P.lookahead >= x && P.strstart > 0 && (le = P.strstart - 1, ie = Ge[le], ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le])) {
        ge = P.strstart + A;
        do
          ;
        while (ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && le < ge);
        P.match_length = A - (ge - le), P.match_length > P.lookahead && (P.match_length = P.lookahead);
      }
      if (P.match_length >= x ? (be = t._tr_tally(P, 1, P.match_length - x), P.lookahead -= P.match_length, P.strstart += P.match_length, P.match_length = 0) : (be = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++), be && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : K) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : te;
  }
  function _e(P, Me) {
    for (var be; ; ) {
      if (P.lookahead === 0 && (Te(P), P.lookahead === 0)) {
        if (Me === n)
          return F;
        break;
      }
      if (P.match_length = 0, be = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++, be && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : K) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : te;
  }
  function Ce(P, Me, be, ie, le) {
    this.good_length = P, this.max_lazy = Me, this.nice_length = be, this.max_chain = ie, this.func = le;
  }
  var Ve;
  Ve = [
    /*      good lazy nice chain */
    new Ce(0, 0, 0, 0, ze),
    /* 0 store only */
    new Ce(4, 4, 8, 4, z),
    /* 1 max speed, no lazy matches */
    new Ce(4, 5, 16, 8, z),
    /* 2 */
    new Ce(4, 6, 32, 32, z),
    /* 3 */
    new Ce(4, 4, 16, 16, ue),
    /* 4 lazy matches */
    new Ce(8, 16, 32, 32, ue),
    /* 5 */
    new Ce(8, 16, 128, 128, ue),
    /* 6 */
    new Ce(8, 32, 128, 256, ue),
    /* 7 */
    new Ce(32, 128, 258, 1024, ue),
    /* 8 */
    new Ce(32, 258, 258, 4096, ue)
    /* 9 max compression */
  ];
  function ke(P) {
    P.window_size = 2 * P.w_size, Be(P.head), P.max_lazy_match = Ve[P.level].max_lazy, P.good_match = Ve[P.level].good_length, P.nice_match = Ve[P.level].nice_length, P.max_chain_length = Ve[P.level].max_chain, P.strstart = 0, P.block_start = 0, P.lookahead = 0, P.insert = 0, P.match_length = P.prev_length = x - 1, P.match_available = 0, P.ins_h = 0;
  }
  function X() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = q, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(d * 2), this.dyn_dtree = new e.Buf16((2 * v + 1) * 2), this.bl_tree = new e.Buf16((2 * a + 1) * 2), Be(this.dyn_ltree), Be(this.dyn_dtree), Be(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(w + 1), this.heap = new e.Buf16(2 * y + 1), Be(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * y + 1), Be(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function Se(P) {
    var Me;
    return !P || !P.state ? ce(P, p) : (P.total_in = P.total_out = 0, P.data_type = k, Me = P.state, Me.pending = 0, Me.pending_out = 0, Me.wrap < 0 && (Me.wrap = -Me.wrap), Me.status = Me.wrap ? _ : H, P.adler = Me.wrap === 2 ? 0 : 1, Me.last_flush = n, t._tr_init(Me), s);
  }
  function Ae(P) {
    var Me = Se(P);
    return Me === s && ke(P.state), Me;
  }
  function qe(P, Me) {
    return !P || !P.state || P.state.wrap !== 2 ? p : (P.state.gzhead = Me, s);
  }
  function pe(P, Me, be, ie, le, ge) {
    if (!P)
      return p;
    var Ge = 1;
    if (Me === M && (Me = 6), ie < 0 ? (Ge = 0, ie = -ie) : ie > 15 && (Ge = 2, ie -= 16), le < 1 || le > $ || be !== q || ie < 8 || ie > 15 || Me < 0 || Me > 9 || ge < 0 || ge > j)
      return ce(P, p);
    ie === 8 && (ie = 9);
    var $e = new X();
    return P.state = $e, $e.strm = P, $e.wrap = Ge, $e.gzhead = null, $e.w_bits = ie, $e.w_size = 1 << $e.w_bits, $e.w_mask = $e.w_size - 1, $e.hash_bits = le + 7, $e.hash_size = 1 << $e.hash_bits, $e.hash_mask = $e.hash_size - 1, $e.hash_shift = ~~(($e.hash_bits + x - 1) / x), $e.window = new e.Buf8($e.w_size * 2), $e.head = new e.Buf16($e.hash_size), $e.prev = new e.Buf16($e.w_size), $e.lit_bufsize = 1 << le + 6, $e.pending_buf_size = $e.lit_bufsize * 4, $e.pending_buf = new e.Buf8($e.pending_buf_size), $e.d_buf = 1 * $e.lit_bufsize, $e.l_buf = 3 * $e.lit_bufsize, $e.level = Me, $e.strategy = ge, $e.method = be, Ae(P);
  }
  function Ee(P, Me) {
    return pe(P, Me, q, re, Q, N);
  }
  function G(P, Me) {
    var be, ie, le, ge;
    if (!P || !P.state || Me > h || Me < 0)
      return P ? ce(P, p) : p;
    if (ie = P.state, !P.output || !P.input && P.avail_in !== 0 || ie.status === V && Me !== c)
      return ce(P, P.avail_out === 0 ? E : p);
    if (ie.strm = P, be = ie.last_flush, ie.last_flush = Me, ie.status === _)
      if (ie.wrap === 2)
        P.adler = 0, L(ie, 31), L(ie, 139), L(ie, 8), ie.gzhead ? (L(
          ie,
          (ie.gzhead.text ? 1 : 0) + (ie.gzhead.hcrc ? 2 : 0) + (ie.gzhead.extra ? 4 : 0) + (ie.gzhead.name ? 8 : 0) + (ie.gzhead.comment ? 16 : 0)
        ), L(ie, ie.gzhead.time & 255), L(ie, ie.gzhead.time >> 8 & 255), L(ie, ie.gzhead.time >> 16 & 255), L(ie, ie.gzhead.time >> 24 & 255), L(ie, ie.level === 9 ? 2 : ie.strategy >= B || ie.level < 2 ? 4 : 0), L(ie, ie.gzhead.os & 255), ie.gzhead.extra && ie.gzhead.extra.length && (L(ie, ie.gzhead.extra.length & 255), L(ie, ie.gzhead.extra.length >> 8 & 255)), ie.gzhead.hcrc && (P.adler = i(P.adler, ie.pending_buf, ie.pending, 0)), ie.gzindex = 0, ie.status = l) : (L(ie, 0), L(ie, 0), L(ie, 0), L(ie, 0), L(ie, 0), L(ie, ie.level === 9 ? 2 : ie.strategy >= B || ie.level < 2 ? 4 : 0), L(ie, W), ie.status = H);
      else {
        var Ge = q + (ie.w_bits - 8 << 4) << 8, $e = -1;
        ie.strategy >= B || ie.level < 2 ? $e = 0 : ie.level < 6 ? $e = 1 : ie.level === 6 ? $e = 2 : $e = 3, Ge |= $e << 6, ie.strstart !== 0 && (Ge |= g), Ge += 31 - Ge % 31, ie.status = H, Z(ie, Ge), ie.strstart !== 0 && (Z(ie, P.adler >>> 16), Z(ie, P.adler & 65535)), P.adler = 1;
      }
    if (ie.status === l)
      if (ie.gzhead.extra) {
        for (le = ie.pending; ie.gzindex < (ie.gzhead.extra.length & 65535) && !(ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ee(P), le = ie.pending, ie.pending === ie.pending_buf_size)); )
          L(ie, ie.gzhead.extra[ie.gzindex] & 255), ie.gzindex++;
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ie.gzindex === ie.gzhead.extra.length && (ie.gzindex = 0, ie.status = R);
      } else
        ie.status = R;
    if (ie.status === R)
      if (ie.gzhead.name) {
        le = ie.pending;
        do {
          if (ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ee(P), le = ie.pending, ie.pending === ie.pending_buf_size)) {
            ge = 1;
            break;
          }
          ie.gzindex < ie.gzhead.name.length ? ge = ie.gzhead.name.charCodeAt(ie.gzindex++) & 255 : ge = 0, L(ie, ge);
        } while (ge !== 0);
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ge === 0 && (ie.gzindex = 0, ie.status = Y);
      } else
        ie.status = Y;
    if (ie.status === Y)
      if (ie.gzhead.comment) {
        le = ie.pending;
        do {
          if (ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ee(P), le = ie.pending, ie.pending === ie.pending_buf_size)) {
            ge = 1;
            break;
          }
          ie.gzindex < ie.gzhead.comment.length ? ge = ie.gzhead.comment.charCodeAt(ie.gzindex++) & 255 : ge = 0, L(ie, ge);
        } while (ge !== 0);
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ge === 0 && (ie.status = oe);
      } else
        ie.status = oe;
    if (ie.status === oe && (ie.gzhead.hcrc ? (ie.pending + 2 > ie.pending_buf_size && ee(P), ie.pending + 2 <= ie.pending_buf_size && (L(ie, P.adler & 255), L(ie, P.adler >> 8 & 255), P.adler = 0, ie.status = H)) : ie.status = H), ie.pending !== 0) {
      if (ee(P), P.avail_out === 0)
        return ie.last_flush = -1, s;
    } else if (P.avail_in === 0 && ve(Me) <= ve(be) && Me !== c)
      return ce(P, E);
    if (ie.status === V && P.avail_in !== 0)
      return ce(P, E);
    if (P.avail_in !== 0 || ie.lookahead !== 0 || Me !== n && ie.status !== V) {
      var Ne = ie.strategy === B ? _e(ie, Me) : ie.strategy === T ? se(ie, Me) : Ve[ie.level].func(ie, Me);
      if ((Ne === he || Ne === K) && (ie.status = V), Ne === F || Ne === he)
        return P.avail_out === 0 && (ie.last_flush = -1), s;
      if (Ne === te && (Me === f ? t._tr_align(ie) : Me !== h && (t._tr_stored_block(ie, 0, 0, !1), Me === u && (Be(ie.head), ie.lookahead === 0 && (ie.strstart = 0, ie.block_start = 0, ie.insert = 0))), ee(P), P.avail_out === 0))
        return ie.last_flush = -1, s;
    }
    return Me !== c ? s : ie.wrap <= 0 ? b : (ie.wrap === 2 ? (L(ie, P.adler & 255), L(ie, P.adler >> 8 & 255), L(ie, P.adler >> 16 & 255), L(ie, P.adler >> 24 & 255), L(ie, P.total_in & 255), L(ie, P.total_in >> 8 & 255), L(ie, P.total_in >> 16 & 255), L(ie, P.total_in >> 24 & 255)) : (Z(ie, P.adler >>> 16), Z(ie, P.adler & 65535)), ee(P), ie.wrap > 0 && (ie.wrap = -ie.wrap), ie.pending !== 0 ? s : b);
  }
  function Ie(P) {
    var Me;
    return !P || !P.state ? p : (Me = P.state.status, Me !== _ && Me !== l && Me !== R && Me !== Y && Me !== oe && Me !== H && Me !== V ? ce(P, p) : (P.state = null, Me === H ? ce(P, m) : s));
  }
  function je(P, Me) {
    var be = Me.length, ie, le, ge, Ge, $e, Ne, nt, st;
    if (!P || !P.state || (ie = P.state, Ge = ie.wrap, Ge === 2 || Ge === 1 && ie.status !== _ || ie.lookahead))
      return p;
    for (Ge === 1 && (P.adler = r(P.adler, Me, be, 0)), ie.wrap = 0, be >= ie.w_size && (Ge === 0 && (Be(ie.head), ie.strstart = 0, ie.block_start = 0, ie.insert = 0), st = new e.Buf8(ie.w_size), e.arraySet(st, Me, be - ie.w_size, ie.w_size, 0), Me = st, be = ie.w_size), $e = P.avail_in, Ne = P.next_in, nt = P.input, P.avail_in = be, P.next_in = 0, P.input = Me, Te(ie); ie.lookahead >= x; ) {
      le = ie.strstart, ge = ie.lookahead - (x - 1);
      do
        ie.ins_h = (ie.ins_h << ie.hash_shift ^ ie.window[le + x - 1]) & ie.hash_mask, ie.prev[le & ie.w_mask] = ie.head[ie.ins_h], ie.head[ie.ins_h] = le, le++;
      while (--ge);
      ie.strstart = le, ie.lookahead = x - 1, Te(ie);
    }
    return ie.strstart += ie.lookahead, ie.block_start = ie.strstart, ie.insert = ie.lookahead, ie.lookahead = 0, ie.match_length = ie.prev_length = x - 1, ie.match_available = 0, P.next_in = Ne, P.input = nt, P.avail_in = $e, ie.wrap = Ge, s;
  }
  return Fr.deflateInit = Ee, Fr.deflateInit2 = pe, Fr.deflateReset = Ae, Fr.deflateResetKeep = Se, Fr.deflateSetHeader = qe, Fr.deflate = G, Fr.deflateEnd = Ie, Fr.deflateSetDictionary = je, Fr.deflateInfo = "pako deflate (from Nodeca project)", Fr;
}
var Ar = {}, $s, Jd;
function gx() {
  if (Jd)
    return $s;
  Jd = 1;
  var e = 30, t = 12;
  return $s = function(i, o) {
    var n, f, u, c, h, s, b, p, m, E, M, I, B, T, j, N, k, q, $, re, Q, fe, U, y, v;
    n = i.state, f = i.next_in, y = i.input, u = f + (i.avail_in - 5), c = i.next_out, v = i.output, h = c - (o - i.avail_out), s = c + (i.avail_out - 257), b = n.dmax, p = n.wsize, m = n.whave, E = n.wnext, M = n.window, I = n.hold, B = n.bits, T = n.lencode, j = n.distcode, N = (1 << n.lenbits) - 1, k = (1 << n.distbits) - 1;
    e:
      do {
        B < 15 && (I += y[f++] << B, B += 8, I += y[f++] << B, B += 8), q = T[I & N];
        t:
          for (; ; ) {
            if ($ = q >>> 24, I >>>= $, B -= $, $ = q >>> 16 & 255, $ === 0)
              v[c++] = q & 65535;
            else if ($ & 16) {
              re = q & 65535, $ &= 15, $ && (B < $ && (I += y[f++] << B, B += 8), re += I & (1 << $) - 1, I >>>= $, B -= $), B < 15 && (I += y[f++] << B, B += 8, I += y[f++] << B, B += 8), q = j[I & k];
              r:
                for (; ; ) {
                  if ($ = q >>> 24, I >>>= $, B -= $, $ = q >>> 16 & 255, $ & 16) {
                    if (Q = q & 65535, $ &= 15, B < $ && (I += y[f++] << B, B += 8, B < $ && (I += y[f++] << B, B += 8)), Q += I & (1 << $) - 1, Q > b) {
                      i.msg = "invalid distance too far back", n.mode = e;
                      break e;
                    }
                    if (I >>>= $, B -= $, $ = c - h, Q > $) {
                      if ($ = Q - $, $ > m && n.sane) {
                        i.msg = "invalid distance too far back", n.mode = e;
                        break e;
                      }
                      if (fe = 0, U = M, E === 0) {
                        if (fe += p - $, $ < re) {
                          re -= $;
                          do
                            v[c++] = M[fe++];
                          while (--$);
                          fe = c - Q, U = v;
                        }
                      } else if (E < $) {
                        if (fe += p + E - $, $ -= E, $ < re) {
                          re -= $;
                          do
                            v[c++] = M[fe++];
                          while (--$);
                          if (fe = 0, E < re) {
                            $ = E, re -= $;
                            do
                              v[c++] = M[fe++];
                            while (--$);
                            fe = c - Q, U = v;
                          }
                        }
                      } else if (fe += E - $, $ < re) {
                        re -= $;
                        do
                          v[c++] = M[fe++];
                        while (--$);
                        fe = c - Q, U = v;
                      }
                      for (; re > 2; )
                        v[c++] = U[fe++], v[c++] = U[fe++], v[c++] = U[fe++], re -= 3;
                      re && (v[c++] = U[fe++], re > 1 && (v[c++] = U[fe++]));
                    } else {
                      fe = c - Q;
                      do
                        v[c++] = v[fe++], v[c++] = v[fe++], v[c++] = v[fe++], re -= 3;
                      while (re > 2);
                      re && (v[c++] = v[fe++], re > 1 && (v[c++] = v[fe++]));
                    }
                  } else if ($ & 64) {
                    i.msg = "invalid distance code", n.mode = e;
                    break e;
                  } else {
                    q = j[(q & 65535) + (I & (1 << $) - 1)];
                    continue r;
                  }
                  break;
                }
            } else if ($ & 64)
              if ($ & 32) {
                n.mode = t;
                break e;
              } else {
                i.msg = "invalid literal/length code", n.mode = e;
                break e;
              }
            else {
              q = T[(q & 65535) + (I & (1 << $) - 1)];
              continue t;
            }
            break;
          }
      } while (f < u && c < s);
    re = B >> 3, f -= re, B -= re << 3, I &= (1 << B) - 1, i.next_in = f, i.next_out = c, i.avail_in = f < u ? 5 + (u - f) : 5 - (f - u), i.avail_out = c < s ? 257 + (s - c) : 257 - (c - s), n.hold = I, n.bits = B;
  }, $s;
}
var Us, Xd;
function mx() {
  if (Xd)
    return Us;
  Xd = 1;
  var e = nf(), t = 15, r = 852, i = 592, o = 0, n = 1, f = 2, u = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], c = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], h = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], s = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return Us = function(p, m, E, M, I, B, T, j) {
    var N = j.bits, k = 0, q = 0, $ = 0, re = 0, Q = 0, fe = 0, U = 0, y = 0, v = 0, a = 0, d, w, x, A, S, g = null, _ = 0, l, R = new e.Buf16(t + 1), Y = new e.Buf16(t + 1), oe = null, H = 0, V, F, te;
    for (k = 0; k <= t; k++)
      R[k] = 0;
    for (q = 0; q < M; q++)
      R[m[E + q]]++;
    for (Q = N, re = t; re >= 1 && R[re] === 0; re--)
      ;
    if (Q > re && (Q = re), re === 0)
      return I[B++] = 1 << 24 | 64 << 16 | 0, I[B++] = 1 << 24 | 64 << 16 | 0, j.bits = 1, 0;
    for ($ = 1; $ < re && R[$] === 0; $++)
      ;
    for (Q < $ && (Q = $), y = 1, k = 1; k <= t; k++)
      if (y <<= 1, y -= R[k], y < 0)
        return -1;
    if (y > 0 && (p === o || re !== 1))
      return -1;
    for (Y[1] = 0, k = 1; k < t; k++)
      Y[k + 1] = Y[k] + R[k];
    for (q = 0; q < M; q++)
      m[E + q] !== 0 && (T[Y[m[E + q]]++] = q);
    if (p === o ? (g = oe = T, l = 19) : p === n ? (g = u, _ -= 257, oe = c, H -= 257, l = 256) : (g = h, oe = s, l = -1), a = 0, q = 0, k = $, S = B, fe = Q, U = 0, x = -1, v = 1 << Q, A = v - 1, p === n && v > r || p === f && v > i)
      return 1;
    for (; ; ) {
      V = k - U, T[q] < l ? (F = 0, te = T[q]) : T[q] > l ? (F = oe[H + T[q]], te = g[_ + T[q]]) : (F = 96, te = 0), d = 1 << k - U, w = 1 << fe, $ = w;
      do
        w -= d, I[S + (a >> U) + w] = V << 24 | F << 16 | te | 0;
      while (w !== 0);
      for (d = 1 << k - 1; a & d; )
        d >>= 1;
      if (d !== 0 ? (a &= d - 1, a += d) : a = 0, q++, --R[k] === 0) {
        if (k === re)
          break;
        k = m[E + T[q]];
      }
      if (k > Q && (a & A) !== x) {
        for (U === 0 && (U = Q), S += $, fe = k - U, y = 1 << fe; fe + U < re && (y -= R[fe + U], !(y <= 0)); )
          fe++, y <<= 1;
        if (v += 1 << fe, p === n && v > r || p === f && v > i)
          return 1;
        x = a & A, I[x] = Q << 24 | fe << 16 | S - B | 0;
      }
    }
    return a !== 0 && (I[S + a] = k - U << 24 | 64 << 16 | 0), j.bits = Q, 0;
  }, Us;
}
var Yd;
function wx() {
  if (Yd)
    return Ar;
  Yd = 1;
  var e = nf(), t = Ty(), r = Oy(), i = gx(), o = mx(), n = 0, f = 1, u = 2, c = 4, h = 5, s = 6, b = 0, p = 1, m = 2, E = -2, M = -3, I = -4, B = -5, T = 8, j = 1, N = 2, k = 3, q = 4, $ = 5, re = 6, Q = 7, fe = 8, U = 9, y = 10, v = 11, a = 12, d = 13, w = 14, x = 15, A = 16, S = 17, g = 18, _ = 19, l = 20, R = 21, Y = 22, oe = 23, H = 24, V = 25, F = 26, te = 27, he = 28, K = 29, W = 30, ce = 31, ve = 32, Be = 852, ee = 592, C = 15, L = C;
  function Z(pe) {
    return (pe >>> 24 & 255) + (pe >>> 8 & 65280) + ((pe & 65280) << 8) + ((pe & 255) << 24);
  }
  function de() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function me(pe) {
    var Ee;
    return !pe || !pe.state ? E : (Ee = pe.state, pe.total_in = pe.total_out = Ee.total = 0, pe.msg = "", Ee.wrap && (pe.adler = Ee.wrap & 1), Ee.mode = j, Ee.last = 0, Ee.havedict = 0, Ee.dmax = 32768, Ee.head = null, Ee.hold = 0, Ee.bits = 0, Ee.lencode = Ee.lendyn = new e.Buf32(Be), Ee.distcode = Ee.distdyn = new e.Buf32(ee), Ee.sane = 1, Ee.back = -1, b);
  }
  function Te(pe) {
    var Ee;
    return !pe || !pe.state ? E : (Ee = pe.state, Ee.wsize = 0, Ee.whave = 0, Ee.wnext = 0, me(pe));
  }
  function ze(pe, Ee) {
    var G, Ie;
    return !pe || !pe.state || (Ie = pe.state, Ee < 0 ? (G = 0, Ee = -Ee) : (G = (Ee >> 4) + 1, Ee < 48 && (Ee &= 15)), Ee && (Ee < 8 || Ee > 15)) ? E : (Ie.window !== null && Ie.wbits !== Ee && (Ie.window = null), Ie.wrap = G, Ie.wbits = Ee, Te(pe));
  }
  function z(pe, Ee) {
    var G, Ie;
    return pe ? (Ie = new de(), pe.state = Ie, Ie.window = null, G = ze(pe, Ee), G !== b && (pe.state = null), G) : E;
  }
  function ue(pe) {
    return z(pe, L);
  }
  var se = !0, _e, Ce;
  function Ve(pe) {
    if (se) {
      var Ee;
      for (_e = new e.Buf32(512), Ce = new e.Buf32(32), Ee = 0; Ee < 144; )
        pe.lens[Ee++] = 8;
      for (; Ee < 256; )
        pe.lens[Ee++] = 9;
      for (; Ee < 280; )
        pe.lens[Ee++] = 7;
      for (; Ee < 288; )
        pe.lens[Ee++] = 8;
      for (o(f, pe.lens, 0, 288, _e, 0, pe.work, { bits: 9 }), Ee = 0; Ee < 32; )
        pe.lens[Ee++] = 5;
      o(u, pe.lens, 0, 32, Ce, 0, pe.work, { bits: 5 }), se = !1;
    }
    pe.lencode = _e, pe.lenbits = 9, pe.distcode = Ce, pe.distbits = 5;
  }
  function ke(pe, Ee, G, Ie) {
    var je, P = pe.state;
    return P.window === null && (P.wsize = 1 << P.wbits, P.wnext = 0, P.whave = 0, P.window = new e.Buf8(P.wsize)), Ie >= P.wsize ? (e.arraySet(P.window, Ee, G - P.wsize, P.wsize, 0), P.wnext = 0, P.whave = P.wsize) : (je = P.wsize - P.wnext, je > Ie && (je = Ie), e.arraySet(P.window, Ee, G - Ie, je, P.wnext), Ie -= je, Ie ? (e.arraySet(P.window, Ee, G - Ie, Ie, 0), P.wnext = Ie, P.whave = P.wsize) : (P.wnext += je, P.wnext === P.wsize && (P.wnext = 0), P.whave < P.wsize && (P.whave += je))), 0;
  }
  function X(pe, Ee) {
    var G, Ie, je, P, Me, be, ie, le, ge, Ge, $e, Ne, nt, st, Je = 0, ft, D, J, ne, O, ae, we, xe, Re = new e.Buf8(4), De, He, Ue = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!pe || !pe.state || !pe.output || !pe.input && pe.avail_in !== 0)
      return E;
    G = pe.state, G.mode === a && (G.mode = d), Me = pe.next_out, je = pe.output, ie = pe.avail_out, P = pe.next_in, Ie = pe.input, be = pe.avail_in, le = G.hold, ge = G.bits, Ge = be, $e = ie, xe = b;
    e:
      for (; ; )
        switch (G.mode) {
          case j:
            if (G.wrap === 0) {
              G.mode = d;
              break;
            }
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (G.wrap & 2 && le === 35615) {
              G.check = 0, Re[0] = le & 255, Re[1] = le >>> 8 & 255, G.check = r(G.check, Re, 2, 0), le = 0, ge = 0, G.mode = N;
              break;
            }
            if (G.flags = 0, G.head && (G.head.done = !1), !(G.wrap & 1) || /* check if zlib header allowed */
            (((le & 255) << 8) + (le >> 8)) % 31) {
              pe.msg = "incorrect header check", G.mode = W;
              break;
            }
            if ((le & 15) !== T) {
              pe.msg = "unknown compression method", G.mode = W;
              break;
            }
            if (le >>>= 4, ge -= 4, we = (le & 15) + 8, G.wbits === 0)
              G.wbits = we;
            else if (we > G.wbits) {
              pe.msg = "invalid window size", G.mode = W;
              break;
            }
            G.dmax = 1 << we, pe.adler = G.check = 1, G.mode = le & 512 ? y : a, le = 0, ge = 0;
            break;
          case N:
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (G.flags = le, (G.flags & 255) !== T) {
              pe.msg = "unknown compression method", G.mode = W;
              break;
            }
            if (G.flags & 57344) {
              pe.msg = "unknown header flags set", G.mode = W;
              break;
            }
            G.head && (G.head.text = le >> 8 & 1), G.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, G.check = r(G.check, Re, 2, 0)), le = 0, ge = 0, G.mode = k;
          case k:
            for (; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            G.head && (G.head.time = le), G.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, Re[2] = le >>> 16 & 255, Re[3] = le >>> 24 & 255, G.check = r(G.check, Re, 4, 0)), le = 0, ge = 0, G.mode = q;
          case q:
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            G.head && (G.head.xflags = le & 255, G.head.os = le >> 8), G.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, G.check = r(G.check, Re, 2, 0)), le = 0, ge = 0, G.mode = $;
          case $:
            if (G.flags & 1024) {
              for (; ge < 16; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              G.length = le, G.head && (G.head.extra_len = le), G.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, G.check = r(G.check, Re, 2, 0)), le = 0, ge = 0;
            } else
              G.head && (G.head.extra = null);
            G.mode = re;
          case re:
            if (G.flags & 1024 && (Ne = G.length, Ne > be && (Ne = be), Ne && (G.head && (we = G.head.extra_len - G.length, G.head.extra || (G.head.extra = new Array(G.head.extra_len)), e.arraySet(
              G.head.extra,
              Ie,
              P,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              Ne,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              we
            )), G.flags & 512 && (G.check = r(G.check, Ie, Ne, P)), be -= Ne, P += Ne, G.length -= Ne), G.length))
              break e;
            G.length = 0, G.mode = Q;
          case Q:
            if (G.flags & 2048) {
              if (be === 0)
                break e;
              Ne = 0;
              do
                we = Ie[P + Ne++], G.head && we && G.length < 65536 && (G.head.name += String.fromCharCode(we));
              while (we && Ne < be);
              if (G.flags & 512 && (G.check = r(G.check, Ie, Ne, P)), be -= Ne, P += Ne, we)
                break e;
            } else
              G.head && (G.head.name = null);
            G.length = 0, G.mode = fe;
          case fe:
            if (G.flags & 4096) {
              if (be === 0)
                break e;
              Ne = 0;
              do
                we = Ie[P + Ne++], G.head && we && G.length < 65536 && (G.head.comment += String.fromCharCode(we));
              while (we && Ne < be);
              if (G.flags & 512 && (G.check = r(G.check, Ie, Ne, P)), be -= Ne, P += Ne, we)
                break e;
            } else
              G.head && (G.head.comment = null);
            G.mode = U;
          case U:
            if (G.flags & 512) {
              for (; ge < 16; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (le !== (G.check & 65535)) {
                pe.msg = "header crc mismatch", G.mode = W;
                break;
              }
              le = 0, ge = 0;
            }
            G.head && (G.head.hcrc = G.flags >> 9 & 1, G.head.done = !0), pe.adler = G.check = 0, G.mode = a;
            break;
          case y:
            for (; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            pe.adler = G.check = Z(le), le = 0, ge = 0, G.mode = v;
          case v:
            if (G.havedict === 0)
              return pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, G.hold = le, G.bits = ge, m;
            pe.adler = G.check = 1, G.mode = a;
          case a:
            if (Ee === h || Ee === s)
              break e;
          case d:
            if (G.last) {
              le >>>= ge & 7, ge -= ge & 7, G.mode = te;
              break;
            }
            for (; ge < 3; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            switch (G.last = le & 1, le >>>= 1, ge -= 1, le & 3) {
              case 0:
                G.mode = w;
                break;
              case 1:
                if (Ve(G), G.mode = l, Ee === s) {
                  le >>>= 2, ge -= 2;
                  break e;
                }
                break;
              case 2:
                G.mode = S;
                break;
              case 3:
                pe.msg = "invalid block type", G.mode = W;
            }
            le >>>= 2, ge -= 2;
            break;
          case w:
            for (le >>>= ge & 7, ge -= ge & 7; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if ((le & 65535) !== (le >>> 16 ^ 65535)) {
              pe.msg = "invalid stored block lengths", G.mode = W;
              break;
            }
            if (G.length = le & 65535, le = 0, ge = 0, G.mode = x, Ee === s)
              break e;
          case x:
            G.mode = A;
          case A:
            if (Ne = G.length, Ne) {
              if (Ne > be && (Ne = be), Ne > ie && (Ne = ie), Ne === 0)
                break e;
              e.arraySet(je, Ie, P, Ne, Me), be -= Ne, P += Ne, ie -= Ne, Me += Ne, G.length -= Ne;
              break;
            }
            G.mode = a;
            break;
          case S:
            for (; ge < 14; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (G.nlen = (le & 31) + 257, le >>>= 5, ge -= 5, G.ndist = (le & 31) + 1, le >>>= 5, ge -= 5, G.ncode = (le & 15) + 4, le >>>= 4, ge -= 4, G.nlen > 286 || G.ndist > 30) {
              pe.msg = "too many length or distance symbols", G.mode = W;
              break;
            }
            G.have = 0, G.mode = g;
          case g:
            for (; G.have < G.ncode; ) {
              for (; ge < 3; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              G.lens[Ue[G.have++]] = le & 7, le >>>= 3, ge -= 3;
            }
            for (; G.have < 19; )
              G.lens[Ue[G.have++]] = 0;
            if (G.lencode = G.lendyn, G.lenbits = 7, De = { bits: G.lenbits }, xe = o(n, G.lens, 0, 19, G.lencode, 0, G.work, De), G.lenbits = De.bits, xe) {
              pe.msg = "invalid code lengths set", G.mode = W;
              break;
            }
            G.have = 0, G.mode = _;
          case _:
            for (; G.have < G.nlen + G.ndist; ) {
              for (; Je = G.lencode[le & (1 << G.lenbits) - 1], ft = Je >>> 24, D = Je >>> 16 & 255, J = Je & 65535, !(ft <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (J < 16)
                le >>>= ft, ge -= ft, G.lens[G.have++] = J;
              else {
                if (J === 16) {
                  for (He = ft + 2; ge < He; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  if (le >>>= ft, ge -= ft, G.have === 0) {
                    pe.msg = "invalid bit length repeat", G.mode = W;
                    break;
                  }
                  we = G.lens[G.have - 1], Ne = 3 + (le & 3), le >>>= 2, ge -= 2;
                } else if (J === 17) {
                  for (He = ft + 3; ge < He; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  le >>>= ft, ge -= ft, we = 0, Ne = 3 + (le & 7), le >>>= 3, ge -= 3;
                } else {
                  for (He = ft + 7; ge < He; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  le >>>= ft, ge -= ft, we = 0, Ne = 11 + (le & 127), le >>>= 7, ge -= 7;
                }
                if (G.have + Ne > G.nlen + G.ndist) {
                  pe.msg = "invalid bit length repeat", G.mode = W;
                  break;
                }
                for (; Ne--; )
                  G.lens[G.have++] = we;
              }
            }
            if (G.mode === W)
              break;
            if (G.lens[256] === 0) {
              pe.msg = "invalid code -- missing end-of-block", G.mode = W;
              break;
            }
            if (G.lenbits = 9, De = { bits: G.lenbits }, xe = o(f, G.lens, 0, G.nlen, G.lencode, 0, G.work, De), G.lenbits = De.bits, xe) {
              pe.msg = "invalid literal/lengths set", G.mode = W;
              break;
            }
            if (G.distbits = 6, G.distcode = G.distdyn, De = { bits: G.distbits }, xe = o(u, G.lens, G.nlen, G.ndist, G.distcode, 0, G.work, De), G.distbits = De.bits, xe) {
              pe.msg = "invalid distances set", G.mode = W;
              break;
            }
            if (G.mode = l, Ee === s)
              break e;
          case l:
            G.mode = R;
          case R:
            if (be >= 6 && ie >= 258) {
              pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, G.hold = le, G.bits = ge, i(pe, $e), Me = pe.next_out, je = pe.output, ie = pe.avail_out, P = pe.next_in, Ie = pe.input, be = pe.avail_in, le = G.hold, ge = G.bits, G.mode === a && (G.back = -1);
              break;
            }
            for (G.back = 0; Je = G.lencode[le & (1 << G.lenbits) - 1], ft = Je >>> 24, D = Je >>> 16 & 255, J = Je & 65535, !(ft <= ge); ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (D && !(D & 240)) {
              for (ne = ft, O = D, ae = J; Je = G.lencode[ae + ((le & (1 << ne + O) - 1) >> ne)], ft = Je >>> 24, D = Je >>> 16 & 255, J = Je & 65535, !(ne + ft <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              le >>>= ne, ge -= ne, G.back += ne;
            }
            if (le >>>= ft, ge -= ft, G.back += ft, G.length = J, D === 0) {
              G.mode = F;
              break;
            }
            if (D & 32) {
              G.back = -1, G.mode = a;
              break;
            }
            if (D & 64) {
              pe.msg = "invalid literal/length code", G.mode = W;
              break;
            }
            G.extra = D & 15, G.mode = Y;
          case Y:
            if (G.extra) {
              for (He = G.extra; ge < He; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              G.length += le & (1 << G.extra) - 1, le >>>= G.extra, ge -= G.extra, G.back += G.extra;
            }
            G.was = G.length, G.mode = oe;
          case oe:
            for (; Je = G.distcode[le & (1 << G.distbits) - 1], ft = Je >>> 24, D = Je >>> 16 & 255, J = Je & 65535, !(ft <= ge); ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (!(D & 240)) {
              for (ne = ft, O = D, ae = J; Je = G.distcode[ae + ((le & (1 << ne + O) - 1) >> ne)], ft = Je >>> 24, D = Je >>> 16 & 255, J = Je & 65535, !(ne + ft <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              le >>>= ne, ge -= ne, G.back += ne;
            }
            if (le >>>= ft, ge -= ft, G.back += ft, D & 64) {
              pe.msg = "invalid distance code", G.mode = W;
              break;
            }
            G.offset = J, G.extra = D & 15, G.mode = H;
          case H:
            if (G.extra) {
              for (He = G.extra; ge < He; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              G.offset += le & (1 << G.extra) - 1, le >>>= G.extra, ge -= G.extra, G.back += G.extra;
            }
            if (G.offset > G.dmax) {
              pe.msg = "invalid distance too far back", G.mode = W;
              break;
            }
            G.mode = V;
          case V:
            if (ie === 0)
              break e;
            if (Ne = $e - ie, G.offset > Ne) {
              if (Ne = G.offset - Ne, Ne > G.whave && G.sane) {
                pe.msg = "invalid distance too far back", G.mode = W;
                break;
              }
              Ne > G.wnext ? (Ne -= G.wnext, nt = G.wsize - Ne) : nt = G.wnext - Ne, Ne > G.length && (Ne = G.length), st = G.window;
            } else
              st = je, nt = Me - G.offset, Ne = G.length;
            Ne > ie && (Ne = ie), ie -= Ne, G.length -= Ne;
            do
              je[Me++] = st[nt++];
            while (--Ne);
            G.length === 0 && (G.mode = R);
            break;
          case F:
            if (ie === 0)
              break e;
            je[Me++] = G.length, ie--, G.mode = R;
            break;
          case te:
            if (G.wrap) {
              for (; ge < 32; ) {
                if (be === 0)
                  break e;
                be--, le |= Ie[P++] << ge, ge += 8;
              }
              if ($e -= ie, pe.total_out += $e, G.total += $e, $e && (pe.adler = G.check = /*UPDATE(state.check, put - _out, _out);*/
              G.flags ? r(G.check, je, $e, Me - $e) : t(G.check, je, $e, Me - $e)), $e = ie, (G.flags ? le : Z(le)) !== G.check) {
                pe.msg = "incorrect data check", G.mode = W;
                break;
              }
              le = 0, ge = 0;
            }
            G.mode = he;
          case he:
            if (G.wrap && G.flags) {
              for (; ge < 32; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (le !== (G.total & 4294967295)) {
                pe.msg = "incorrect length check", G.mode = W;
                break;
              }
              le = 0, ge = 0;
            }
            G.mode = K;
          case K:
            xe = p;
            break e;
          case W:
            xe = M;
            break e;
          case ce:
            return I;
          case ve:
          default:
            return E;
        }
    return pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, G.hold = le, G.bits = ge, (G.wsize || $e !== pe.avail_out && G.mode < W && (G.mode < te || Ee !== c)) && ke(pe, pe.output, pe.next_out, $e - pe.avail_out), Ge -= pe.avail_in, $e -= pe.avail_out, pe.total_in += Ge, pe.total_out += $e, G.total += $e, G.wrap && $e && (pe.adler = G.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    G.flags ? r(G.check, je, $e, pe.next_out - $e) : t(G.check, je, $e, pe.next_out - $e)), pe.data_type = G.bits + (G.last ? 64 : 0) + (G.mode === a ? 128 : 0) + (G.mode === l || G.mode === x ? 256 : 0), (Ge === 0 && $e === 0 || Ee === c) && xe === b && (xe = B), xe;
  }
  function Se(pe) {
    if (!pe || !pe.state)
      return E;
    var Ee = pe.state;
    return Ee.window && (Ee.window = null), pe.state = null, b;
  }
  function Ae(pe, Ee) {
    var G;
    return !pe || !pe.state || (G = pe.state, !(G.wrap & 2)) ? E : (G.head = Ee, Ee.done = !1, b);
  }
  function qe(pe, Ee) {
    var G = Ee.length, Ie, je, P;
    return !pe || !pe.state || (Ie = pe.state, Ie.wrap !== 0 && Ie.mode !== v) ? E : Ie.mode === v && (je = 1, je = t(je, Ee, G, 0), je !== Ie.check) ? M : (P = ke(pe, Ee, G, G), P ? (Ie.mode = ce, I) : (Ie.havedict = 1, b));
  }
  return Ar.inflateReset = Te, Ar.inflateReset2 = ze, Ar.inflateResetKeep = me, Ar.inflateInit = ue, Ar.inflateInit2 = z, Ar.inflate = X, Ar.inflateEnd = Se, Ar.inflateGetHeader = Ae, Ar.inflateSetDictionary = qe, Ar.inflateInfo = "pako inflate (from Nodeca project)", Ar;
}
var Fs, Qd;
function _x() {
  return Qd || (Qd = 1, Fs = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), Fs;
}
var e1;
function xx() {
  return e1 || (e1 = 1, function(e) {
    var t = ho(), r = px(), i = yx(), o = wx(), n = _x();
    for (var f in n)
      e[f] = n[f];
    e.NONE = 0, e.DEFLATE = 1, e.INFLATE = 2, e.GZIP = 3, e.GUNZIP = 4, e.DEFLATERAW = 5, e.INFLATERAW = 6, e.UNZIP = 7;
    var u = 31, c = 139;
    function h(s) {
      if (typeof s != "number" || s < e.DEFLATE || s > e.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = s, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
    }
    h.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = !0;
        return;
      }
      this.pending_close = !1, t(this.init_done, "close before init"), t(this.mode <= e.UNZIP), this.mode === e.DEFLATE || this.mode === e.GZIP || this.mode === e.DEFLATERAW ? i.deflateEnd(this.strm) : (this.mode === e.INFLATE || this.mode === e.GUNZIP || this.mode === e.INFLATERAW || this.mode === e.UNZIP) && o.inflateEnd(this.strm), this.mode = e.NONE, this.dictionary = null;
    }, h.prototype.write = function(s, b, p, m, E, M, I) {
      return this._write(!0, s, b, p, m, E, M, I);
    }, h.prototype.writeSync = function(s, b, p, m, E, M, I) {
      return this._write(!1, s, b, p, m, E, M, I);
    }, h.prototype._write = function(s, b, p, m, E, M, I, B) {
      if (t.equal(arguments.length, 8), t(this.init_done, "write before init"), t(this.mode !== e.NONE, "already finalized"), t.equal(!1, this.write_in_progress, "write already in progress"), t.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, t.equal(!1, b === void 0, "must provide flush value"), this.write_in_progress = !0, b !== e.Z_NO_FLUSH && b !== e.Z_PARTIAL_FLUSH && b !== e.Z_SYNC_FLUSH && b !== e.Z_FULL_FLUSH && b !== e.Z_FINISH && b !== e.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (p == null && (p = Le.Buffer.alloc(0), E = 0, m = 0), this.strm.avail_in = E, this.strm.input = p, this.strm.next_in = m, this.strm.avail_out = B, this.strm.output = M, this.strm.next_out = I, this.flush = b, !s)
        return this._process(), this._checkError() ? this._afterSync() : void 0;
      var T = this;
      return at.nextTick(function() {
        T._process(), T._after();
      }), this;
    }, h.prototype._afterSync = function() {
      var s = this.strm.avail_out, b = this.strm.avail_in;
      return this.write_in_progress = !1, [b, s];
    }, h.prototype._process = function() {
      var s = null;
      switch (this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = i.deflate(this.strm, this.flush);
          break;
        case e.UNZIP:
          switch (this.strm.avail_in > 0 && (s = this.strm.next_in), this.gzip_id_bytes_read) {
            case 0:
              if (s === null)
                break;
              if (this.strm.input[s] === u) {
                if (this.gzip_id_bytes_read = 1, s++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = e.INFLATE;
                break;
              }
            case 1:
              if (s === null)
                break;
              this.strm.input[s] === c ? (this.gzip_id_bytes_read = 2, this.mode = e.GUNZIP) : this.mode = e.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
          for (this.err = o.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          ), this.err === e.Z_NEED_DICT && this.dictionary && (this.err = o.inflateSetDictionary(this.strm, this.dictionary), this.err === e.Z_OK ? this.err = o.inflate(this.strm, this.flush) : this.err === e.Z_DATA_ERROR && (this.err = e.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === e.GUNZIP && this.err === e.Z_STREAM_END && this.strm.next_in[0] !== 0; )
            this.reset(), this.err = o.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    }, h.prototype._checkError = function() {
      switch (this.err) {
        case e.Z_OK:
        case e.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === e.Z_FINISH)
            return this._error("unexpected end of file"), !1;
          break;
        case e.Z_STREAM_END:
          break;
        case e.Z_NEED_DICT:
          return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
        default:
          return this._error("Zlib error"), !1;
      }
      return !0;
    }, h.prototype._after = function() {
      if (this._checkError()) {
        var s = this.strm.avail_out, b = this.strm.avail_in;
        this.write_in_progress = !1, this.callback(b, s), this.pending_close && this.close();
      }
    }, h.prototype._error = function(s) {
      this.strm.msg && (s = this.strm.msg), this.onerror(
        s,
        this.err
        // no hope of rescue.
      ), this.write_in_progress = !1, this.pending_close && this.close();
    }, h.prototype.init = function(s, b, p, m, E) {
      t(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), t(s >= 8 && s <= 15, "invalid windowBits"), t(b >= -1 && b <= 9, "invalid compression level"), t(p >= 1 && p <= 9, "invalid memlevel"), t(m === e.Z_FILTERED || m === e.Z_HUFFMAN_ONLY || m === e.Z_RLE || m === e.Z_FIXED || m === e.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(b, s, p, m, E), this._setDictionary();
    }, h.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    }, h.prototype.reset = function() {
      this._reset(), this._setDictionary();
    }, h.prototype._init = function(s, b, p, m, E) {
      switch (this.level = s, this.windowBits = b, this.memLevel = p, this.strategy = m, this.flush = e.Z_NO_FLUSH, this.err = e.Z_OK, (this.mode === e.GZIP || this.mode === e.GUNZIP) && (this.windowBits += 16), this.mode === e.UNZIP && (this.windowBits += 32), (this.mode === e.DEFLATERAW || this.mode === e.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new r(), this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = i.deflateInit2(this.strm, this.level, e.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
        case e.UNZIP:
          this.err = o.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      this.err !== e.Z_OK && this._error("Init error"), this.dictionary = E, this.write_in_progress = !1, this.init_done = !0;
    }, h.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (this.err = e.Z_OK, this.mode) {
          case e.DEFLATE:
          case e.DEFLATERAW:
            this.err = i.deflateSetDictionary(this.strm, this.dictionary);
            break;
        }
        this.err !== e.Z_OK && this._error("Failed to set dictionary");
      }
    }, h.prototype._reset = function() {
      switch (this.err = e.Z_OK, this.mode) {
        case e.DEFLATE:
        case e.DEFLATERAW:
        case e.GZIP:
          this.err = i.deflateReset(this.strm);
          break;
        case e.INFLATE:
        case e.INFLATERAW:
        case e.GUNZIP:
          this.err = o.inflateReset(this.strm);
          break;
      }
      this.err !== e.Z_OK && this._error("Failed to reset stream");
    }, e.Zlib = h;
  }(ms)), ms;
}
var t1;
function Ex() {
  return t1 || (t1 = 1, function(e) {
    var t = Le.Buffer, r = Ay().Transform, i = xx(), o = gn(), n = ho().ok, f = Le.kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + f.toString(16) + " bytes";
    i.Z_MIN_WINDOWBITS = 8, i.Z_MAX_WINDOWBITS = 15, i.Z_DEFAULT_WINDOWBITS = 15, i.Z_MIN_CHUNK = 64, i.Z_MAX_CHUNK = 1 / 0, i.Z_DEFAULT_CHUNK = 16 * 1024, i.Z_MIN_MEMLEVEL = 1, i.Z_MAX_MEMLEVEL = 9, i.Z_DEFAULT_MEMLEVEL = 8, i.Z_MIN_LEVEL = -1, i.Z_MAX_LEVEL = 9, i.Z_DEFAULT_LEVEL = i.Z_DEFAULT_COMPRESSION;
    for (var c = Object.keys(i), h = 0; h < c.length; h++) {
      var s = c[h];
      s.match(/^Z/) && Object.defineProperty(e, s, {
        enumerable: !0,
        value: i[s],
        writable: !1
      });
    }
    for (var b = {
      Z_OK: i.Z_OK,
      Z_STREAM_END: i.Z_STREAM_END,
      Z_NEED_DICT: i.Z_NEED_DICT,
      Z_ERRNO: i.Z_ERRNO,
      Z_STREAM_ERROR: i.Z_STREAM_ERROR,
      Z_DATA_ERROR: i.Z_DATA_ERROR,
      Z_MEM_ERROR: i.Z_MEM_ERROR,
      Z_BUF_ERROR: i.Z_BUF_ERROR,
      Z_VERSION_ERROR: i.Z_VERSION_ERROR
    }, p = Object.keys(b), m = 0; m < p.length; m++) {
      var E = p[m];
      b[b[E]] = E;
    }
    Object.defineProperty(e, "codes", {
      enumerable: !0,
      value: Object.freeze(b),
      writable: !1
    }), e.Deflate = B, e.Inflate = T, e.Gzip = j, e.Gunzip = N, e.DeflateRaw = k, e.InflateRaw = q, e.Unzip = $, e.createDeflate = function(y) {
      return new B(y);
    }, e.createInflate = function(y) {
      return new T(y);
    }, e.createDeflateRaw = function(y) {
      return new k(y);
    }, e.createInflateRaw = function(y) {
      return new q(y);
    }, e.createGzip = function(y) {
      return new j(y);
    }, e.createGunzip = function(y) {
      return new N(y);
    }, e.createUnzip = function(y) {
      return new $(y);
    }, e.deflate = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new B(v), y, a);
    }, e.deflateSync = function(y, v) {
      return I(new B(v), y);
    }, e.gzip = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new j(v), y, a);
    }, e.gzipSync = function(y, v) {
      return I(new j(v), y);
    }, e.deflateRaw = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new k(v), y, a);
    }, e.deflateRawSync = function(y, v) {
      return I(new k(v), y);
    }, e.unzip = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new $(v), y, a);
    }, e.unzipSync = function(y, v) {
      return I(new $(v), y);
    }, e.inflate = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new T(v), y, a);
    }, e.inflateSync = function(y, v) {
      return I(new T(v), y);
    }, e.gunzip = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new N(v), y, a);
    }, e.gunzipSync = function(y, v) {
      return I(new N(v), y);
    }, e.inflateRaw = function(y, v, a) {
      return typeof v == "function" && (a = v, v = {}), M(new q(v), y, a);
    }, e.inflateRawSync = function(y, v) {
      return I(new q(v), y);
    };
    function M(y, v, a) {
      var d = [], w = 0;
      y.on("error", A), y.on("end", S), y.end(v), x();
      function x() {
        for (var g; (g = y.read()) !== null; )
          d.push(g), w += g.length;
        y.once("readable", x);
      }
      function A(g) {
        y.removeListener("end", S), y.removeListener("readable", x), a(g);
      }
      function S() {
        var g, _ = null;
        w >= f ? _ = new RangeError(u) : g = t.concat(d, w), d = [], y.close(), a(_, g);
      }
    }
    function I(y, v) {
      if (typeof v == "string" && (v = t.from(v)), !t.isBuffer(v))
        throw new TypeError("Not a string or buffer");
      var a = y._finishFlushFlag;
      return y._processChunk(v, a);
    }
    function B(y) {
      if (!(this instanceof B))
        return new B(y);
      Q.call(this, y, i.DEFLATE);
    }
    function T(y) {
      if (!(this instanceof T))
        return new T(y);
      Q.call(this, y, i.INFLATE);
    }
    function j(y) {
      if (!(this instanceof j))
        return new j(y);
      Q.call(this, y, i.GZIP);
    }
    function N(y) {
      if (!(this instanceof N))
        return new N(y);
      Q.call(this, y, i.GUNZIP);
    }
    function k(y) {
      if (!(this instanceof k))
        return new k(y);
      Q.call(this, y, i.DEFLATERAW);
    }
    function q(y) {
      if (!(this instanceof q))
        return new q(y);
      Q.call(this, y, i.INFLATERAW);
    }
    function $(y) {
      if (!(this instanceof $))
        return new $(y);
      Q.call(this, y, i.UNZIP);
    }
    function re(y) {
      return y === i.Z_NO_FLUSH || y === i.Z_PARTIAL_FLUSH || y === i.Z_SYNC_FLUSH || y === i.Z_FULL_FLUSH || y === i.Z_FINISH || y === i.Z_BLOCK;
    }
    function Q(y, v) {
      var a = this;
      if (this._opts = y = y || {}, this._chunkSize = y.chunkSize || e.Z_DEFAULT_CHUNK, r.call(this, y), y.flush && !re(y.flush))
        throw new Error("Invalid flush flag: " + y.flush);
      if (y.finishFlush && !re(y.finishFlush))
        throw new Error("Invalid flush flag: " + y.finishFlush);
      if (this._flushFlag = y.flush || i.Z_NO_FLUSH, this._finishFlushFlag = typeof y.finishFlush < "u" ? y.finishFlush : i.Z_FINISH, y.chunkSize && (y.chunkSize < e.Z_MIN_CHUNK || y.chunkSize > e.Z_MAX_CHUNK))
        throw new Error("Invalid chunk size: " + y.chunkSize);
      if (y.windowBits && (y.windowBits < e.Z_MIN_WINDOWBITS || y.windowBits > e.Z_MAX_WINDOWBITS))
        throw new Error("Invalid windowBits: " + y.windowBits);
      if (y.level && (y.level < e.Z_MIN_LEVEL || y.level > e.Z_MAX_LEVEL))
        throw new Error("Invalid compression level: " + y.level);
      if (y.memLevel && (y.memLevel < e.Z_MIN_MEMLEVEL || y.memLevel > e.Z_MAX_MEMLEVEL))
        throw new Error("Invalid memLevel: " + y.memLevel);
      if (y.strategy && y.strategy != e.Z_FILTERED && y.strategy != e.Z_HUFFMAN_ONLY && y.strategy != e.Z_RLE && y.strategy != e.Z_FIXED && y.strategy != e.Z_DEFAULT_STRATEGY)
        throw new Error("Invalid strategy: " + y.strategy);
      if (y.dictionary && !t.isBuffer(y.dictionary))
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      this._handle = new i.Zlib(v);
      var d = this;
      this._hadError = !1, this._handle.onerror = function(A, S) {
        fe(d), d._hadError = !0;
        var g = new Error(A);
        g.errno = S, g.code = e.codes[S], d.emit("error", g);
      };
      var w = e.Z_DEFAULT_COMPRESSION;
      typeof y.level == "number" && (w = y.level);
      var x = e.Z_DEFAULT_STRATEGY;
      typeof y.strategy == "number" && (x = y.strategy), this._handle.init(y.windowBits || e.Z_DEFAULT_WINDOWBITS, w, y.memLevel || e.Z_DEFAULT_MEMLEVEL, x, y.dictionary), this._buffer = t.allocUnsafe(this._chunkSize), this._offset = 0, this._level = w, this._strategy = x, this.once("end", this.close), Object.defineProperty(this, "_closed", {
        get: function() {
          return !a._handle;
        },
        configurable: !0,
        enumerable: !0
      });
    }
    o.inherits(Q, r), Q.prototype.params = function(y, v, a) {
      if (y < e.Z_MIN_LEVEL || y > e.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + y);
      if (v != e.Z_FILTERED && v != e.Z_HUFFMAN_ONLY && v != e.Z_RLE && v != e.Z_FIXED && v != e.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + v);
      if (this._level !== y || this._strategy !== v) {
        var d = this;
        this.flush(i.Z_SYNC_FLUSH, function() {
          n(d._handle, "zlib binding closed"), d._handle.params(y, v), d._hadError || (d._level = y, d._strategy = v, a && a());
        });
      } else
        at.nextTick(a);
    }, Q.prototype.reset = function() {
      return n(this._handle, "zlib binding closed"), this._handle.reset();
    }, Q.prototype._flush = function(y) {
      this._transform(t.alloc(0), "", y);
    }, Q.prototype.flush = function(y, v) {
      var a = this, d = this._writableState;
      (typeof y == "function" || y === void 0 && !v) && (v = y, y = i.Z_FULL_FLUSH), d.ended ? v && at.nextTick(v) : d.ending ? v && this.once("end", v) : d.needDrain ? v && this.once("drain", function() {
        return a.flush(y, v);
      }) : (this._flushFlag = y, this.write(t.alloc(0), "", v));
    }, Q.prototype.close = function(y) {
      fe(this, y), at.nextTick(U, this);
    };
    function fe(y, v) {
      v && at.nextTick(v), y._handle && (y._handle.close(), y._handle = null);
    }
    function U(y) {
      y.emit("close");
    }
    Q.prototype._transform = function(y, v, a) {
      var d, w = this._writableState, x = w.ending || w.ended, A = x && (!y || w.length === y.length);
      if (y !== null && !t.isBuffer(y))
        return a(new Error("invalid input"));
      if (!this._handle)
        return a(new Error("zlib binding closed"));
      A ? d = this._finishFlushFlag : (d = this._flushFlag, y.length >= w.length && (this._flushFlag = this._opts.flush || i.Z_NO_FLUSH)), this._processChunk(y, d, a);
    }, Q.prototype._processChunk = function(y, v, a) {
      var d = y && y.length, w = this._chunkSize - this._offset, x = 0, A = this, S = typeof a == "function";
      if (!S) {
        var g = [], _ = 0, l;
        this.on("error", function(V) {
          l = V;
        }), n(this._handle, "zlib binding closed");
        do
          var R = this._handle.writeSync(
            v,
            y,
            // in
            x,
            // in_off
            d,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            w
          );
        while (!this._hadError && H(R[0], R[1]));
        if (this._hadError)
          throw l;
        if (_ >= f)
          throw fe(this), new RangeError(u);
        var Y = t.concat(g, _);
        return fe(this), Y;
      }
      n(this._handle, "zlib binding closed");
      var oe = this._handle.write(
        v,
        y,
        // in
        x,
        // in_off
        d,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        w
      );
      oe.buffer = y, oe.callback = H;
      function H(V, F) {
        if (this && (this.buffer = null, this.callback = null), !A._hadError) {
          var te = w - F;
          if (n(te >= 0, "have should not go down"), te > 0) {
            var he = A._buffer.slice(A._offset, A._offset + te);
            A._offset += te, S ? A.push(he) : (g.push(he), _ += he.length);
          }
          if ((F === 0 || A._offset >= A._chunkSize) && (w = A._chunkSize, A._offset = 0, A._buffer = t.allocUnsafe(A._chunkSize)), F === 0) {
            if (x += d - V, d = V, !S)
              return !0;
            var K = A._handle.write(v, y, x, d, A._buffer, A._offset, A._chunkSize);
            K.callback = H, K.buffer = y;
            return;
          }
          if (!S)
            return !1;
          a();
        }
      }
    }, o.inherits(B, Q), o.inherits(T, Q), o.inherits(j, Q), o.inherits(N, Q), o.inherits(k, Q), o.inherits(q, Q), o.inherits($, Q);
  }(ys)), ys;
}
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.InvalidStatusCodeError = Yn.InvalidCertError = void 0;
const Py = Object.freeze({
  redirect: !0,
  expectStatusCode: 200,
  headers: {},
  full: !1,
  keepAlive: !0,
  cors: !1,
  referrer: !1,
  sslAllowSelfSigned: !1,
  _redirectCount: 0
});
class rh extends Error {
  constructor(t, r) {
    super(t), this.fingerprint256 = r;
  }
}
Yn.InvalidCertError = rh;
class t0 extends Error {
  constructor(t) {
    super(`Request Failed. Status Code: ${t}`), this.statusCode = t;
  }
}
Yn.InvalidStatusCodeError = t0;
function Cy(e, t) {
  if (!t || t === "text" || t === "json")
    try {
      let r = new TextDecoder("utf8", { fatal: !0 }).decode(e);
      if (t === "text")
        return r;
      try {
        return JSON.parse(r);
      } catch (i) {
        if (t === "json")
          throw i;
        return r;
      }
    } catch (r) {
      if (t === "text" || t === "json")
        throw r;
    }
  return e;
}
let r1 = {};
function nh(e, t) {
  var p;
  let r = { ...Py, ...t };
  const i = Sy(), o = ax(), n = Ex(), { promisify: f } = gn(), { resolve: u } = Qh(), c = !!/^https/.test(e);
  let h = {
    method: r.method || "GET",
    headers: { "Accept-Encoding": "gzip, deflate, br" }
  };
  const s = (m) => m.replace(/:| /g, "").toLowerCase();
  if (r.keepAlive) {
    const m = {
      keepAlive: !0,
      keepAliveMsecs: 3e4,
      maxFreeSockets: 1024,
      maxCachedSessions: 1024
    }, E = [
      c,
      c && ((p = r.sslPinnedCertificates) == null ? void 0 : p.map((M) => s(M)).sort())
    ].join();
    h.agent = r1[E] || (r1[E] = new (c ? o : i).Agent(m));
  }
  r.type === "json" && (h.headers["Content-Type"] = "application/json"), r.data && (r.method || (h.method = "POST"), h.body = r.type === "json" ? JSON.stringify(r.data) : r.data), h.headers = { ...h.headers, ...r.headers }, r.sslAllowSelfSigned && (h.rejectUnauthorized = !1);
  const b = async (m) => {
    const E = m.statusCode;
    if (r.redirect && 300 <= E && E < 400 && m.headers.location) {
      if (r._redirectCount == 10)
        throw new Error("Request failed. Too much redirects.");
      return r._redirectCount += 1, await nh(u(e, m.headers.location), r);
    }
    if (r.expectStatusCode && E !== r.expectStatusCode)
      throw m.resume(), new t0(E);
    let M = [];
    for await (const j of m)
      M.push(j);
    let I = Le.Buffer.concat(M);
    const B = m.headers["content-encoding"];
    B === "br" && (I = await f(n.brotliDecompress)(I)), (B === "gzip" || B === "deflate") && (I = await f(n.unzip)(I));
    const T = Cy(I, r.type);
    return r.full ? { headers: m.headers, status: E, body: T } : T;
  };
  return new Promise((m, E) => {
    var j;
    const M = async (N) => {
      if (N && N.code === "DEPTH_ZERO_SELF_SIGNED_CERT")
        try {
          await nh(e, { ...r, sslAllowSelfSigned: !0, sslPinnedCertificates: [] });
        } catch (k) {
          k && k.fingerprint256 && (N = new rh(`Self-signed SSL certificate: ${k.fingerprint256}`, k.fingerprint256));
        }
      E(N);
    }, I = (c ? o : i).request(e, h, (N) => {
      N.on("error", M), (async () => {
        try {
          m(await b(N));
        } catch (k) {
          E(k);
        }
      })();
    });
    I.on("error", M);
    const B = (j = r.sslPinnedCertificates) == null ? void 0 : j.map((N) => s(N)), T = (N) => {
      var q;
      const k = s(((q = N.getPeerCertificate()) == null ? void 0 : q.fingerprint256) || "");
      if (!(!k && N.isSessionReused()) && !B.includes(k))
        return I.emit("error", new rh(`Invalid SSL certificate: ${k} Expected: ${B}`, k)), I.abort();
    };
    r.sslPinnedCertificates && I.on("socket", (N) => {
      N.listeners("secureConnect").map((q) => (q.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || N.on("secureConnect", T.bind(null, N));
    }), r.keepAlive && I.setNoDelay(!0), h.body && I.write(h.body), I.end();
  });
}
const Sx = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((e) => e.toLowerCase())), Ax = new Set([
  "Accept-Charset",
  "Accept-Encoding",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Connection",
  "Content-Length",
  "Cookie",
  "Cookie2",
  "Date",
  "DNT",
  "Expect",
  "Host",
  "Keep-Alive",
  "Origin",
  "Referer",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via"
].map((e) => e.toLowerCase()));
async function Mx(e, t) {
  let r = { ...Py, ...t };
  const i = new Headers();
  r.type === "json" && i.set("Content-Type", "application/json");
  let o = new URL(e);
  if (o.username) {
    const c = btoa(`${o.username}:${o.password}`);
    i.set("Authorization", `Basic ${c}`), o.username = "", o.password = "";
  }
  e = "" + o;
  for (let c in r.headers) {
    const h = c.toLowerCase();
    (Sx.has(h) || r.cors && !Ax.has(h)) && i.set(c, r.headers[c]);
  }
  let n = { headers: i, redirect: r.redirect ? "follow" : "manual" };
  r.referrer || (n.referrerPolicy = "no-referrer"), r.cors && (n.mode = "cors"), r.data && (r.method || (n.method = "POST"), n.body = r.type === "json" ? JSON.stringify(r.data) : r.data);
  const f = await fetch(e, n);
  if (r.expectStatusCode && f.status !== r.expectStatusCode)
    throw new t0(f.status);
  const u = Cy(new Uint8Array(await f.arrayBuffer()), r.type);
  return r.full ? { headers: Object.fromEntries(f.headers.entries()), status: f.status, body: u } : u;
}
const Rx = !!(typeof at == "object" && at.versions && at.versions.node && at.versions.v8);
function Bx(e, t) {
  return (Rx ? nh : Mx)(e, t);
}
Yn.default = Bx;
Object.defineProperty(Pi, "__esModule", { value: !0 });
Pi.getProvider = Pi.fetchFromProvider = void 0;
const Ix = Yn, Tx = async (e, t) => (await (0, Ix.default)(e, {
  headers: {
    "content-type": "application/json"
  },
  type: "json",
  data: {
    method: t.method,
    params: t.params,
    jsonrpc: "2.0",
    id: 1
  }
})).result;
Pi.fetchFromProvider = Tx;
const Ox = (e) => {
  var t;
  if (typeof e == "string")
    return e;
  if (((t = e == null ? void 0 : e.connection) == null ? void 0 : t.url) !== void 0)
    return e.connection.url;
  throw new Error("Must provide valid provider URL or Web3Provider");
};
Pi.getProvider = Ox;
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(o, n, f, u) {
    u === void 0 && (u = f);
    var c = Object.getOwnPropertyDescriptor(n, f);
    (!c || ("get" in c ? !n.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return n[f];
    } }), Object.defineProperty(o, u, c);
  } : function(o, n, f, u) {
    u === void 0 && (u = f), o[u] = n[f];
  }), r = Ze && Ze.__exportStar || function(o, n) {
    for (var f in o)
      f !== "default" && !Object.prototype.hasOwnProperty.call(n, f) && t(n, o, f);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toAscii = e.stripHexPrefix = e.padToEven = e.isHexString = e.isHexPrefixed = e.getKeys = e.getBinarySize = e.fromUtf8 = e.fromAscii = e.arrayContainsArray = void 0, r(Do, e), r(Wo, e), r(Wh, e), r(_a, e), r(Zo, e), r(pr, e), r(ri, e), r(Zh, e), r(vy, e), r(Xo, e);
  var i = Dt;
  Object.defineProperty(e, "arrayContainsArray", { enumerable: !0, get: function() {
    return i.arrayContainsArray;
  } }), Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return i.fromAscii;
  } }), Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return i.fromUtf8;
  } }), Object.defineProperty(e, "getBinarySize", { enumerable: !0, get: function() {
    return i.getBinarySize;
  } }), Object.defineProperty(e, "getKeys", { enumerable: !0, get: function() {
    return i.getKeys;
  } }), Object.defineProperty(e, "isHexPrefixed", { enumerable: !0, get: function() {
    return i.isHexPrefixed;
  } }), Object.defineProperty(e, "isHexString", { enumerable: !0, get: function() {
    return i.isHexString;
  } }), Object.defineProperty(e, "padToEven", { enumerable: !0, get: function() {
    return i.padToEven;
  } }), Object.defineProperty(e, "stripHexPrefix", { enumerable: !0, get: function() {
    return i.stripHexPrefix;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return i.toAscii;
  } }), r(Yo, e), r(Pi, e);
})(ma);
var Xt = {}, Ny = function(t) {
  if (typeof t != "string")
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof t + ", while checking isHexPrefixed.");
  return t.slice(0, 2) === "0x";
}, Px = Ny, Cx = function(t) {
  return typeof t != "string" ? t : Px(t) ? t.slice(2) : t;
}, Nx = Ny, Ly = Cx;
function af(e) {
  var t = e;
  if (typeof t != "string")
    throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof t + ", while padToEven.");
  return t.length % 2 && (t = "0" + t), t;
}
function ky(e) {
  var t = e.toString(16);
  return "0x" + t;
}
function Lx(e) {
  var t = ky(e);
  return new Le.Buffer(af(t.slice(2)), "hex");
}
function kx(e) {
  if (typeof e != "string")
    throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof e + "'.");
  return Le.Buffer.byteLength(e, "utf8");
}
function jx(e, t, r) {
  if (Array.isArray(e) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof e + "'");
  if (Array.isArray(t) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof t + "'");
  return t[!!r && "some" || "every"](function(i) {
    return e.indexOf(i) >= 0;
  });
}
function qx(e) {
  var t = new Le.Buffer(af(Ly(e).replace(/^0+|0+$/g, "")), "hex");
  return t.toString("utf8");
}
function Dx(e) {
  var t = "", r = 0, i = e.length;
  for (e.substring(0, 2) === "0x" && (r = 2); r < i; r += 2) {
    var o = parseInt(e.substr(r, 2), 16);
    t += String.fromCharCode(o);
  }
  return t;
}
function $x(e) {
  var t = new Le.Buffer(e, "utf8");
  return "0x" + af(t.toString("hex")).replace(/^0+|0+$/g, "");
}
function Ux(e) {
  for (var t = "", r = 0; r < e.length; r++) {
    var i = e.charCodeAt(r), o = i.toString(16);
    t += o.length < 2 ? "0" + o : o;
  }
  return "0x" + t;
}
function Fx(e, t, r) {
  if (!Array.isArray(e))
    throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof e + "'");
  if (typeof t != "string")
    throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof t + "'.");
  for (var i = [], o = 0; o < e.length; o++) {
    var n = e[o][t];
    if (r && !n)
      n = "";
    else if (typeof n != "string")
      throw new Error("invalid abi");
    i.push(n);
  }
  return i;
}
function zx(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
var r0 = {
  arrayContainsArray: jx,
  intToBuffer: Lx,
  getBinarySize: kx,
  isHexPrefixed: Nx,
  stripHexPrefix: Ly,
  padToEven: af,
  intToHex: ky,
  fromAscii: Ux,
  fromUtf8: $x,
  toAscii: Dx,
  toUtf8: qx,
  getKeys: Fx,
  isHexString: zx
};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.numberToBuffer = Xt.normalize = Xt.recoverPublicKey = Xt.concatSig = Xt.legacyToBuffer = Xt.isNullish = Xt.padWithZeroes = void 0;
const Pr = ma, ih = r0;
function ah(e, t) {
  if (e !== "" && !/^[a-f0-9]+$/iu.test(e))
    throw new Error(`Expected an unprefixed hex string. Received: ${e}`);
  if (t < 0)
    throw new Error(`Expected a non-negative integer target length. Received: ${t}`);
  return String.prototype.padStart.call(e, t, "0");
}
Xt.padWithZeroes = ah;
function Hx(e) {
  return e == null;
}
Xt.isNullish = Hx;
function Vx(e) {
  return typeof e == "string" && !(0, ih.isHexString)(e) ? Le.Buffer.from(e) : (0, Pr.toBuffer)(e);
}
Xt.legacyToBuffer = Vx;
function Wx(e, t, r) {
  const i = (0, Pr.fromSigned)(t), o = (0, Pr.fromSigned)(r), n = (0, Pr.bufferToInt)(e), f = ah((0, Pr.toUnsigned)(i).toString("hex"), 64), u = ah((0, Pr.toUnsigned)(o).toString("hex"), 64), c = (0, ih.stripHexPrefix)((0, ih.intToHex)(n));
  return (0, Pr.addHexPrefix)(f.concat(u, c));
}
Xt.concatSig = Wx;
function Kx(e, t) {
  const r = (0, Pr.fromRpcSig)(t);
  return (0, Pr.ecrecover)(e, r.v, r.r, r.s);
}
Xt.recoverPublicKey = Kx;
function Zx(e) {
  if (e) {
    if (typeof e == "number") {
      if (e < 0)
        return "0x";
      const t = (0, Pr.toBuffer)(e);
      e = (0, Pr.bufferToHex)(t);
    }
    if (typeof e != "string") {
      let t = "eth-sig-util.normalize() requires hex string or integer input.";
      throw t += ` received ${typeof e}: ${e}`, new Error(t);
    }
    return (0, Pr.addHexPrefix)(e.toLowerCase());
  }
}
Xt.normalize = Zx;
function Gx(e) {
  const t = e.toString(16), r = t.length % 2 ? "0" : "";
  return Le.Buffer.from(r + t, "hex");
}
Xt.numberToBuffer = Gx;
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.extractPublicKey = Tn.recoverPersonalSignature = Tn.personalSign = void 0;
const xi = ma, on = Xt;
function Jx({ privateKey: e, data: t }) {
  if ((0, on.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, on.isNullish)(e))
    throw new Error("Missing privateKey parameter");
  const r = (0, on.legacyToBuffer)(t), i = (0, xi.hashPersonalMessage)(r), o = (0, xi.ecsign)(i, e);
  return (0, on.concatSig)((0, xi.toBuffer)(o.v), o.r, o.s);
}
Tn.personalSign = Jx;
function Xx({ data: e, signature: t }) {
  if ((0, on.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, on.isNullish)(t))
    throw new Error("Missing signature parameter");
  const r = jy(e, t), i = (0, xi.publicToAddress)(r);
  return (0, xi.bufferToHex)(i);
}
Tn.recoverPersonalSignature = Xx;
function Yx({ data: e, signature: t }) {
  if ((0, on.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, on.isNullish)(t))
    throw new Error("Missing signature parameter");
  return `0x${jy(e, t).toString("hex")}`;
}
Tn.extractPublicKey = Yx;
function jy(e, t) {
  const r = (0, xi.hashPersonalMessage)((0, on.legacyToBuffer)(e));
  return (0, on.recoverPublicKey)(r, t);
}
var qy = {}, On = {}, n0 = { exports: {} };
n0.exports;
(function(e) {
  (function(t, r) {
    function i(U, y) {
      if (!U)
        throw new Error(y || "Assertion failed");
    }
    function o(U, y) {
      U.super_ = y;
      var v = function() {
      };
      v.prototype = y.prototype, U.prototype = new v(), U.prototype.constructor = U;
    }
    function n(U, y, v) {
      if (n.isBN(U))
        return U;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, U !== null && ((y === "le" || y === "be") && (v = y, y = 10), this._init(U || 0, y || 10, v || "be"));
    }
    typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
    var f;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? f = window.Buffer : f = Le.Buffer;
    } catch {
    }
    n.isBN = function(y) {
      return y instanceof n ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === n.wordSize && Array.isArray(y.words);
    }, n.max = function(y, v) {
      return y.cmp(v) > 0 ? y : v;
    }, n.min = function(y, v) {
      return y.cmp(v) < 0 ? y : v;
    }, n.prototype._init = function(y, v, a) {
      if (typeof y == "number")
        return this._initNumber(y, v, a);
      if (typeof y == "object")
        return this._initArray(y, v, a);
      v === "hex" && (v = 16), i(v === (v | 0) && v >= 2 && v <= 36), y = y.toString().replace(/\s+/g, "");
      var d = 0;
      y[0] === "-" && (d++, this.negative = 1), d < y.length && (v === 16 ? this._parseHex(y, d, a) : (this._parseBase(y, v, d), a === "le" && this._initArray(this.toArray(), v, a)));
    }, n.prototype._initNumber = function(y, v, a) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : (i(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), a === "le" && this._initArray(this.toArray(), v, a);
    }, n.prototype._initArray = function(y, v, a) {
      if (i(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        this.words[d] = 0;
      var w, x, A = 0;
      if (a === "be")
        for (d = y.length - 1, w = 0; d >= 0; d -= 3)
          x = y[d] | y[d - 1] << 8 | y[d - 2] << 16, this.words[w] |= x << A & 67108863, this.words[w + 1] = x >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);
      else if (a === "le")
        for (d = 0, w = 0; d < y.length; d += 3)
          x = y[d] | y[d + 1] << 8 | y[d + 2] << 16, this.words[w] |= x << A & 67108863, this.words[w + 1] = x >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);
      return this.strip();
    };
    function u(U, y) {
      var v = U.charCodeAt(y);
      return v >= 65 && v <= 70 ? v - 55 : v >= 97 && v <= 102 ? v - 87 : v - 48 & 15;
    }
    function c(U, y, v) {
      var a = u(U, v);
      return v - 1 >= y && (a |= u(U, v - 1) << 4), a;
    }
    n.prototype._parseHex = function(y, v, a) {
      this.length = Math.ceil((y.length - v) / 6), this.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        this.words[d] = 0;
      var w = 0, x = 0, A;
      if (a === "be")
        for (d = y.length - 1; d >= v; d -= 2)
          A = c(y, v, d) << w, this.words[x] |= A & 67108863, w >= 18 ? (w -= 18, x += 1, this.words[x] |= A >>> 26) : w += 8;
      else {
        var S = y.length - v;
        for (d = S % 2 === 0 ? v + 1 : v; d < y.length; d += 2)
          A = c(y, v, d) << w, this.words[x] |= A & 67108863, w >= 18 ? (w -= 18, x += 1, this.words[x] |= A >>> 26) : w += 8;
      }
      this.strip();
    };
    function h(U, y, v, a) {
      for (var d = 0, w = Math.min(U.length, v), x = y; x < w; x++) {
        var A = U.charCodeAt(x) - 48;
        d *= a, A >= 49 ? d += A - 49 + 10 : A >= 17 ? d += A - 17 + 10 : d += A;
      }
      return d;
    }
    n.prototype._parseBase = function(y, v, a) {
      this.words = [0], this.length = 1;
      for (var d = 0, w = 1; w <= 67108863; w *= v)
        d++;
      d--, w = w / v | 0;
      for (var x = y.length - a, A = x % d, S = Math.min(x, x - A) + a, g = 0, _ = a; _ < S; _ += d)
        g = h(y, _, _ + d, v), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (A !== 0) {
        var l = 1;
        for (g = h(y, _, y.length, v), _ = 0; _ < A; _++)
          l *= v;
        this.imuln(l), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, n.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var v = 0; v < this.length; v++)
        y.words[v] = this.words[v];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, n.prototype.clone = function() {
      var y = new n(null);
      return this.copy(y), y;
    }, n.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, n.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, n.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, n.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var s = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], b = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], p = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    n.prototype.toString = function(y, v) {
      y = y || 10, v = v | 0 || 1;
      var a;
      if (y === 16 || y === "hex") {
        a = "";
        for (var d = 0, w = 0, x = 0; x < this.length; x++) {
          var A = this.words[x], S = ((A << d | w) & 16777215).toString(16);
          w = A >>> 24 - d & 16777215, w !== 0 || x !== this.length - 1 ? a = s[6 - S.length] + S + a : a = S + a, d += 2, d >= 26 && (d -= 26, x--);
        }
        for (w !== 0 && (a = w.toString(16) + a); a.length % v !== 0; )
          a = "0" + a;
        return this.negative !== 0 && (a = "-" + a), a;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var g = b[y], _ = p[y];
        a = "";
        var l = this.clone();
        for (l.negative = 0; !l.isZero(); ) {
          var R = l.modn(_).toString(y);
          l = l.idivn(_), l.isZero() ? a = R + a : a = s[g - R.length] + R + a;
        }
        for (this.isZero() && (a = "0" + a); a.length % v !== 0; )
          a = "0" + a;
        return this.negative !== 0 && (a = "-" + a), a;
      }
      i(!1, "Base should be between 2 and 36");
    }, n.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, n.prototype.toJSON = function() {
      return this.toString(16);
    }, n.prototype.toBuffer = function(y, v) {
      return i(typeof f < "u"), this.toArrayLike(f, y, v);
    }, n.prototype.toArray = function(y, v) {
      return this.toArrayLike(Array, y, v);
    }, n.prototype.toArrayLike = function(y, v, a) {
      var d = this.byteLength(), w = a || Math.max(1, d);
      i(d <= w, "byte array longer than desired length"), i(w > 0, "Requested array length <= 0"), this.strip();
      var x = v === "le", A = new y(w), S, g, _ = this.clone();
      if (x) {
        for (g = 0; !_.isZero(); g++)
          S = _.andln(255), _.iushrn(8), A[g] = S;
        for (; g < w; g++)
          A[g] = 0;
      } else {
        for (g = 0; g < w - d; g++)
          A[g] = 0;
        for (g = 0; !_.isZero(); g++)
          S = _.andln(255), _.iushrn(8), A[w - g - 1] = S;
      }
      return A;
    }, Math.clz32 ? n.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : n.prototype._countBits = function(y) {
      var v = y, a = 0;
      return v >= 4096 && (a += 13, v >>>= 13), v >= 64 && (a += 7, v >>>= 7), v >= 8 && (a += 4, v >>>= 4), v >= 2 && (a += 2, v >>>= 2), a + v;
    }, n.prototype._zeroBits = function(y) {
      if (y === 0)
        return 26;
      var v = y, a = 0;
      return v & 8191 || (a += 13, v >>>= 13), v & 127 || (a += 7, v >>>= 7), v & 15 || (a += 4, v >>>= 4), v & 3 || (a += 2, v >>>= 2), v & 1 || a++, a;
    }, n.prototype.bitLength = function() {
      var y = this.words[this.length - 1], v = this._countBits(y);
      return (this.length - 1) * 26 + v;
    };
    function m(U) {
      for (var y = new Array(U.bitLength()), v = 0; v < y.length; v++) {
        var a = v / 26 | 0, d = v % 26;
        y[v] = (U.words[a] & 1 << d) >>> d;
      }
      return y;
    }
    n.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var y = 0, v = 0; v < this.length; v++) {
        var a = this._zeroBits(this.words[v]);
        if (y += a, a !== 26)
          break;
      }
      return y;
    }, n.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, n.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, n.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, n.prototype.isNeg = function() {
      return this.negative !== 0;
    }, n.prototype.neg = function() {
      return this.clone().ineg();
    }, n.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, n.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var v = 0; v < y.length; v++)
        this.words[v] = this.words[v] | y.words[v];
      return this.strip();
    }, n.prototype.ior = function(y) {
      return i((this.negative | y.negative) === 0), this.iuor(y);
    }, n.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, n.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, n.prototype.iuand = function(y) {
      var v;
      this.length > y.length ? v = y : v = this;
      for (var a = 0; a < v.length; a++)
        this.words[a] = this.words[a] & y.words[a];
      return this.length = v.length, this.strip();
    }, n.prototype.iand = function(y) {
      return i((this.negative | y.negative) === 0), this.iuand(y);
    }, n.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, n.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, n.prototype.iuxor = function(y) {
      var v, a;
      this.length > y.length ? (v = this, a = y) : (v = y, a = this);
      for (var d = 0; d < a.length; d++)
        this.words[d] = v.words[d] ^ a.words[d];
      if (this !== v)
        for (; d < v.length; d++)
          this.words[d] = v.words[d];
      return this.length = v.length, this.strip();
    }, n.prototype.ixor = function(y) {
      return i((this.negative | y.negative) === 0), this.iuxor(y);
    }, n.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, n.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, n.prototype.inotn = function(y) {
      i(typeof y == "number" && y >= 0);
      var v = Math.ceil(y / 26) | 0, a = y % 26;
      this._expand(v), a > 0 && v--;
      for (var d = 0; d < v; d++)
        this.words[d] = ~this.words[d] & 67108863;
      return a > 0 && (this.words[d] = ~this.words[d] & 67108863 >> 26 - a), this.strip();
    }, n.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, n.prototype.setn = function(y, v) {
      i(typeof y == "number" && y >= 0);
      var a = y / 26 | 0, d = y % 26;
      return this._expand(a + 1), v ? this.words[a] = this.words[a] | 1 << d : this.words[a] = this.words[a] & ~(1 << d), this.strip();
    }, n.prototype.iadd = function(y) {
      var v;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, v = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, v = this.isub(y), y.negative = 1, v._normSign();
      var a, d;
      this.length > y.length ? (a = this, d = y) : (a = y, d = this);
      for (var w = 0, x = 0; x < d.length; x++)
        v = (a.words[x] | 0) + (d.words[x] | 0) + w, this.words[x] = v & 67108863, w = v >>> 26;
      for (; w !== 0 && x < a.length; x++)
        v = (a.words[x] | 0) + w, this.words[x] = v & 67108863, w = v >>> 26;
      if (this.length = a.length, w !== 0)
        this.words[this.length] = w, this.length++;
      else if (a !== this)
        for (; x < a.length; x++)
          this.words[x] = a.words[x];
      return this;
    }, n.prototype.add = function(y) {
      var v;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, v = this.sub(y), y.negative ^= 1, v) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, v = y.sub(this), this.negative = 1, v) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, n.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var v = this.iadd(y);
        return y.negative = 1, v._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var a = this.cmp(y);
      if (a === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var d, w;
      a > 0 ? (d = this, w = y) : (d = y, w = this);
      for (var x = 0, A = 0; A < w.length; A++)
        v = (d.words[A] | 0) - (w.words[A] | 0) + x, x = v >> 26, this.words[A] = v & 67108863;
      for (; x !== 0 && A < d.length; A++)
        v = (d.words[A] | 0) + x, x = v >> 26, this.words[A] = v & 67108863;
      if (x === 0 && A < d.length && d !== this)
        for (; A < d.length; A++)
          this.words[A] = d.words[A];
      return this.length = Math.max(this.length, A), d !== this && (this.negative = 1), this.strip();
    }, n.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function E(U, y, v) {
      v.negative = y.negative ^ U.negative;
      var a = U.length + y.length | 0;
      v.length = a, a = a - 1 | 0;
      var d = U.words[0] | 0, w = y.words[0] | 0, x = d * w, A = x & 67108863, S = x / 67108864 | 0;
      v.words[0] = A;
      for (var g = 1; g < a; g++) {
        for (var _ = S >>> 26, l = S & 67108863, R = Math.min(g, y.length - 1), Y = Math.max(0, g - U.length + 1); Y <= R; Y++) {
          var oe = g - Y | 0;
          d = U.words[oe] | 0, w = y.words[Y] | 0, x = d * w + l, _ += x / 67108864 | 0, l = x & 67108863;
        }
        v.words[g] = l | 0, S = _ | 0;
      }
      return S !== 0 ? v.words[g] = S | 0 : v.length--, v.strip();
    }
    var M = function(y, v, a) {
      var d = y.words, w = v.words, x = a.words, A = 0, S, g, _, l = d[0] | 0, R = l & 8191, Y = l >>> 13, oe = d[1] | 0, H = oe & 8191, V = oe >>> 13, F = d[2] | 0, te = F & 8191, he = F >>> 13, K = d[3] | 0, W = K & 8191, ce = K >>> 13, ve = d[4] | 0, Be = ve & 8191, ee = ve >>> 13, C = d[5] | 0, L = C & 8191, Z = C >>> 13, de = d[6] | 0, me = de & 8191, Te = de >>> 13, ze = d[7] | 0, z = ze & 8191, ue = ze >>> 13, se = d[8] | 0, _e = se & 8191, Ce = se >>> 13, Ve = d[9] | 0, ke = Ve & 8191, X = Ve >>> 13, Se = w[0] | 0, Ae = Se & 8191, qe = Se >>> 13, pe = w[1] | 0, Ee = pe & 8191, G = pe >>> 13, Ie = w[2] | 0, je = Ie & 8191, P = Ie >>> 13, Me = w[3] | 0, be = Me & 8191, ie = Me >>> 13, le = w[4] | 0, ge = le & 8191, Ge = le >>> 13, $e = w[5] | 0, Ne = $e & 8191, nt = $e >>> 13, st = w[6] | 0, Je = st & 8191, ft = st >>> 13, D = w[7] | 0, J = D & 8191, ne = D >>> 13, O = w[8] | 0, ae = O & 8191, we = O >>> 13, xe = w[9] | 0, Re = xe & 8191, De = xe >>> 13;
      a.negative = y.negative ^ v.negative, a.length = 19, S = Math.imul(R, Ae), g = Math.imul(R, qe), g = g + Math.imul(Y, Ae) | 0, _ = Math.imul(Y, qe);
      var He = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, S = Math.imul(H, Ae), g = Math.imul(H, qe), g = g + Math.imul(V, Ae) | 0, _ = Math.imul(V, qe), S = S + Math.imul(R, Ee) | 0, g = g + Math.imul(R, G) | 0, g = g + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, G) | 0;
      var Ue = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, S = Math.imul(te, Ae), g = Math.imul(te, qe), g = g + Math.imul(he, Ae) | 0, _ = Math.imul(he, qe), S = S + Math.imul(H, Ee) | 0, g = g + Math.imul(H, G) | 0, g = g + Math.imul(V, Ee) | 0, _ = _ + Math.imul(V, G) | 0, S = S + Math.imul(R, je) | 0, g = g + Math.imul(R, P) | 0, g = g + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, P) | 0;
      var yt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, S = Math.imul(W, Ae), g = Math.imul(W, qe), g = g + Math.imul(ce, Ae) | 0, _ = Math.imul(ce, qe), S = S + Math.imul(te, Ee) | 0, g = g + Math.imul(te, G) | 0, g = g + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, G) | 0, S = S + Math.imul(H, je) | 0, g = g + Math.imul(H, P) | 0, g = g + Math.imul(V, je) | 0, _ = _ + Math.imul(V, P) | 0, S = S + Math.imul(R, be) | 0, g = g + Math.imul(R, ie) | 0, g = g + Math.imul(Y, be) | 0, _ = _ + Math.imul(Y, ie) | 0;
      var et = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, S = Math.imul(Be, Ae), g = Math.imul(Be, qe), g = g + Math.imul(ee, Ae) | 0, _ = Math.imul(ee, qe), S = S + Math.imul(W, Ee) | 0, g = g + Math.imul(W, G) | 0, g = g + Math.imul(ce, Ee) | 0, _ = _ + Math.imul(ce, G) | 0, S = S + Math.imul(te, je) | 0, g = g + Math.imul(te, P) | 0, g = g + Math.imul(he, je) | 0, _ = _ + Math.imul(he, P) | 0, S = S + Math.imul(H, be) | 0, g = g + Math.imul(H, ie) | 0, g = g + Math.imul(V, be) | 0, _ = _ + Math.imul(V, ie) | 0, S = S + Math.imul(R, ge) | 0, g = g + Math.imul(R, Ge) | 0, g = g + Math.imul(Y, ge) | 0, _ = _ + Math.imul(Y, Ge) | 0;
      var ut = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, S = Math.imul(L, Ae), g = Math.imul(L, qe), g = g + Math.imul(Z, Ae) | 0, _ = Math.imul(Z, qe), S = S + Math.imul(Be, Ee) | 0, g = g + Math.imul(Be, G) | 0, g = g + Math.imul(ee, Ee) | 0, _ = _ + Math.imul(ee, G) | 0, S = S + Math.imul(W, je) | 0, g = g + Math.imul(W, P) | 0, g = g + Math.imul(ce, je) | 0, _ = _ + Math.imul(ce, P) | 0, S = S + Math.imul(te, be) | 0, g = g + Math.imul(te, ie) | 0, g = g + Math.imul(he, be) | 0, _ = _ + Math.imul(he, ie) | 0, S = S + Math.imul(H, ge) | 0, g = g + Math.imul(H, Ge) | 0, g = g + Math.imul(V, ge) | 0, _ = _ + Math.imul(V, Ge) | 0, S = S + Math.imul(R, Ne) | 0, g = g + Math.imul(R, nt) | 0, g = g + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, nt) | 0;
      var ct = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, S = Math.imul(me, Ae), g = Math.imul(me, qe), g = g + Math.imul(Te, Ae) | 0, _ = Math.imul(Te, qe), S = S + Math.imul(L, Ee) | 0, g = g + Math.imul(L, G) | 0, g = g + Math.imul(Z, Ee) | 0, _ = _ + Math.imul(Z, G) | 0, S = S + Math.imul(Be, je) | 0, g = g + Math.imul(Be, P) | 0, g = g + Math.imul(ee, je) | 0, _ = _ + Math.imul(ee, P) | 0, S = S + Math.imul(W, be) | 0, g = g + Math.imul(W, ie) | 0, g = g + Math.imul(ce, be) | 0, _ = _ + Math.imul(ce, ie) | 0, S = S + Math.imul(te, ge) | 0, g = g + Math.imul(te, Ge) | 0, g = g + Math.imul(he, ge) | 0, _ = _ + Math.imul(he, Ge) | 0, S = S + Math.imul(H, Ne) | 0, g = g + Math.imul(H, nt) | 0, g = g + Math.imul(V, Ne) | 0, _ = _ + Math.imul(V, nt) | 0, S = S + Math.imul(R, Je) | 0, g = g + Math.imul(R, ft) | 0, g = g + Math.imul(Y, Je) | 0, _ = _ + Math.imul(Y, ft) | 0;
      var vt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, S = Math.imul(z, Ae), g = Math.imul(z, qe), g = g + Math.imul(ue, Ae) | 0, _ = Math.imul(ue, qe), S = S + Math.imul(me, Ee) | 0, g = g + Math.imul(me, G) | 0, g = g + Math.imul(Te, Ee) | 0, _ = _ + Math.imul(Te, G) | 0, S = S + Math.imul(L, je) | 0, g = g + Math.imul(L, P) | 0, g = g + Math.imul(Z, je) | 0, _ = _ + Math.imul(Z, P) | 0, S = S + Math.imul(Be, be) | 0, g = g + Math.imul(Be, ie) | 0, g = g + Math.imul(ee, be) | 0, _ = _ + Math.imul(ee, ie) | 0, S = S + Math.imul(W, ge) | 0, g = g + Math.imul(W, Ge) | 0, g = g + Math.imul(ce, ge) | 0, _ = _ + Math.imul(ce, Ge) | 0, S = S + Math.imul(te, Ne) | 0, g = g + Math.imul(te, nt) | 0, g = g + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, nt) | 0, S = S + Math.imul(H, Je) | 0, g = g + Math.imul(H, ft) | 0, g = g + Math.imul(V, Je) | 0, _ = _ + Math.imul(V, ft) | 0, S = S + Math.imul(R, J) | 0, g = g + Math.imul(R, ne) | 0, g = g + Math.imul(Y, J) | 0, _ = _ + Math.imul(Y, ne) | 0;
      var pt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, S = Math.imul(_e, Ae), g = Math.imul(_e, qe), g = g + Math.imul(Ce, Ae) | 0, _ = Math.imul(Ce, qe), S = S + Math.imul(z, Ee) | 0, g = g + Math.imul(z, G) | 0, g = g + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, G) | 0, S = S + Math.imul(me, je) | 0, g = g + Math.imul(me, P) | 0, g = g + Math.imul(Te, je) | 0, _ = _ + Math.imul(Te, P) | 0, S = S + Math.imul(L, be) | 0, g = g + Math.imul(L, ie) | 0, g = g + Math.imul(Z, be) | 0, _ = _ + Math.imul(Z, ie) | 0, S = S + Math.imul(Be, ge) | 0, g = g + Math.imul(Be, Ge) | 0, g = g + Math.imul(ee, ge) | 0, _ = _ + Math.imul(ee, Ge) | 0, S = S + Math.imul(W, Ne) | 0, g = g + Math.imul(W, nt) | 0, g = g + Math.imul(ce, Ne) | 0, _ = _ + Math.imul(ce, nt) | 0, S = S + Math.imul(te, Je) | 0, g = g + Math.imul(te, ft) | 0, g = g + Math.imul(he, Je) | 0, _ = _ + Math.imul(he, ft) | 0, S = S + Math.imul(H, J) | 0, g = g + Math.imul(H, ne) | 0, g = g + Math.imul(V, J) | 0, _ = _ + Math.imul(V, ne) | 0, S = S + Math.imul(R, ae) | 0, g = g + Math.imul(R, we) | 0, g = g + Math.imul(Y, ae) | 0, _ = _ + Math.imul(Y, we) | 0;
      var ht = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, S = Math.imul(ke, Ae), g = Math.imul(ke, qe), g = g + Math.imul(X, Ae) | 0, _ = Math.imul(X, qe), S = S + Math.imul(_e, Ee) | 0, g = g + Math.imul(_e, G) | 0, g = g + Math.imul(Ce, Ee) | 0, _ = _ + Math.imul(Ce, G) | 0, S = S + Math.imul(z, je) | 0, g = g + Math.imul(z, P) | 0, g = g + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, P) | 0, S = S + Math.imul(me, be) | 0, g = g + Math.imul(me, ie) | 0, g = g + Math.imul(Te, be) | 0, _ = _ + Math.imul(Te, ie) | 0, S = S + Math.imul(L, ge) | 0, g = g + Math.imul(L, Ge) | 0, g = g + Math.imul(Z, ge) | 0, _ = _ + Math.imul(Z, Ge) | 0, S = S + Math.imul(Be, Ne) | 0, g = g + Math.imul(Be, nt) | 0, g = g + Math.imul(ee, Ne) | 0, _ = _ + Math.imul(ee, nt) | 0, S = S + Math.imul(W, Je) | 0, g = g + Math.imul(W, ft) | 0, g = g + Math.imul(ce, Je) | 0, _ = _ + Math.imul(ce, ft) | 0, S = S + Math.imul(te, J) | 0, g = g + Math.imul(te, ne) | 0, g = g + Math.imul(he, J) | 0, _ = _ + Math.imul(he, ne) | 0, S = S + Math.imul(H, ae) | 0, g = g + Math.imul(H, we) | 0, g = g + Math.imul(V, ae) | 0, _ = _ + Math.imul(V, we) | 0, S = S + Math.imul(R, Re) | 0, g = g + Math.imul(R, De) | 0, g = g + Math.imul(Y, Re) | 0, _ = _ + Math.imul(Y, De) | 0;
      var dt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, S = Math.imul(ke, Ee), g = Math.imul(ke, G), g = g + Math.imul(X, Ee) | 0, _ = Math.imul(X, G), S = S + Math.imul(_e, je) | 0, g = g + Math.imul(_e, P) | 0, g = g + Math.imul(Ce, je) | 0, _ = _ + Math.imul(Ce, P) | 0, S = S + Math.imul(z, be) | 0, g = g + Math.imul(z, ie) | 0, g = g + Math.imul(ue, be) | 0, _ = _ + Math.imul(ue, ie) | 0, S = S + Math.imul(me, ge) | 0, g = g + Math.imul(me, Ge) | 0, g = g + Math.imul(Te, ge) | 0, _ = _ + Math.imul(Te, Ge) | 0, S = S + Math.imul(L, Ne) | 0, g = g + Math.imul(L, nt) | 0, g = g + Math.imul(Z, Ne) | 0, _ = _ + Math.imul(Z, nt) | 0, S = S + Math.imul(Be, Je) | 0, g = g + Math.imul(Be, ft) | 0, g = g + Math.imul(ee, Je) | 0, _ = _ + Math.imul(ee, ft) | 0, S = S + Math.imul(W, J) | 0, g = g + Math.imul(W, ne) | 0, g = g + Math.imul(ce, J) | 0, _ = _ + Math.imul(ce, ne) | 0, S = S + Math.imul(te, ae) | 0, g = g + Math.imul(te, we) | 0, g = g + Math.imul(he, ae) | 0, _ = _ + Math.imul(he, we) | 0, S = S + Math.imul(H, Re) | 0, g = g + Math.imul(H, De) | 0, g = g + Math.imul(V, Re) | 0, _ = _ + Math.imul(V, De) | 0;
      var lt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, S = Math.imul(ke, je), g = Math.imul(ke, P), g = g + Math.imul(X, je) | 0, _ = Math.imul(X, P), S = S + Math.imul(_e, be) | 0, g = g + Math.imul(_e, ie) | 0, g = g + Math.imul(Ce, be) | 0, _ = _ + Math.imul(Ce, ie) | 0, S = S + Math.imul(z, ge) | 0, g = g + Math.imul(z, Ge) | 0, g = g + Math.imul(ue, ge) | 0, _ = _ + Math.imul(ue, Ge) | 0, S = S + Math.imul(me, Ne) | 0, g = g + Math.imul(me, nt) | 0, g = g + Math.imul(Te, Ne) | 0, _ = _ + Math.imul(Te, nt) | 0, S = S + Math.imul(L, Je) | 0, g = g + Math.imul(L, ft) | 0, g = g + Math.imul(Z, Je) | 0, _ = _ + Math.imul(Z, ft) | 0, S = S + Math.imul(Be, J) | 0, g = g + Math.imul(Be, ne) | 0, g = g + Math.imul(ee, J) | 0, _ = _ + Math.imul(ee, ne) | 0, S = S + Math.imul(W, ae) | 0, g = g + Math.imul(W, we) | 0, g = g + Math.imul(ce, ae) | 0, _ = _ + Math.imul(ce, we) | 0, S = S + Math.imul(te, Re) | 0, g = g + Math.imul(te, De) | 0, g = g + Math.imul(he, Re) | 0, _ = _ + Math.imul(he, De) | 0;
      var tt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, S = Math.imul(ke, be), g = Math.imul(ke, ie), g = g + Math.imul(X, be) | 0, _ = Math.imul(X, ie), S = S + Math.imul(_e, ge) | 0, g = g + Math.imul(_e, Ge) | 0, g = g + Math.imul(Ce, ge) | 0, _ = _ + Math.imul(Ce, Ge) | 0, S = S + Math.imul(z, Ne) | 0, g = g + Math.imul(z, nt) | 0, g = g + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, nt) | 0, S = S + Math.imul(me, Je) | 0, g = g + Math.imul(me, ft) | 0, g = g + Math.imul(Te, Je) | 0, _ = _ + Math.imul(Te, ft) | 0, S = S + Math.imul(L, J) | 0, g = g + Math.imul(L, ne) | 0, g = g + Math.imul(Z, J) | 0, _ = _ + Math.imul(Z, ne) | 0, S = S + Math.imul(Be, ae) | 0, g = g + Math.imul(Be, we) | 0, g = g + Math.imul(ee, ae) | 0, _ = _ + Math.imul(ee, we) | 0, S = S + Math.imul(W, Re) | 0, g = g + Math.imul(W, De) | 0, g = g + Math.imul(ce, Re) | 0, _ = _ + Math.imul(ce, De) | 0;
      var ot = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, S = Math.imul(ke, ge), g = Math.imul(ke, Ge), g = g + Math.imul(X, ge) | 0, _ = Math.imul(X, Ge), S = S + Math.imul(_e, Ne) | 0, g = g + Math.imul(_e, nt) | 0, g = g + Math.imul(Ce, Ne) | 0, _ = _ + Math.imul(Ce, nt) | 0, S = S + Math.imul(z, Je) | 0, g = g + Math.imul(z, ft) | 0, g = g + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ue, ft) | 0, S = S + Math.imul(me, J) | 0, g = g + Math.imul(me, ne) | 0, g = g + Math.imul(Te, J) | 0, _ = _ + Math.imul(Te, ne) | 0, S = S + Math.imul(L, ae) | 0, g = g + Math.imul(L, we) | 0, g = g + Math.imul(Z, ae) | 0, _ = _ + Math.imul(Z, we) | 0, S = S + Math.imul(Be, Re) | 0, g = g + Math.imul(Be, De) | 0, g = g + Math.imul(ee, Re) | 0, _ = _ + Math.imul(ee, De) | 0;
      var Qe = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, S = Math.imul(ke, Ne), g = Math.imul(ke, nt), g = g + Math.imul(X, Ne) | 0, _ = Math.imul(X, nt), S = S + Math.imul(_e, Je) | 0, g = g + Math.imul(_e, ft) | 0, g = g + Math.imul(Ce, Je) | 0, _ = _ + Math.imul(Ce, ft) | 0, S = S + Math.imul(z, J) | 0, g = g + Math.imul(z, ne) | 0, g = g + Math.imul(ue, J) | 0, _ = _ + Math.imul(ue, ne) | 0, S = S + Math.imul(me, ae) | 0, g = g + Math.imul(me, we) | 0, g = g + Math.imul(Te, ae) | 0, _ = _ + Math.imul(Te, we) | 0, S = S + Math.imul(L, Re) | 0, g = g + Math.imul(L, De) | 0, g = g + Math.imul(Z, Re) | 0, _ = _ + Math.imul(Z, De) | 0;
      var rt = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, S = Math.imul(ke, Je), g = Math.imul(ke, ft), g = g + Math.imul(X, Je) | 0, _ = Math.imul(X, ft), S = S + Math.imul(_e, J) | 0, g = g + Math.imul(_e, ne) | 0, g = g + Math.imul(Ce, J) | 0, _ = _ + Math.imul(Ce, ne) | 0, S = S + Math.imul(z, ae) | 0, g = g + Math.imul(z, we) | 0, g = g + Math.imul(ue, ae) | 0, _ = _ + Math.imul(ue, we) | 0, S = S + Math.imul(me, Re) | 0, g = g + Math.imul(me, De) | 0, g = g + Math.imul(Te, Re) | 0, _ = _ + Math.imul(Te, De) | 0;
      var it = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, S = Math.imul(ke, J), g = Math.imul(ke, ne), g = g + Math.imul(X, J) | 0, _ = Math.imul(X, ne), S = S + Math.imul(_e, ae) | 0, g = g + Math.imul(_e, we) | 0, g = g + Math.imul(Ce, ae) | 0, _ = _ + Math.imul(Ce, we) | 0, S = S + Math.imul(z, Re) | 0, g = g + Math.imul(z, De) | 0, g = g + Math.imul(ue, Re) | 0, _ = _ + Math.imul(ue, De) | 0;
      var Ye = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, S = Math.imul(ke, ae), g = Math.imul(ke, we), g = g + Math.imul(X, ae) | 0, _ = Math.imul(X, we), S = S + Math.imul(_e, Re) | 0, g = g + Math.imul(_e, De) | 0, g = g + Math.imul(Ce, Re) | 0, _ = _ + Math.imul(Ce, De) | 0;
      var Oe = (A + S | 0) + ((g & 8191) << 13) | 0;
      A = (_ + (g >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, S = Math.imul(ke, Re), g = Math.imul(ke, De), g = g + Math.imul(X, Re) | 0, _ = Math.imul(X, De);
      var Pe = (A + S | 0) + ((g & 8191) << 13) | 0;
      return A = (_ + (g >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, x[0] = He, x[1] = Ue, x[2] = yt, x[3] = et, x[4] = ut, x[5] = ct, x[6] = vt, x[7] = pt, x[8] = ht, x[9] = dt, x[10] = lt, x[11] = tt, x[12] = ot, x[13] = Qe, x[14] = rt, x[15] = it, x[16] = Ye, x[17] = Oe, x[18] = Pe, A !== 0 && (x[19] = A, a.length++), a;
    };
    Math.imul || (M = E);
    function I(U, y, v) {
      v.negative = y.negative ^ U.negative, v.length = U.length + y.length;
      for (var a = 0, d = 0, w = 0; w < v.length - 1; w++) {
        var x = d;
        d = 0;
        for (var A = a & 67108863, S = Math.min(w, y.length - 1), g = Math.max(0, w - U.length + 1); g <= S; g++) {
          var _ = w - g, l = U.words[_] | 0, R = y.words[g] | 0, Y = l * R, oe = Y & 67108863;
          x = x + (Y / 67108864 | 0) | 0, oe = oe + A | 0, A = oe & 67108863, x = x + (oe >>> 26) | 0, d += x >>> 26, x &= 67108863;
        }
        v.words[w] = A, a = x, x = d;
      }
      return a !== 0 ? v.words[w] = a : v.length--, v.strip();
    }
    function B(U, y, v) {
      var a = new T();
      return a.mulp(U, y, v);
    }
    n.prototype.mulTo = function(y, v) {
      var a, d = this.length + y.length;
      return this.length === 10 && y.length === 10 ? a = M(this, y, v) : d < 63 ? a = E(this, y, v) : d < 1024 ? a = I(this, y, v) : a = B(this, y, v), a;
    };
    function T(U, y) {
      this.x = U, this.y = y;
    }
    T.prototype.makeRBT = function(y) {
      for (var v = new Array(y), a = n.prototype._countBits(y) - 1, d = 0; d < y; d++)
        v[d] = this.revBin(d, a, y);
      return v;
    }, T.prototype.revBin = function(y, v, a) {
      if (y === 0 || y === a - 1)
        return y;
      for (var d = 0, w = 0; w < v; w++)
        d |= (y & 1) << v - w - 1, y >>= 1;
      return d;
    }, T.prototype.permute = function(y, v, a, d, w, x) {
      for (var A = 0; A < x; A++)
        d[A] = v[y[A]], w[A] = a[y[A]];
    }, T.prototype.transform = function(y, v, a, d, w, x) {
      this.permute(x, y, v, a, d, w);
      for (var A = 1; A < w; A <<= 1)
        for (var S = A << 1, g = Math.cos(2 * Math.PI / S), _ = Math.sin(2 * Math.PI / S), l = 0; l < w; l += S)
          for (var R = g, Y = _, oe = 0; oe < A; oe++) {
            var H = a[l + oe], V = d[l + oe], F = a[l + oe + A], te = d[l + oe + A], he = R * F - Y * te;
            te = R * te + Y * F, F = he, a[l + oe] = H + F, d[l + oe] = V + te, a[l + oe + A] = H - F, d[l + oe + A] = V - te, oe !== S && (he = g * R - _ * Y, Y = g * Y + _ * R, R = he);
          }
    }, T.prototype.guessLen13b = function(y, v) {
      var a = Math.max(v, y) | 1, d = a & 1, w = 0;
      for (a = a / 2 | 0; a; a = a >>> 1)
        w++;
      return 1 << w + 1 + d;
    }, T.prototype.conjugate = function(y, v, a) {
      if (!(a <= 1))
        for (var d = 0; d < a / 2; d++) {
          var w = y[d];
          y[d] = y[a - d - 1], y[a - d - 1] = w, w = v[d], v[d] = -v[a - d - 1], v[a - d - 1] = -w;
        }
    }, T.prototype.normalize13b = function(y, v) {
      for (var a = 0, d = 0; d < v / 2; d++) {
        var w = Math.round(y[2 * d + 1] / v) * 8192 + Math.round(y[2 * d] / v) + a;
        y[d] = w & 67108863, w < 67108864 ? a = 0 : a = w / 67108864 | 0;
      }
      return y;
    }, T.prototype.convert13b = function(y, v, a, d) {
      for (var w = 0, x = 0; x < v; x++)
        w = w + (y[x] | 0), a[2 * x] = w & 8191, w = w >>> 13, a[2 * x + 1] = w & 8191, w = w >>> 13;
      for (x = 2 * v; x < d; ++x)
        a[x] = 0;
      i(w === 0), i((w & -8192) === 0);
    }, T.prototype.stub = function(y) {
      for (var v = new Array(y), a = 0; a < y; a++)
        v[a] = 0;
      return v;
    }, T.prototype.mulp = function(y, v, a) {
      var d = 2 * this.guessLen13b(y.length, v.length), w = this.makeRBT(d), x = this.stub(d), A = new Array(d), S = new Array(d), g = new Array(d), _ = new Array(d), l = new Array(d), R = new Array(d), Y = a.words;
      Y.length = d, this.convert13b(y.words, y.length, A, d), this.convert13b(v.words, v.length, _, d), this.transform(A, x, S, g, d, w), this.transform(_, x, l, R, d, w);
      for (var oe = 0; oe < d; oe++) {
        var H = S[oe] * l[oe] - g[oe] * R[oe];
        g[oe] = S[oe] * R[oe] + g[oe] * l[oe], S[oe] = H;
      }
      return this.conjugate(S, g, d), this.transform(S, g, Y, x, d, w), this.conjugate(Y, x, d), this.normalize13b(Y, d), a.negative = y.negative ^ v.negative, a.length = y.length + v.length, a.strip();
    }, n.prototype.mul = function(y) {
      var v = new n(null);
      return v.words = new Array(this.length + y.length), this.mulTo(y, v);
    }, n.prototype.mulf = function(y) {
      var v = new n(null);
      return v.words = new Array(this.length + y.length), B(this, y, v);
    }, n.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, n.prototype.imuln = function(y) {
      i(typeof y == "number"), i(y < 67108864);
      for (var v = 0, a = 0; a < this.length; a++) {
        var d = (this.words[a] | 0) * y, w = (d & 67108863) + (v & 67108863);
        v >>= 26, v += d / 67108864 | 0, v += w >>> 26, this.words[a] = w & 67108863;
      }
      return v !== 0 && (this.words[a] = v, this.length++), this;
    }, n.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, n.prototype.sqr = function() {
      return this.mul(this);
    }, n.prototype.isqr = function() {
      return this.imul(this.clone());
    }, n.prototype.pow = function(y) {
      var v = m(y);
      if (v.length === 0)
        return new n(1);
      for (var a = this, d = 0; d < v.length && v[d] === 0; d++, a = a.sqr())
        ;
      if (++d < v.length)
        for (var w = a.sqr(); d < v.length; d++, w = w.sqr())
          v[d] !== 0 && (a = a.mul(w));
      return a;
    }, n.prototype.iushln = function(y) {
      i(typeof y == "number" && y >= 0);
      var v = y % 26, a = (y - v) / 26, d = 67108863 >>> 26 - v << 26 - v, w;
      if (v !== 0) {
        var x = 0;
        for (w = 0; w < this.length; w++) {
          var A = this.words[w] & d, S = (this.words[w] | 0) - A << v;
          this.words[w] = S | x, x = A >>> 26 - v;
        }
        x && (this.words[w] = x, this.length++);
      }
      if (a !== 0) {
        for (w = this.length - 1; w >= 0; w--)
          this.words[w + a] = this.words[w];
        for (w = 0; w < a; w++)
          this.words[w] = 0;
        this.length += a;
      }
      return this.strip();
    }, n.prototype.ishln = function(y) {
      return i(this.negative === 0), this.iushln(y);
    }, n.prototype.iushrn = function(y, v, a) {
      i(typeof y == "number" && y >= 0);
      var d;
      v ? d = (v - v % 26) / 26 : d = 0;
      var w = y % 26, x = Math.min((y - w) / 26, this.length), A = 67108863 ^ 67108863 >>> w << w, S = a;
      if (d -= x, d = Math.max(0, d), S) {
        for (var g = 0; g < x; g++)
          S.words[g] = this.words[g];
        S.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, g = 0; g < this.length; g++)
            this.words[g] = this.words[g + x];
        else
          this.words[0] = 0, this.length = 1;
      var _ = 0;
      for (g = this.length - 1; g >= 0 && (_ !== 0 || g >= d); g--) {
        var l = this.words[g] | 0;
        this.words[g] = _ << 26 - w | l >>> w, _ = l & A;
      }
      return S && _ !== 0 && (S.words[S.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, n.prototype.ishrn = function(y, v, a) {
      return i(this.negative === 0), this.iushrn(y, v, a);
    }, n.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, n.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, n.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, n.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, n.prototype.testn = function(y) {
      i(typeof y == "number" && y >= 0);
      var v = y % 26, a = (y - v) / 26, d = 1 << v;
      if (this.length <= a)
        return !1;
      var w = this.words[a];
      return !!(w & d);
    }, n.prototype.imaskn = function(y) {
      i(typeof y == "number" && y >= 0);
      var v = y % 26, a = (y - v) / 26;
      if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= a)
        return this;
      if (v !== 0 && a++, this.length = Math.min(a, this.length), v !== 0) {
        var d = 67108863 ^ 67108863 >>> v << v;
        this.words[this.length - 1] &= d;
      }
      return this.strip();
    }, n.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, n.prototype.iaddn = function(y) {
      return i(typeof y == "number"), i(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, n.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
        this.words[v] -= 67108864, v === this.length - 1 ? this.words[v + 1] = 1 : this.words[v + 1]++;
      return this.length = Math.max(this.length, v + 1), this;
    }, n.prototype.isubn = function(y) {
      if (i(typeof y == "number"), i(y < 67108864), y < 0)
        return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var v = 0; v < this.length && this.words[v] < 0; v++)
          this.words[v] += 67108864, this.words[v + 1] -= 1;
      return this.strip();
    }, n.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, n.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, n.prototype.iabs = function() {
      return this.negative = 0, this;
    }, n.prototype.abs = function() {
      return this.clone().iabs();
    }, n.prototype._ishlnsubmul = function(y, v, a) {
      var d = y.length + a, w;
      this._expand(d);
      var x, A = 0;
      for (w = 0; w < y.length; w++) {
        x = (this.words[w + a] | 0) + A;
        var S = (y.words[w] | 0) * v;
        x -= S & 67108863, A = (x >> 26) - (S / 67108864 | 0), this.words[w + a] = x & 67108863;
      }
      for (; w < this.length - a; w++)
        x = (this.words[w + a] | 0) + A, A = x >> 26, this.words[w + a] = x & 67108863;
      if (A === 0)
        return this.strip();
      for (i(A === -1), A = 0, w = 0; w < this.length; w++)
        x = -(this.words[w] | 0) + A, A = x >> 26, this.words[w] = x & 67108863;
      return this.negative = 1, this.strip();
    }, n.prototype._wordDiv = function(y, v) {
      var a = this.length - y.length, d = this.clone(), w = y, x = w.words[w.length - 1] | 0, A = this._countBits(x);
      a = 26 - A, a !== 0 && (w = w.ushln(a), d.iushln(a), x = w.words[w.length - 1] | 0);
      var S = d.length - w.length, g;
      if (v !== "mod") {
        g = new n(null), g.length = S + 1, g.words = new Array(g.length);
        for (var _ = 0; _ < g.length; _++)
          g.words[_] = 0;
      }
      var l = d.clone()._ishlnsubmul(w, 1, S);
      l.negative === 0 && (d = l, g && (g.words[S] = 1));
      for (var R = S - 1; R >= 0; R--) {
        var Y = (d.words[w.length + R] | 0) * 67108864 + (d.words[w.length + R - 1] | 0);
        for (Y = Math.min(Y / x | 0, 67108863), d._ishlnsubmul(w, Y, R); d.negative !== 0; )
          Y--, d.negative = 0, d._ishlnsubmul(w, 1, R), d.isZero() || (d.negative ^= 1);
        g && (g.words[R] = Y);
      }
      return g && g.strip(), d.strip(), v !== "div" && a !== 0 && d.iushrn(a), {
        div: g || null,
        mod: d
      };
    }, n.prototype.divmod = function(y, v, a) {
      if (i(!y.isZero()), this.isZero())
        return {
          div: new n(0),
          mod: new n(0)
        };
      var d, w, x;
      return this.negative !== 0 && y.negative === 0 ? (x = this.neg().divmod(y, v), v !== "mod" && (d = x.div.neg()), v !== "div" && (w = x.mod.neg(), a && w.negative !== 0 && w.iadd(y)), {
        div: d,
        mod: w
      }) : this.negative === 0 && y.negative !== 0 ? (x = this.divmod(y.neg(), v), v !== "mod" && (d = x.div.neg()), {
        div: d,
        mod: x.mod
      }) : this.negative & y.negative ? (x = this.neg().divmod(y.neg(), v), v !== "div" && (w = x.mod.neg(), a && w.negative !== 0 && w.isub(y)), {
        div: x.div,
        mod: w
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new n(0),
        mod: this
      } : y.length === 1 ? v === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : v === "mod" ? {
        div: null,
        mod: new n(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new n(this.modn(y.words[0]))
      } : this._wordDiv(y, v);
    }, n.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, n.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, n.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, n.prototype.divRound = function(y) {
      var v = this.divmod(y);
      if (v.mod.isZero())
        return v.div;
      var a = v.div.negative !== 0 ? v.mod.isub(y) : v.mod, d = y.ushrn(1), w = y.andln(1), x = a.cmp(d);
      return x < 0 || w === 1 && x === 0 ? v.div : v.div.negative !== 0 ? v.div.isubn(1) : v.div.iaddn(1);
    }, n.prototype.modn = function(y) {
      i(y <= 67108863);
      for (var v = (1 << 26) % y, a = 0, d = this.length - 1; d >= 0; d--)
        a = (v * a + (this.words[d] | 0)) % y;
      return a;
    }, n.prototype.idivn = function(y) {
      i(y <= 67108863);
      for (var v = 0, a = this.length - 1; a >= 0; a--) {
        var d = (this.words[a] | 0) + v * 67108864;
        this.words[a] = d / y | 0, v = d % y;
      }
      return this.strip();
    }, n.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, n.prototype.egcd = function(y) {
      i(y.negative === 0), i(!y.isZero());
      var v = this, a = y.clone();
      v.negative !== 0 ? v = v.umod(y) : v = v.clone();
      for (var d = new n(1), w = new n(0), x = new n(0), A = new n(1), S = 0; v.isEven() && a.isEven(); )
        v.iushrn(1), a.iushrn(1), ++S;
      for (var g = a.clone(), _ = v.clone(); !v.isZero(); ) {
        for (var l = 0, R = 1; !(v.words[0] & R) && l < 26; ++l, R <<= 1)
          ;
        if (l > 0)
          for (v.iushrn(l); l-- > 0; )
            (d.isOdd() || w.isOdd()) && (d.iadd(g), w.isub(_)), d.iushrn(1), w.iushrn(1);
        for (var Y = 0, oe = 1; !(a.words[0] & oe) && Y < 26; ++Y, oe <<= 1)
          ;
        if (Y > 0)
          for (a.iushrn(Y); Y-- > 0; )
            (x.isOdd() || A.isOdd()) && (x.iadd(g), A.isub(_)), x.iushrn(1), A.iushrn(1);
        v.cmp(a) >= 0 ? (v.isub(a), d.isub(x), w.isub(A)) : (a.isub(v), x.isub(d), A.isub(w));
      }
      return {
        a: x,
        b: A,
        gcd: a.iushln(S)
      };
    }, n.prototype._invmp = function(y) {
      i(y.negative === 0), i(!y.isZero());
      var v = this, a = y.clone();
      v.negative !== 0 ? v = v.umod(y) : v = v.clone();
      for (var d = new n(1), w = new n(0), x = a.clone(); v.cmpn(1) > 0 && a.cmpn(1) > 0; ) {
        for (var A = 0, S = 1; !(v.words[0] & S) && A < 26; ++A, S <<= 1)
          ;
        if (A > 0)
          for (v.iushrn(A); A-- > 0; )
            d.isOdd() && d.iadd(x), d.iushrn(1);
        for (var g = 0, _ = 1; !(a.words[0] & _) && g < 26; ++g, _ <<= 1)
          ;
        if (g > 0)
          for (a.iushrn(g); g-- > 0; )
            w.isOdd() && w.iadd(x), w.iushrn(1);
        v.cmp(a) >= 0 ? (v.isub(a), d.isub(w)) : (a.isub(v), w.isub(d));
      }
      var l;
      return v.cmpn(1) === 0 ? l = d : l = w, l.cmpn(0) < 0 && l.iadd(y), l;
    }, n.prototype.gcd = function(y) {
      if (this.isZero())
        return y.abs();
      if (y.isZero())
        return this.abs();
      var v = this.clone(), a = y.clone();
      v.negative = 0, a.negative = 0;
      for (var d = 0; v.isEven() && a.isEven(); d++)
        v.iushrn(1), a.iushrn(1);
      do {
        for (; v.isEven(); )
          v.iushrn(1);
        for (; a.isEven(); )
          a.iushrn(1);
        var w = v.cmp(a);
        if (w < 0) {
          var x = v;
          v = a, a = x;
        } else if (w === 0 || a.cmpn(1) === 0)
          break;
        v.isub(a);
      } while (!0);
      return a.iushln(d);
    }, n.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, n.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, n.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, n.prototype.andln = function(y) {
      return this.words[0] & y;
    }, n.prototype.bincn = function(y) {
      i(typeof y == "number");
      var v = y % 26, a = (y - v) / 26, d = 1 << v;
      if (this.length <= a)
        return this._expand(a + 1), this.words[a] |= d, this;
      for (var w = d, x = a; w !== 0 && x < this.length; x++) {
        var A = this.words[x] | 0;
        A += w, w = A >>> 26, A &= 67108863, this.words[x] = A;
      }
      return w !== 0 && (this.words[x] = w, this.length++), this;
    }, n.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, n.prototype.cmpn = function(y) {
      var v = y < 0;
      if (this.negative !== 0 && !v)
        return -1;
      if (this.negative === 0 && v)
        return 1;
      this.strip();
      var a;
      if (this.length > 1)
        a = 1;
      else {
        v && (y = -y), i(y <= 67108863, "Number is too big");
        var d = this.words[0] | 0;
        a = d === y ? 0 : d < y ? -1 : 1;
      }
      return this.negative !== 0 ? -a | 0 : a;
    }, n.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0)
        return -1;
      if (this.negative === 0 && y.negative !== 0)
        return 1;
      var v = this.ucmp(y);
      return this.negative !== 0 ? -v | 0 : v;
    }, n.prototype.ucmp = function(y) {
      if (this.length > y.length)
        return 1;
      if (this.length < y.length)
        return -1;
      for (var v = 0, a = this.length - 1; a >= 0; a--) {
        var d = this.words[a] | 0, w = y.words[a] | 0;
        if (d !== w) {
          d < w ? v = -1 : d > w && (v = 1);
          break;
        }
      }
      return v;
    }, n.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, n.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, n.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, n.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, n.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, n.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, n.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, n.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, n.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, n.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, n.red = function(y) {
      return new Q(y);
    }, n.prototype.toRed = function(y) {
      return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, n.prototype.fromRed = function() {
      return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, n.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, n.prototype.forceRed = function(y) {
      return i(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, n.prototype.redAdd = function(y) {
      return i(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, n.prototype.redIAdd = function(y) {
      return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, n.prototype.redSub = function(y) {
      return i(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, n.prototype.redISub = function(y) {
      return i(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, n.prototype.redShl = function(y) {
      return i(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, n.prototype.redMul = function(y) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, n.prototype.redIMul = function(y) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, n.prototype.redSqr = function() {
      return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, n.prototype.redISqr = function() {
      return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, n.prototype.redSqrt = function() {
      return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, n.prototype.redInvm = function() {
      return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, n.prototype.redNeg = function() {
      return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, n.prototype.redPow = function(y) {
      return i(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var j = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function N(U, y) {
      this.name = U, this.p = new n(y, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    N.prototype._tmp = function() {
      var y = new n(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, N.prototype.ireduce = function(y) {
      var v = y, a;
      do
        this.split(v, this.tmp), v = this.imulK(v), v = v.iadd(this.tmp), a = v.bitLength();
      while (a > this.n);
      var d = a < this.n ? -1 : v.ucmp(this.p);
      return d === 0 ? (v.words[0] = 0, v.length = 1) : d > 0 ? v.isub(this.p) : v.strip !== void 0 ? v.strip() : v._strip(), v;
    }, N.prototype.split = function(y, v) {
      y.iushrn(this.n, 0, v);
    }, N.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function k() {
      N.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    o(k, N), k.prototype.split = function(y, v) {
      for (var a = 4194303, d = Math.min(y.length, 9), w = 0; w < d; w++)
        v.words[w] = y.words[w];
      if (v.length = d, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var x = y.words[9];
      for (v.words[v.length++] = x & a, w = 10; w < y.length; w++) {
        var A = y.words[w] | 0;
        y.words[w - 10] = (A & a) << 4 | x >>> 22, x = A;
      }
      x >>>= 22, y.words[w - 10] = x, x === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, k.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var v = 0, a = 0; a < y.length; a++) {
        var d = y.words[a] | 0;
        v += d * 977, y.words[a] = v & 67108863, v = d * 64 + (v / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function q() {
      N.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    o(q, N);
    function $() {
      N.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    o($, N);
    function re() {
      N.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    o(re, N), re.prototype.imulK = function(y) {
      for (var v = 0, a = 0; a < y.length; a++) {
        var d = (y.words[a] | 0) * 19 + v, w = d & 67108863;
        d >>>= 26, y.words[a] = w, v = d;
      }
      return v !== 0 && (y.words[y.length++] = v), y;
    }, n._prime = function(y) {
      if (j[y])
        return j[y];
      var v;
      if (y === "k256")
        v = new k();
      else if (y === "p224")
        v = new q();
      else if (y === "p192")
        v = new $();
      else if (y === "p25519")
        v = new re();
      else
        throw new Error("Unknown prime " + y);
      return j[y] = v, v;
    };
    function Q(U) {
      if (typeof U == "string") {
        var y = n._prime(U);
        this.m = y.p, this.prime = y;
      } else
        i(U.gtn(1), "modulus must be greater than 1"), this.m = U, this.prime = null;
    }
    Q.prototype._verify1 = function(y) {
      i(y.negative === 0, "red works only with positives"), i(y.red, "red works only with red numbers");
    }, Q.prototype._verify2 = function(y, v) {
      i((y.negative | v.negative) === 0, "red works only with positives"), i(
        y.red && y.red === v.red,
        "red works only with red numbers"
      );
    }, Q.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, Q.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, Q.prototype.add = function(y, v) {
      this._verify2(y, v);
      var a = y.add(v);
      return a.cmp(this.m) >= 0 && a.isub(this.m), a._forceRed(this);
    }, Q.prototype.iadd = function(y, v) {
      this._verify2(y, v);
      var a = y.iadd(v);
      return a.cmp(this.m) >= 0 && a.isub(this.m), a;
    }, Q.prototype.sub = function(y, v) {
      this._verify2(y, v);
      var a = y.sub(v);
      return a.cmpn(0) < 0 && a.iadd(this.m), a._forceRed(this);
    }, Q.prototype.isub = function(y, v) {
      this._verify2(y, v);
      var a = y.isub(v);
      return a.cmpn(0) < 0 && a.iadd(this.m), a;
    }, Q.prototype.shl = function(y, v) {
      return this._verify1(y), this.imod(y.ushln(v));
    }, Q.prototype.imul = function(y, v) {
      return this._verify2(y, v), this.imod(y.imul(v));
    }, Q.prototype.mul = function(y, v) {
      return this._verify2(y, v), this.imod(y.mul(v));
    }, Q.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, Q.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, Q.prototype.sqrt = function(y) {
      if (y.isZero())
        return y.clone();
      var v = this.m.andln(3);
      if (i(v % 2 === 1), v === 3) {
        var a = this.m.add(new n(1)).iushrn(2);
        return this.pow(y, a);
      }
      for (var d = this.m.subn(1), w = 0; !d.isZero() && d.andln(1) === 0; )
        w++, d.iushrn(1);
      i(!d.isZero());
      var x = new n(1).toRed(this), A = x.redNeg(), S = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new n(2 * g * g).toRed(this); this.pow(g, S).cmp(A) !== 0; )
        g.redIAdd(A);
      for (var _ = this.pow(g, d), l = this.pow(y, d.addn(1).iushrn(1)), R = this.pow(y, d), Y = w; R.cmp(x) !== 0; ) {
        for (var oe = R, H = 0; oe.cmp(x) !== 0; H++)
          oe = oe.redSqr();
        i(H < Y);
        var V = this.pow(_, new n(1).iushln(Y - H - 1));
        l = l.redMul(V), _ = V.redSqr(), R = R.redMul(_), Y = H;
      }
      return l;
    }, Q.prototype.invm = function(y) {
      var v = y._invmp(this.m);
      return v.negative !== 0 ? (v.negative = 0, this.imod(v).redNeg()) : this.imod(v);
    }, Q.prototype.pow = function(y, v) {
      if (v.isZero())
        return new n(1).toRed(this);
      if (v.cmpn(1) === 0)
        return y.clone();
      var a = 4, d = new Array(1 << a);
      d[0] = new n(1).toRed(this), d[1] = y;
      for (var w = 2; w < d.length; w++)
        d[w] = this.mul(d[w - 1], y);
      var x = d[0], A = 0, S = 0, g = v.bitLength() % 26;
      for (g === 0 && (g = 26), w = v.length - 1; w >= 0; w--) {
        for (var _ = v.words[w], l = g - 1; l >= 0; l--) {
          var R = _ >> l & 1;
          if (x !== d[0] && (x = this.sqr(x)), R === 0 && A === 0) {
            S = 0;
            continue;
          }
          A <<= 1, A |= R, S++, !(S !== a && (w !== 0 || l !== 0)) && (x = this.mul(x, d[A]), S = 0, A = 0);
        }
        g = 26;
      }
      return x;
    }, Q.prototype.convertTo = function(y) {
      var v = y.umod(this.m);
      return v === y ? v.clone() : v;
    }, Q.prototype.convertFrom = function(y) {
      var v = y.clone();
      return v.red = null, v;
    }, n.mont = function(y) {
      return new fe(y);
    };
    function fe(U) {
      Q.call(this, U), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o(fe, Q), fe.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, fe.prototype.convertFrom = function(y) {
      var v = this.imod(y.mul(this.rinv));
      return v.red = null, v;
    }, fe.prototype.imul = function(y, v) {
      if (y.isZero() || v.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var a = y.imul(v), d = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = a.isub(d).iushrn(this.shift), x = w;
      return w.cmp(this.m) >= 0 ? x = w.isub(this.m) : w.cmpn(0) < 0 && (x = w.iadd(this.m)), x._forceRed(this);
    }, fe.prototype.mul = function(y, v) {
      if (y.isZero() || v.isZero())
        return new n(0)._forceRed(this);
      var a = y.mul(v), d = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = a.isub(d).iushrn(this.shift), x = w;
      return w.cmp(this.m) >= 0 ? x = w.isub(this.m) : w.cmpn(0) < 0 && (x = w.iadd(this.m)), x._forceRed(this);
    }, fe.prototype.invm = function(y) {
      var v = this.imod(y._invmp(this.m).mul(this.r2));
      return v._forceRed(this);
    };
  })(e, Ze);
})(n0);
var tr = n0.exports, Qx = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(On, "__esModule", { value: !0 });
On.rawEncode = On.parseNumber = On.solidityPack = void 0;
const Bn = ma, In = Qx(tr), eE = r0, Dy = Xt;
function tE(e, t) {
  if (e.length !== t.length)
    throw new Error("Number of types are not matching the values");
  const r = [];
  for (let i = 0; i < e.length; i++) {
    const o = Uy(e[i]), n = t[i];
    r.push($y(o, n, null));
  }
  return Le.Buffer.concat(r);
}
On.solidityPack = tE;
function lo(e) {
  return e.endsWith("]");
}
function of(e) {
  const t = e.match(/(.*)\[(.*?)\]$/u);
  return t ? t[2] === "" ? "dynamic" : parseInt(t[2], 10) : null;
}
function Ei(e) {
  const t = /^\D+(\d+)$/u.exec(e);
  if (t === null)
    throw new Error(`Invalid parseTypeN input "${e}".`);
  return parseInt(t[1], 10);
}
function Mn(e) {
  const t = typeof e;
  if (t === "string")
    return (0, Bn.isHexPrefixed)(e) ? new In.default((0, eE.stripHexPrefix)(e), 16) : new In.default(e, 10);
  if (t === "number")
    return new In.default(e);
  if (e && Object.prototype.hasOwnProperty.call(e, "toArray") || In.default.isBN(e))
    return e;
  throw new Error("Argument is not a number");
}
On.parseNumber = Mn;
function $y(e, t, r) {
  if (lo(e)) {
    const i = e.replace(/\[.*?\]/u, "");
    if (!lo(i)) {
      const n = of(e);
      if (n !== "dynamic" && n !== 0 && n !== null && t.length > n)
        throw new Error(`Elements exceed array size: ${n}`);
    }
    const o = t.map((n) => $y(i, n, 256));
    return Le.Buffer.concat(o);
  } else {
    if (e === "bytes")
      return t;
    if (e === "string")
      return Le.Buffer.from(t, "utf8");
    if (e === "bool") {
      r = r || 8;
      const i = Array(r / 4).join("0");
      return Le.Buffer.from(t ? `${i}1` : `${i}0`, "hex");
    } else if (e === "address") {
      let i = 20;
      return r && (i = r / 8), (0, Bn.setLengthLeft)((0, Bn.toBuffer)(t), i);
    } else if (e.startsWith("bytes")) {
      const i = Ei(e);
      if (i < 1 || i > 32)
        throw new Error(`Invalid bytes<N> width: ${i}`);
      return typeof t == "number" && (t = (0, Dy.normalize)(t)), (0, Bn.setLengthRight)((0, Bn.toBuffer)(t), i);
    } else if (e.startsWith("uint")) {
      const i = Ei(e);
      if (i % 8 || i < 8 || i > 256)
        throw new Error(`Invalid uint<N> width: ${i}`);
      const o = Mn(t);
      if (o.bitLength() > i)
        throw new Error(`Supplied uint exceeds width: ${i} vs ${o.bitLength()}`);
      return r = r || i, o.toArrayLike(Le.Buffer, "be", r / 8);
    } else if (e.startsWith("int")) {
      const i = Ei(e);
      if (i % 8 || i < 8 || i > 256)
        throw new Error(`Invalid int<N> width: ${i}`);
      const o = Mn(t);
      if (o.bitLength() > i)
        throw new Error(`Supplied int exceeds width: ${i} vs ${o.bitLength()}`);
      return r = r || i, o.toTwos(i).toArrayLike(Le.Buffer, "be", r / 8);
    }
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function Uy(e) {
  return e.startsWith("int[") ? `int256${e.slice(3)}` : e === "int" ? "int256" : e.startsWith("uint[") ? `uint256${e.slice(4)}` : e === "uint" ? "uint256" : e.startsWith("fixed[") ? `fixed128x128${e.slice(5)}` : e === "fixed" ? "fixed128x128" : e.startsWith("ufixed[") ? `ufixed128x128${e.slice(6)}` : e === "ufixed" ? "ufixed128x128" : e;
}
function rE(e, t) {
  const r = [], i = [];
  let o = 0;
  e.forEach((n) => {
    if (lo(n)) {
      const f = of(n);
      f !== "dynamic" && f !== null ? o += 32 * f : o += 32;
    } else
      o += 32;
  });
  for (let n = 0; n < e.length; n++) {
    const f = Uy(e[n]), u = t[n], c = Yr(f, u);
    nE(f) ? (r.push(Yr("uint256", o)), i.push(c), o += c.length) : r.push(c);
  }
  return Le.Buffer.concat(r.concat(i));
}
On.rawEncode = rE;
function Yr(e, t) {
  if (e === "address")
    return Yr("uint160", Mn(t));
  if (e === "bool")
    return Yr("uint8", t ? 1 : 0);
  if (e === "string")
    return Yr("bytes", Le.Buffer.from(t, "utf8"));
  if (lo(e)) {
    if (typeof t.length > "u")
      throw new Error("Not an array?");
    const r = of(e);
    if (r !== "dynamic" && r !== 0 && r !== null && t.length > r)
      throw new Error(`Elements exceed array size: ${r}`);
    const i = [];
    e = e.slice(0, e.lastIndexOf("[")), typeof t == "string" && (t = JSON.parse(t));
    for (const o in t)
      Object.prototype.hasOwnProperty.call(t, o) && i.push(Yr(e, t[o]));
    if (r === "dynamic") {
      const o = Yr("uint256", t.length);
      i.unshift(o);
    }
    return Le.Buffer.concat(i);
  } else if (e === "bytes") {
    t = Le.Buffer.from(t);
    let r = Le.Buffer.concat([Yr("uint256", t.length), t]);
    return t.length % 32 !== 0 && (r = Le.Buffer.concat([r, (0, Bn.zeros)(32 - t.length % 32)])), r;
  } else if (e.startsWith("bytes")) {
    const r = Ei(e);
    if (r < 1 || r > 32)
      throw new Error(`Invalid bytes<N> width: ${r}`);
    const i = typeof t == "number" ? (0, Dy.normalize)(t) : t;
    return (0, Bn.setLengthRight)((0, Bn.toBuffer)(i), 32);
  } else if (e.startsWith("uint")) {
    const r = Ei(e);
    if (r % 8 || r < 8 || r > 256)
      throw new Error(`Invalid uint<N> width: ${r}`);
    const i = Mn(t);
    if (i.bitLength() > r)
      throw new Error(`Supplied uint exceeds width: ${r} vs ${i.bitLength()}`);
    if (i.isNeg())
      throw new Error("Supplied uint is negative");
    return i.toArrayLike(Le.Buffer, "be", 32);
  } else if (e.startsWith("int")) {
    const r = Ei(e);
    if (r % 8 || r < 8 || r > 256)
      throw new Error(`Invalid int<N> width: ${r}`);
    const i = Mn(t);
    if (i.bitLength() > r)
      throw new Error(`Supplied int exceeds width: ${r} vs ${i.bitLength()}`);
    return i.toTwos(256).toArrayLike(Le.Buffer, "be", 32);
  } else if (e.startsWith("ufixed")) {
    const r = n1(e), i = Mn(t);
    if (i.isNeg())
      throw new Error("Supplied ufixed is negative");
    return Yr("uint256", i.mul(new In.default(2).pow(new In.default(r[1]))));
  } else if (e.startsWith("fixed")) {
    const r = n1(e);
    return Yr("int256", Mn(t).mul(new In.default(2).pow(new In.default(r[1]))));
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function nE(e) {
  return e === "string" || e === "bytes" || of(e) === "dynamic";
}
function n1(e) {
  const t = /^\D+(\d+)x(\d+)$/u.exec(e);
  if (t === null || t.length < 1)
    throw new Error(`Invalid parseTypeNxM input "${e}".`);
  return [parseInt(t[1], 10), parseInt(t[2], 10)];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.recoverTypedSignature = e.signTypedData = e.typedSignatureHash = e.TypedDataUtils = e.TYPED_MESSAGE_SCHEMA = e.SignTypedDataVersion = void 0;
  const t = ma, r = Lr, i = r0, o = On, n = Xt;
  var f;
  (function(k) {
    k.V1 = "V1", k.V3 = "V3", k.V4 = "V4";
  })(f = e.SignTypedDataVersion || (e.SignTypedDataVersion = {})), e.TYPED_MESSAGE_SCHEMA = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  };
  function u(k, q) {
    if (Object.keys(f).includes(k)) {
      if (q && !q.includes(k))
        throw new Error(`SignTypedDataVersion not allowed: '${k}'. Allowed versions are: ${q.join(", ")}`);
    } else
      throw new Error(`Invalid version: '${k}'`);
  }
  function c(k, q, $, re, Q) {
    if (u(Q, [f.V3, f.V4]), k[$] !== void 0)
      return [
        "bytes32",
        // TODO: return Buffer, remove string from return type
        Q === f.V4 && re == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, t.arrToBufArr)((0, r.keccak256)(h($, re, k, Q)))
      ];
    if (re === void 0)
      throw new Error(`missing value for field ${q} of type ${$}`);
    if ($ === "bytes") {
      if (typeof re == "number")
        re = (0, n.numberToBuffer)(re);
      else if ((0, i.isHexString)(re)) {
        const fe = re.length % 2 ? "0" : "";
        re = Le.Buffer.from(fe + re.slice(2), "hex");
      } else
        re = Le.Buffer.from(re, "utf8");
      return ["bytes32", (0, t.arrToBufArr)((0, r.keccak256)(re))];
    }
    if ($ === "string")
      return typeof re == "number" ? re = (0, n.numberToBuffer)(re) : re = Le.Buffer.from(re ?? "", "utf8"), ["bytes32", (0, t.arrToBufArr)((0, r.keccak256)(re))];
    if ($.endsWith("]")) {
      if (Q === f.V3)
        throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
      const fe = $.slice(0, $.lastIndexOf("[")), U = re.map((y) => c(k, q, fe, y, Q));
      return [
        "bytes32",
        (0, t.arrToBufArr)((0, r.keccak256)((0, o.rawEncode)(U.map(([y]) => y), U.map(([, y]) => y))))
      ];
    }
    return [$, re];
  }
  function h(k, q, $, re) {
    u(re, [f.V3, f.V4]);
    const Q = ["bytes32"], fe = [m(k, $)];
    for (const U of $[k]) {
      if (re === f.V3 && q[U.name] === void 0)
        continue;
      const [y, v] = c($, U.name, U.type, q[U.name], re);
      Q.push(y), fe.push(v);
    }
    return (0, o.rawEncode)(Q, fe);
  }
  function s(k, q) {
    let $ = "";
    const re = b(k, q);
    re.delete(k);
    const Q = [k, ...Array.from(re).sort()];
    for (const fe of Q) {
      if (!q[fe])
        throw new Error(`No type definition specified: ${fe}`);
      $ += `${fe}(${q[fe].map(({ name: y, type: v }) => `${v} ${y}`).join(",")})`;
    }
    return $;
  }
  function b(k, q, $ = /* @__PURE__ */ new Set()) {
    if (typeof k != "string")
      throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(k)}`);
    if ([k] = k.match(/^\w*/u), $.has(k) || q[k] === void 0)
      return $;
    $.add(k);
    for (const Q of q[k])
      b(Q.type, q, $);
    return $;
  }
  function p(k, q, $, re) {
    u(re, [f.V3, f.V4]);
    const Q = h(k, q, $, re), fe = (0, r.keccak256)(Q);
    return (0, t.arrToBufArr)(fe);
  }
  function m(k, q) {
    const $ = Le.Buffer.from(s(k, q), "utf-8");
    return (0, t.arrToBufArr)((0, r.keccak256)($));
  }
  function E(k) {
    const q = {};
    for (const $ in e.TYPED_MESSAGE_SCHEMA.properties)
      k[$] && (q[$] = k[$]);
    return "types" in q && (q.types = Object.assign({ EIP712Domain: [] }, q.types)), q;
  }
  function M(k, q) {
    u(q, [f.V3, f.V4]);
    const $ = E(k), { domain: re } = $, Q = { EIP712Domain: $.types.EIP712Domain };
    return p("EIP712Domain", re, Q, q);
  }
  function I(k, q) {
    u(q, [f.V3, f.V4]);
    const $ = E(k), re = [Le.Buffer.from("1901", "hex")];
    return re.push(M(k, q)), $.primaryType !== "EIP712Domain" && re.push(p(
      // TODO: Validate that this is a string, so this type cast can be removed.
      $.primaryType,
      $.message,
      $.types,
      q
    )), (0, t.arrToBufArr)((0, r.keccak256)(Le.Buffer.concat(re)));
  }
  e.TypedDataUtils = {
    encodeData: h,
    encodeType: s,
    findTypeDependencies: b,
    hashStruct: p,
    hashType: m,
    sanitizeData: E,
    eip712Hash: I,
    eip712DomainHash: M
  };
  function B(k) {
    const q = T(k);
    return (0, t.bufferToHex)(q);
  }
  e.typedSignatureHash = B;
  function T(k) {
    const q = new Error("Expect argument to be non-empty array");
    if (typeof k != "object" || !("length" in k) || !k.length)
      throw q;
    const $ = k.map(function(fe) {
      return fe.type !== "bytes" ? fe.value : (0, n.legacyToBuffer)(fe.value);
    }), re = k.map(function(fe) {
      return fe.type;
    }), Q = k.map(function(fe) {
      if (!fe.name)
        throw q;
      return `${fe.type} ${fe.name}`;
    });
    return (0, t.arrToBufArr)((0, r.keccak256)((0, o.solidityPack)(["bytes32", "bytes32"], [
      (0, r.keccak256)((0, o.solidityPack)(new Array(k.length).fill("string"), Q)),
      (0, r.keccak256)((0, o.solidityPack)(re, $))
    ])));
  }
  function j({ privateKey: k, data: q, version: $ }) {
    if (u($), (0, n.isNullish)(q))
      throw new Error("Missing data parameter");
    if ((0, n.isNullish)(k))
      throw new Error("Missing private key parameter");
    const re = $ === f.V1 ? T(q) : e.TypedDataUtils.eip712Hash(q, $), Q = (0, t.ecsign)(re, k);
    return (0, n.concatSig)((0, t.toBuffer)(Q.v), Q.r, Q.s);
  }
  e.signTypedData = j;
  function N({ data: k, signature: q, version: $ }) {
    if (u($), (0, n.isNullish)(k))
      throw new Error("Missing data parameter");
    if ((0, n.isNullish)(q))
      throw new Error("Missing signature parameter");
    const re = $ === f.V1 ? T(k) : e.TypedDataUtils.eip712Hash(k, $), Q = (0, n.recoverPublicKey)(re, q), fe = (0, t.publicToAddress)(Q);
    return (0, t.bufferToHex)(fe);
  }
  e.recoverTypedSignature = N;
})(qy);
var Nr = {}, Fy = { exports: {} }, Et = {}, Ua = { exports: {} }, i1;
function $i() {
  if (i1)
    return Ua.exports;
  i1 = 1;
  var e = 65536, t = 4294967295;
  function r() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var i = Rt().Buffer, o = Ze.crypto || Ze.msCrypto;
  o && o.getRandomValues ? Ua.exports = n : Ua.exports = r;
  function n(f, u) {
    if (f > t)
      throw new RangeError("requested too many random bytes");
    var c = i.allocUnsafe(f);
    if (f > 0)
      if (f > e)
        for (var h = 0; h < f; h += e)
          o.getRandomValues(c.slice(h, h + e));
      else
        o.getRandomValues(c);
    return typeof u == "function" ? at.nextTick(function() {
      u(null, c);
    }) : c;
  }
  return Ua.exports;
}
var zs, a1;
function zy() {
  if (a1)
    return zs;
  a1 = 1;
  var e = Rt().Buffer, t = tf().Transform, r = _t();
  function i(n, f) {
    if (!e.isBuffer(n) && typeof n != "string")
      throw new TypeError(f + " must be a string or a buffer");
  }
  function o(n) {
    t.call(this), this._block = e.allocUnsafe(n), this._blockSize = n, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return r(o, t), o.prototype._transform = function(n, f, u) {
    var c = null;
    try {
      this.update(n, f);
    } catch (h) {
      c = h;
    }
    u(c);
  }, o.prototype._flush = function(n) {
    var f = null;
    try {
      this.push(this.digest());
    } catch (u) {
      f = u;
    }
    n(f);
  }, o.prototype.update = function(n, f) {
    if (i(n, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(n) || (n = e.from(n, f));
    for (var u = this._block, c = 0; this._blockOffset + n.length - c >= this._blockSize; ) {
      for (var h = this._blockOffset; h < this._blockSize; )
        u[h++] = n[c++];
      this._update(), this._blockOffset = 0;
    }
    for (; c < n.length; )
      u[this._blockOffset++] = n[c++];
    for (var s = 0, b = n.length * 8; b > 0; ++s)
      this._length[s] += b, b = this._length[s] / 4294967296 | 0, b > 0 && (this._length[s] -= 4294967296 * b);
    return this;
  }, o.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, o.prototype.digest = function(n) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var f = this._digest();
    n !== void 0 && (f = f.toString(n)), this._block.fill(0), this._blockOffset = 0;
    for (var u = 0; u < 4; ++u)
      this._length[u] = 0;
    return f;
  }, o.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, zs = o, zs;
}
var Hs, o1;
function i0() {
  if (o1)
    return Hs;
  o1 = 1;
  var e = _t(), t = zy(), r = Rt().Buffer, i = new Array(16);
  function o() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(o, t), o.prototype._update = function() {
    for (var s = i, b = 0; b < 16; ++b)
      s[b] = this._block.readInt32LE(b * 4);
    var p = this._a, m = this._b, E = this._c, M = this._d;
    p = f(p, m, E, M, s[0], 3614090360, 7), M = f(M, p, m, E, s[1], 3905402710, 12), E = f(E, M, p, m, s[2], 606105819, 17), m = f(m, E, M, p, s[3], 3250441966, 22), p = f(p, m, E, M, s[4], 4118548399, 7), M = f(M, p, m, E, s[5], 1200080426, 12), E = f(E, M, p, m, s[6], 2821735955, 17), m = f(m, E, M, p, s[7], 4249261313, 22), p = f(p, m, E, M, s[8], 1770035416, 7), M = f(M, p, m, E, s[9], 2336552879, 12), E = f(E, M, p, m, s[10], 4294925233, 17), m = f(m, E, M, p, s[11], 2304563134, 22), p = f(p, m, E, M, s[12], 1804603682, 7), M = f(M, p, m, E, s[13], 4254626195, 12), E = f(E, M, p, m, s[14], 2792965006, 17), m = f(m, E, M, p, s[15], 1236535329, 22), p = u(p, m, E, M, s[1], 4129170786, 5), M = u(M, p, m, E, s[6], 3225465664, 9), E = u(E, M, p, m, s[11], 643717713, 14), m = u(m, E, M, p, s[0], 3921069994, 20), p = u(p, m, E, M, s[5], 3593408605, 5), M = u(M, p, m, E, s[10], 38016083, 9), E = u(E, M, p, m, s[15], 3634488961, 14), m = u(m, E, M, p, s[4], 3889429448, 20), p = u(p, m, E, M, s[9], 568446438, 5), M = u(M, p, m, E, s[14], 3275163606, 9), E = u(E, M, p, m, s[3], 4107603335, 14), m = u(m, E, M, p, s[8], 1163531501, 20), p = u(p, m, E, M, s[13], 2850285829, 5), M = u(M, p, m, E, s[2], 4243563512, 9), E = u(E, M, p, m, s[7], 1735328473, 14), m = u(m, E, M, p, s[12], 2368359562, 20), p = c(p, m, E, M, s[5], 4294588738, 4), M = c(M, p, m, E, s[8], 2272392833, 11), E = c(E, M, p, m, s[11], 1839030562, 16), m = c(m, E, M, p, s[14], 4259657740, 23), p = c(p, m, E, M, s[1], 2763975236, 4), M = c(M, p, m, E, s[4], 1272893353, 11), E = c(E, M, p, m, s[7], 4139469664, 16), m = c(m, E, M, p, s[10], 3200236656, 23), p = c(p, m, E, M, s[13], 681279174, 4), M = c(M, p, m, E, s[0], 3936430074, 11), E = c(E, M, p, m, s[3], 3572445317, 16), m = c(m, E, M, p, s[6], 76029189, 23), p = c(p, m, E, M, s[9], 3654602809, 4), M = c(M, p, m, E, s[12], 3873151461, 11), E = c(E, M, p, m, s[15], 530742520, 16), m = c(m, E, M, p, s[2], 3299628645, 23), p = h(p, m, E, M, s[0], 4096336452, 6), M = h(M, p, m, E, s[7], 1126891415, 10), E = h(E, M, p, m, s[14], 2878612391, 15), m = h(m, E, M, p, s[5], 4237533241, 21), p = h(p, m, E, M, s[12], 1700485571, 6), M = h(M, p, m, E, s[3], 2399980690, 10), E = h(E, M, p, m, s[10], 4293915773, 15), m = h(m, E, M, p, s[1], 2240044497, 21), p = h(p, m, E, M, s[8], 1873313359, 6), M = h(M, p, m, E, s[15], 4264355552, 10), E = h(E, M, p, m, s[6], 2734768916, 15), m = h(m, E, M, p, s[13], 1309151649, 21), p = h(p, m, E, M, s[4], 4149444226, 6), M = h(M, p, m, E, s[11], 3174756917, 10), E = h(E, M, p, m, s[2], 718787259, 15), m = h(m, E, M, p, s[9], 3951481745, 21), this._a = this._a + p | 0, this._b = this._b + m | 0, this._c = this._c + E | 0, this._d = this._d + M | 0;
  }, o.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var s = r.allocUnsafe(16);
    return s.writeInt32LE(this._a, 0), s.writeInt32LE(this._b, 4), s.writeInt32LE(this._c, 8), s.writeInt32LE(this._d, 12), s;
  };
  function n(s, b) {
    return s << b | s >>> 32 - b;
  }
  function f(s, b, p, m, E, M, I) {
    return n(s + (b & p | ~b & m) + E + M | 0, I) + b | 0;
  }
  function u(s, b, p, m, E, M, I) {
    return n(s + (b & m | p & ~m) + E + M | 0, I) + b | 0;
  }
  function c(s, b, p, m, E, M, I) {
    return n(s + (b ^ p ^ m) + E + M | 0, I) + b | 0;
  }
  function h(s, b, p, m, E, M, I) {
    return n(s + (p ^ (b | ~m)) + E + M | 0, I) + b | 0;
  }
  return Hs = o, Hs;
}
var Vs, f1;
function a0() {
  if (f1)
    return Vs;
  f1 = 1;
  var e = Le.Buffer, t = _t(), r = zy(), i = new Array(16), o = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], n = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], f = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], u = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], c = [0, 1518500249, 1859775393, 2400959708, 2840853838], h = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function s() {
    r.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(s, r), s.prototype._update = function() {
    for (var B = i, T = 0; T < 16; ++T)
      B[T] = this._block.readInt32LE(T * 4);
    for (var j = this._a | 0, N = this._b | 0, k = this._c | 0, q = this._d | 0, $ = this._e | 0, re = this._a | 0, Q = this._b | 0, fe = this._c | 0, U = this._d | 0, y = this._e | 0, v = 0; v < 80; v += 1) {
      var a, d;
      v < 16 ? (a = p(j, N, k, q, $, B[o[v]], c[0], f[v]), d = I(re, Q, fe, U, y, B[n[v]], h[0], u[v])) : v < 32 ? (a = m(j, N, k, q, $, B[o[v]], c[1], f[v]), d = M(re, Q, fe, U, y, B[n[v]], h[1], u[v])) : v < 48 ? (a = E(j, N, k, q, $, B[o[v]], c[2], f[v]), d = E(re, Q, fe, U, y, B[n[v]], h[2], u[v])) : v < 64 ? (a = M(j, N, k, q, $, B[o[v]], c[3], f[v]), d = m(re, Q, fe, U, y, B[n[v]], h[3], u[v])) : (a = I(j, N, k, q, $, B[o[v]], c[4], f[v]), d = p(re, Q, fe, U, y, B[n[v]], h[4], u[v])), j = $, $ = q, q = b(k, 10), k = N, N = a, re = y, y = U, U = b(fe, 10), fe = Q, Q = d;
    }
    var w = this._b + k + U | 0;
    this._b = this._c + q + y | 0, this._c = this._d + $ + re | 0, this._d = this._e + j + Q | 0, this._e = this._a + N + fe | 0, this._a = w;
  }, s.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var B = e.alloc ? e.alloc(20) : new e(20);
    return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B.writeInt32LE(this._e, 16), B;
  };
  function b(B, T) {
    return B << T | B >>> 32 - T;
  }
  function p(B, T, j, N, k, q, $, re) {
    return b(B + (T ^ j ^ N) + q + $ | 0, re) + k | 0;
  }
  function m(B, T, j, N, k, q, $, re) {
    return b(B + (T & j | ~T & N) + q + $ | 0, re) + k | 0;
  }
  function E(B, T, j, N, k, q, $, re) {
    return b(B + ((T | ~j) ^ N) + q + $ | 0, re) + k | 0;
  }
  function M(B, T, j, N, k, q, $, re) {
    return b(B + (T & N | j & ~N) + q + $ | 0, re) + k | 0;
  }
  function I(B, T, j, N, k, q, $, re) {
    return b(B + (T ^ (j | ~N)) + q + $ | 0, re) + k | 0;
  }
  return Vs = s, Vs;
}
var Ws = { exports: {} }, Ks, s1;
function Ui() {
  if (s1)
    return Ks;
  s1 = 1;
  var e = Rt().Buffer;
  function t(r, i) {
    this._block = e.alloc(r), this._finalSize = i, this._blockSize = r, this._len = 0;
  }
  return t.prototype.update = function(r, i) {
    typeof r == "string" && (i = i || "utf8", r = e.from(r, i));
    for (var o = this._block, n = this._blockSize, f = r.length, u = this._len, c = 0; c < f; ) {
      for (var h = u % n, s = Math.min(f - c, n - h), b = 0; b < s; b++)
        o[h + b] = r[c + b];
      u += s, c += s, u % n === 0 && this._update(o);
    }
    return this._len += f, this;
  }, t.prototype.digest = function(r) {
    var i = this._len % this._blockSize;
    this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var o = this._len * 8;
    if (o <= 4294967295)
      this._block.writeUInt32BE(o, this._blockSize - 4);
    else {
      var n = (o & 4294967295) >>> 0, f = (o - n) / 4294967296;
      this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
    }
    this._update(this._block);
    var u = this._hash();
    return r ? u.toString(r) : u;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, Ks = t, Ks;
}
var Zs, u1;
function iE() {
  if (u1)
    return Zs;
  u1 = 1;
  var e = _t(), t = Ui(), r = Rt().Buffer, i = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], o = new Array(80);
  function n() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function f(h) {
    return h << 5 | h >>> 27;
  }
  function u(h) {
    return h << 30 | h >>> 2;
  }
  function c(h, s, b, p) {
    return h === 0 ? s & b | ~s & p : h === 2 ? s & b | s & p | b & p : s ^ b ^ p;
  }
  return n.prototype._update = function(h) {
    for (var s = this._w, b = this._a | 0, p = this._b | 0, m = this._c | 0, E = this._d | 0, M = this._e | 0, I = 0; I < 16; ++I)
      s[I] = h.readInt32BE(I * 4);
    for (; I < 80; ++I)
      s[I] = s[I - 3] ^ s[I - 8] ^ s[I - 14] ^ s[I - 16];
    for (var B = 0; B < 80; ++B) {
      var T = ~~(B / 20), j = f(b) + c(T, p, m, E) + M + s[B] + i[T] | 0;
      M = E, E = m, m = u(p), p = b, b = j;
    }
    this._a = b + this._a | 0, this._b = p + this._b | 0, this._c = m + this._c | 0, this._d = E + this._d | 0, this._e = M + this._e | 0;
  }, n.prototype._hash = function() {
    var h = r.allocUnsafe(20);
    return h.writeInt32BE(this._a | 0, 0), h.writeInt32BE(this._b | 0, 4), h.writeInt32BE(this._c | 0, 8), h.writeInt32BE(this._d | 0, 12), h.writeInt32BE(this._e | 0, 16), h;
  }, Zs = n, Zs;
}
var Gs, c1;
function aE() {
  if (c1)
    return Gs;
  c1 = 1;
  var e = _t(), t = Ui(), r = Rt().Buffer, i = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], o = new Array(80);
  function n() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function f(s) {
    return s << 1 | s >>> 31;
  }
  function u(s) {
    return s << 5 | s >>> 27;
  }
  function c(s) {
    return s << 30 | s >>> 2;
  }
  function h(s, b, p, m) {
    return s === 0 ? b & p | ~b & m : s === 2 ? b & p | b & m | p & m : b ^ p ^ m;
  }
  return n.prototype._update = function(s) {
    for (var b = this._w, p = this._a | 0, m = this._b | 0, E = this._c | 0, M = this._d | 0, I = this._e | 0, B = 0; B < 16; ++B)
      b[B] = s.readInt32BE(B * 4);
    for (; B < 80; ++B)
      b[B] = f(b[B - 3] ^ b[B - 8] ^ b[B - 14] ^ b[B - 16]);
    for (var T = 0; T < 80; ++T) {
      var j = ~~(T / 20), N = u(p) + h(j, m, E, M) + I + b[T] + i[j] | 0;
      I = M, M = E, E = c(m), m = p, p = N;
    }
    this._a = p + this._a | 0, this._b = m + this._b | 0, this._c = E + this._c | 0, this._d = M + this._d | 0, this._e = I + this._e | 0;
  }, n.prototype._hash = function() {
    var s = r.allocUnsafe(20);
    return s.writeInt32BE(this._a | 0, 0), s.writeInt32BE(this._b | 0, 4), s.writeInt32BE(this._c | 0, 8), s.writeInt32BE(this._d | 0, 12), s.writeInt32BE(this._e | 0, 16), s;
  }, Gs = n, Gs;
}
var Js, h1;
function Hy() {
  if (h1)
    return Js;
  h1 = 1;
  var e = _t(), t = Ui(), r = Rt().Buffer, i = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], o = new Array(64);
  function n() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function f(p, m, E) {
    return E ^ p & (m ^ E);
  }
  function u(p, m, E) {
    return p & m | E & (p | m);
  }
  function c(p) {
    return (p >>> 2 | p << 30) ^ (p >>> 13 | p << 19) ^ (p >>> 22 | p << 10);
  }
  function h(p) {
    return (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7);
  }
  function s(p) {
    return (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3;
  }
  function b(p) {
    return (p >>> 17 | p << 15) ^ (p >>> 19 | p << 13) ^ p >>> 10;
  }
  return n.prototype._update = function(p) {
    for (var m = this._w, E = this._a | 0, M = this._b | 0, I = this._c | 0, B = this._d | 0, T = this._e | 0, j = this._f | 0, N = this._g | 0, k = this._h | 0, q = 0; q < 16; ++q)
      m[q] = p.readInt32BE(q * 4);
    for (; q < 64; ++q)
      m[q] = b(m[q - 2]) + m[q - 7] + s(m[q - 15]) + m[q - 16] | 0;
    for (var $ = 0; $ < 64; ++$) {
      var re = k + h(T) + f(T, j, N) + i[$] + m[$] | 0, Q = c(E) + u(E, M, I) | 0;
      k = N, N = j, j = T, T = B + re | 0, B = I, I = M, M = E, E = re + Q | 0;
    }
    this._a = E + this._a | 0, this._b = M + this._b | 0, this._c = I + this._c | 0, this._d = B + this._d | 0, this._e = T + this._e | 0, this._f = j + this._f | 0, this._g = N + this._g | 0, this._h = k + this._h | 0;
  }, n.prototype._hash = function() {
    var p = r.allocUnsafe(32);
    return p.writeInt32BE(this._a, 0), p.writeInt32BE(this._b, 4), p.writeInt32BE(this._c, 8), p.writeInt32BE(this._d, 12), p.writeInt32BE(this._e, 16), p.writeInt32BE(this._f, 20), p.writeInt32BE(this._g, 24), p.writeInt32BE(this._h, 28), p;
  }, Js = n, Js;
}
var Xs, l1;
function oE() {
  if (l1)
    return Xs;
  l1 = 1;
  var e = _t(), t = Hy(), r = Ui(), i = Rt().Buffer, o = new Array(64);
  function n() {
    this.init(), this._w = o, r.call(this, 64, 56);
  }
  return e(n, t), n.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, n.prototype._hash = function() {
    var f = i.allocUnsafe(28);
    return f.writeInt32BE(this._a, 0), f.writeInt32BE(this._b, 4), f.writeInt32BE(this._c, 8), f.writeInt32BE(this._d, 12), f.writeInt32BE(this._e, 16), f.writeInt32BE(this._f, 20), f.writeInt32BE(this._g, 24), f;
  }, Xs = n, Xs;
}
var Ys, d1;
function Vy() {
  if (d1)
    return Ys;
  d1 = 1;
  var e = _t(), t = Ui(), r = Rt().Buffer, i = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], o = new Array(160);
  function n() {
    this.init(), this._w = o, t.call(this, 128, 112);
  }
  e(n, t), n.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function f(M, I, B) {
    return B ^ M & (I ^ B);
  }
  function u(M, I, B) {
    return M & I | B & (M | I);
  }
  function c(M, I) {
    return (M >>> 28 | I << 4) ^ (I >>> 2 | M << 30) ^ (I >>> 7 | M << 25);
  }
  function h(M, I) {
    return (M >>> 14 | I << 18) ^ (M >>> 18 | I << 14) ^ (I >>> 9 | M << 23);
  }
  function s(M, I) {
    return (M >>> 1 | I << 31) ^ (M >>> 8 | I << 24) ^ M >>> 7;
  }
  function b(M, I) {
    return (M >>> 1 | I << 31) ^ (M >>> 8 | I << 24) ^ (M >>> 7 | I << 25);
  }
  function p(M, I) {
    return (M >>> 19 | I << 13) ^ (I >>> 29 | M << 3) ^ M >>> 6;
  }
  function m(M, I) {
    return (M >>> 19 | I << 13) ^ (I >>> 29 | M << 3) ^ (M >>> 6 | I << 26);
  }
  function E(M, I) {
    return M >>> 0 < I >>> 0 ? 1 : 0;
  }
  return n.prototype._update = function(M) {
    for (var I = this._w, B = this._ah | 0, T = this._bh | 0, j = this._ch | 0, N = this._dh | 0, k = this._eh | 0, q = this._fh | 0, $ = this._gh | 0, re = this._hh | 0, Q = this._al | 0, fe = this._bl | 0, U = this._cl | 0, y = this._dl | 0, v = this._el | 0, a = this._fl | 0, d = this._gl | 0, w = this._hl | 0, x = 0; x < 32; x += 2)
      I[x] = M.readInt32BE(x * 4), I[x + 1] = M.readInt32BE(x * 4 + 4);
    for (; x < 160; x += 2) {
      var A = I[x - 30], S = I[x - 15 * 2 + 1], g = s(A, S), _ = b(S, A);
      A = I[x - 2 * 2], S = I[x - 2 * 2 + 1];
      var l = p(A, S), R = m(S, A), Y = I[x - 7 * 2], oe = I[x - 7 * 2 + 1], H = I[x - 16 * 2], V = I[x - 16 * 2 + 1], F = _ + oe | 0, te = g + Y + E(F, _) | 0;
      F = F + R | 0, te = te + l + E(F, R) | 0, F = F + V | 0, te = te + H + E(F, V) | 0, I[x] = te, I[x + 1] = F;
    }
    for (var he = 0; he < 160; he += 2) {
      te = I[he], F = I[he + 1];
      var K = u(B, T, j), W = u(Q, fe, U), ce = c(B, Q), ve = c(Q, B), Be = h(k, v), ee = h(v, k), C = i[he], L = i[he + 1], Z = f(k, q, $), de = f(v, a, d), me = w + ee | 0, Te = re + Be + E(me, w) | 0;
      me = me + de | 0, Te = Te + Z + E(me, de) | 0, me = me + L | 0, Te = Te + C + E(me, L) | 0, me = me + F | 0, Te = Te + te + E(me, F) | 0;
      var ze = ve + W | 0, z = ce + K + E(ze, ve) | 0;
      re = $, w = d, $ = q, d = a, q = k, a = v, v = y + me | 0, k = N + Te + E(v, y) | 0, N = j, y = U, j = T, U = fe, T = B, fe = Q, Q = me + ze | 0, B = Te + z + E(Q, me) | 0;
    }
    this._al = this._al + Q | 0, this._bl = this._bl + fe | 0, this._cl = this._cl + U | 0, this._dl = this._dl + y | 0, this._el = this._el + v | 0, this._fl = this._fl + a | 0, this._gl = this._gl + d | 0, this._hl = this._hl + w | 0, this._ah = this._ah + B + E(this._al, Q) | 0, this._bh = this._bh + T + E(this._bl, fe) | 0, this._ch = this._ch + j + E(this._cl, U) | 0, this._dh = this._dh + N + E(this._dl, y) | 0, this._eh = this._eh + k + E(this._el, v) | 0, this._fh = this._fh + q + E(this._fl, a) | 0, this._gh = this._gh + $ + E(this._gl, d) | 0, this._hh = this._hh + re + E(this._hl, w) | 0;
  }, n.prototype._hash = function() {
    var M = r.allocUnsafe(64);
    function I(B, T, j) {
      M.writeInt32BE(B, j), M.writeInt32BE(T, j + 4);
    }
    return I(this._ah, this._al, 0), I(this._bh, this._bl, 8), I(this._ch, this._cl, 16), I(this._dh, this._dl, 24), I(this._eh, this._el, 32), I(this._fh, this._fl, 40), I(this._gh, this._gl, 48), I(this._hh, this._hl, 56), M;
  }, Ys = n, Ys;
}
var Qs, p1;
function fE() {
  if (p1)
    return Qs;
  p1 = 1;
  var e = _t(), t = Vy(), r = Ui(), i = Rt().Buffer, o = new Array(160);
  function n() {
    this.init(), this._w = o, r.call(this, 128, 112);
  }
  return e(n, t), n.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, n.prototype._hash = function() {
    var f = i.allocUnsafe(48);
    function u(c, h, s) {
      f.writeInt32BE(c, s), f.writeInt32BE(h, s + 4);
    }
    return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), f;
  }, Qs = n, Qs;
}
var v1;
function o0() {
  if (v1)
    return Ws.exports;
  v1 = 1;
  var e = Ws.exports = function(r) {
    r = r.toLowerCase();
    var i = e[r];
    if (!i)
      throw new Error(r + " is not supported (we accept pull requests)");
    return new i();
  };
  return e.sha = iE(), e.sha1 = aE(), e.sha224 = oE(), e.sha256 = Hy(), e.sha384 = fE(), e.sha512 = Vy(), Ws.exports;
}
var eu, b1;
function Ln() {
  if (b1)
    return eu;
  b1 = 1;
  var e = Rt().Buffer, t = Ay().Transform, r = th().StringDecoder, i = _t();
  function o(n) {
    t.call(this), this.hashMode = typeof n == "string", this.hashMode ? this[n] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return i(o, t), o.prototype.update = function(n, f, u) {
    typeof n == "string" && (n = e.from(n, f));
    var c = this._update(n);
    return this.hashMode ? this : (u && (c = this._toString(c, u)), c);
  }, o.prototype.setAutoPadding = function() {
  }, o.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, o.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, o.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, o.prototype._transform = function(n, f, u) {
    var c;
    try {
      this.hashMode ? this._update(n) : this.push(this._update(n));
    } catch (h) {
      c = h;
    } finally {
      u(c);
    }
  }, o.prototype._flush = function(n) {
    var f;
    try {
      this.push(this.__final());
    } catch (u) {
      f = u;
    }
    n(f);
  }, o.prototype._finalOrDigest = function(n) {
    var f = this.__final() || e.alloc(0);
    return n && (f = this._toString(f, n, !0)), f;
  }, o.prototype._toString = function(n, f, u) {
    if (this._decoder || (this._decoder = new r(f), this._encoding = f), this._encoding !== f)
      throw new Error("can't switch encodings");
    var c = this._decoder.write(n);
    return u && (c += this._decoder.end()), c;
  }, eu = o, eu;
}
var tu, y1;
function xa() {
  if (y1)
    return tu;
  y1 = 1;
  var e = _t(), t = i0(), r = a0(), i = o0(), o = Ln();
  function n(f) {
    o.call(this, "digest"), this._hash = f;
  }
  return e(n, o), n.prototype._update = function(f) {
    this._hash.update(f);
  }, n.prototype._final = function() {
    return this._hash.digest();
  }, tu = function(u) {
    return u = u.toLowerCase(), u === "md5" ? new t() : u === "rmd160" || u === "ripemd160" ? new r() : new n(i(u));
  }, tu;
}
var ru, g1;
function sE() {
  if (g1)
    return ru;
  g1 = 1;
  var e = _t(), t = Rt().Buffer, r = Ln(), i = t.alloc(128), o = 64;
  function n(f, u) {
    r.call(this, "digest"), typeof u == "string" && (u = t.from(u)), this._alg = f, this._key = u, u.length > o ? u = f(u) : u.length < o && (u = t.concat([u, i], o));
    for (var c = this._ipad = t.allocUnsafe(o), h = this._opad = t.allocUnsafe(o), s = 0; s < o; s++)
      c[s] = u[s] ^ 54, h[s] = u[s] ^ 92;
    this._hash = [c];
  }
  return e(n, r), n.prototype._update = function(f) {
    this._hash.push(f);
  }, n.prototype._final = function() {
    var f = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, f]));
  }, ru = n, ru;
}
var nu, m1;
function Wy() {
  if (m1)
    return nu;
  m1 = 1;
  var e = i0();
  return nu = function(t) {
    return new e().update(t).digest();
  }, nu;
}
var iu, w1;
function Ky() {
  if (w1)
    return iu;
  w1 = 1;
  var e = _t(), t = sE(), r = Ln(), i = Rt().Buffer, o = Wy(), n = a0(), f = o0(), u = i.alloc(128);
  function c(h, s) {
    r.call(this, "digest"), typeof s == "string" && (s = i.from(s));
    var b = h === "sha512" || h === "sha384" ? 128 : 64;
    if (this._alg = h, this._key = s, s.length > b) {
      var p = h === "rmd160" ? new n() : f(h);
      s = p.update(s).digest();
    } else
      s.length < b && (s = i.concat([s, u], b));
    for (var m = this._ipad = i.allocUnsafe(b), E = this._opad = i.allocUnsafe(b), M = 0; M < b; M++)
      m[M] = s[M] ^ 54, E[M] = s[M] ^ 92;
    this._hash = h === "rmd160" ? new n() : f(h), this._hash.update(m);
  }
  return e(c, r), c.prototype._update = function(h) {
    this._hash.update(h);
  }, c.prototype._final = function() {
    var h = this._hash.digest(), s = this._alg === "rmd160" ? new n() : f(this._alg);
    return s.update(this._opad).update(h).digest();
  }, iu = function(s, b) {
    return s = s.toLowerCase(), s === "rmd160" || s === "ripemd160" ? new c("rmd160", b) : s === "md5" ? new t(o, b) : new c(s, b);
  }, iu;
}
const uE = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, cE = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, hE = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, lE = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, dE = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, pE = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, vE = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, bE = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, yE = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, gE = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, mE = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, Zy = {
  sha224WithRSAEncryption: uE,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: cE,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: hE,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: lE,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: dE,
  sha224: pE,
  sha384: vE,
  sha512: bE,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: yE,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: gE,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: mE,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var au, _1;
function wE() {
  return _1 || (_1 = 1, au = Zy), au;
}
var Fa = {}, ou, x1;
function Gy() {
  if (x1)
    return ou;
  x1 = 1;
  var e = Math.pow(2, 30) - 1;
  return ou = function(t, r) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof r != "number")
      throw new TypeError("Key length not a number");
    if (r < 0 || r > e || r !== r)
      throw new TypeError("Bad key length");
  }, ou;
}
var fu, E1;
function Jy() {
  if (E1)
    return fu;
  E1 = 1;
  var e;
  if (Ze.process && Ze.process.browser)
    e = "utf-8";
  else if (Ze.process && Ze.process.version) {
    var t = parseInt(at.version.split(".")[0].slice(1), 10);
    e = t >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return fu = e, fu;
}
var su, S1;
function Xy() {
  if (S1)
    return su;
  S1 = 1;
  var e = Rt().Buffer;
  return su = function(t, r, i) {
    if (e.isBuffer(t))
      return t;
    if (typeof t == "string")
      return e.from(t, r);
    if (ArrayBuffer.isView(t))
      return e.from(t.buffer);
    throw new TypeError(i + " must be a string, a Buffer, a typed array or a DataView");
  }, su;
}
var uu, A1;
function Yy() {
  if (A1)
    return uu;
  A1 = 1;
  var e = Wy(), t = a0(), r = o0(), i = Rt().Buffer, o = Gy(), n = Jy(), f = Xy(), u = i.alloc(128), c = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function h(p, m, E) {
    var M = s(p), I = p === "sha512" || p === "sha384" ? 128 : 64;
    m.length > I ? m = M(m) : m.length < I && (m = i.concat([m, u], I));
    for (var B = i.allocUnsafe(I + c[p]), T = i.allocUnsafe(I + c[p]), j = 0; j < I; j++)
      B[j] = m[j] ^ 54, T[j] = m[j] ^ 92;
    var N = i.allocUnsafe(I + E + 4);
    B.copy(N, 0, 0, I), this.ipad1 = N, this.ipad2 = B, this.opad = T, this.alg = p, this.blocksize = I, this.hash = M, this.size = c[p];
  }
  h.prototype.run = function(p, m) {
    p.copy(m, this.blocksize);
    var E = this.hash(m);
    return E.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function s(p) {
    function m(M) {
      return r(p).update(M).digest();
    }
    function E(M) {
      return new t().update(M).digest();
    }
    return p === "rmd160" || p === "ripemd160" ? E : p === "md5" ? e : m;
  }
  function b(p, m, E, M, I) {
    o(E, M), p = f(p, n, "Password"), m = f(m, n, "Salt"), I = I || "sha1";
    var B = new h(I, p, m.length), T = i.allocUnsafe(M), j = i.allocUnsafe(m.length + 4);
    m.copy(j, 0, 0, m.length);
    for (var N = 0, k = c[I], q = Math.ceil(M / k), $ = 1; $ <= q; $++) {
      j.writeUInt32BE($, m.length);
      for (var re = B.run(j, B.ipad1), Q = re, fe = 1; fe < E; fe++) {
        Q = B.run(Q, B.ipad2);
        for (var U = 0; U < k; U++)
          re[U] ^= Q[U];
      }
      re.copy(T, N), N += k;
    }
    return T;
  }
  return uu = b, uu;
}
var cu, M1;
function _E() {
  if (M1)
    return cu;
  M1 = 1;
  var e = Rt().Buffer, t = Gy(), r = Jy(), i = Yy(), o = Xy(), n, f = Ze.crypto && Ze.crypto.subtle, u = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, c = [];
  function h(E) {
    if (Ze.process && !Ze.process.browser || !f || !f.importKey || !f.deriveBits)
      return Promise.resolve(!1);
    if (c[E] !== void 0)
      return c[E];
    n = n || e.alloc(8);
    var M = p(n, n, 10, 128, E).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return c[E] = M, M;
  }
  var s;
  function b() {
    return s || (Ze.process && Ze.process.nextTick ? s = Ze.process.nextTick : Ze.queueMicrotask ? s = Ze.queueMicrotask : Ze.setImmediate ? s = Ze.setImmediate : s = Ze.setTimeout, s);
  }
  function p(E, M, I, B, T) {
    return f.importKey(
      "raw",
      E,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(j) {
      return f.deriveBits({
        name: "PBKDF2",
        salt: M,
        iterations: I,
        hash: {
          name: T
        }
      }, j, B << 3);
    }).then(function(j) {
      return e.from(j);
    });
  }
  function m(E, M) {
    E.then(function(I) {
      b()(function() {
        M(null, I);
      });
    }, function(I) {
      b()(function() {
        M(I);
      });
    });
  }
  return cu = function(E, M, I, B, T, j) {
    typeof T == "function" && (j = T, T = void 0), T = T || "sha1";
    var N = u[T.toLowerCase()];
    if (!N || typeof Ze.Promise != "function") {
      b()(function() {
        var k;
        try {
          k = i(E, M, I, B, T);
        } catch (q) {
          return j(q);
        }
        j(null, k);
      });
      return;
    }
    if (t(I, B), E = o(E, r, "Password"), M = o(M, r, "Salt"), typeof j != "function")
      throw new Error("No callback provided to pbkdf2");
    m(h(N).then(function(k) {
      return k ? p(E, M, I, B, N) : i(E, M, I, B, T);
    }), j);
  }, cu;
}
var R1;
function Qy() {
  return R1 || (R1 = 1, Fa.pbkdf2 = _E(), Fa.pbkdf2Sync = Yy()), Fa;
}
var Mr = {}, jn = {}, mr = {}, B1;
function eg() {
  if (B1)
    return mr;
  B1 = 1, mr.readUInt32BE = function(o, n) {
    var f = o[0 + n] << 24 | o[1 + n] << 16 | o[2 + n] << 8 | o[3 + n];
    return f >>> 0;
  }, mr.writeUInt32BE = function(o, n, f) {
    o[0 + f] = n >>> 24, o[1 + f] = n >>> 16 & 255, o[2 + f] = n >>> 8 & 255, o[3 + f] = n & 255;
  }, mr.ip = function(o, n, f, u) {
    for (var c = 0, h = 0, s = 6; s >= 0; s -= 2) {
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= n >>> b + s & 1;
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= o >>> b + s & 1;
    }
    for (var s = 6; s >= 0; s -= 2) {
      for (var b = 1; b <= 25; b += 8)
        h <<= 1, h |= n >>> b + s & 1;
      for (var b = 1; b <= 25; b += 8)
        h <<= 1, h |= o >>> b + s & 1;
    }
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, mr.rip = function(o, n, f, u) {
    for (var c = 0, h = 0, s = 0; s < 4; s++)
      for (var b = 24; b >= 0; b -= 8)
        c <<= 1, c |= n >>> b + s & 1, c <<= 1, c |= o >>> b + s & 1;
    for (var s = 4; s < 8; s++)
      for (var b = 24; b >= 0; b -= 8)
        h <<= 1, h |= n >>> b + s & 1, h <<= 1, h |= o >>> b + s & 1;
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, mr.pc1 = function(o, n, f, u) {
    for (var c = 0, h = 0, s = 7; s >= 5; s--) {
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= n >> b + s & 1;
      for (var b = 0; b <= 24; b += 8)
        c <<= 1, c |= o >> b + s & 1;
    }
    for (var b = 0; b <= 24; b += 8)
      c <<= 1, c |= n >> b + s & 1;
    for (var s = 1; s <= 3; s++) {
      for (var b = 0; b <= 24; b += 8)
        h <<= 1, h |= n >> b + s & 1;
      for (var b = 0; b <= 24; b += 8)
        h <<= 1, h |= o >> b + s & 1;
    }
    for (var b = 0; b <= 24; b += 8)
      h <<= 1, h |= o >> b + s & 1;
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, mr.r28shl = function(o, n) {
    return o << n & 268435455 | o >>> 28 - n;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  mr.pc2 = function(o, n, f, u) {
    for (var c = 0, h = 0, s = e.length >>> 1, b = 0; b < s; b++)
      c <<= 1, c |= o >>> e[b] & 1;
    for (var b = s; b < e.length; b++)
      h <<= 1, h |= n >>> e[b] & 1;
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, mr.expand = function(o, n, f) {
    var u = 0, c = 0;
    u = (o & 1) << 5 | o >>> 27;
    for (var h = 23; h >= 15; h -= 4)
      u <<= 6, u |= o >>> h & 63;
    for (var h = 11; h >= 3; h -= 4)
      c |= o >>> h & 63, c <<= 6;
    c |= (o & 31) << 1 | o >>> 31, n[f + 0] = u >>> 0, n[f + 1] = c >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  mr.substitute = function(o, n) {
    for (var f = 0, u = 0; u < 4; u++) {
      var c = o >>> 18 - u * 6 & 63, h = t[u * 64 + c];
      f <<= 4, f |= h;
    }
    for (var u = 0; u < 4; u++) {
      var c = n >>> 18 - u * 6 & 63, h = t[4 * 64 + u * 64 + c];
      f <<= 4, f |= h;
    }
    return f >>> 0;
  };
  var r = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return mr.permute = function(o) {
    for (var n = 0, f = 0; f < r.length; f++)
      n <<= 1, n |= o >>> r[f] & 1;
    return n >>> 0;
  }, mr.padSplit = function(o, n, f) {
    for (var u = o.toString(2); u.length < n; )
      u = "0" + u;
    for (var c = [], h = 0; h < n; h += f)
      c.push(u.slice(h, h + f));
    return c.join(" ");
  }, mr;
}
var hu, I1;
function qr() {
  if (I1)
    return hu;
  I1 = 1, hu = e;
  function e(t, r) {
    if (!t)
      throw new Error(r || "Assertion failed");
  }
  return e.equal = function(r, i, o) {
    if (r != i)
      throw new Error(o || "Assertion failed: " + r + " != " + i);
  }, hu;
}
var lu, T1;
function f0() {
  if (T1)
    return lu;
  T1 = 1;
  var e = qr();
  function t(r) {
    this.options = r, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = r.padding !== !1;
  }
  return lu = t, t.prototype._init = function() {
  }, t.prototype.update = function(i) {
    return i.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(i) : this._updateEncrypt(i);
  }, t.prototype._buffer = function(i, o) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, i.length - o), f = 0; f < n; f++)
      this.buffer[this.bufferOff + f] = i[o + f];
    return this.bufferOff += n, n;
  }, t.prototype._flushBuffer = function(i, o) {
    return this._update(this.buffer, 0, i, o), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(i) {
    var o = 0, n = 0, f = (this.bufferOff + i.length) / this.blockSize | 0, u = new Array(f * this.blockSize);
    this.bufferOff !== 0 && (o += this._buffer(i, o), this.bufferOff === this.buffer.length && (n += this._flushBuffer(u, n)));
    for (var c = i.length - (i.length - o) % this.blockSize; o < c; o += this.blockSize)
      this._update(i, o, u, n), n += this.blockSize;
    for (; o < i.length; o++, this.bufferOff++)
      this.buffer[this.bufferOff] = i[o];
    return u;
  }, t.prototype._updateDecrypt = function(i) {
    for (var o = 0, n = 0, f = Math.ceil((this.bufferOff + i.length) / this.blockSize) - 1, u = new Array(f * this.blockSize); f > 0; f--)
      o += this._buffer(i, o), n += this._flushBuffer(u, n);
    return o += this._buffer(i, o), u;
  }, t.prototype.final = function(i) {
    var o;
    i && (o = this.update(i));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), o ? o.concat(n) : n;
  }, t.prototype._pad = function(i, o) {
    if (o === 0)
      return !1;
    for (; o < i.length; )
      i[o++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var i = new Array(this.blockSize);
    return this._update(this.buffer, 0, i, 0), i;
  }, t.prototype._unpad = function(i) {
    return i;
  }, t.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var i = new Array(this.blockSize);
    return this._flushBuffer(i, 0), this._unpad(i);
  }, lu;
}
var du, O1;
function tg() {
  if (O1)
    return du;
  O1 = 1;
  var e = qr(), t = _t(), r = eg(), i = f0();
  function o() {
    this.tmp = new Array(2), this.keys = null;
  }
  function n(u) {
    i.call(this, u);
    var c = new o();
    this._desState = c, this.deriveKeys(c, u.key);
  }
  t(n, i), du = n, n.create = function(c) {
    return new n(c);
  };
  var f = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return n.prototype.deriveKeys = function(c, h) {
    c.keys = new Array(16 * 2), e.equal(h.length, this.blockSize, "Invalid key length");
    var s = r.readUInt32BE(h, 0), b = r.readUInt32BE(h, 4);
    r.pc1(s, b, c.tmp, 0), s = c.tmp[0], b = c.tmp[1];
    for (var p = 0; p < c.keys.length; p += 2) {
      var m = f[p >>> 1];
      s = r.r28shl(s, m), b = r.r28shl(b, m), r.pc2(s, b, c.keys, p);
    }
  }, n.prototype._update = function(c, h, s, b) {
    var p = this._desState, m = r.readUInt32BE(c, h), E = r.readUInt32BE(c, h + 4);
    r.ip(m, E, p.tmp, 0), m = p.tmp[0], E = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, m, E, p.tmp, 0) : this._decrypt(p, m, E, p.tmp, 0), m = p.tmp[0], E = p.tmp[1], r.writeUInt32BE(s, m, b), r.writeUInt32BE(s, E, b + 4);
  }, n.prototype._pad = function(c, h) {
    if (this.padding === !1)
      return !1;
    for (var s = c.length - h, b = h; b < c.length; b++)
      c[b] = s;
    return !0;
  }, n.prototype._unpad = function(c) {
    if (this.padding === !1)
      return c;
    for (var h = c[c.length - 1], s = c.length - h; s < c.length; s++)
      e.equal(c[s], h);
    return c.slice(0, c.length - h);
  }, n.prototype._encrypt = function(c, h, s, b, p) {
    for (var m = h, E = s, M = 0; M < c.keys.length; M += 2) {
      var I = c.keys[M], B = c.keys[M + 1];
      r.expand(E, c.tmp, 0), I ^= c.tmp[0], B ^= c.tmp[1];
      var T = r.substitute(I, B), j = r.permute(T), N = E;
      E = (m ^ j) >>> 0, m = N;
    }
    r.rip(E, m, b, p);
  }, n.prototype._decrypt = function(c, h, s, b, p) {
    for (var m = s, E = h, M = c.keys.length - 2; M >= 0; M -= 2) {
      var I = c.keys[M], B = c.keys[M + 1];
      r.expand(m, c.tmp, 0), I ^= c.tmp[0], B ^= c.tmp[1];
      var T = r.substitute(I, B), j = r.permute(T), N = m;
      m = (E ^ j) >>> 0, E = N;
    }
    r.rip(m, E, b, p);
  }, du;
}
var pu = {}, P1;
function xE() {
  if (P1)
    return pu;
  P1 = 1;
  var e = qr(), t = _t(), r = {};
  function i(n) {
    e.equal(n.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var f = 0; f < this.iv.length; f++)
      this.iv[f] = n[f];
  }
  function o(n) {
    function f(s) {
      n.call(this, s), this._cbcInit();
    }
    t(f, n);
    for (var u = Object.keys(r), c = 0; c < u.length; c++) {
      var h = u[c];
      f.prototype[h] = r[h];
    }
    return f.create = function(b) {
      return new f(b);
    }, f;
  }
  return pu.instantiate = o, r._cbcInit = function() {
    var f = new i(this.options.iv);
    this._cbcState = f;
  }, r._update = function(f, u, c, h) {
    var s = this._cbcState, b = this.constructor.super_.prototype, p = s.iv;
    if (this.type === "encrypt") {
      for (var m = 0; m < this.blockSize; m++)
        p[m] ^= f[u + m];
      b._update.call(this, p, 0, c, h);
      for (var m = 0; m < this.blockSize; m++)
        p[m] = c[h + m];
    } else {
      b._update.call(this, f, u, c, h);
      for (var m = 0; m < this.blockSize; m++)
        c[h + m] ^= p[m];
      for (var m = 0; m < this.blockSize; m++)
        p[m] = f[u + m];
    }
  }, pu;
}
var vu, C1;
function EE() {
  if (C1)
    return vu;
  C1 = 1;
  var e = qr(), t = _t(), r = f0(), i = tg();
  function o(f, u) {
    e.equal(u.length, 24, "Invalid key length");
    var c = u.slice(0, 8), h = u.slice(8, 16), s = u.slice(16, 24);
    f === "encrypt" ? this.ciphers = [
      i.create({ type: "encrypt", key: c }),
      i.create({ type: "decrypt", key: h }),
      i.create({ type: "encrypt", key: s })
    ] : this.ciphers = [
      i.create({ type: "decrypt", key: s }),
      i.create({ type: "encrypt", key: h }),
      i.create({ type: "decrypt", key: c })
    ];
  }
  function n(f) {
    r.call(this, f);
    var u = new o(this.type, this.options.key);
    this._edeState = u;
  }
  return t(n, r), vu = n, n.create = function(u) {
    return new n(u);
  }, n.prototype._update = function(u, c, h, s) {
    var b = this._edeState;
    b.ciphers[0]._update(u, c, h, s), b.ciphers[1]._update(h, s, h, s), b.ciphers[2]._update(h, s, h, s);
  }, n.prototype._pad = i.prototype._pad, n.prototype._unpad = i.prototype._unpad, vu;
}
var N1;
function SE() {
  return N1 || (N1 = 1, jn.utils = eg(), jn.Cipher = f0(), jn.DES = tg(), jn.CBC = xE(), jn.EDE = EE()), jn;
}
var bu, L1;
function AE() {
  if (L1)
    return bu;
  L1 = 1;
  var e = Ln(), t = SE(), r = _t(), i = Rt().Buffer, o = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  o.des = o["des-cbc"], o.des3 = o["des-ede3-cbc"], bu = n, r(n, e);
  function n(f) {
    e.call(this);
    var u = f.mode.toLowerCase(), c = o[u], h;
    f.decrypt ? h = "decrypt" : h = "encrypt";
    var s = f.key;
    i.isBuffer(s) || (s = i.from(s)), (u === "des-ede" || u === "des-ede-cbc") && (s = i.concat([s, s.slice(0, 8)]));
    var b = f.iv;
    i.isBuffer(b) || (b = i.from(b)), this._des = c.create({
      key: s,
      iv: b,
      type: h
    });
  }
  return n.prototype._update = function(f) {
    return i.from(this._des.update(f));
  }, n.prototype._final = function() {
    return i.from(this._des.final());
  }, bu;
}
var Rr = {}, za = {}, Ha = {}, k1;
function ME() {
  return k1 || (k1 = 1, Ha.encrypt = function(e, t) {
    return e._cipher.encryptBlock(t);
  }, Ha.decrypt = function(e, t) {
    return e._cipher.decryptBlock(t);
  }), Ha;
}
var Va = {}, yu, j1;
function Ea() {
  return j1 || (j1 = 1, yu = function(t, r) {
    for (var i = Math.min(t.length, r.length), o = new Le.Buffer(i), n = 0; n < i; ++n)
      o[n] = t[n] ^ r[n];
    return o;
  }), yu;
}
var q1;
function RE() {
  if (q1)
    return Va;
  q1 = 1;
  var e = Ea();
  return Va.encrypt = function(t, r) {
    var i = e(r, t._prev);
    return t._prev = t._cipher.encryptBlock(i), t._prev;
  }, Va.decrypt = function(t, r) {
    var i = t._prev;
    t._prev = r;
    var o = t._cipher.decryptBlock(r);
    return e(o, i);
  }, Va;
}
var gu = {}, D1;
function BE() {
  if (D1)
    return gu;
  D1 = 1;
  var e = Rt().Buffer, t = Ea();
  function r(i, o, n) {
    var f = o.length, u = t(o, i._cache);
    return i._cache = i._cache.slice(f), i._prev = e.concat([i._prev, n ? o : u]), u;
  }
  return gu.encrypt = function(i, o, n) {
    for (var f = e.allocUnsafe(0), u; o.length; )
      if (i._cache.length === 0 && (i._cache = i._cipher.encryptBlock(i._prev), i._prev = e.allocUnsafe(0)), i._cache.length <= o.length)
        u = i._cache.length, f = e.concat([f, r(i, o.slice(0, u), n)]), o = o.slice(u);
      else {
        f = e.concat([f, r(i, o, n)]);
        break;
      }
    return f;
  }, gu;
}
var mu = {}, $1;
function IE() {
  if ($1)
    return mu;
  $1 = 1;
  var e = Rt().Buffer;
  function t(r, i, o) {
    var n = r._cipher.encryptBlock(r._prev), f = n[0] ^ i;
    return r._prev = e.concat([
      r._prev.slice(1),
      e.from([o ? i : f])
    ]), f;
  }
  return mu.encrypt = function(r, i, o) {
    for (var n = i.length, f = e.allocUnsafe(n), u = -1; ++u < n; )
      f[u] = t(r, i[u], o);
    return f;
  }, mu;
}
var wu = {}, U1;
function TE() {
  if (U1)
    return wu;
  U1 = 1;
  var e = Rt().Buffer;
  function t(i, o, n) {
    for (var f, u = -1, c = 8, h = 0, s, b; ++u < c; )
      f = i._cipher.encryptBlock(i._prev), s = o & 1 << 7 - u ? 128 : 0, b = f[0] ^ s, h += (b & 128) >> u % 8, i._prev = r(i._prev, n ? s : b);
    return h;
  }
  function r(i, o) {
    var n = i.length, f = -1, u = e.allocUnsafe(i.length);
    for (i = e.concat([i, e.from([o])]); ++f < n; )
      u[f] = i[f] << 1 | i[f + 1] >> 7;
    return u;
  }
  return wu.encrypt = function(i, o, n) {
    for (var f = o.length, u = e.allocUnsafe(f), c = -1; ++c < f; )
      u[c] = t(i, o[c], n);
    return u;
  }, wu;
}
var _u = {}, F1;
function OE() {
  if (F1)
    return _u;
  F1 = 1;
  var e = Ea();
  function t(r) {
    return r._prev = r._cipher.encryptBlock(r._prev), r._prev;
  }
  return _u.encrypt = function(r, i) {
    for (; r._cache.length < i.length; )
      r._cache = Le.Buffer.concat([r._cache, t(r)]);
    var o = r._cache.slice(0, i.length);
    return r._cache = r._cache.slice(i.length), e(i, o);
  }, _u;
}
var xu = {}, Eu, z1;
function rg() {
  if (z1)
    return Eu;
  z1 = 1;
  function e(t) {
    for (var r = t.length, i; r--; )
      if (i = t.readUInt8(r), i === 255)
        t.writeUInt8(0, r);
      else {
        i++, t.writeUInt8(i, r);
        break;
      }
  }
  return Eu = e, Eu;
}
var H1;
function V1() {
  if (H1)
    return xu;
  H1 = 1;
  var e = Ea(), t = Rt().Buffer, r = rg();
  function i(n) {
    var f = n._cipher.encryptBlockRaw(n._prev);
    return r(n._prev), f;
  }
  var o = 16;
  return xu.encrypt = function(n, f) {
    var u = Math.ceil(f.length / o), c = n._cache.length;
    n._cache = t.concat([
      n._cache,
      t.allocUnsafe(u * o)
    ]);
    for (var h = 0; h < u; h++) {
      var s = i(n), b = c + h * o;
      n._cache.writeUInt32BE(s[0], b + 0), n._cache.writeUInt32BE(s[1], b + 4), n._cache.writeUInt32BE(s[2], b + 8), n._cache.writeUInt32BE(s[3], b + 12);
    }
    var p = n._cache.slice(0, f.length);
    return n._cache = n._cache.slice(f.length), e(f, p);
  }, xu;
}
const PE = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, CE = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, NE = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, ng = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: PE,
  aes192: CE,
  aes256: NE,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var Su, W1;
function s0() {
  if (W1)
    return Su;
  W1 = 1;
  var e = {
    ECB: ME(),
    CBC: RE(),
    CFB: BE(),
    CFB8: IE(),
    CFB1: TE(),
    OFB: OE(),
    CTR: V1(),
    GCM: V1()
  }, t = ng;
  for (var r in t)
    t[r].module = e[t[r].mode];
  return Su = t, Su;
}
var Au = {}, K1;
function ff() {
  if (K1)
    return Au;
  K1 = 1;
  var e = Rt().Buffer;
  function t(u) {
    e.isBuffer(u) || (u = e.from(u));
    for (var c = u.length / 4 | 0, h = new Array(c), s = 0; s < c; s++)
      h[s] = u.readUInt32BE(s * 4);
    return h;
  }
  function r(u) {
    for (var c = 0; c < u.length; u++)
      u[c] = 0;
  }
  function i(u, c, h, s, b) {
    for (var p = h[0], m = h[1], E = h[2], M = h[3], I = u[0] ^ c[0], B = u[1] ^ c[1], T = u[2] ^ c[2], j = u[3] ^ c[3], N, k, q, $, re = 4, Q = 1; Q < b; Q++)
      N = p[I >>> 24] ^ m[B >>> 16 & 255] ^ E[T >>> 8 & 255] ^ M[j & 255] ^ c[re++], k = p[B >>> 24] ^ m[T >>> 16 & 255] ^ E[j >>> 8 & 255] ^ M[I & 255] ^ c[re++], q = p[T >>> 24] ^ m[j >>> 16 & 255] ^ E[I >>> 8 & 255] ^ M[B & 255] ^ c[re++], $ = p[j >>> 24] ^ m[I >>> 16 & 255] ^ E[B >>> 8 & 255] ^ M[T & 255] ^ c[re++], I = N, B = k, T = q, j = $;
    return N = (s[I >>> 24] << 24 | s[B >>> 16 & 255] << 16 | s[T >>> 8 & 255] << 8 | s[j & 255]) ^ c[re++], k = (s[B >>> 24] << 24 | s[T >>> 16 & 255] << 16 | s[j >>> 8 & 255] << 8 | s[I & 255]) ^ c[re++], q = (s[T >>> 24] << 24 | s[j >>> 16 & 255] << 16 | s[I >>> 8 & 255] << 8 | s[B & 255]) ^ c[re++], $ = (s[j >>> 24] << 24 | s[I >>> 16 & 255] << 16 | s[B >>> 8 & 255] << 8 | s[T & 255]) ^ c[re++], N = N >>> 0, k = k >>> 0, q = q >>> 0, $ = $ >>> 0, [N, k, q, $];
  }
  var o = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], n = function() {
    for (var u = new Array(256), c = 0; c < 256; c++)
      c < 128 ? u[c] = c << 1 : u[c] = c << 1 ^ 283;
    for (var h = [], s = [], b = [[], [], [], []], p = [[], [], [], []], m = 0, E = 0, M = 0; M < 256; ++M) {
      var I = E ^ E << 1 ^ E << 2 ^ E << 3 ^ E << 4;
      I = I >>> 8 ^ I & 255 ^ 99, h[m] = I, s[I] = m;
      var B = u[m], T = u[B], j = u[T], N = u[I] * 257 ^ I * 16843008;
      b[0][m] = N << 24 | N >>> 8, b[1][m] = N << 16 | N >>> 16, b[2][m] = N << 8 | N >>> 24, b[3][m] = N, N = j * 16843009 ^ T * 65537 ^ B * 257 ^ m * 16843008, p[0][I] = N << 24 | N >>> 8, p[1][I] = N << 16 | N >>> 16, p[2][I] = N << 8 | N >>> 24, p[3][I] = N, m === 0 ? m = E = 1 : (m = B ^ u[u[u[j ^ B]]], E ^= u[u[E]]);
    }
    return {
      SBOX: h,
      INV_SBOX: s,
      SUB_MIX: b,
      INV_SUB_MIX: p
    };
  }();
  function f(u) {
    this._key = t(u), this._reset();
  }
  return f.blockSize = 4 * 4, f.keySize = 256 / 8, f.prototype.blockSize = f.blockSize, f.prototype.keySize = f.keySize, f.prototype._reset = function() {
    for (var u = this._key, c = u.length, h = c + 6, s = (h + 1) * 4, b = [], p = 0; p < c; p++)
      b[p] = u[p];
    for (p = c; p < s; p++) {
      var m = b[p - 1];
      p % c === 0 ? (m = m << 8 | m >>> 24, m = n.SBOX[m >>> 24] << 24 | n.SBOX[m >>> 16 & 255] << 16 | n.SBOX[m >>> 8 & 255] << 8 | n.SBOX[m & 255], m ^= o[p / c | 0] << 24) : c > 6 && p % c === 4 && (m = n.SBOX[m >>> 24] << 24 | n.SBOX[m >>> 16 & 255] << 16 | n.SBOX[m >>> 8 & 255] << 8 | n.SBOX[m & 255]), b[p] = b[p - c] ^ m;
    }
    for (var E = [], M = 0; M < s; M++) {
      var I = s - M, B = b[I - (M % 4 ? 0 : 4)];
      M < 4 || I <= 4 ? E[M] = B : E[M] = n.INV_SUB_MIX[0][n.SBOX[B >>> 24]] ^ n.INV_SUB_MIX[1][n.SBOX[B >>> 16 & 255]] ^ n.INV_SUB_MIX[2][n.SBOX[B >>> 8 & 255]] ^ n.INV_SUB_MIX[3][n.SBOX[B & 255]];
    }
    this._nRounds = h, this._keySchedule = b, this._invKeySchedule = E;
  }, f.prototype.encryptBlockRaw = function(u) {
    return u = t(u), i(u, this._keySchedule, n.SUB_MIX, n.SBOX, this._nRounds);
  }, f.prototype.encryptBlock = function(u) {
    var c = this.encryptBlockRaw(u), h = e.allocUnsafe(16);
    return h.writeUInt32BE(c[0], 0), h.writeUInt32BE(c[1], 4), h.writeUInt32BE(c[2], 8), h.writeUInt32BE(c[3], 12), h;
  }, f.prototype.decryptBlock = function(u) {
    u = t(u);
    var c = u[1];
    u[1] = u[3], u[3] = c;
    var h = i(u, this._invKeySchedule, n.INV_SUB_MIX, n.INV_SBOX, this._nRounds), s = e.allocUnsafe(16);
    return s.writeUInt32BE(h[0], 0), s.writeUInt32BE(h[3], 4), s.writeUInt32BE(h[2], 8), s.writeUInt32BE(h[1], 12), s;
  }, f.prototype.scrub = function() {
    r(this._keySchedule), r(this._invKeySchedule), r(this._key);
  }, Au.AES = f, Au;
}
var Mu, Z1;
function LE() {
  if (Z1)
    return Mu;
  Z1 = 1;
  var e = Rt().Buffer, t = e.alloc(16, 0);
  function r(n) {
    return [
      n.readUInt32BE(0),
      n.readUInt32BE(4),
      n.readUInt32BE(8),
      n.readUInt32BE(12)
    ];
  }
  function i(n) {
    var f = e.allocUnsafe(16);
    return f.writeUInt32BE(n[0] >>> 0, 0), f.writeUInt32BE(n[1] >>> 0, 4), f.writeUInt32BE(n[2] >>> 0, 8), f.writeUInt32BE(n[3] >>> 0, 12), f;
  }
  function o(n) {
    this.h = n, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return o.prototype.ghash = function(n) {
    for (var f = -1; ++f < n.length; )
      this.state[f] ^= n[f];
    this._multiply();
  }, o.prototype._multiply = function() {
    for (var n = r(this.h), f = [0, 0, 0, 0], u, c, h, s = -1; ++s < 128; ) {
      for (c = (this.state[~~(s / 8)] & 1 << 7 - s % 8) !== 0, c && (f[0] ^= n[0], f[1] ^= n[1], f[2] ^= n[2], f[3] ^= n[3]), h = (n[3] & 1) !== 0, u = 3; u > 0; u--)
        n[u] = n[u] >>> 1 | (n[u - 1] & 1) << 31;
      n[0] = n[0] >>> 1, h && (n[0] = n[0] ^ 225 << 24);
    }
    this.state = i(f);
  }, o.prototype.update = function(n) {
    this.cache = e.concat([this.cache, n]);
    for (var f; this.cache.length >= 16; )
      f = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(f);
  }, o.prototype.final = function(n, f) {
    return this.cache.length && this.ghash(e.concat([this.cache, t], 16)), this.ghash(i([0, n, 0, f])), this.state;
  }, Mu = o, Mu;
}
var Ru, G1;
function ig() {
  if (G1)
    return Ru;
  G1 = 1;
  var e = ff(), t = Rt().Buffer, r = Ln(), i = _t(), o = LE(), n = Ea(), f = rg();
  function u(s, b) {
    var p = 0;
    s.length !== b.length && p++;
    for (var m = Math.min(s.length, b.length), E = 0; E < m; ++E)
      p += s[E] ^ b[E];
    return p;
  }
  function c(s, b, p) {
    if (b.length === 12)
      return s._finID = t.concat([b, t.from([0, 0, 0, 1])]), t.concat([b, t.from([0, 0, 0, 2])]);
    var m = new o(p), E = b.length, M = E % 16;
    m.update(b), M && (M = 16 - M, m.update(t.alloc(M, 0))), m.update(t.alloc(8, 0));
    var I = E * 8, B = t.alloc(8);
    B.writeUIntBE(I, 0, 8), m.update(B), s._finID = m.state;
    var T = t.from(s._finID);
    return f(T), T;
  }
  function h(s, b, p, m) {
    r.call(this);
    var E = t.alloc(4, 0);
    this._cipher = new e.AES(b);
    var M = this._cipher.encryptBlock(E);
    this._ghash = new o(M), p = c(this, p, M), this._prev = t.from(p), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = m, this._alen = 0, this._len = 0, this._mode = s, this._authTag = null, this._called = !1;
  }
  return i(h, r), h.prototype._update = function(s) {
    if (!this._called && this._alen) {
      var b = 16 - this._alen % 16;
      b < 16 && (b = t.alloc(b, 0), this._ghash.update(b));
    }
    this._called = !0;
    var p = this._mode.encrypt(this, s);
    return this._decrypt ? this._ghash.update(s) : this._ghash.update(p), this._len += s.length, p;
  }, h.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var s = n(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && u(s, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = s, this._cipher.scrub();
  }, h.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, h.prototype.setAuthTag = function(b) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = b;
  }, h.prototype.setAAD = function(b) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(b), this._alen += b.length;
  }, Ru = h, Ru;
}
var Bu, J1;
function ag() {
  if (J1)
    return Bu;
  J1 = 1;
  var e = ff(), t = Rt().Buffer, r = Ln(), i = _t();
  function o(n, f, u, c) {
    r.call(this), this._cipher = new e.AES(f), this._prev = t.from(u), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = c, this._mode = n;
  }
  return i(o, r), o.prototype._update = function(n) {
    return this._mode.encrypt(this, n, this._decrypt);
  }, o.prototype._final = function() {
    this._cipher.scrub();
  }, Bu = o, Bu;
}
var Iu, X1;
function sf() {
  if (X1)
    return Iu;
  X1 = 1;
  var e = Rt().Buffer, t = i0();
  function r(i, o, n, f) {
    if (e.isBuffer(i) || (i = e.from(i, "binary")), o && (e.isBuffer(o) || (o = e.from(o, "binary")), o.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var u = n / 8, c = e.alloc(u), h = e.alloc(f || 0), s = e.alloc(0); u > 0 || f > 0; ) {
      var b = new t();
      b.update(s), b.update(i), o && b.update(o), s = b.digest();
      var p = 0;
      if (u > 0) {
        var m = c.length - u;
        p = Math.min(u, s.length), s.copy(c, m, 0, p), u -= p;
      }
      if (p < s.length && f > 0) {
        var E = h.length - f, M = Math.min(f, s.length - p);
        s.copy(h, E, p, p + M), f -= M;
      }
    }
    return s.fill(0), { key: c, iv: h };
  }
  return Iu = r, Iu;
}
var Y1;
function kE() {
  if (Y1)
    return za;
  Y1 = 1;
  var e = s0(), t = ig(), r = Rt().Buffer, i = ag(), o = Ln(), n = ff(), f = sf(), u = _t();
  function c(m, E, M) {
    o.call(this), this._cache = new s(), this._cipher = new n.AES(E), this._prev = r.from(M), this._mode = m, this._autopadding = !0;
  }
  u(c, o), c.prototype._update = function(m) {
    this._cache.add(m);
    for (var E, M, I = []; E = this._cache.get(); )
      M = this._mode.encrypt(this, E), I.push(M);
    return r.concat(I);
  };
  var h = r.alloc(16, 16);
  c.prototype._final = function() {
    var m = this._cache.flush();
    if (this._autopadding)
      return m = this._mode.encrypt(this, m), this._cipher.scrub(), m;
    if (!m.equals(h))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(m) {
    return this._autopadding = !!m, this;
  };
  function s() {
    this.cache = r.allocUnsafe(0);
  }
  s.prototype.add = function(m) {
    this.cache = r.concat([this.cache, m]);
  }, s.prototype.get = function() {
    if (this.cache.length > 15) {
      var m = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), m;
    }
    return null;
  }, s.prototype.flush = function() {
    for (var m = 16 - this.cache.length, E = r.allocUnsafe(m), M = -1; ++M < m; )
      E.writeUInt8(m, M);
    return r.concat([this.cache, E]);
  };
  function b(m, E, M) {
    var I = e[m.toLowerCase()];
    if (!I)
      throw new TypeError("invalid suite type");
    if (typeof E == "string" && (E = r.from(E)), E.length !== I.key / 8)
      throw new TypeError("invalid key length " + E.length);
    if (typeof M == "string" && (M = r.from(M)), I.mode !== "GCM" && M.length !== I.iv)
      throw new TypeError("invalid iv length " + M.length);
    return I.type === "stream" ? new i(I.module, E, M) : I.type === "auth" ? new t(I.module, E, M) : new c(I.module, E, M);
  }
  function p(m, E) {
    var M = e[m.toLowerCase()];
    if (!M)
      throw new TypeError("invalid suite type");
    var I = f(E, !1, M.key, M.iv);
    return b(m, I.key, I.iv);
  }
  return za.createCipheriv = b, za.createCipher = p, za;
}
var Wa = {}, Q1;
function jE() {
  if (Q1)
    return Wa;
  Q1 = 1;
  var e = ig(), t = Rt().Buffer, r = s0(), i = ag(), o = Ln(), n = ff(), f = sf(), u = _t();
  function c(m, E, M) {
    o.call(this), this._cache = new h(), this._last = void 0, this._cipher = new n.AES(E), this._prev = t.from(M), this._mode = m, this._autopadding = !0;
  }
  u(c, o), c.prototype._update = function(m) {
    this._cache.add(m);
    for (var E, M, I = []; E = this._cache.get(this._autopadding); )
      M = this._mode.decrypt(this, E), I.push(M);
    return t.concat(I);
  }, c.prototype._final = function() {
    var m = this._cache.flush();
    if (this._autopadding)
      return s(this._mode.decrypt(this, m));
    if (m)
      throw new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(m) {
    return this._autopadding = !!m, this;
  };
  function h() {
    this.cache = t.allocUnsafe(0);
  }
  h.prototype.add = function(m) {
    this.cache = t.concat([this.cache, m]);
  }, h.prototype.get = function(m) {
    var E;
    if (m) {
      if (this.cache.length > 16)
        return E = this.cache.slice(0, 16), this.cache = this.cache.slice(16), E;
    } else if (this.cache.length >= 16)
      return E = this.cache.slice(0, 16), this.cache = this.cache.slice(16), E;
    return null;
  }, h.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function s(m) {
    var E = m[15];
    if (E < 1 || E > 16)
      throw new Error("unable to decrypt data");
    for (var M = -1; ++M < E; )
      if (m[M + (16 - E)] !== E)
        throw new Error("unable to decrypt data");
    if (E !== 16)
      return m.slice(0, 16 - E);
  }
  function b(m, E, M) {
    var I = r[m.toLowerCase()];
    if (!I)
      throw new TypeError("invalid suite type");
    if (typeof M == "string" && (M = t.from(M)), I.mode !== "GCM" && M.length !== I.iv)
      throw new TypeError("invalid iv length " + M.length);
    if (typeof E == "string" && (E = t.from(E)), E.length !== I.key / 8)
      throw new TypeError("invalid key length " + E.length);
    return I.type === "stream" ? new i(I.module, E, M, !0) : I.type === "auth" ? new e(I.module, E, M, !0) : new c(I.module, E, M);
  }
  function p(m, E) {
    var M = r[m.toLowerCase()];
    if (!M)
      throw new TypeError("invalid suite type");
    var I = f(E, !1, M.key, M.iv);
    return b(m, I.key, I.iv);
  }
  return Wa.createDecipher = p, Wa.createDecipheriv = b, Wa;
}
var ep;
function u0() {
  if (ep)
    return Rr;
  ep = 1;
  var e = kE(), t = jE(), r = ng;
  function i() {
    return Object.keys(r);
  }
  return Rr.createCipher = Rr.Cipher = e.createCipher, Rr.createCipheriv = Rr.Cipheriv = e.createCipheriv, Rr.createDecipher = Rr.Decipher = t.createDecipher, Rr.createDecipheriv = Rr.Decipheriv = t.createDecipheriv, Rr.listCiphers = Rr.getCiphers = i, Rr;
}
var Tu = {}, tp;
function qE() {
  return tp || (tp = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(Tu)), Tu;
}
var rp;
function DE() {
  if (rp)
    return Mr;
  rp = 1;
  var e = AE(), t = u0(), r = s0(), i = qE(), o = sf();
  function n(s, b) {
    s = s.toLowerCase();
    var p, m;
    if (r[s])
      p = r[s].key, m = r[s].iv;
    else if (i[s])
      p = i[s].key * 8, m = i[s].iv;
    else
      throw new TypeError("invalid suite type");
    var E = o(b, !1, p, m);
    return u(s, E.key, E.iv);
  }
  function f(s, b) {
    s = s.toLowerCase();
    var p, m;
    if (r[s])
      p = r[s].key, m = r[s].iv;
    else if (i[s])
      p = i[s].key * 8, m = i[s].iv;
    else
      throw new TypeError("invalid suite type");
    var E = o(b, !1, p, m);
    return c(s, E.key, E.iv);
  }
  function u(s, b, p) {
    if (s = s.toLowerCase(), r[s])
      return t.createCipheriv(s, b, p);
    if (i[s])
      return new e({ key: b, iv: p, mode: s });
    throw new TypeError("invalid suite type");
  }
  function c(s, b, p) {
    if (s = s.toLowerCase(), r[s])
      return t.createDecipheriv(s, b, p);
    if (i[s])
      return new e({ key: b, iv: p, mode: s, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function h() {
    return Object.keys(i).concat(t.getCiphers());
  }
  return Mr.createCipher = Mr.Cipher = n, Mr.createCipheriv = Mr.Cipheriv = u, Mr.createDecipher = Mr.Decipher = f, Mr.createDecipheriv = Mr.Decipheriv = c, Mr.listCiphers = Mr.getCiphers = h, Mr;
}
var qn = {}, Ka = { exports: {} }, np;
function c0() {
  if (np)
    return Ka.exports;
  np = 1;
  var e;
  Ka.exports = function(o) {
    return e || (e = new t(null)), e.generate(o);
  };
  function t(i) {
    this.rand = i;
  }
  if (Ka.exports.Rand = t, t.prototype.generate = function(o) {
    return this._rand(o);
  }, t.prototype._rand = function(o) {
    if (this.rand.getBytes)
      return this.rand.getBytes(o);
    for (var n = new Uint8Array(o), f = 0; f < n.length; f++)
      n[f] = this.rand.getByte();
    return n;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(o) {
      var n = new Uint8Array(o);
      return self.crypto.getRandomValues(n), n;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(o) {
      var n = new Uint8Array(o);
      return self.msCrypto.getRandomValues(n), n;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var r = Eg();
      if (typeof r.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(o) {
        return r.randomBytes(o);
      };
    } catch {
    }
  return Ka.exports;
}
var Ou, ip;
function og() {
  if (ip)
    return Ou;
  ip = 1;
  var e = tr, t = c0();
  function r(i) {
    this.rand = i || new t.Rand();
  }
  return Ou = r, r.create = function(o) {
    return new r(o);
  }, r.prototype._randbelow = function(o) {
    var n = o.bitLength(), f = Math.ceil(n / 8);
    do
      var u = new e(this.rand.generate(f));
    while (u.cmp(o) >= 0);
    return u;
  }, r.prototype._randrange = function(o, n) {
    var f = n.sub(o);
    return o.add(this._randbelow(f));
  }, r.prototype.test = function(o, n, f) {
    var u = o.bitLength(), c = e.mont(o), h = new e(1).toRed(c);
    n || (n = Math.max(1, u / 48 | 0));
    for (var s = o.subn(1), b = 0; !s.testn(b); b++)
      ;
    for (var p = o.shrn(b), m = s.toRed(c), E = !0; n > 0; n--) {
      var M = this._randrange(new e(2), s);
      f && f(M);
      var I = M.toRed(c).redPow(p);
      if (!(I.cmp(h) === 0 || I.cmp(m) === 0)) {
        for (var B = 1; B < b; B++) {
          if (I = I.redSqr(), I.cmp(h) === 0)
            return !1;
          if (I.cmp(m) === 0)
            break;
        }
        if (B === b)
          return !1;
      }
    }
    return E;
  }, r.prototype.getDivisor = function(o, n) {
    var f = o.bitLength(), u = e.mont(o), c = new e(1).toRed(u);
    n || (n = Math.max(1, f / 48 | 0));
    for (var h = o.subn(1), s = 0; !h.testn(s); s++)
      ;
    for (var b = o.shrn(s), p = h.toRed(u); n > 0; n--) {
      var m = this._randrange(new e(2), h), E = o.gcd(m);
      if (E.cmpn(1) !== 0)
        return E;
      var M = m.toRed(u).redPow(b);
      if (!(M.cmp(c) === 0 || M.cmp(p) === 0)) {
        for (var I = 1; I < s; I++) {
          if (M = M.redSqr(), M.cmp(c) === 0)
            return M.fromRed().subn(1).gcd(o);
          if (M.cmp(p) === 0)
            break;
        }
        if (I === s)
          return M = M.redSqr(), M.fromRed().subn(1).gcd(o);
      }
    }
    return !1;
  }, Ou;
}
var Pu, ap;
function fg() {
  if (ap)
    return Pu;
  ap = 1;
  var e = $i();
  Pu = I, I.simpleSieve = E, I.fermatTest = M;
  var t = tr, r = new t(24), i = og(), o = new i(), n = new t(1), f = new t(2), u = new t(5);
  new t(16), new t(8);
  var c = new t(10), h = new t(3);
  new t(7);
  var s = new t(11), b = new t(4);
  new t(12);
  var p = null;
  function m() {
    if (p !== null)
      return p;
    var B = 1048576, T = [];
    T[0] = 2;
    for (var j = 1, N = 3; N < B; N += 2) {
      for (var k = Math.ceil(Math.sqrt(N)), q = 0; q < j && T[q] <= k && N % T[q] !== 0; q++)
        ;
      j !== q && T[q] <= k || (T[j++] = N);
    }
    return p = T, T;
  }
  function E(B) {
    for (var T = m(), j = 0; j < T.length; j++)
      if (B.modn(T[j]) === 0)
        return B.cmpn(T[j]) === 0;
    return !0;
  }
  function M(B) {
    var T = t.mont(B);
    return f.toRed(T).redPow(B.subn(1)).fromRed().cmpn(1) === 0;
  }
  function I(B, T) {
    if (B < 16)
      return T === 2 || T === 5 ? new t([140, 123]) : new t([140, 39]);
    T = new t(T);
    for (var j, N; ; ) {
      for (j = new t(e(Math.ceil(B / 8))); j.bitLength() > B; )
        j.ishrn(1);
      if (j.isEven() && j.iadd(n), j.testn(1) || j.iadd(f), T.cmp(f)) {
        if (!T.cmp(u))
          for (; j.mod(c).cmp(h); )
            j.iadd(b);
      } else
        for (; j.mod(r).cmp(s); )
          j.iadd(b);
      if (N = j.shrn(1), E(N) && E(j) && M(N) && M(j) && o.test(N) && o.test(j))
        return j;
    }
  }
  return Pu;
}
const $E = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, UE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, FE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, zE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, HE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, VE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, WE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, KE = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, ZE = {
  modp1: $E,
  modp2: UE,
  modp5: FE,
  modp14: zE,
  modp15: HE,
  modp16: VE,
  modp17: WE,
  modp18: KE
};
var Cu, op;
function GE() {
  if (op)
    return Cu;
  op = 1;
  var e = tr, t = og(), r = new t(), i = new e(24), o = new e(11), n = new e(10), f = new e(3), u = new e(7), c = fg(), h = $i();
  Cu = E;
  function s(I, B) {
    return B = B || "utf8", Le.Buffer.isBuffer(I) || (I = new Le.Buffer(I, B)), this._pub = new e(I), this;
  }
  function b(I, B) {
    return B = B || "utf8", Le.Buffer.isBuffer(I) || (I = new Le.Buffer(I, B)), this._priv = new e(I), this;
  }
  var p = {};
  function m(I, B) {
    var T = B.toString("hex"), j = [T, I.toString(16)].join("_");
    if (j in p)
      return p[j];
    var N = 0;
    if (I.isEven() || !c.simpleSieve || !c.fermatTest(I) || !r.test(I))
      return N += 1, T === "02" || T === "05" ? N += 8 : N += 4, p[j] = N, N;
    r.test(I.shrn(1)) || (N += 2);
    var k;
    switch (T) {
      case "02":
        I.mod(i).cmp(o) && (N += 8);
        break;
      case "05":
        k = I.mod(n), k.cmp(f) && k.cmp(u) && (N += 8);
        break;
      default:
        N += 4;
    }
    return p[j] = N, N;
  }
  function E(I, B, T) {
    this.setGenerator(B), this.__prime = new e(I), this._prime = e.mont(this.__prime), this._primeLen = I.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, T ? (this.setPublicKey = s, this.setPrivateKey = b) : this._primeCode = 8;
  }
  Object.defineProperty(E.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = m(this.__prime, this.__gen)), this._primeCode;
    }
  }), E.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(h(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, E.prototype.computeSecret = function(I) {
    I = new e(I), I = I.toRed(this._prime);
    var B = I.redPow(this._priv).fromRed(), T = new Le.Buffer(B.toArray()), j = this.getPrime();
    if (T.length < j.length) {
      var N = new Le.Buffer(j.length - T.length);
      N.fill(0), T = Le.Buffer.concat([N, T]);
    }
    return T;
  }, E.prototype.getPublicKey = function(B) {
    return M(this._pub, B);
  }, E.prototype.getPrivateKey = function(B) {
    return M(this._priv, B);
  }, E.prototype.getPrime = function(I) {
    return M(this.__prime, I);
  }, E.prototype.getGenerator = function(I) {
    return M(this._gen, I);
  }, E.prototype.setGenerator = function(I, B) {
    return B = B || "utf8", Le.Buffer.isBuffer(I) || (I = new Le.Buffer(I, B)), this.__gen = I, this._gen = new e(I), this;
  };
  function M(I, B) {
    var T = new Le.Buffer(I.toArray());
    return B ? T.toString(B) : T;
  }
  return Cu;
}
var fp;
function JE() {
  if (fp)
    return qn;
  fp = 1;
  var e = fg(), t = ZE, r = GE();
  function i(f) {
    var u = new Le.Buffer(t[f].prime, "hex"), c = new Le.Buffer(t[f].gen, "hex");
    return new r(u, c);
  }
  var o = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function n(f, u, c, h) {
    return Le.Buffer.isBuffer(u) || o[u] === void 0 ? n(f, "binary", u, c) : (u = u || "binary", h = h || "binary", c = c || new Le.Buffer([2]), Le.Buffer.isBuffer(c) || (c = new Le.Buffer(c, h)), typeof f == "number" ? new r(e(f, c), c, !0) : (Le.Buffer.isBuffer(f) || (f = new Le.Buffer(f, u)), new r(f, c, !0)));
  }
  return qn.DiffieHellmanGroup = qn.createDiffieHellmanGroup = qn.getDiffieHellman = i, qn.createDiffieHellman = qn.DiffieHellman = n, qn;
}
var Gi = { exports: {} }, Qa = { exports: {} };
Qa.exports;
var sp;
function XE() {
  return sp || (sp = 1, function(e) {
    (function(t, r) {
      function i(v, a) {
        if (!v)
          throw new Error(a || "Assertion failed");
      }
      function o(v, a) {
        v.super_ = a;
        var d = function() {
        };
        d.prototype = a.prototype, v.prototype = new d(), v.prototype.constructor = v;
      }
      function n(v, a, d) {
        if (n.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((a === "le" || a === "be") && (d = a, a = 10), this._init(v || 0, a || 10, d || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var f;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? f = window.Buffer : f = Le.Buffer;
      } catch {
      }
      n.isBN = function(a) {
        return a instanceof n ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words);
      }, n.max = function(a, d) {
        return a.cmp(d) > 0 ? a : d;
      }, n.min = function(a, d) {
        return a.cmp(d) < 0 ? a : d;
      }, n.prototype._init = function(a, d, w) {
        if (typeof a == "number")
          return this._initNumber(a, d, w);
        if (typeof a == "object")
          return this._initArray(a, d, w);
        d === "hex" && (d = 16), i(d === (d | 0) && d >= 2 && d <= 36), a = a.toString().replace(/\s+/g, "");
        var x = 0;
        a[0] === "-" && (x++, this.negative = 1), x < a.length && (d === 16 ? this._parseHex(a, x, w) : (this._parseBase(a, d, x), w === "le" && this._initArray(this.toArray(), d, w)));
      }, n.prototype._initNumber = function(a, d, w) {
        a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
          a & 67108863,
          a / 67108864 & 67108863
        ], this.length = 2) : (i(a < 9007199254740992), this.words = [
          a & 67108863,
          a / 67108864 & 67108863,
          1
        ], this.length = 3), w === "le" && this._initArray(this.toArray(), d, w);
      }, n.prototype._initArray = function(a, d, w) {
        if (i(typeof a.length == "number"), a.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A, S, g = 0;
        if (w === "be")
          for (x = a.length - 1, A = 0; x >= 0; x -= 3)
            S = a[x] | a[x - 1] << 8 | a[x - 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        else if (w === "le")
          for (x = 0, A = 0; x < a.length; x += 3)
            S = a[x] | a[x + 1] << 8 | a[x + 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        return this._strip();
      };
      function u(v, a) {
        var d = v.charCodeAt(a);
        if (d >= 48 && d <= 57)
          return d - 48;
        if (d >= 65 && d <= 70)
          return d - 55;
        if (d >= 97 && d <= 102)
          return d - 87;
        i(!1, "Invalid character in " + v);
      }
      function c(v, a, d) {
        var w = u(v, d);
        return d - 1 >= a && (w |= u(v, d - 1) << 4), w;
      }
      n.prototype._parseHex = function(a, d, w) {
        this.length = Math.ceil((a.length - d) / 6), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A = 0, S = 0, g;
        if (w === "be")
          for (x = a.length - 1; x >= d; x -= 2)
            g = c(a, d, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        else {
          var _ = a.length - d;
          for (x = _ % 2 === 0 ? d + 1 : d; x < a.length; x += 2)
            g = c(a, d, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        }
        this._strip();
      };
      function h(v, a, d, w) {
        for (var x = 0, A = 0, S = Math.min(v.length, d), g = a; g < S; g++) {
          var _ = v.charCodeAt(g) - 48;
          x *= w, _ >= 49 ? A = _ - 49 + 10 : _ >= 17 ? A = _ - 17 + 10 : A = _, i(_ >= 0 && A < w, "Invalid character"), x += A;
        }
        return x;
      }
      n.prototype._parseBase = function(a, d, w) {
        this.words = [0], this.length = 1;
        for (var x = 0, A = 1; A <= 67108863; A *= d)
          x++;
        x--, A = A / d | 0;
        for (var S = a.length - w, g = S % x, _ = Math.min(S, S - g) + w, l = 0, R = w; R < _; R += x)
          l = h(a, R, R + x, d), this.imuln(A), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        if (g !== 0) {
          var Y = 1;
          for (l = h(a, R, a.length, d), R = 0; R < g; R++)
            Y *= d;
          this.imuln(Y), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        }
        this._strip();
      }, n.prototype.copy = function(a) {
        a.words = new Array(this.length);
        for (var d = 0; d < this.length; d++)
          a.words[d] = this.words[d];
        a.length = this.length, a.negative = this.negative, a.red = this.red;
      };
      function s(v, a) {
        v.words = a.words, v.length = a.length, v.negative = a.negative, v.red = a.red;
      }
      if (n.prototype._move = function(a) {
        s(a, this);
      }, n.prototype.clone = function() {
        var a = new n(null);
        return this.copy(a), a;
      }, n.prototype._expand = function(a) {
        for (; this.length < a; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = b;
        } catch {
          n.prototype.inspect = b;
        }
      else
        n.prototype.inspect = b;
      function b() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var p = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], E = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(a, d) {
        a = a || 10, d = d | 0 || 1;
        var w;
        if (a === 16 || a === "hex") {
          w = "";
          for (var x = 0, A = 0, S = 0; S < this.length; S++) {
            var g = this.words[S], _ = ((g << x | A) & 16777215).toString(16);
            A = g >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), A !== 0 || S !== this.length - 1 ? w = p[6 - _.length] + _ + w : w = _ + w;
          }
          for (A !== 0 && (w = A.toString(16) + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        if (a === (a | 0) && a >= 2 && a <= 36) {
          var l = m[a], R = E[a];
          w = "";
          var Y = this.clone();
          for (Y.negative = 0; !Y.isZero(); ) {
            var oe = Y.modrn(R).toString(a);
            Y = Y.idivn(R), Y.isZero() ? w = oe + w : w = p[l - oe.length] + oe + w;
          }
          for (this.isZero() && (w = "0" + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        i(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var a = this.words[0];
        return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, f && (n.prototype.toBuffer = function(a, d) {
        return this.toArrayLike(f, a, d);
      }), n.prototype.toArray = function(a, d) {
        return this.toArrayLike(Array, a, d);
      };
      var M = function(a, d) {
        return a.allocUnsafe ? a.allocUnsafe(d) : new a(d);
      };
      n.prototype.toArrayLike = function(a, d, w) {
        this._strip();
        var x = this.byteLength(), A = w || Math.max(1, x);
        i(x <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var S = M(a, A), g = d === "le" ? "LE" : "BE";
        return this["_toArrayLike" + g](S, x), S;
      }, n.prototype._toArrayLikeLE = function(a, d) {
        for (var w = 0, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[w++] = g & 255, w < a.length && (a[w++] = g >> 8 & 255), w < a.length && (a[w++] = g >> 16 & 255), S === 6 ? (w < a.length && (a[w++] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (w < a.length)
          for (a[w++] = x; w < a.length; )
            a[w++] = 0;
      }, n.prototype._toArrayLikeBE = function(a, d) {
        for (var w = a.length - 1, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[w--] = g & 255, w >= 0 && (a[w--] = g >> 8 & 255), w >= 0 && (a[w--] = g >> 16 & 255), S === 6 ? (w >= 0 && (a[w--] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (w >= 0)
          for (a[w--] = x; w >= 0; )
            a[w--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(a) {
        return 32 - Math.clz32(a);
      } : n.prototype._countBits = function(a) {
        var d = a, w = 0;
        return d >= 4096 && (w += 13, d >>>= 13), d >= 64 && (w += 7, d >>>= 7), d >= 8 && (w += 4, d >>>= 4), d >= 2 && (w += 2, d >>>= 2), w + d;
      }, n.prototype._zeroBits = function(a) {
        if (a === 0)
          return 26;
        var d = a, w = 0;
        return d & 8191 || (w += 13, d >>>= 13), d & 127 || (w += 7, d >>>= 7), d & 15 || (w += 4, d >>>= 4), d & 3 || (w += 2, d >>>= 2), d & 1 || w++, w;
      }, n.prototype.bitLength = function() {
        var a = this.words[this.length - 1], d = this._countBits(a);
        return (this.length - 1) * 26 + d;
      };
      function I(v) {
        for (var a = new Array(v.bitLength()), d = 0; d < a.length; d++) {
          var w = d / 26 | 0, x = d % 26;
          a[d] = v.words[w] >>> x & 1;
        }
        return a;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var a = 0, d = 0; d < this.length; d++) {
          var w = this._zeroBits(this.words[d]);
          if (a += w, w !== 26)
            break;
        }
        return a;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(a) {
        return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(a) {
        return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(a) {
        for (; this.length < a.length; )
          this.words[this.length++] = 0;
        for (var d = 0; d < a.length; d++)
          this.words[d] = this.words[d] | a.words[d];
        return this._strip();
      }, n.prototype.ior = function(a) {
        return i((this.negative | a.negative) === 0), this.iuor(a);
      }, n.prototype.or = function(a) {
        return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
      }, n.prototype.uor = function(a) {
        return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
      }, n.prototype.iuand = function(a) {
        var d;
        this.length > a.length ? d = a : d = this;
        for (var w = 0; w < d.length; w++)
          this.words[w] = this.words[w] & a.words[w];
        return this.length = d.length, this._strip();
      }, n.prototype.iand = function(a) {
        return i((this.negative | a.negative) === 0), this.iuand(a);
      }, n.prototype.and = function(a) {
        return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
      }, n.prototype.uand = function(a) {
        return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
      }, n.prototype.iuxor = function(a) {
        var d, w;
        this.length > a.length ? (d = this, w = a) : (d = a, w = this);
        for (var x = 0; x < w.length; x++)
          this.words[x] = d.words[x] ^ w.words[x];
        if (this !== d)
          for (; x < d.length; x++)
            this.words[x] = d.words[x];
        return this.length = d.length, this._strip();
      }, n.prototype.ixor = function(a) {
        return i((this.negative | a.negative) === 0), this.iuxor(a);
      }, n.prototype.xor = function(a) {
        return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
      }, n.prototype.uxor = function(a) {
        return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
      }, n.prototype.inotn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = Math.ceil(a / 26) | 0, w = a % 26;
        this._expand(d), w > 0 && d--;
        for (var x = 0; x < d; x++)
          this.words[x] = ~this.words[x] & 67108863;
        return w > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - w), this._strip();
      }, n.prototype.notn = function(a) {
        return this.clone().inotn(a);
      }, n.prototype.setn = function(a, d) {
        i(typeof a == "number" && a >= 0);
        var w = a / 26 | 0, x = a % 26;
        return this._expand(w + 1), d ? this.words[w] = this.words[w] | 1 << x : this.words[w] = this.words[w] & ~(1 << x), this._strip();
      }, n.prototype.iadd = function(a) {
        var d;
        if (this.negative !== 0 && a.negative === 0)
          return this.negative = 0, d = this.isub(a), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && a.negative !== 0)
          return a.negative = 0, d = this.isub(a), a.negative = 1, d._normSign();
        var w, x;
        this.length > a.length ? (w = this, x = a) : (w = a, x = this);
        for (var A = 0, S = 0; S < x.length; S++)
          d = (w.words[S] | 0) + (x.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        for (; A !== 0 && S < w.length; S++)
          d = (w.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        if (this.length = w.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (w !== this)
          for (; S < w.length; S++)
            this.words[S] = w.words[S];
        return this;
      }, n.prototype.add = function(a) {
        var d;
        return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, d = this.sub(a), a.negative ^= 1, d) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, d = a.sub(this), this.negative = 1, d) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
      }, n.prototype.isub = function(a) {
        if (a.negative !== 0) {
          a.negative = 0;
          var d = this.iadd(a);
          return a.negative = 1, d._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
        var w = this.cmp(a);
        if (w === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var x, A;
        w > 0 ? (x = this, A = a) : (x = a, A = this);
        for (var S = 0, g = 0; g < A.length; g++)
          d = (x.words[g] | 0) - (A.words[g] | 0) + S, S = d >> 26, this.words[g] = d & 67108863;
        for (; S !== 0 && g < x.length; g++)
          d = (x.words[g] | 0) + S, S = d >> 26, this.words[g] = d & 67108863;
        if (S === 0 && g < x.length && x !== this)
          for (; g < x.length; g++)
            this.words[g] = x.words[g];
        return this.length = Math.max(this.length, g), x !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(a) {
        return this.clone().isub(a);
      };
      function B(v, a, d) {
        d.negative = a.negative ^ v.negative;
        var w = v.length + a.length | 0;
        d.length = w, w = w - 1 | 0;
        var x = v.words[0] | 0, A = a.words[0] | 0, S = x * A, g = S & 67108863, _ = S / 67108864 | 0;
        d.words[0] = g;
        for (var l = 1; l < w; l++) {
          for (var R = _ >>> 26, Y = _ & 67108863, oe = Math.min(l, a.length - 1), H = Math.max(0, l - v.length + 1); H <= oe; H++) {
            var V = l - H | 0;
            x = v.words[V] | 0, A = a.words[H] | 0, S = x * A + Y, R += S / 67108864 | 0, Y = S & 67108863;
          }
          d.words[l] = Y | 0, _ = R | 0;
        }
        return _ !== 0 ? d.words[l] = _ | 0 : d.length--, d._strip();
      }
      var T = function(a, d, w) {
        var x = a.words, A = d.words, S = w.words, g = 0, _, l, R, Y = x[0] | 0, oe = Y & 8191, H = Y >>> 13, V = x[1] | 0, F = V & 8191, te = V >>> 13, he = x[2] | 0, K = he & 8191, W = he >>> 13, ce = x[3] | 0, ve = ce & 8191, Be = ce >>> 13, ee = x[4] | 0, C = ee & 8191, L = ee >>> 13, Z = x[5] | 0, de = Z & 8191, me = Z >>> 13, Te = x[6] | 0, ze = Te & 8191, z = Te >>> 13, ue = x[7] | 0, se = ue & 8191, _e = ue >>> 13, Ce = x[8] | 0, Ve = Ce & 8191, ke = Ce >>> 13, X = x[9] | 0, Se = X & 8191, Ae = X >>> 13, qe = A[0] | 0, pe = qe & 8191, Ee = qe >>> 13, G = A[1] | 0, Ie = G & 8191, je = G >>> 13, P = A[2] | 0, Me = P & 8191, be = P >>> 13, ie = A[3] | 0, le = ie & 8191, ge = ie >>> 13, Ge = A[4] | 0, $e = Ge & 8191, Ne = Ge >>> 13, nt = A[5] | 0, st = nt & 8191, Je = nt >>> 13, ft = A[6] | 0, D = ft & 8191, J = ft >>> 13, ne = A[7] | 0, O = ne & 8191, ae = ne >>> 13, we = A[8] | 0, xe = we & 8191, Re = we >>> 13, De = A[9] | 0, He = De & 8191, Ue = De >>> 13;
        w.negative = a.negative ^ d.negative, w.length = 19, _ = Math.imul(oe, pe), l = Math.imul(oe, Ee), l = l + Math.imul(H, pe) | 0, R = Math.imul(H, Ee);
        var yt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, _ = Math.imul(F, pe), l = Math.imul(F, Ee), l = l + Math.imul(te, pe) | 0, R = Math.imul(te, Ee), _ = _ + Math.imul(oe, Ie) | 0, l = l + Math.imul(oe, je) | 0, l = l + Math.imul(H, Ie) | 0, R = R + Math.imul(H, je) | 0;
        var et = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _ = Math.imul(K, pe), l = Math.imul(K, Ee), l = l + Math.imul(W, pe) | 0, R = Math.imul(W, Ee), _ = _ + Math.imul(F, Ie) | 0, l = l + Math.imul(F, je) | 0, l = l + Math.imul(te, Ie) | 0, R = R + Math.imul(te, je) | 0, _ = _ + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, be) | 0, l = l + Math.imul(H, Me) | 0, R = R + Math.imul(H, be) | 0;
        var ut = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, _ = Math.imul(ve, pe), l = Math.imul(ve, Ee), l = l + Math.imul(Be, pe) | 0, R = Math.imul(Be, Ee), _ = _ + Math.imul(K, Ie) | 0, l = l + Math.imul(K, je) | 0, l = l + Math.imul(W, Ie) | 0, R = R + Math.imul(W, je) | 0, _ = _ + Math.imul(F, Me) | 0, l = l + Math.imul(F, be) | 0, l = l + Math.imul(te, Me) | 0, R = R + Math.imul(te, be) | 0, _ = _ + Math.imul(oe, le) | 0, l = l + Math.imul(oe, ge) | 0, l = l + Math.imul(H, le) | 0, R = R + Math.imul(H, ge) | 0;
        var ct = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, _ = Math.imul(C, pe), l = Math.imul(C, Ee), l = l + Math.imul(L, pe) | 0, R = Math.imul(L, Ee), _ = _ + Math.imul(ve, Ie) | 0, l = l + Math.imul(ve, je) | 0, l = l + Math.imul(Be, Ie) | 0, R = R + Math.imul(Be, je) | 0, _ = _ + Math.imul(K, Me) | 0, l = l + Math.imul(K, be) | 0, l = l + Math.imul(W, Me) | 0, R = R + Math.imul(W, be) | 0, _ = _ + Math.imul(F, le) | 0, l = l + Math.imul(F, ge) | 0, l = l + Math.imul(te, le) | 0, R = R + Math.imul(te, ge) | 0, _ = _ + Math.imul(oe, $e) | 0, l = l + Math.imul(oe, Ne) | 0, l = l + Math.imul(H, $e) | 0, R = R + Math.imul(H, Ne) | 0;
        var vt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, _ = Math.imul(de, pe), l = Math.imul(de, Ee), l = l + Math.imul(me, pe) | 0, R = Math.imul(me, Ee), _ = _ + Math.imul(C, Ie) | 0, l = l + Math.imul(C, je) | 0, l = l + Math.imul(L, Ie) | 0, R = R + Math.imul(L, je) | 0, _ = _ + Math.imul(ve, Me) | 0, l = l + Math.imul(ve, be) | 0, l = l + Math.imul(Be, Me) | 0, R = R + Math.imul(Be, be) | 0, _ = _ + Math.imul(K, le) | 0, l = l + Math.imul(K, ge) | 0, l = l + Math.imul(W, le) | 0, R = R + Math.imul(W, ge) | 0, _ = _ + Math.imul(F, $e) | 0, l = l + Math.imul(F, Ne) | 0, l = l + Math.imul(te, $e) | 0, R = R + Math.imul(te, Ne) | 0, _ = _ + Math.imul(oe, st) | 0, l = l + Math.imul(oe, Je) | 0, l = l + Math.imul(H, st) | 0, R = R + Math.imul(H, Je) | 0;
        var pt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, _ = Math.imul(ze, pe), l = Math.imul(ze, Ee), l = l + Math.imul(z, pe) | 0, R = Math.imul(z, Ee), _ = _ + Math.imul(de, Ie) | 0, l = l + Math.imul(de, je) | 0, l = l + Math.imul(me, Ie) | 0, R = R + Math.imul(me, je) | 0, _ = _ + Math.imul(C, Me) | 0, l = l + Math.imul(C, be) | 0, l = l + Math.imul(L, Me) | 0, R = R + Math.imul(L, be) | 0, _ = _ + Math.imul(ve, le) | 0, l = l + Math.imul(ve, ge) | 0, l = l + Math.imul(Be, le) | 0, R = R + Math.imul(Be, ge) | 0, _ = _ + Math.imul(K, $e) | 0, l = l + Math.imul(K, Ne) | 0, l = l + Math.imul(W, $e) | 0, R = R + Math.imul(W, Ne) | 0, _ = _ + Math.imul(F, st) | 0, l = l + Math.imul(F, Je) | 0, l = l + Math.imul(te, st) | 0, R = R + Math.imul(te, Je) | 0, _ = _ + Math.imul(oe, D) | 0, l = l + Math.imul(oe, J) | 0, l = l + Math.imul(H, D) | 0, R = R + Math.imul(H, J) | 0;
        var ht = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, _ = Math.imul(se, pe), l = Math.imul(se, Ee), l = l + Math.imul(_e, pe) | 0, R = Math.imul(_e, Ee), _ = _ + Math.imul(ze, Ie) | 0, l = l + Math.imul(ze, je) | 0, l = l + Math.imul(z, Ie) | 0, R = R + Math.imul(z, je) | 0, _ = _ + Math.imul(de, Me) | 0, l = l + Math.imul(de, be) | 0, l = l + Math.imul(me, Me) | 0, R = R + Math.imul(me, be) | 0, _ = _ + Math.imul(C, le) | 0, l = l + Math.imul(C, ge) | 0, l = l + Math.imul(L, le) | 0, R = R + Math.imul(L, ge) | 0, _ = _ + Math.imul(ve, $e) | 0, l = l + Math.imul(ve, Ne) | 0, l = l + Math.imul(Be, $e) | 0, R = R + Math.imul(Be, Ne) | 0, _ = _ + Math.imul(K, st) | 0, l = l + Math.imul(K, Je) | 0, l = l + Math.imul(W, st) | 0, R = R + Math.imul(W, Je) | 0, _ = _ + Math.imul(F, D) | 0, l = l + Math.imul(F, J) | 0, l = l + Math.imul(te, D) | 0, R = R + Math.imul(te, J) | 0, _ = _ + Math.imul(oe, O) | 0, l = l + Math.imul(oe, ae) | 0, l = l + Math.imul(H, O) | 0, R = R + Math.imul(H, ae) | 0;
        var dt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, _ = Math.imul(Ve, pe), l = Math.imul(Ve, Ee), l = l + Math.imul(ke, pe) | 0, R = Math.imul(ke, Ee), _ = _ + Math.imul(se, Ie) | 0, l = l + Math.imul(se, je) | 0, l = l + Math.imul(_e, Ie) | 0, R = R + Math.imul(_e, je) | 0, _ = _ + Math.imul(ze, Me) | 0, l = l + Math.imul(ze, be) | 0, l = l + Math.imul(z, Me) | 0, R = R + Math.imul(z, be) | 0, _ = _ + Math.imul(de, le) | 0, l = l + Math.imul(de, ge) | 0, l = l + Math.imul(me, le) | 0, R = R + Math.imul(me, ge) | 0, _ = _ + Math.imul(C, $e) | 0, l = l + Math.imul(C, Ne) | 0, l = l + Math.imul(L, $e) | 0, R = R + Math.imul(L, Ne) | 0, _ = _ + Math.imul(ve, st) | 0, l = l + Math.imul(ve, Je) | 0, l = l + Math.imul(Be, st) | 0, R = R + Math.imul(Be, Je) | 0, _ = _ + Math.imul(K, D) | 0, l = l + Math.imul(K, J) | 0, l = l + Math.imul(W, D) | 0, R = R + Math.imul(W, J) | 0, _ = _ + Math.imul(F, O) | 0, l = l + Math.imul(F, ae) | 0, l = l + Math.imul(te, O) | 0, R = R + Math.imul(te, ae) | 0, _ = _ + Math.imul(oe, xe) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(H, xe) | 0, R = R + Math.imul(H, Re) | 0;
        var lt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, _ = Math.imul(Se, pe), l = Math.imul(Se, Ee), l = l + Math.imul(Ae, pe) | 0, R = Math.imul(Ae, Ee), _ = _ + Math.imul(Ve, Ie) | 0, l = l + Math.imul(Ve, je) | 0, l = l + Math.imul(ke, Ie) | 0, R = R + Math.imul(ke, je) | 0, _ = _ + Math.imul(se, Me) | 0, l = l + Math.imul(se, be) | 0, l = l + Math.imul(_e, Me) | 0, R = R + Math.imul(_e, be) | 0, _ = _ + Math.imul(ze, le) | 0, l = l + Math.imul(ze, ge) | 0, l = l + Math.imul(z, le) | 0, R = R + Math.imul(z, ge) | 0, _ = _ + Math.imul(de, $e) | 0, l = l + Math.imul(de, Ne) | 0, l = l + Math.imul(me, $e) | 0, R = R + Math.imul(me, Ne) | 0, _ = _ + Math.imul(C, st) | 0, l = l + Math.imul(C, Je) | 0, l = l + Math.imul(L, st) | 0, R = R + Math.imul(L, Je) | 0, _ = _ + Math.imul(ve, D) | 0, l = l + Math.imul(ve, J) | 0, l = l + Math.imul(Be, D) | 0, R = R + Math.imul(Be, J) | 0, _ = _ + Math.imul(K, O) | 0, l = l + Math.imul(K, ae) | 0, l = l + Math.imul(W, O) | 0, R = R + Math.imul(W, ae) | 0, _ = _ + Math.imul(F, xe) | 0, l = l + Math.imul(F, Re) | 0, l = l + Math.imul(te, xe) | 0, R = R + Math.imul(te, Re) | 0, _ = _ + Math.imul(oe, He) | 0, l = l + Math.imul(oe, Ue) | 0, l = l + Math.imul(H, He) | 0, R = R + Math.imul(H, Ue) | 0;
        var tt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, _ = Math.imul(Se, Ie), l = Math.imul(Se, je), l = l + Math.imul(Ae, Ie) | 0, R = Math.imul(Ae, je), _ = _ + Math.imul(Ve, Me) | 0, l = l + Math.imul(Ve, be) | 0, l = l + Math.imul(ke, Me) | 0, R = R + Math.imul(ke, be) | 0, _ = _ + Math.imul(se, le) | 0, l = l + Math.imul(se, ge) | 0, l = l + Math.imul(_e, le) | 0, R = R + Math.imul(_e, ge) | 0, _ = _ + Math.imul(ze, $e) | 0, l = l + Math.imul(ze, Ne) | 0, l = l + Math.imul(z, $e) | 0, R = R + Math.imul(z, Ne) | 0, _ = _ + Math.imul(de, st) | 0, l = l + Math.imul(de, Je) | 0, l = l + Math.imul(me, st) | 0, R = R + Math.imul(me, Je) | 0, _ = _ + Math.imul(C, D) | 0, l = l + Math.imul(C, J) | 0, l = l + Math.imul(L, D) | 0, R = R + Math.imul(L, J) | 0, _ = _ + Math.imul(ve, O) | 0, l = l + Math.imul(ve, ae) | 0, l = l + Math.imul(Be, O) | 0, R = R + Math.imul(Be, ae) | 0, _ = _ + Math.imul(K, xe) | 0, l = l + Math.imul(K, Re) | 0, l = l + Math.imul(W, xe) | 0, R = R + Math.imul(W, Re) | 0, _ = _ + Math.imul(F, He) | 0, l = l + Math.imul(F, Ue) | 0, l = l + Math.imul(te, He) | 0, R = R + Math.imul(te, Ue) | 0;
        var ot = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, _ = Math.imul(Se, Me), l = Math.imul(Se, be), l = l + Math.imul(Ae, Me) | 0, R = Math.imul(Ae, be), _ = _ + Math.imul(Ve, le) | 0, l = l + Math.imul(Ve, ge) | 0, l = l + Math.imul(ke, le) | 0, R = R + Math.imul(ke, ge) | 0, _ = _ + Math.imul(se, $e) | 0, l = l + Math.imul(se, Ne) | 0, l = l + Math.imul(_e, $e) | 0, R = R + Math.imul(_e, Ne) | 0, _ = _ + Math.imul(ze, st) | 0, l = l + Math.imul(ze, Je) | 0, l = l + Math.imul(z, st) | 0, R = R + Math.imul(z, Je) | 0, _ = _ + Math.imul(de, D) | 0, l = l + Math.imul(de, J) | 0, l = l + Math.imul(me, D) | 0, R = R + Math.imul(me, J) | 0, _ = _ + Math.imul(C, O) | 0, l = l + Math.imul(C, ae) | 0, l = l + Math.imul(L, O) | 0, R = R + Math.imul(L, ae) | 0, _ = _ + Math.imul(ve, xe) | 0, l = l + Math.imul(ve, Re) | 0, l = l + Math.imul(Be, xe) | 0, R = R + Math.imul(Be, Re) | 0, _ = _ + Math.imul(K, He) | 0, l = l + Math.imul(K, Ue) | 0, l = l + Math.imul(W, He) | 0, R = R + Math.imul(W, Ue) | 0;
        var Qe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, _ = Math.imul(Se, le), l = Math.imul(Se, ge), l = l + Math.imul(Ae, le) | 0, R = Math.imul(Ae, ge), _ = _ + Math.imul(Ve, $e) | 0, l = l + Math.imul(Ve, Ne) | 0, l = l + Math.imul(ke, $e) | 0, R = R + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(se, st) | 0, l = l + Math.imul(se, Je) | 0, l = l + Math.imul(_e, st) | 0, R = R + Math.imul(_e, Je) | 0, _ = _ + Math.imul(ze, D) | 0, l = l + Math.imul(ze, J) | 0, l = l + Math.imul(z, D) | 0, R = R + Math.imul(z, J) | 0, _ = _ + Math.imul(de, O) | 0, l = l + Math.imul(de, ae) | 0, l = l + Math.imul(me, O) | 0, R = R + Math.imul(me, ae) | 0, _ = _ + Math.imul(C, xe) | 0, l = l + Math.imul(C, Re) | 0, l = l + Math.imul(L, xe) | 0, R = R + Math.imul(L, Re) | 0, _ = _ + Math.imul(ve, He) | 0, l = l + Math.imul(ve, Ue) | 0, l = l + Math.imul(Be, He) | 0, R = R + Math.imul(Be, Ue) | 0;
        var rt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, _ = Math.imul(Se, $e), l = Math.imul(Se, Ne), l = l + Math.imul(Ae, $e) | 0, R = Math.imul(Ae, Ne), _ = _ + Math.imul(Ve, st) | 0, l = l + Math.imul(Ve, Je) | 0, l = l + Math.imul(ke, st) | 0, R = R + Math.imul(ke, Je) | 0, _ = _ + Math.imul(se, D) | 0, l = l + Math.imul(se, J) | 0, l = l + Math.imul(_e, D) | 0, R = R + Math.imul(_e, J) | 0, _ = _ + Math.imul(ze, O) | 0, l = l + Math.imul(ze, ae) | 0, l = l + Math.imul(z, O) | 0, R = R + Math.imul(z, ae) | 0, _ = _ + Math.imul(de, xe) | 0, l = l + Math.imul(de, Re) | 0, l = l + Math.imul(me, xe) | 0, R = R + Math.imul(me, Re) | 0, _ = _ + Math.imul(C, He) | 0, l = l + Math.imul(C, Ue) | 0, l = l + Math.imul(L, He) | 0, R = R + Math.imul(L, Ue) | 0;
        var it = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, _ = Math.imul(Se, st), l = Math.imul(Se, Je), l = l + Math.imul(Ae, st) | 0, R = Math.imul(Ae, Je), _ = _ + Math.imul(Ve, D) | 0, l = l + Math.imul(Ve, J) | 0, l = l + Math.imul(ke, D) | 0, R = R + Math.imul(ke, J) | 0, _ = _ + Math.imul(se, O) | 0, l = l + Math.imul(se, ae) | 0, l = l + Math.imul(_e, O) | 0, R = R + Math.imul(_e, ae) | 0, _ = _ + Math.imul(ze, xe) | 0, l = l + Math.imul(ze, Re) | 0, l = l + Math.imul(z, xe) | 0, R = R + Math.imul(z, Re) | 0, _ = _ + Math.imul(de, He) | 0, l = l + Math.imul(de, Ue) | 0, l = l + Math.imul(me, He) | 0, R = R + Math.imul(me, Ue) | 0;
        var Ye = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, _ = Math.imul(Se, D), l = Math.imul(Se, J), l = l + Math.imul(Ae, D) | 0, R = Math.imul(Ae, J), _ = _ + Math.imul(Ve, O) | 0, l = l + Math.imul(Ve, ae) | 0, l = l + Math.imul(ke, O) | 0, R = R + Math.imul(ke, ae) | 0, _ = _ + Math.imul(se, xe) | 0, l = l + Math.imul(se, Re) | 0, l = l + Math.imul(_e, xe) | 0, R = R + Math.imul(_e, Re) | 0, _ = _ + Math.imul(ze, He) | 0, l = l + Math.imul(ze, Ue) | 0, l = l + Math.imul(z, He) | 0, R = R + Math.imul(z, Ue) | 0;
        var Oe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, _ = Math.imul(Se, O), l = Math.imul(Se, ae), l = l + Math.imul(Ae, O) | 0, R = Math.imul(Ae, ae), _ = _ + Math.imul(Ve, xe) | 0, l = l + Math.imul(Ve, Re) | 0, l = l + Math.imul(ke, xe) | 0, R = R + Math.imul(ke, Re) | 0, _ = _ + Math.imul(se, He) | 0, l = l + Math.imul(se, Ue) | 0, l = l + Math.imul(_e, He) | 0, R = R + Math.imul(_e, Ue) | 0;
        var Pe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, _ = Math.imul(Se, xe), l = Math.imul(Se, Re), l = l + Math.imul(Ae, xe) | 0, R = Math.imul(Ae, Re), _ = _ + Math.imul(Ve, He) | 0, l = l + Math.imul(Ve, Ue) | 0, l = l + Math.imul(ke, He) | 0, R = R + Math.imul(ke, Ue) | 0;
        var Ke = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, _ = Math.imul(Se, He), l = Math.imul(Se, Ue), l = l + Math.imul(Ae, He) | 0, R = Math.imul(Ae, Ue);
        var Fe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        return g = (R + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, S[0] = yt, S[1] = et, S[2] = ut, S[3] = ct, S[4] = vt, S[5] = pt, S[6] = ht, S[7] = dt, S[8] = lt, S[9] = tt, S[10] = ot, S[11] = Qe, S[12] = rt, S[13] = it, S[14] = Ye, S[15] = Oe, S[16] = Pe, S[17] = Ke, S[18] = Fe, g !== 0 && (S[19] = g, w.length++), w;
      };
      Math.imul || (T = B);
      function j(v, a, d) {
        d.negative = a.negative ^ v.negative, d.length = v.length + a.length;
        for (var w = 0, x = 0, A = 0; A < d.length - 1; A++) {
          var S = x;
          x = 0;
          for (var g = w & 67108863, _ = Math.min(A, a.length - 1), l = Math.max(0, A - v.length + 1); l <= _; l++) {
            var R = A - l, Y = v.words[R] | 0, oe = a.words[l] | 0, H = Y * oe, V = H & 67108863;
            S = S + (H / 67108864 | 0) | 0, V = V + g | 0, g = V & 67108863, S = S + (V >>> 26) | 0, x += S >>> 26, S &= 67108863;
          }
          d.words[A] = g, w = S, S = x;
        }
        return w !== 0 ? d.words[A] = w : d.length--, d._strip();
      }
      function N(v, a, d) {
        return j(v, a, d);
      }
      n.prototype.mulTo = function(a, d) {
        var w, x = this.length + a.length;
        return this.length === 10 && a.length === 10 ? w = T(this, a, d) : x < 63 ? w = B(this, a, d) : x < 1024 ? w = j(this, a, d) : w = N(this, a, d), w;
      }, n.prototype.mul = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), this.mulTo(a, d);
      }, n.prototype.mulf = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), N(this, a, d);
      }, n.prototype.imul = function(a) {
        return this.clone().mulTo(a, this);
      }, n.prototype.imuln = function(a) {
        var d = a < 0;
        d && (a = -a), i(typeof a == "number"), i(a < 67108864);
        for (var w = 0, x = 0; x < this.length; x++) {
          var A = (this.words[x] | 0) * a, S = (A & 67108863) + (w & 67108863);
          w >>= 26, w += A / 67108864 | 0, w += S >>> 26, this.words[x] = S & 67108863;
        }
        return w !== 0 && (this.words[x] = w, this.length++), d ? this.ineg() : this;
      }, n.prototype.muln = function(a) {
        return this.clone().imuln(a);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(a) {
        var d = I(a);
        if (d.length === 0)
          return new n(1);
        for (var w = this, x = 0; x < d.length && d[x] === 0; x++, w = w.sqr())
          ;
        if (++x < d.length)
          for (var A = w.sqr(); x < d.length; x++, A = A.sqr())
            d[x] !== 0 && (w = w.mul(A));
        return w;
      }, n.prototype.iushln = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 67108863 >>> 26 - d << 26 - d, A;
        if (d !== 0) {
          var S = 0;
          for (A = 0; A < this.length; A++) {
            var g = this.words[A] & x, _ = (this.words[A] | 0) - g << d;
            this.words[A] = _ | S, S = g >>> 26 - d;
          }
          S && (this.words[A] = S, this.length++);
        }
        if (w !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + w] = this.words[A];
          for (A = 0; A < w; A++)
            this.words[A] = 0;
          this.length += w;
        }
        return this._strip();
      }, n.prototype.ishln = function(a) {
        return i(this.negative === 0), this.iushln(a);
      }, n.prototype.iushrn = function(a, d, w) {
        i(typeof a == "number" && a >= 0);
        var x;
        d ? x = (d - d % 26) / 26 : x = 0;
        var A = a % 26, S = Math.min((a - A) / 26, this.length), g = 67108863 ^ 67108863 >>> A << A, _ = w;
        if (x -= S, x = Math.max(0, x), _) {
          for (var l = 0; l < S; l++)
            _.words[l] = this.words[l];
          _.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, l = 0; l < this.length; l++)
              this.words[l] = this.words[l + S];
          else
            this.words[0] = 0, this.length = 1;
        var R = 0;
        for (l = this.length - 1; l >= 0 && (R !== 0 || l >= x); l--) {
          var Y = this.words[l] | 0;
          this.words[l] = R << 26 - A | Y >>> A, R = Y & g;
        }
        return _ && R !== 0 && (_.words[_.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(a, d, w) {
        return i(this.negative === 0), this.iushrn(a, d, w);
      }, n.prototype.shln = function(a) {
        return this.clone().ishln(a);
      }, n.prototype.ushln = function(a) {
        return this.clone().iushln(a);
      }, n.prototype.shrn = function(a) {
        return this.clone().ishrn(a);
      }, n.prototype.ushrn = function(a) {
        return this.clone().iushrn(a);
      }, n.prototype.testn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return !1;
        var A = this.words[w];
        return !!(A & x);
      }, n.prototype.imaskn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w)
          return this;
        if (d !== 0 && w++, this.length = Math.min(w, this.length), d !== 0) {
          var x = 67108863 ^ 67108863 >>> d << d;
          this.words[this.length - 1] &= x;
        }
        return this._strip();
      }, n.prototype.maskn = function(a) {
        return this.clone().imaskn(a);
      }, n.prototype.iaddn = function(a) {
        return i(typeof a == "number"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
      }, n.prototype._iaddn = function(a) {
        this.words[0] += a;
        for (var d = 0; d < this.length && this.words[d] >= 67108864; d++)
          this.words[d] -= 67108864, d === this.length - 1 ? this.words[d + 1] = 1 : this.words[d + 1]++;
        return this.length = Math.max(this.length, d + 1), this;
      }, n.prototype.isubn = function(a) {
        if (i(typeof a == "number"), i(a < 67108864), a < 0)
          return this.iaddn(-a);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(a), this.negative = 1, this;
        if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var d = 0; d < this.length && this.words[d] < 0; d++)
            this.words[d] += 67108864, this.words[d + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(a) {
        return this.clone().iaddn(a);
      }, n.prototype.subn = function(a) {
        return this.clone().isubn(a);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(a, d, w) {
        var x = a.length + w, A;
        this._expand(x);
        var S, g = 0;
        for (A = 0; A < a.length; A++) {
          S = (this.words[A + w] | 0) + g;
          var _ = (a.words[A] | 0) * d;
          S -= _ & 67108863, g = (S >> 26) - (_ / 67108864 | 0), this.words[A + w] = S & 67108863;
        }
        for (; A < this.length - w; A++)
          S = (this.words[A + w] | 0) + g, g = S >> 26, this.words[A + w] = S & 67108863;
        if (g === 0)
          return this._strip();
        for (i(g === -1), g = 0, A = 0; A < this.length; A++)
          S = -(this.words[A] | 0) + g, g = S >> 26, this.words[A] = S & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(a, d) {
        var w = this.length - a.length, x = this.clone(), A = a, S = A.words[A.length - 1] | 0, g = this._countBits(S);
        w = 26 - g, w !== 0 && (A = A.ushln(w), x.iushln(w), S = A.words[A.length - 1] | 0);
        var _ = x.length - A.length, l;
        if (d !== "mod") {
          l = new n(null), l.length = _ + 1, l.words = new Array(l.length);
          for (var R = 0; R < l.length; R++)
            l.words[R] = 0;
        }
        var Y = x.clone()._ishlnsubmul(A, 1, _);
        Y.negative === 0 && (x = Y, l && (l.words[_] = 1));
        for (var oe = _ - 1; oe >= 0; oe--) {
          var H = (x.words[A.length + oe] | 0) * 67108864 + (x.words[A.length + oe - 1] | 0);
          for (H = Math.min(H / S | 0, 67108863), x._ishlnsubmul(A, H, oe); x.negative !== 0; )
            H--, x.negative = 0, x._ishlnsubmul(A, 1, oe), x.isZero() || (x.negative ^= 1);
          l && (l.words[oe] = H);
        }
        return l && l._strip(), x._strip(), d !== "div" && w !== 0 && x.iushrn(w), {
          div: l || null,
          mod: x
        };
      }, n.prototype.divmod = function(a, d, w) {
        if (i(!a.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var x, A, S;
        return this.negative !== 0 && a.negative === 0 ? (S = this.neg().divmod(a, d), d !== "mod" && (x = S.div.neg()), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.iadd(a)), {
          div: x,
          mod: A
        }) : this.negative === 0 && a.negative !== 0 ? (S = this.divmod(a.neg(), d), d !== "mod" && (x = S.div.neg()), {
          div: x,
          mod: S.mod
        }) : this.negative & a.negative ? (S = this.neg().divmod(a.neg(), d), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.isub(a)), {
          div: S.div,
          mod: A
        }) : a.length > this.length || this.cmp(a) < 0 ? {
          div: new n(0),
          mod: this
        } : a.length === 1 ? d === "div" ? {
          div: this.divn(a.words[0]),
          mod: null
        } : d === "mod" ? {
          div: null,
          mod: new n(this.modrn(a.words[0]))
        } : {
          div: this.divn(a.words[0]),
          mod: new n(this.modrn(a.words[0]))
        } : this._wordDiv(a, d);
      }, n.prototype.div = function(a) {
        return this.divmod(a, "div", !1).div;
      }, n.prototype.mod = function(a) {
        return this.divmod(a, "mod", !1).mod;
      }, n.prototype.umod = function(a) {
        return this.divmod(a, "mod", !0).mod;
      }, n.prototype.divRound = function(a) {
        var d = this.divmod(a);
        if (d.mod.isZero())
          return d.div;
        var w = d.div.negative !== 0 ? d.mod.isub(a) : d.mod, x = a.ushrn(1), A = a.andln(1), S = w.cmp(x);
        return S < 0 || A === 1 && S === 0 ? d.div : d.div.negative !== 0 ? d.div.isubn(1) : d.div.iaddn(1);
      }, n.prototype.modrn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = (1 << 26) % a, x = 0, A = this.length - 1; A >= 0; A--)
          x = (w * x + (this.words[A] | 0)) % a;
        return d ? -x : x;
      }, n.prototype.modn = function(a) {
        return this.modrn(a);
      }, n.prototype.idivn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = 0, x = this.length - 1; x >= 0; x--) {
          var A = (this.words[x] | 0) + w * 67108864;
          this.words[x] = A / a | 0, w = A % a;
        }
        return this._strip(), d ? this.ineg() : this;
      }, n.prototype.divn = function(a) {
        return this.clone().idivn(a);
      }, n.prototype.egcd = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = new n(0), g = new n(1), _ = 0; d.isEven() && w.isEven(); )
          d.iushrn(1), w.iushrn(1), ++_;
        for (var l = w.clone(), R = d.clone(); !d.isZero(); ) {
          for (var Y = 0, oe = 1; !(d.words[0] & oe) && Y < 26; ++Y, oe <<= 1)
            ;
          if (Y > 0)
            for (d.iushrn(Y); Y-- > 0; )
              (x.isOdd() || A.isOdd()) && (x.iadd(l), A.isub(R)), x.iushrn(1), A.iushrn(1);
          for (var H = 0, V = 1; !(w.words[0] & V) && H < 26; ++H, V <<= 1)
            ;
          if (H > 0)
            for (w.iushrn(H); H-- > 0; )
              (S.isOdd() || g.isOdd()) && (S.iadd(l), g.isub(R)), S.iushrn(1), g.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(S), A.isub(g)) : (w.isub(d), S.isub(x), g.isub(A));
        }
        return {
          a: S,
          b: g,
          gcd: w.iushln(_)
        };
      }, n.prototype._invmp = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = w.clone(); d.cmpn(1) > 0 && w.cmpn(1) > 0; ) {
          for (var g = 0, _ = 1; !(d.words[0] & _) && g < 26; ++g, _ <<= 1)
            ;
          if (g > 0)
            for (d.iushrn(g); g-- > 0; )
              x.isOdd() && x.iadd(S), x.iushrn(1);
          for (var l = 0, R = 1; !(w.words[0] & R) && l < 26; ++l, R <<= 1)
            ;
          if (l > 0)
            for (w.iushrn(l); l-- > 0; )
              A.isOdd() && A.iadd(S), A.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(A)) : (w.isub(d), A.isub(x));
        }
        var Y;
        return d.cmpn(1) === 0 ? Y = x : Y = A, Y.cmpn(0) < 0 && Y.iadd(a), Y;
      }, n.prototype.gcd = function(a) {
        if (this.isZero())
          return a.abs();
        if (a.isZero())
          return this.abs();
        var d = this.clone(), w = a.clone();
        d.negative = 0, w.negative = 0;
        for (var x = 0; d.isEven() && w.isEven(); x++)
          d.iushrn(1), w.iushrn(1);
        do {
          for (; d.isEven(); )
            d.iushrn(1);
          for (; w.isEven(); )
            w.iushrn(1);
          var A = d.cmp(w);
          if (A < 0) {
            var S = d;
            d = w, w = S;
          } else if (A === 0 || w.cmpn(1) === 0)
            break;
          d.isub(w);
        } while (!0);
        return w.iushln(x);
      }, n.prototype.invm = function(a) {
        return this.egcd(a).a.umod(a);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(a) {
        return this.words[0] & a;
      }, n.prototype.bincn = function(a) {
        i(typeof a == "number");
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return this._expand(w + 1), this.words[w] |= x, this;
        for (var A = x, S = w; A !== 0 && S < this.length; S++) {
          var g = this.words[S] | 0;
          g += A, A = g >>> 26, g &= 67108863, this.words[S] = g;
        }
        return A !== 0 && (this.words[S] = A, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(a) {
        var d = a < 0;
        if (this.negative !== 0 && !d)
          return -1;
        if (this.negative === 0 && d)
          return 1;
        this._strip();
        var w;
        if (this.length > 1)
          w = 1;
        else {
          d && (a = -a), i(a <= 67108863, "Number is too big");
          var x = this.words[0] | 0;
          w = x === a ? 0 : x < a ? -1 : 1;
        }
        return this.negative !== 0 ? -w | 0 : w;
      }, n.prototype.cmp = function(a) {
        if (this.negative !== 0 && a.negative === 0)
          return -1;
        if (this.negative === 0 && a.negative !== 0)
          return 1;
        var d = this.ucmp(a);
        return this.negative !== 0 ? -d | 0 : d;
      }, n.prototype.ucmp = function(a) {
        if (this.length > a.length)
          return 1;
        if (this.length < a.length)
          return -1;
        for (var d = 0, w = this.length - 1; w >= 0; w--) {
          var x = this.words[w] | 0, A = a.words[w] | 0;
          if (x !== A) {
            x < A ? d = -1 : x > A && (d = 1);
            break;
          }
        }
        return d;
      }, n.prototype.gtn = function(a) {
        return this.cmpn(a) === 1;
      }, n.prototype.gt = function(a) {
        return this.cmp(a) === 1;
      }, n.prototype.gten = function(a) {
        return this.cmpn(a) >= 0;
      }, n.prototype.gte = function(a) {
        return this.cmp(a) >= 0;
      }, n.prototype.ltn = function(a) {
        return this.cmpn(a) === -1;
      }, n.prototype.lt = function(a) {
        return this.cmp(a) === -1;
      }, n.prototype.lten = function(a) {
        return this.cmpn(a) <= 0;
      }, n.prototype.lte = function(a) {
        return this.cmp(a) <= 0;
      }, n.prototype.eqn = function(a) {
        return this.cmpn(a) === 0;
      }, n.prototype.eq = function(a) {
        return this.cmp(a) === 0;
      }, n.red = function(a) {
        return new U(a);
      }, n.prototype.toRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
      }, n.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(a) {
        return this.red = a, this;
      }, n.prototype.forceRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(a);
      }, n.prototype.redAdd = function(a) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
      }, n.prototype.redIAdd = function(a) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
      }, n.prototype.redSub = function(a) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
      }, n.prototype.redISub = function(a) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
      }, n.prototype.redShl = function(a) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
      }, n.prototype.redMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
      }, n.prototype.redIMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
      }, n.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(a) {
        return i(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
      };
      var k = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function q(v, a) {
        this.name = v, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      q.prototype._tmp = function() {
        var a = new n(null);
        return a.words = new Array(Math.ceil(this.n / 13)), a;
      }, q.prototype.ireduce = function(a) {
        var d = a, w;
        do
          this.split(d, this.tmp), d = this.imulK(d), d = d.iadd(this.tmp), w = d.bitLength();
        while (w > this.n);
        var x = w < this.n ? -1 : d.ucmp(this.p);
        return x === 0 ? (d.words[0] = 0, d.length = 1) : x > 0 ? d.isub(this.p) : d.strip !== void 0 ? d.strip() : d._strip(), d;
      }, q.prototype.split = function(a, d) {
        a.iushrn(this.n, 0, d);
      }, q.prototype.imulK = function(a) {
        return a.imul(this.k);
      };
      function $() {
        q.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      o($, q), $.prototype.split = function(a, d) {
        for (var w = 4194303, x = Math.min(a.length, 9), A = 0; A < x; A++)
          d.words[A] = a.words[A];
        if (d.length = x, a.length <= 9) {
          a.words[0] = 0, a.length = 1;
          return;
        }
        var S = a.words[9];
        for (d.words[d.length++] = S & w, A = 10; A < a.length; A++) {
          var g = a.words[A] | 0;
          a.words[A - 10] = (g & w) << 4 | S >>> 22, S = g;
        }
        S >>>= 22, a.words[A - 10] = S, S === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
      }, $.prototype.imulK = function(a) {
        a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = a.words[w] | 0;
          d += x * 977, a.words[w] = d & 67108863, d = x * 64 + (d / 67108864 | 0);
        }
        return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
      };
      function re() {
        q.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      o(re, q);
      function Q() {
        q.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      o(Q, q);
      function fe() {
        q.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      o(fe, q), fe.prototype.imulK = function(a) {
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = (a.words[w] | 0) * 19 + d, A = x & 67108863;
          x >>>= 26, a.words[w] = A, d = x;
        }
        return d !== 0 && (a.words[a.length++] = d), a;
      }, n._prime = function(a) {
        if (k[a])
          return k[a];
        var d;
        if (a === "k256")
          d = new $();
        else if (a === "p224")
          d = new re();
        else if (a === "p192")
          d = new Q();
        else if (a === "p25519")
          d = new fe();
        else
          throw new Error("Unknown prime " + a);
        return k[a] = d, d;
      };
      function U(v) {
        if (typeof v == "string") {
          var a = n._prime(v);
          this.m = a.p, this.prime = a;
        } else
          i(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      U.prototype._verify1 = function(a) {
        i(a.negative === 0, "red works only with positives"), i(a.red, "red works only with red numbers");
      }, U.prototype._verify2 = function(a, d) {
        i((a.negative | d.negative) === 0, "red works only with positives"), i(
          a.red && a.red === d.red,
          "red works only with red numbers"
        );
      }, U.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : (s(a, a.umod(this.m)._forceRed(this)), a);
      }, U.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      }, U.prototype.add = function(a, d) {
        this._verify2(a, d);
        var w = a.add(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
      }, U.prototype.iadd = function(a, d) {
        this._verify2(a, d);
        var w = a.iadd(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w;
      }, U.prototype.sub = function(a, d) {
        this._verify2(a, d);
        var w = a.sub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
      }, U.prototype.isub = function(a, d) {
        this._verify2(a, d);
        var w = a.isub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w;
      }, U.prototype.shl = function(a, d) {
        return this._verify1(a), this.imod(a.ushln(d));
      }, U.prototype.imul = function(a, d) {
        return this._verify2(a, d), this.imod(a.imul(d));
      }, U.prototype.mul = function(a, d) {
        return this._verify2(a, d), this.imod(a.mul(d));
      }, U.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      }, U.prototype.sqr = function(a) {
        return this.mul(a, a);
      }, U.prototype.sqrt = function(a) {
        if (a.isZero())
          return a.clone();
        var d = this.m.andln(3);
        if (i(d % 2 === 1), d === 3) {
          var w = this.m.add(new n(1)).iushrn(2);
          return this.pow(a, w);
        }
        for (var x = this.m.subn(1), A = 0; !x.isZero() && x.andln(1) === 0; )
          A++, x.iushrn(1);
        i(!x.isZero());
        var S = new n(1).toRed(this), g = S.redNeg(), _ = this.m.subn(1).iushrn(1), l = this.m.bitLength();
        for (l = new n(2 * l * l).toRed(this); this.pow(l, _).cmp(g) !== 0; )
          l.redIAdd(g);
        for (var R = this.pow(l, x), Y = this.pow(a, x.addn(1).iushrn(1)), oe = this.pow(a, x), H = A; oe.cmp(S) !== 0; ) {
          for (var V = oe, F = 0; V.cmp(S) !== 0; F++)
            V = V.redSqr();
          i(F < H);
          var te = this.pow(R, new n(1).iushln(H - F - 1));
          Y = Y.redMul(te), R = te.redSqr(), oe = oe.redMul(R), H = F;
        }
        return Y;
      }, U.prototype.invm = function(a) {
        var d = a._invmp(this.m);
        return d.negative !== 0 ? (d.negative = 0, this.imod(d).redNeg()) : this.imod(d);
      }, U.prototype.pow = function(a, d) {
        if (d.isZero())
          return new n(1).toRed(this);
        if (d.cmpn(1) === 0)
          return a.clone();
        var w = 4, x = new Array(1 << w);
        x[0] = new n(1).toRed(this), x[1] = a;
        for (var A = 2; A < x.length; A++)
          x[A] = this.mul(x[A - 1], a);
        var S = x[0], g = 0, _ = 0, l = d.bitLength() % 26;
        for (l === 0 && (l = 26), A = d.length - 1; A >= 0; A--) {
          for (var R = d.words[A], Y = l - 1; Y >= 0; Y--) {
            var oe = R >> Y & 1;
            if (S !== x[0] && (S = this.sqr(S)), oe === 0 && g === 0) {
              _ = 0;
              continue;
            }
            g <<= 1, g |= oe, _++, !(_ !== w && (A !== 0 || Y !== 0)) && (S = this.mul(S, x[g]), _ = 0, g = 0);
          }
          l = 26;
        }
        return S;
      }, U.prototype.convertTo = function(a) {
        var d = a.umod(this.m);
        return d === a ? d.clone() : d;
      }, U.prototype.convertFrom = function(a) {
        var d = a.clone();
        return d.red = null, d;
      }, n.mont = function(a) {
        return new y(a);
      };
      function y(v) {
        U.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(y, U), y.prototype.convertTo = function(a) {
        return this.imod(a.ushln(this.shift));
      }, y.prototype.convertFrom = function(a) {
        var d = this.imod(a.mul(this.rinv));
        return d.red = null, d;
      }, y.prototype.imul = function(a, d) {
        if (a.isZero() || d.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var w = a.imul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.mul = function(a, d) {
        if (a.isZero() || d.isZero())
          return new n(0)._forceRed(this);
        var w = a.mul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.invm = function(a) {
        var d = this.imod(a._invmp(this.m).mul(this.r2));
        return d._forceRed(this);
      };
    })(e, Ze);
  }(Qa)), Qa.exports;
}
var Nu, up;
function h0() {
  if (up)
    return Nu;
  up = 1;
  var e = XE(), t = $i();
  function r(n) {
    var f = i(n), u = f.toRed(e.mont(n.modulus)).redPow(new e(n.publicExponent)).fromRed();
    return { blinder: u, unblinder: f.invm(n.modulus) };
  }
  function i(n) {
    var f = n.modulus.byteLength(), u;
    do
      u = new e(t(f));
    while (u.cmp(n.modulus) >= 0 || !u.umod(n.prime1) || !u.umod(n.prime2));
    return u;
  }
  function o(n, f) {
    var u = r(f), c = f.modulus.byteLength(), h = new e(n).mul(u.blinder).umod(f.modulus), s = h.toRed(e.mont(f.prime1)), b = h.toRed(e.mont(f.prime2)), p = f.coefficient, m = f.prime1, E = f.prime2, M = s.redPow(f.exponent1).fromRed(), I = b.redPow(f.exponent2).fromRed(), B = M.isub(I).imul(p).umod(m).imul(E);
    return I.iadd(B).imul(u.unblinder).umod(f.modulus).toArrayLike(Le.Buffer, "be", c);
  }
  return o.getr = i, Nu = o, Nu;
}
var Lu = {};
const YE = "elliptic", QE = "6.5.4", e7 = "EC cryptography", t7 = "lib/elliptic.js", r7 = [
  "lib"
], n7 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, i7 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, a7 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], o7 = "Fedor Indutny <fedor@indutny.com>", f7 = "MIT", s7 = {
  url: "https://github.com/indutny/elliptic/issues"
}, u7 = "https://github.com/indutny/elliptic", c7 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, h7 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, l7 = {
  name: YE,
  version: QE,
  description: e7,
  main: t7,
  files: r7,
  scripts: n7,
  repository: i7,
  keywords: a7,
  author: o7,
  license: f7,
  bugs: s7,
  homepage: u7,
  devDependencies: c7,
  dependencies: h7
};
var ku = {}, ju = {}, cp;
function sg() {
  return cp || (cp = 1, function(e) {
    var t = e;
    function r(n, f) {
      if (Array.isArray(n))
        return n.slice();
      if (!n)
        return [];
      var u = [];
      if (typeof n != "string") {
        for (var c = 0; c < n.length; c++)
          u[c] = n[c] | 0;
        return u;
      }
      if (f === "hex") {
        n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n);
        for (var c = 0; c < n.length; c += 2)
          u.push(parseInt(n[c] + n[c + 1], 16));
      } else
        for (var c = 0; c < n.length; c++) {
          var h = n.charCodeAt(c), s = h >> 8, b = h & 255;
          s ? u.push(s, b) : u.push(b);
        }
      return u;
    }
    t.toArray = r;
    function i(n) {
      return n.length === 1 ? "0" + n : n;
    }
    t.zero2 = i;
    function o(n) {
      for (var f = "", u = 0; u < n.length; u++)
        f += i(n[u].toString(16));
      return f;
    }
    t.toHex = o, t.encode = function(f, u) {
      return u === "hex" ? o(f) : f;
    };
  }(ju)), ju;
}
var hp;
function Dr() {
  return hp || (hp = 1, function(e) {
    var t = e, r = tr, i = qr(), o = sg();
    t.assert = i, t.toArray = o.toArray, t.zero2 = o.zero2, t.toHex = o.toHex, t.encode = o.encode;
    function n(s, b, p) {
      var m = new Array(Math.max(s.bitLength(), p) + 1);
      m.fill(0);
      for (var E = 1 << b + 1, M = s.clone(), I = 0; I < m.length; I++) {
        var B, T = M.andln(E - 1);
        M.isOdd() ? (T > (E >> 1) - 1 ? B = (E >> 1) - T : B = T, M.isubn(B)) : B = 0, m[I] = B, M.iushrn(1);
      }
      return m;
    }
    t.getNAF = n;
    function f(s, b) {
      var p = [
        [],
        []
      ];
      s = s.clone(), b = b.clone();
      for (var m = 0, E = 0, M; s.cmpn(-m) > 0 || b.cmpn(-E) > 0; ) {
        var I = s.andln(3) + m & 3, B = b.andln(3) + E & 3;
        I === 3 && (I = -1), B === 3 && (B = -1);
        var T;
        I & 1 ? (M = s.andln(7) + m & 7, (M === 3 || M === 5) && B === 2 ? T = -I : T = I) : T = 0, p[0].push(T);
        var j;
        B & 1 ? (M = b.andln(7) + E & 7, (M === 3 || M === 5) && I === 2 ? j = -B : j = B) : j = 0, p[1].push(j), 2 * m === T + 1 && (m = 1 - m), 2 * E === j + 1 && (E = 1 - E), s.iushrn(1), b.iushrn(1);
      }
      return p;
    }
    t.getJSF = f;
    function u(s, b, p) {
      var m = "_" + b;
      s.prototype[b] = function() {
        return this[m] !== void 0 ? this[m] : this[m] = p.call(this);
      };
    }
    t.cachedProperty = u;
    function c(s) {
      return typeof s == "string" ? t.toArray(s, "hex") : s;
    }
    t.parseBytes = c;
    function h(s) {
      return new r(s, "hex", "le");
    }
    t.intFromLE = h;
  }(ku)), ku;
}
var qu = {}, Du, lp;
function uf() {
  if (lp)
    return Du;
  lp = 1;
  var e = tr, t = Dr(), r = t.getNAF, i = t.getJSF, o = t.assert;
  function n(u, c) {
    this.type = u, this.p = new e(c.p, 16), this.red = c.prime ? e.red(c.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = c.n && new e(c.n, 16), this.g = c.g && this.pointFromJSON(c.g, c.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var h = this.n && this.p.div(this.n);
    !h || h.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  Du = n, n.prototype.point = function() {
    throw new Error("Not implemented");
  }, n.prototype.validate = function() {
    throw new Error("Not implemented");
  }, n.prototype._fixedNafMul = function(c, h) {
    o(c.precomputed);
    var s = c._getDoubles(), b = r(h, 1, this._bitLength), p = (1 << s.step + 1) - (s.step % 2 === 0 ? 2 : 1);
    p /= 3;
    var m = [], E, M;
    for (E = 0; E < b.length; E += s.step) {
      M = 0;
      for (var I = E + s.step - 1; I >= E; I--)
        M = (M << 1) + b[I];
      m.push(M);
    }
    for (var B = this.jpoint(null, null, null), T = this.jpoint(null, null, null), j = p; j > 0; j--) {
      for (E = 0; E < m.length; E++)
        M = m[E], M === j ? T = T.mixedAdd(s.points[E]) : M === -j && (T = T.mixedAdd(s.points[E].neg()));
      B = B.add(T);
    }
    return B.toP();
  }, n.prototype._wnafMul = function(c, h) {
    var s = 4, b = c._getNAFPoints(s);
    s = b.wnd;
    for (var p = b.points, m = r(h, s, this._bitLength), E = this.jpoint(null, null, null), M = m.length - 1; M >= 0; M--) {
      for (var I = 0; M >= 0 && m[M] === 0; M--)
        I++;
      if (M >= 0 && I++, E = E.dblp(I), M < 0)
        break;
      var B = m[M];
      o(B !== 0), c.type === "affine" ? B > 0 ? E = E.mixedAdd(p[B - 1 >> 1]) : E = E.mixedAdd(p[-B - 1 >> 1].neg()) : B > 0 ? E = E.add(p[B - 1 >> 1]) : E = E.add(p[-B - 1 >> 1].neg());
    }
    return c.type === "affine" ? E.toP() : E;
  }, n.prototype._wnafMulAdd = function(c, h, s, b, p) {
    var m = this._wnafT1, E = this._wnafT2, M = this._wnafT3, I = 0, B, T, j;
    for (B = 0; B < b; B++) {
      j = h[B];
      var N = j._getNAFPoints(c);
      m[B] = N.wnd, E[B] = N.points;
    }
    for (B = b - 1; B >= 1; B -= 2) {
      var k = B - 1, q = B;
      if (m[k] !== 1 || m[q] !== 1) {
        M[k] = r(s[k], m[k], this._bitLength), M[q] = r(s[q], m[q], this._bitLength), I = Math.max(M[k].length, I), I = Math.max(M[q].length, I);
        continue;
      }
      var $ = [
        h[k],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        h[q]
        /* 7 */
      ];
      h[k].y.cmp(h[q].y) === 0 ? ($[1] = h[k].add(h[q]), $[2] = h[k].toJ().mixedAdd(h[q].neg())) : h[k].y.cmp(h[q].y.redNeg()) === 0 ? ($[1] = h[k].toJ().mixedAdd(h[q]), $[2] = h[k].add(h[q].neg())) : ($[1] = h[k].toJ().mixedAdd(h[q]), $[2] = h[k].toJ().mixedAdd(h[q].neg()));
      var re = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Q = i(s[k], s[q]);
      for (I = Math.max(Q[0].length, I), M[k] = new Array(I), M[q] = new Array(I), T = 0; T < I; T++) {
        var fe = Q[0][T] | 0, U = Q[1][T] | 0;
        M[k][T] = re[(fe + 1) * 3 + (U + 1)], M[q][T] = 0, E[k] = $;
      }
    }
    var y = this.jpoint(null, null, null), v = this._wnafT4;
    for (B = I; B >= 0; B--) {
      for (var a = 0; B >= 0; ) {
        var d = !0;
        for (T = 0; T < b; T++)
          v[T] = M[T][B] | 0, v[T] !== 0 && (d = !1);
        if (!d)
          break;
        a++, B--;
      }
      if (B >= 0 && a++, y = y.dblp(a), B < 0)
        break;
      for (T = 0; T < b; T++) {
        var w = v[T];
        w !== 0 && (w > 0 ? j = E[T][w - 1 >> 1] : w < 0 && (j = E[T][-w - 1 >> 1].neg()), j.type === "affine" ? y = y.mixedAdd(j) : y = y.add(j));
      }
    }
    for (B = 0; B < b; B++)
      E[B] = null;
    return p ? y : y.toP();
  };
  function f(u, c) {
    this.curve = u, this.type = c, this.precomputed = null;
  }
  return n.BasePoint = f, f.prototype.eq = function() {
    throw new Error("Not implemented");
  }, f.prototype.validate = function() {
    return this.curve.validate(this);
  }, n.prototype.decodePoint = function(c, h) {
    c = t.toArray(c, h);
    var s = this.p.byteLength();
    if ((c[0] === 4 || c[0] === 6 || c[0] === 7) && c.length - 1 === 2 * s) {
      c[0] === 6 ? o(c[c.length - 1] % 2 === 0) : c[0] === 7 && o(c[c.length - 1] % 2 === 1);
      var b = this.point(
        c.slice(1, 1 + s),
        c.slice(1 + s, 1 + 2 * s)
      );
      return b;
    } else if ((c[0] === 2 || c[0] === 3) && c.length - 1 === s)
      return this.pointFromX(c.slice(1, 1 + s), c[0] === 3);
    throw new Error("Unknown point format");
  }, f.prototype.encodeCompressed = function(c) {
    return this.encode(c, !0);
  }, f.prototype._encode = function(c) {
    var h = this.curve.p.byteLength(), s = this.getX().toArray("be", h);
    return c ? [this.getY().isEven() ? 2 : 3].concat(s) : [4].concat(s, this.getY().toArray("be", h));
  }, f.prototype.encode = function(c, h) {
    return t.encode(this._encode(h), c);
  }, f.prototype.precompute = function(c) {
    if (this.precomputed)
      return this;
    var h = {
      doubles: null,
      naf: null,
      beta: null
    };
    return h.naf = this._getNAFPoints(8), h.doubles = this._getDoubles(4, c), h.beta = this._getBeta(), this.precomputed = h, this;
  }, f.prototype._hasDoubles = function(c) {
    if (!this.precomputed)
      return !1;
    var h = this.precomputed.doubles;
    return h ? h.points.length >= Math.ceil((c.bitLength() + 1) / h.step) : !1;
  }, f.prototype._getDoubles = function(c, h) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var s = [this], b = this, p = 0; p < h; p += c) {
      for (var m = 0; m < c; m++)
        b = b.dbl();
      s.push(b);
    }
    return {
      step: c,
      points: s
    };
  }, f.prototype._getNAFPoints = function(c) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var h = [this], s = (1 << c) - 1, b = s === 1 ? null : this.dbl(), p = 1; p < s; p++)
      h[p] = h[p - 1].add(b);
    return {
      wnd: c,
      points: h
    };
  }, f.prototype._getBeta = function() {
    return null;
  }, f.prototype.dblp = function(c) {
    for (var h = this, s = 0; s < c; s++)
      h = h.dbl();
    return h;
  }, Du;
}
var $u, dp;
function d7() {
  if (dp)
    return $u;
  dp = 1;
  var e = Dr(), t = tr, r = _t(), i = uf(), o = e.assert;
  function n(c) {
    i.call(this, "short", c), this.a = new t(c.a, 16).toRed(this.red), this.b = new t(c.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(c), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  r(n, i), $u = n, n.prototype._getEndomorphism = function(h) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var s, b;
      if (h.beta)
        s = new t(h.beta, 16).toRed(this.red);
      else {
        var p = this._getEndoRoots(this.p);
        s = p[0].cmp(p[1]) < 0 ? p[0] : p[1], s = s.toRed(this.red);
      }
      if (h.lambda)
        b = new t(h.lambda, 16);
      else {
        var m = this._getEndoRoots(this.n);
        this.g.mul(m[0]).x.cmp(this.g.x.redMul(s)) === 0 ? b = m[0] : (b = m[1], o(this.g.mul(b).x.cmp(this.g.x.redMul(s)) === 0));
      }
      var E;
      return h.basis ? E = h.basis.map(function(M) {
        return {
          a: new t(M.a, 16),
          b: new t(M.b, 16)
        };
      }) : E = this._getEndoBasis(b), {
        beta: s,
        lambda: b,
        basis: E
      };
    }
  }, n.prototype._getEndoRoots = function(h) {
    var s = h === this.p ? this.red : t.mont(h), b = new t(2).toRed(s).redInvm(), p = b.redNeg(), m = new t(3).toRed(s).redNeg().redSqrt().redMul(b), E = p.redAdd(m).fromRed(), M = p.redSub(m).fromRed();
    return [E, M];
  }, n.prototype._getEndoBasis = function(h) {
    for (var s = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), b = h, p = this.n.clone(), m = new t(1), E = new t(0), M = new t(0), I = new t(1), B, T, j, N, k, q, $, re = 0, Q, fe; b.cmpn(0) !== 0; ) {
      var U = p.div(b);
      Q = p.sub(U.mul(b)), fe = M.sub(U.mul(m));
      var y = I.sub(U.mul(E));
      if (!j && Q.cmp(s) < 0)
        B = $.neg(), T = m, j = Q.neg(), N = fe;
      else if (j && ++re === 2)
        break;
      $ = Q, p = b, b = Q, M = m, m = fe, I = E, E = y;
    }
    k = Q.neg(), q = fe;
    var v = j.sqr().add(N.sqr()), a = k.sqr().add(q.sqr());
    return a.cmp(v) >= 0 && (k = B, q = T), j.negative && (j = j.neg(), N = N.neg()), k.negative && (k = k.neg(), q = q.neg()), [
      { a: j, b: N },
      { a: k, b: q }
    ];
  }, n.prototype._endoSplit = function(h) {
    var s = this.endo.basis, b = s[0], p = s[1], m = p.b.mul(h).divRound(this.n), E = b.b.neg().mul(h).divRound(this.n), M = m.mul(b.a), I = E.mul(p.a), B = m.mul(b.b), T = E.mul(p.b), j = h.sub(M).sub(I), N = B.add(T).neg();
    return { k1: j, k2: N };
  }, n.prototype.pointFromX = function(h, s) {
    h = new t(h, 16), h.red || (h = h.toRed(this.red));
    var b = h.redSqr().redMul(h).redIAdd(h.redMul(this.a)).redIAdd(this.b), p = b.redSqrt();
    if (p.redSqr().redSub(b).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var m = p.fromRed().isOdd();
    return (s && !m || !s && m) && (p = p.redNeg()), this.point(h, p);
  }, n.prototype.validate = function(h) {
    if (h.inf)
      return !0;
    var s = h.x, b = h.y, p = this.a.redMul(s), m = s.redSqr().redMul(s).redIAdd(p).redIAdd(this.b);
    return b.redSqr().redISub(m).cmpn(0) === 0;
  }, n.prototype._endoWnafMulAdd = function(h, s, b) {
    for (var p = this._endoWnafT1, m = this._endoWnafT2, E = 0; E < h.length; E++) {
      var M = this._endoSplit(s[E]), I = h[E], B = I._getBeta();
      M.k1.negative && (M.k1.ineg(), I = I.neg(!0)), M.k2.negative && (M.k2.ineg(), B = B.neg(!0)), p[E * 2] = I, p[E * 2 + 1] = B, m[E * 2] = M.k1, m[E * 2 + 1] = M.k2;
    }
    for (var T = this._wnafMulAdd(1, p, m, E * 2, b), j = 0; j < E * 2; j++)
      p[j] = null, m[j] = null;
    return T;
  };
  function f(c, h, s, b) {
    i.BasePoint.call(this, c, "affine"), h === null && s === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(h, 16), this.y = new t(s, 16), b && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  r(f, i.BasePoint), n.prototype.point = function(h, s, b) {
    return new f(this, h, s, b);
  }, n.prototype.pointFromJSON = function(h, s) {
    return f.fromJSON(this, h, s);
  }, f.prototype._getBeta = function() {
    if (this.curve.endo) {
      var h = this.precomputed;
      if (h && h.beta)
        return h.beta;
      var s = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (h) {
        var b = this.curve, p = function(m) {
          return b.point(m.x.redMul(b.endo.beta), m.y);
        };
        h.beta = s, s.precomputed = {
          beta: null,
          naf: h.naf && {
            wnd: h.naf.wnd,
            points: h.naf.points.map(p)
          },
          doubles: h.doubles && {
            step: h.doubles.step,
            points: h.doubles.points.map(p)
          }
        };
      }
      return s;
    }
  }, f.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, f.fromJSON = function(h, s, b) {
    typeof s == "string" && (s = JSON.parse(s));
    var p = h.point(s[0], s[1], b);
    if (!s[2])
      return p;
    function m(M) {
      return h.point(M[0], M[1], b);
    }
    var E = s[2];
    return p.precomputed = {
      beta: null,
      doubles: E.doubles && {
        step: E.doubles.step,
        points: [p].concat(E.doubles.points.map(m))
      },
      naf: E.naf && {
        wnd: E.naf.wnd,
        points: [p].concat(E.naf.points.map(m))
      }
    }, p;
  }, f.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, f.prototype.isInfinity = function() {
    return this.inf;
  }, f.prototype.add = function(h) {
    if (this.inf)
      return h;
    if (h.inf)
      return this;
    if (this.eq(h))
      return this.dbl();
    if (this.neg().eq(h))
      return this.curve.point(null, null);
    if (this.x.cmp(h.x) === 0)
      return this.curve.point(null, null);
    var s = this.y.redSub(h.y);
    s.cmpn(0) !== 0 && (s = s.redMul(this.x.redSub(h.x).redInvm()));
    var b = s.redSqr().redISub(this.x).redISub(h.x), p = s.redMul(this.x.redSub(b)).redISub(this.y);
    return this.curve.point(b, p);
  }, f.prototype.dbl = function() {
    if (this.inf)
      return this;
    var h = this.y.redAdd(this.y);
    if (h.cmpn(0) === 0)
      return this.curve.point(null, null);
    var s = this.curve.a, b = this.x.redSqr(), p = h.redInvm(), m = b.redAdd(b).redIAdd(b).redIAdd(s).redMul(p), E = m.redSqr().redISub(this.x.redAdd(this.x)), M = m.redMul(this.x.redSub(E)).redISub(this.y);
    return this.curve.point(E, M);
  }, f.prototype.getX = function() {
    return this.x.fromRed();
  }, f.prototype.getY = function() {
    return this.y.fromRed();
  }, f.prototype.mul = function(h) {
    return h = new t(h, 16), this.isInfinity() ? this : this._hasDoubles(h) ? this.curve._fixedNafMul(this, h) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [h]) : this.curve._wnafMul(this, h);
  }, f.prototype.mulAdd = function(h, s, b) {
    var p = [this, s], m = [h, b];
    return this.curve.endo ? this.curve._endoWnafMulAdd(p, m) : this.curve._wnafMulAdd(1, p, m, 2);
  }, f.prototype.jmulAdd = function(h, s, b) {
    var p = [this, s], m = [h, b];
    return this.curve.endo ? this.curve._endoWnafMulAdd(p, m, !0) : this.curve._wnafMulAdd(1, p, m, 2, !0);
  }, f.prototype.eq = function(h) {
    return this === h || this.inf === h.inf && (this.inf || this.x.cmp(h.x) === 0 && this.y.cmp(h.y) === 0);
  }, f.prototype.neg = function(h) {
    if (this.inf)
      return this;
    var s = this.curve.point(this.x, this.y.redNeg());
    if (h && this.precomputed) {
      var b = this.precomputed, p = function(m) {
        return m.neg();
      };
      s.precomputed = {
        naf: b.naf && {
          wnd: b.naf.wnd,
          points: b.naf.points.map(p)
        },
        doubles: b.doubles && {
          step: b.doubles.step,
          points: b.doubles.points.map(p)
        }
      };
    }
    return s;
  }, f.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var h = this.curve.jpoint(this.x, this.y, this.curve.one);
    return h;
  };
  function u(c, h, s, b) {
    i.BasePoint.call(this, c, "jacobian"), h === null && s === null && b === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(h, 16), this.y = new t(s, 16), this.z = new t(b, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return r(u, i.BasePoint), n.prototype.jpoint = function(h, s, b) {
    return new u(this, h, s, b);
  }, u.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var h = this.z.redInvm(), s = h.redSqr(), b = this.x.redMul(s), p = this.y.redMul(s).redMul(h);
    return this.curve.point(b, p);
  }, u.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, u.prototype.add = function(h) {
    if (this.isInfinity())
      return h;
    if (h.isInfinity())
      return this;
    var s = h.z.redSqr(), b = this.z.redSqr(), p = this.x.redMul(s), m = h.x.redMul(b), E = this.y.redMul(s.redMul(h.z)), M = h.y.redMul(b.redMul(this.z)), I = p.redSub(m), B = E.redSub(M);
    if (I.cmpn(0) === 0)
      return B.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var T = I.redSqr(), j = T.redMul(I), N = p.redMul(T), k = B.redSqr().redIAdd(j).redISub(N).redISub(N), q = B.redMul(N.redISub(k)).redISub(E.redMul(j)), $ = this.z.redMul(h.z).redMul(I);
    return this.curve.jpoint(k, q, $);
  }, u.prototype.mixedAdd = function(h) {
    if (this.isInfinity())
      return h.toJ();
    if (h.isInfinity())
      return this;
    var s = this.z.redSqr(), b = this.x, p = h.x.redMul(s), m = this.y, E = h.y.redMul(s).redMul(this.z), M = b.redSub(p), I = m.redSub(E);
    if (M.cmpn(0) === 0)
      return I.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var B = M.redSqr(), T = B.redMul(M), j = b.redMul(B), N = I.redSqr().redIAdd(T).redISub(j).redISub(j), k = I.redMul(j.redISub(N)).redISub(m.redMul(T)), q = this.z.redMul(M);
    return this.curve.jpoint(N, k, q);
  }, u.prototype.dblp = function(h) {
    if (h === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!h)
      return this.dbl();
    var s;
    if (this.curve.zeroA || this.curve.threeA) {
      var b = this;
      for (s = 0; s < h; s++)
        b = b.dbl();
      return b;
    }
    var p = this.curve.a, m = this.curve.tinv, E = this.x, M = this.y, I = this.z, B = I.redSqr().redSqr(), T = M.redAdd(M);
    for (s = 0; s < h; s++) {
      var j = E.redSqr(), N = T.redSqr(), k = N.redSqr(), q = j.redAdd(j).redIAdd(j).redIAdd(p.redMul(B)), $ = E.redMul(N), re = q.redSqr().redISub($.redAdd($)), Q = $.redISub(re), fe = q.redMul(Q);
      fe = fe.redIAdd(fe).redISub(k);
      var U = T.redMul(I);
      s + 1 < h && (B = B.redMul(k)), E = re, I = U, T = fe;
    }
    return this.curve.jpoint(E, T.redMul(m), I);
  }, u.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, u.prototype._zeroDbl = function() {
    var h, s, b;
    if (this.zOne) {
      var p = this.x.redSqr(), m = this.y.redSqr(), E = m.redSqr(), M = this.x.redAdd(m).redSqr().redISub(p).redISub(E);
      M = M.redIAdd(M);
      var I = p.redAdd(p).redIAdd(p), B = I.redSqr().redISub(M).redISub(M), T = E.redIAdd(E);
      T = T.redIAdd(T), T = T.redIAdd(T), h = B, s = I.redMul(M.redISub(B)).redISub(T), b = this.y.redAdd(this.y);
    } else {
      var j = this.x.redSqr(), N = this.y.redSqr(), k = N.redSqr(), q = this.x.redAdd(N).redSqr().redISub(j).redISub(k);
      q = q.redIAdd(q);
      var $ = j.redAdd(j).redIAdd(j), re = $.redSqr(), Q = k.redIAdd(k);
      Q = Q.redIAdd(Q), Q = Q.redIAdd(Q), h = re.redISub(q).redISub(q), s = $.redMul(q.redISub(h)).redISub(Q), b = this.y.redMul(this.z), b = b.redIAdd(b);
    }
    return this.curve.jpoint(h, s, b);
  }, u.prototype._threeDbl = function() {
    var h, s, b;
    if (this.zOne) {
      var p = this.x.redSqr(), m = this.y.redSqr(), E = m.redSqr(), M = this.x.redAdd(m).redSqr().redISub(p).redISub(E);
      M = M.redIAdd(M);
      var I = p.redAdd(p).redIAdd(p).redIAdd(this.curve.a), B = I.redSqr().redISub(M).redISub(M);
      h = B;
      var T = E.redIAdd(E);
      T = T.redIAdd(T), T = T.redIAdd(T), s = I.redMul(M.redISub(B)).redISub(T), b = this.y.redAdd(this.y);
    } else {
      var j = this.z.redSqr(), N = this.y.redSqr(), k = this.x.redMul(N), q = this.x.redSub(j).redMul(this.x.redAdd(j));
      q = q.redAdd(q).redIAdd(q);
      var $ = k.redIAdd(k);
      $ = $.redIAdd($);
      var re = $.redAdd($);
      h = q.redSqr().redISub(re), b = this.y.redAdd(this.z).redSqr().redISub(N).redISub(j);
      var Q = N.redSqr();
      Q = Q.redIAdd(Q), Q = Q.redIAdd(Q), Q = Q.redIAdd(Q), s = q.redMul($.redISub(h)).redISub(Q);
    }
    return this.curve.jpoint(h, s, b);
  }, u.prototype._dbl = function() {
    var h = this.curve.a, s = this.x, b = this.y, p = this.z, m = p.redSqr().redSqr(), E = s.redSqr(), M = b.redSqr(), I = E.redAdd(E).redIAdd(E).redIAdd(h.redMul(m)), B = s.redAdd(s);
    B = B.redIAdd(B);
    var T = B.redMul(M), j = I.redSqr().redISub(T.redAdd(T)), N = T.redISub(j), k = M.redSqr();
    k = k.redIAdd(k), k = k.redIAdd(k), k = k.redIAdd(k);
    var q = I.redMul(N).redISub(k), $ = b.redAdd(b).redMul(p);
    return this.curve.jpoint(j, q, $);
  }, u.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var h = this.x.redSqr(), s = this.y.redSqr(), b = this.z.redSqr(), p = s.redSqr(), m = h.redAdd(h).redIAdd(h), E = m.redSqr(), M = this.x.redAdd(s).redSqr().redISub(h).redISub(p);
    M = M.redIAdd(M), M = M.redAdd(M).redIAdd(M), M = M.redISub(E);
    var I = M.redSqr(), B = p.redIAdd(p);
    B = B.redIAdd(B), B = B.redIAdd(B), B = B.redIAdd(B);
    var T = m.redIAdd(M).redSqr().redISub(E).redISub(I).redISub(B), j = s.redMul(T);
    j = j.redIAdd(j), j = j.redIAdd(j);
    var N = this.x.redMul(I).redISub(j);
    N = N.redIAdd(N), N = N.redIAdd(N);
    var k = this.y.redMul(T.redMul(B.redISub(T)).redISub(M.redMul(I)));
    k = k.redIAdd(k), k = k.redIAdd(k), k = k.redIAdd(k);
    var q = this.z.redAdd(M).redSqr().redISub(b).redISub(I);
    return this.curve.jpoint(N, k, q);
  }, u.prototype.mul = function(h, s) {
    return h = new t(h, s), this.curve._wnafMul(this, h);
  }, u.prototype.eq = function(h) {
    if (h.type === "affine")
      return this.eq(h.toJ());
    if (this === h)
      return !0;
    var s = this.z.redSqr(), b = h.z.redSqr();
    if (this.x.redMul(b).redISub(h.x.redMul(s)).cmpn(0) !== 0)
      return !1;
    var p = s.redMul(this.z), m = b.redMul(h.z);
    return this.y.redMul(m).redISub(h.y.redMul(p)).cmpn(0) === 0;
  }, u.prototype.eqXToP = function(h) {
    var s = this.z.redSqr(), b = h.toRed(this.curve.red).redMul(s);
    if (this.x.cmp(b) === 0)
      return !0;
    for (var p = h.clone(), m = this.curve.redN.redMul(s); ; ) {
      if (p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0)
        return !1;
      if (b.redIAdd(m), this.x.cmp(b) === 0)
        return !0;
    }
  }, u.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, u.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, $u;
}
var Uu, pp;
function p7() {
  if (pp)
    return Uu;
  pp = 1;
  var e = tr, t = _t(), r = uf(), i = Dr();
  function o(f) {
    r.call(this, "mont", f), this.a = new e(f.a, 16).toRed(this.red), this.b = new e(f.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(o, r), Uu = o, o.prototype.validate = function(u) {
    var c = u.normalize().x, h = c.redSqr(), s = h.redMul(c).redAdd(h.redMul(this.a)).redAdd(c), b = s.redSqrt();
    return b.redSqr().cmp(s) === 0;
  };
  function n(f, u, c) {
    r.BasePoint.call(this, f, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(u, 16), this.z = new e(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(n, r.BasePoint), o.prototype.decodePoint = function(u, c) {
    return this.point(i.toArray(u, c), 1);
  }, o.prototype.point = function(u, c) {
    return new n(this, u, c);
  }, o.prototype.pointFromJSON = function(u) {
    return n.fromJSON(this, u);
  }, n.prototype.precompute = function() {
  }, n.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, n.fromJSON = function(u, c) {
    return new n(u, c[0], c[1] || u.one);
  }, n.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, n.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, n.prototype.dbl = function() {
    var u = this.x.redAdd(this.z), c = u.redSqr(), h = this.x.redSub(this.z), s = h.redSqr(), b = c.redSub(s), p = c.redMul(s), m = b.redMul(s.redAdd(this.curve.a24.redMul(b)));
    return this.curve.point(p, m);
  }, n.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.diffAdd = function(u, c) {
    var h = this.x.redAdd(this.z), s = this.x.redSub(this.z), b = u.x.redAdd(u.z), p = u.x.redSub(u.z), m = p.redMul(h), E = b.redMul(s), M = c.z.redMul(m.redAdd(E).redSqr()), I = c.x.redMul(m.redISub(E).redSqr());
    return this.curve.point(M, I);
  }, n.prototype.mul = function(u) {
    for (var c = u.clone(), h = this, s = this.curve.point(null, null), b = this, p = []; c.cmpn(0) !== 0; c.iushrn(1))
      p.push(c.andln(1));
    for (var m = p.length - 1; m >= 0; m--)
      p[m] === 0 ? (h = h.diffAdd(s, b), s = s.dbl()) : (s = h.diffAdd(s, b), h = h.dbl());
    return s;
  }, n.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.eq = function(u) {
    return this.getX().cmp(u.getX()) === 0;
  }, n.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, n.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, Uu;
}
var Fu, vp;
function v7() {
  if (vp)
    return Fu;
  vp = 1;
  var e = Dr(), t = tr, r = _t(), i = uf(), o = e.assert;
  function n(u) {
    this.twisted = (u.a | 0) !== 1, this.mOneA = this.twisted && (u.a | 0) === -1, this.extended = this.mOneA, i.call(this, "edwards", u), this.a = new t(u.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(u.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(u.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), o(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (u.c | 0) === 1;
  }
  r(n, i), Fu = n, n.prototype._mulA = function(c) {
    return this.mOneA ? c.redNeg() : this.a.redMul(c);
  }, n.prototype._mulC = function(c) {
    return this.oneC ? c : this.c.redMul(c);
  }, n.prototype.jpoint = function(c, h, s, b) {
    return this.point(c, h, s, b);
  }, n.prototype.pointFromX = function(c, h) {
    c = new t(c, 16), c.red || (c = c.toRed(this.red));
    var s = c.redSqr(), b = this.c2.redSub(this.a.redMul(s)), p = this.one.redSub(this.c2.redMul(this.d).redMul(s)), m = b.redMul(p.redInvm()), E = m.redSqrt();
    if (E.redSqr().redSub(m).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var M = E.fromRed().isOdd();
    return (h && !M || !h && M) && (E = E.redNeg()), this.point(c, E);
  }, n.prototype.pointFromY = function(c, h) {
    c = new t(c, 16), c.red || (c = c.toRed(this.red));
    var s = c.redSqr(), b = s.redSub(this.c2), p = s.redMul(this.d).redMul(this.c2).redSub(this.a), m = b.redMul(p.redInvm());
    if (m.cmp(this.zero) === 0) {
      if (h)
        throw new Error("invalid point");
      return this.point(this.zero, c);
    }
    var E = m.redSqrt();
    if (E.redSqr().redSub(m).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return E.fromRed().isOdd() !== h && (E = E.redNeg()), this.point(E, c);
  }, n.prototype.validate = function(c) {
    if (c.isInfinity())
      return !0;
    c.normalize();
    var h = c.x.redSqr(), s = c.y.redSqr(), b = h.redMul(this.a).redAdd(s), p = this.c2.redMul(this.one.redAdd(this.d.redMul(h).redMul(s)));
    return b.cmp(p) === 0;
  };
  function f(u, c, h, s, b) {
    i.BasePoint.call(this, u, "projective"), c === null && h === null && s === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(c, 16), this.y = new t(h, 16), this.z = s ? new t(s, 16) : this.curve.one, this.t = b && new t(b, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return r(f, i.BasePoint), n.prototype.pointFromJSON = function(c) {
    return f.fromJSON(this, c);
  }, n.prototype.point = function(c, h, s, b) {
    return new f(this, c, h, s, b);
  }, f.fromJSON = function(c, h) {
    return new f(c, h[0], h[1], h[2]);
  }, f.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, f.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, f.prototype._extDbl = function() {
    var c = this.x.redSqr(), h = this.y.redSqr(), s = this.z.redSqr();
    s = s.redIAdd(s);
    var b = this.curve._mulA(c), p = this.x.redAdd(this.y).redSqr().redISub(c).redISub(h), m = b.redAdd(h), E = m.redSub(s), M = b.redSub(h), I = p.redMul(E), B = m.redMul(M), T = p.redMul(M), j = E.redMul(m);
    return this.curve.point(I, B, j, T);
  }, f.prototype._projDbl = function() {
    var c = this.x.redAdd(this.y).redSqr(), h = this.x.redSqr(), s = this.y.redSqr(), b, p, m, E, M, I;
    if (this.curve.twisted) {
      E = this.curve._mulA(h);
      var B = E.redAdd(s);
      this.zOne ? (b = c.redSub(h).redSub(s).redMul(B.redSub(this.curve.two)), p = B.redMul(E.redSub(s)), m = B.redSqr().redSub(B).redSub(B)) : (M = this.z.redSqr(), I = B.redSub(M).redISub(M), b = c.redSub(h).redISub(s).redMul(I), p = B.redMul(E.redSub(s)), m = B.redMul(I));
    } else
      E = h.redAdd(s), M = this.curve._mulC(this.z).redSqr(), I = E.redSub(M).redSub(M), b = this.curve._mulC(c.redISub(E)).redMul(I), p = this.curve._mulC(E).redMul(h.redISub(s)), m = E.redMul(I);
    return this.curve.point(b, p, m);
  }, f.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, f.prototype._extAdd = function(c) {
    var h = this.y.redSub(this.x).redMul(c.y.redSub(c.x)), s = this.y.redAdd(this.x).redMul(c.y.redAdd(c.x)), b = this.t.redMul(this.curve.dd).redMul(c.t), p = this.z.redMul(c.z.redAdd(c.z)), m = s.redSub(h), E = p.redSub(b), M = p.redAdd(b), I = s.redAdd(h), B = m.redMul(E), T = M.redMul(I), j = m.redMul(I), N = E.redMul(M);
    return this.curve.point(B, T, N, j);
  }, f.prototype._projAdd = function(c) {
    var h = this.z.redMul(c.z), s = h.redSqr(), b = this.x.redMul(c.x), p = this.y.redMul(c.y), m = this.curve.d.redMul(b).redMul(p), E = s.redSub(m), M = s.redAdd(m), I = this.x.redAdd(this.y).redMul(c.x.redAdd(c.y)).redISub(b).redISub(p), B = h.redMul(E).redMul(I), T, j;
    return this.curve.twisted ? (T = h.redMul(M).redMul(p.redSub(this.curve._mulA(b))), j = E.redMul(M)) : (T = h.redMul(M).redMul(p.redSub(b)), j = this.curve._mulC(E).redMul(M)), this.curve.point(B, T, j);
  }, f.prototype.add = function(c) {
    return this.isInfinity() ? c : c.isInfinity() ? this : this.curve.extended ? this._extAdd(c) : this._projAdd(c);
  }, f.prototype.mul = function(c) {
    return this._hasDoubles(c) ? this.curve._fixedNafMul(this, c) : this.curve._wnafMul(this, c);
  }, f.prototype.mulAdd = function(c, h, s) {
    return this.curve._wnafMulAdd(1, [this, h], [c, s], 2, !1);
  }, f.prototype.jmulAdd = function(c, h, s) {
    return this.curve._wnafMulAdd(1, [this, h], [c, s], 2, !0);
  }, f.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var c = this.z.redInvm();
    return this.x = this.x.redMul(c), this.y = this.y.redMul(c), this.t && (this.t = this.t.redMul(c)), this.z = this.curve.one, this.zOne = !0, this;
  }, f.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, f.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, f.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, f.prototype.eq = function(c) {
    return this === c || this.getX().cmp(c.getX()) === 0 && this.getY().cmp(c.getY()) === 0;
  }, f.prototype.eqXToP = function(c) {
    var h = c.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(h) === 0)
      return !0;
    for (var s = c.clone(), b = this.curve.redN.redMul(this.z); ; ) {
      if (s.iadd(this.curve.n), s.cmp(this.curve.p) >= 0)
        return !1;
      if (h.redIAdd(b), this.x.cmp(h) === 0)
        return !0;
    }
  }, f.prototype.toP = f.prototype.normalize, f.prototype.mixedAdd = f.prototype.add, Fu;
}
var bp;
function ug() {
  return bp || (bp = 1, function(e) {
    var t = e;
    t.base = uf(), t.short = d7(), t.mont = p7(), t.edwards = v7();
  }(qu)), qu;
}
var zu = {}, Hu = {}, kt = {}, yp;
function sn() {
  if (yp)
    return kt;
  yp = 1;
  var e = qr(), t = _t();
  kt.inherits = t;
  function r(y, v) {
    return (y.charCodeAt(v) & 64512) !== 55296 || v < 0 || v + 1 >= y.length ? !1 : (y.charCodeAt(v + 1) & 64512) === 56320;
  }
  function i(y, v) {
    if (Array.isArray(y))
      return y.slice();
    if (!y)
      return [];
    var a = [];
    if (typeof y == "string")
      if (v) {
        if (v === "hex")
          for (y = y.replace(/[^a-z0-9]+/ig, ""), y.length % 2 !== 0 && (y = "0" + y), w = 0; w < y.length; w += 2)
            a.push(parseInt(y[w] + y[w + 1], 16));
      } else
        for (var d = 0, w = 0; w < y.length; w++) {
          var x = y.charCodeAt(w);
          x < 128 ? a[d++] = x : x < 2048 ? (a[d++] = x >> 6 | 192, a[d++] = x & 63 | 128) : r(y, w) ? (x = 65536 + ((x & 1023) << 10) + (y.charCodeAt(++w) & 1023), a[d++] = x >> 18 | 240, a[d++] = x >> 12 & 63 | 128, a[d++] = x >> 6 & 63 | 128, a[d++] = x & 63 | 128) : (a[d++] = x >> 12 | 224, a[d++] = x >> 6 & 63 | 128, a[d++] = x & 63 | 128);
        }
    else
      for (w = 0; w < y.length; w++)
        a[w] = y[w] | 0;
    return a;
  }
  kt.toArray = i;
  function o(y) {
    for (var v = "", a = 0; a < y.length; a++)
      v += u(y[a].toString(16));
    return v;
  }
  kt.toHex = o;
  function n(y) {
    var v = y >>> 24 | y >>> 8 & 65280 | y << 8 & 16711680 | (y & 255) << 24;
    return v >>> 0;
  }
  kt.htonl = n;
  function f(y, v) {
    for (var a = "", d = 0; d < y.length; d++) {
      var w = y[d];
      v === "little" && (w = n(w)), a += c(w.toString(16));
    }
    return a;
  }
  kt.toHex32 = f;
  function u(y) {
    return y.length === 1 ? "0" + y : y;
  }
  kt.zero2 = u;
  function c(y) {
    return y.length === 7 ? "0" + y : y.length === 6 ? "00" + y : y.length === 5 ? "000" + y : y.length === 4 ? "0000" + y : y.length === 3 ? "00000" + y : y.length === 2 ? "000000" + y : y.length === 1 ? "0000000" + y : y;
  }
  kt.zero8 = c;
  function h(y, v, a, d) {
    var w = a - v;
    e(w % 4 === 0);
    for (var x = new Array(w / 4), A = 0, S = v; A < x.length; A++, S += 4) {
      var g;
      d === "big" ? g = y[S] << 24 | y[S + 1] << 16 | y[S + 2] << 8 | y[S + 3] : g = y[S + 3] << 24 | y[S + 2] << 16 | y[S + 1] << 8 | y[S], x[A] = g >>> 0;
    }
    return x;
  }
  kt.join32 = h;
  function s(y, v) {
    for (var a = new Array(y.length * 4), d = 0, w = 0; d < y.length; d++, w += 4) {
      var x = y[d];
      v === "big" ? (a[w] = x >>> 24, a[w + 1] = x >>> 16 & 255, a[w + 2] = x >>> 8 & 255, a[w + 3] = x & 255) : (a[w + 3] = x >>> 24, a[w + 2] = x >>> 16 & 255, a[w + 1] = x >>> 8 & 255, a[w] = x & 255);
    }
    return a;
  }
  kt.split32 = s;
  function b(y, v) {
    return y >>> v | y << 32 - v;
  }
  kt.rotr32 = b;
  function p(y, v) {
    return y << v | y >>> 32 - v;
  }
  kt.rotl32 = p;
  function m(y, v) {
    return y + v >>> 0;
  }
  kt.sum32 = m;
  function E(y, v, a) {
    return y + v + a >>> 0;
  }
  kt.sum32_3 = E;
  function M(y, v, a, d) {
    return y + v + a + d >>> 0;
  }
  kt.sum32_4 = M;
  function I(y, v, a, d, w) {
    return y + v + a + d + w >>> 0;
  }
  kt.sum32_5 = I;
  function B(y, v, a, d) {
    var w = y[v], x = y[v + 1], A = d + x >>> 0, S = (A < d ? 1 : 0) + a + w;
    y[v] = S >>> 0, y[v + 1] = A;
  }
  kt.sum64 = B;
  function T(y, v, a, d) {
    var w = v + d >>> 0, x = (w < v ? 1 : 0) + y + a;
    return x >>> 0;
  }
  kt.sum64_hi = T;
  function j(y, v, a, d) {
    var w = v + d;
    return w >>> 0;
  }
  kt.sum64_lo = j;
  function N(y, v, a, d, w, x, A, S) {
    var g = 0, _ = v;
    _ = _ + d >>> 0, g += _ < v ? 1 : 0, _ = _ + x >>> 0, g += _ < x ? 1 : 0, _ = _ + S >>> 0, g += _ < S ? 1 : 0;
    var l = y + a + w + A + g;
    return l >>> 0;
  }
  kt.sum64_4_hi = N;
  function k(y, v, a, d, w, x, A, S) {
    var g = v + d + x + S;
    return g >>> 0;
  }
  kt.sum64_4_lo = k;
  function q(y, v, a, d, w, x, A, S, g, _) {
    var l = 0, R = v;
    R = R + d >>> 0, l += R < v ? 1 : 0, R = R + x >>> 0, l += R < x ? 1 : 0, R = R + S >>> 0, l += R < S ? 1 : 0, R = R + _ >>> 0, l += R < _ ? 1 : 0;
    var Y = y + a + w + A + g + l;
    return Y >>> 0;
  }
  kt.sum64_5_hi = q;
  function $(y, v, a, d, w, x, A, S, g, _) {
    var l = v + d + x + S + _;
    return l >>> 0;
  }
  kt.sum64_5_lo = $;
  function re(y, v, a) {
    var d = v << 32 - a | y >>> a;
    return d >>> 0;
  }
  kt.rotr64_hi = re;
  function Q(y, v, a) {
    var d = y << 32 - a | v >>> a;
    return d >>> 0;
  }
  kt.rotr64_lo = Q;
  function fe(y, v, a) {
    return y >>> a;
  }
  kt.shr64_hi = fe;
  function U(y, v, a) {
    var d = y << 32 - a | v >>> a;
    return d >>> 0;
  }
  return kt.shr64_lo = U, kt;
}
var Vu = {}, gp;
function Sa() {
  if (gp)
    return Vu;
  gp = 1;
  var e = sn(), t = qr();
  function r() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return Vu.BlockHash = r, r.prototype.update = function(o, n) {
    if (o = e.toArray(o, n), this.pending ? this.pending = this.pending.concat(o) : this.pending = o, this.pendingTotal += o.length, this.pending.length >= this._delta8) {
      o = this.pending;
      var f = o.length % this._delta8;
      this.pending = o.slice(o.length - f, o.length), this.pending.length === 0 && (this.pending = null), o = e.join32(o, 0, o.length - f, this.endian);
      for (var u = 0; u < o.length; u += this._delta32)
        this._update(o, u, u + this._delta32);
    }
    return this;
  }, r.prototype.digest = function(o) {
    return this.update(this._pad()), t(this.pending === null), this._digest(o);
  }, r.prototype._pad = function() {
    var o = this.pendingTotal, n = this._delta8, f = n - (o + this.padLength) % n, u = new Array(f + this.padLength);
    u[0] = 128;
    for (var c = 1; c < f; c++)
      u[c] = 0;
    if (o <<= 3, this.endian === "big") {
      for (var h = 8; h < this.padLength; h++)
        u[c++] = 0;
      u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = o >>> 24 & 255, u[c++] = o >>> 16 & 255, u[c++] = o >>> 8 & 255, u[c++] = o & 255;
    } else
      for (u[c++] = o & 255, u[c++] = o >>> 8 & 255, u[c++] = o >>> 16 & 255, u[c++] = o >>> 24 & 255, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, h = 8; h < this.padLength; h++)
        u[c++] = 0;
    return u;
  }, Vu;
}
var Dn = {}, Jr = {}, mp;
function cg() {
  if (mp)
    return Jr;
  mp = 1;
  var e = sn(), t = e.rotr32;
  function r(s, b, p, m) {
    if (s === 0)
      return i(b, p, m);
    if (s === 1 || s === 3)
      return n(b, p, m);
    if (s === 2)
      return o(b, p, m);
  }
  Jr.ft_1 = r;
  function i(s, b, p) {
    return s & b ^ ~s & p;
  }
  Jr.ch32 = i;
  function o(s, b, p) {
    return s & b ^ s & p ^ b & p;
  }
  Jr.maj32 = o;
  function n(s, b, p) {
    return s ^ b ^ p;
  }
  Jr.p32 = n;
  function f(s) {
    return t(s, 2) ^ t(s, 13) ^ t(s, 22);
  }
  Jr.s0_256 = f;
  function u(s) {
    return t(s, 6) ^ t(s, 11) ^ t(s, 25);
  }
  Jr.s1_256 = u;
  function c(s) {
    return t(s, 7) ^ t(s, 18) ^ s >>> 3;
  }
  Jr.g0_256 = c;
  function h(s) {
    return t(s, 17) ^ t(s, 19) ^ s >>> 10;
  }
  return Jr.g1_256 = h, Jr;
}
var Wu, wp;
function b7() {
  if (wp)
    return Wu;
  wp = 1;
  var e = sn(), t = Sa(), r = cg(), i = e.rotl32, o = e.sum32, n = e.sum32_5, f = r.ft_1, u = t.BlockHash, c = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function h() {
    if (!(this instanceof h))
      return new h();
    u.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(h, u), Wu = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(b, p) {
    for (var m = this.W, E = 0; E < 16; E++)
      m[E] = b[p + E];
    for (; E < m.length; E++)
      m[E] = i(m[E - 3] ^ m[E - 8] ^ m[E - 14] ^ m[E - 16], 1);
    var M = this.h[0], I = this.h[1], B = this.h[2], T = this.h[3], j = this.h[4];
    for (E = 0; E < m.length; E++) {
      var N = ~~(E / 20), k = n(i(M, 5), f(N, I, B, T), j, m[E], c[N]);
      j = T, T = B, B = i(I, 30), I = M, M = k;
    }
    this.h[0] = o(this.h[0], M), this.h[1] = o(this.h[1], I), this.h[2] = o(this.h[2], B), this.h[3] = o(this.h[3], T), this.h[4] = o(this.h[4], j);
  }, h.prototype._digest = function(b) {
    return b === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, Wu;
}
var Ku, _p;
function hg() {
  if (_p)
    return Ku;
  _p = 1;
  var e = sn(), t = Sa(), r = cg(), i = qr(), o = e.sum32, n = e.sum32_4, f = e.sum32_5, u = r.ch32, c = r.maj32, h = r.s0_256, s = r.s1_256, b = r.g0_256, p = r.g1_256, m = t.BlockHash, E = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function M() {
    if (!(this instanceof M))
      return new M();
    m.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = E, this.W = new Array(64);
  }
  return e.inherits(M, m), Ku = M, M.blockSize = 512, M.outSize = 256, M.hmacStrength = 192, M.padLength = 64, M.prototype._update = function(B, T) {
    for (var j = this.W, N = 0; N < 16; N++)
      j[N] = B[T + N];
    for (; N < j.length; N++)
      j[N] = n(p(j[N - 2]), j[N - 7], b(j[N - 15]), j[N - 16]);
    var k = this.h[0], q = this.h[1], $ = this.h[2], re = this.h[3], Q = this.h[4], fe = this.h[5], U = this.h[6], y = this.h[7];
    for (i(this.k.length === j.length), N = 0; N < j.length; N++) {
      var v = f(y, s(Q), u(Q, fe, U), this.k[N], j[N]), a = o(h(k), c(k, q, $));
      y = U, U = fe, fe = Q, Q = o(re, v), re = $, $ = q, q = k, k = o(v, a);
    }
    this.h[0] = o(this.h[0], k), this.h[1] = o(this.h[1], q), this.h[2] = o(this.h[2], $), this.h[3] = o(this.h[3], re), this.h[4] = o(this.h[4], Q), this.h[5] = o(this.h[5], fe), this.h[6] = o(this.h[6], U), this.h[7] = o(this.h[7], y);
  }, M.prototype._digest = function(B) {
    return B === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, Ku;
}
var Zu, xp;
function y7() {
  if (xp)
    return Zu;
  xp = 1;
  var e = sn(), t = hg();
  function r() {
    if (!(this instanceof r))
      return new r();
    t.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(r, t), Zu = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(o) {
    return o === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, Zu;
}
var Gu, Ep;
function lg() {
  if (Ep)
    return Gu;
  Ep = 1;
  var e = sn(), t = Sa(), r = qr(), i = e.rotr64_hi, o = e.rotr64_lo, n = e.shr64_hi, f = e.shr64_lo, u = e.sum64, c = e.sum64_hi, h = e.sum64_lo, s = e.sum64_4_hi, b = e.sum64_4_lo, p = e.sum64_5_hi, m = e.sum64_5_lo, E = t.BlockHash, M = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function I() {
    if (!(this instanceof I))
      return new I();
    E.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = M, this.W = new Array(160);
  }
  e.inherits(I, E), Gu = I, I.blockSize = 1024, I.outSize = 512, I.hmacStrength = 192, I.padLength = 128, I.prototype._prepareBlock = function(a, d) {
    for (var w = this.W, x = 0; x < 32; x++)
      w[x] = a[d + x];
    for (; x < w.length; x += 2) {
      var A = U(w[x - 4], w[x - 3]), S = y(w[x - 4], w[x - 3]), g = w[x - 14], _ = w[x - 13], l = Q(w[x - 30], w[x - 29]), R = fe(w[x - 30], w[x - 29]), Y = w[x - 32], oe = w[x - 31];
      w[x] = s(
        A,
        S,
        g,
        _,
        l,
        R,
        Y,
        oe
      ), w[x + 1] = b(
        A,
        S,
        g,
        _,
        l,
        R,
        Y,
        oe
      );
    }
  }, I.prototype._update = function(a, d) {
    this._prepareBlock(a, d);
    var w = this.W, x = this.h[0], A = this.h[1], S = this.h[2], g = this.h[3], _ = this.h[4], l = this.h[5], R = this.h[6], Y = this.h[7], oe = this.h[8], H = this.h[9], V = this.h[10], F = this.h[11], te = this.h[12], he = this.h[13], K = this.h[14], W = this.h[15];
    r(this.k.length === w.length);
    for (var ce = 0; ce < w.length; ce += 2) {
      var ve = K, Be = W, ee = $(oe, H), C = re(oe, H), L = B(oe, H, V, F, te), Z = T(oe, H, V, F, te, he), de = this.k[ce], me = this.k[ce + 1], Te = w[ce], ze = w[ce + 1], z = p(
        ve,
        Be,
        ee,
        C,
        L,
        Z,
        de,
        me,
        Te,
        ze
      ), ue = m(
        ve,
        Be,
        ee,
        C,
        L,
        Z,
        de,
        me,
        Te,
        ze
      );
      ve = k(x, A), Be = q(x, A), ee = j(x, A, S, g, _), C = N(x, A, S, g, _, l);
      var se = c(ve, Be, ee, C), _e = h(ve, Be, ee, C);
      K = te, W = he, te = V, he = F, V = oe, F = H, oe = c(R, Y, z, ue), H = h(Y, Y, z, ue), R = _, Y = l, _ = S, l = g, S = x, g = A, x = c(z, ue, se, _e), A = h(z, ue, se, _e);
    }
    u(this.h, 0, x, A), u(this.h, 2, S, g), u(this.h, 4, _, l), u(this.h, 6, R, Y), u(this.h, 8, oe, H), u(this.h, 10, V, F), u(this.h, 12, te, he), u(this.h, 14, K, W);
  }, I.prototype._digest = function(a) {
    return a === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function B(v, a, d, w, x) {
    var A = v & d ^ ~v & x;
    return A < 0 && (A += 4294967296), A;
  }
  function T(v, a, d, w, x, A) {
    var S = a & w ^ ~a & A;
    return S < 0 && (S += 4294967296), S;
  }
  function j(v, a, d, w, x) {
    var A = v & d ^ v & x ^ d & x;
    return A < 0 && (A += 4294967296), A;
  }
  function N(v, a, d, w, x, A) {
    var S = a & w ^ a & A ^ w & A;
    return S < 0 && (S += 4294967296), S;
  }
  function k(v, a) {
    var d = i(v, a, 28), w = i(a, v, 2), x = i(a, v, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function q(v, a) {
    var d = o(v, a, 28), w = o(a, v, 2), x = o(a, v, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function $(v, a) {
    var d = i(v, a, 14), w = i(v, a, 18), x = i(a, v, 9), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function re(v, a) {
    var d = o(v, a, 14), w = o(v, a, 18), x = o(a, v, 9), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function Q(v, a) {
    var d = i(v, a, 1), w = i(v, a, 8), x = n(v, a, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function fe(v, a) {
    var d = o(v, a, 1), w = o(v, a, 8), x = f(v, a, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function U(v, a) {
    var d = i(v, a, 19), w = i(a, v, 29), x = n(v, a, 6), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function y(v, a) {
    var d = o(v, a, 19), w = o(a, v, 29), x = f(v, a, 6), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  return Gu;
}
var Ju, Sp;
function g7() {
  if (Sp)
    return Ju;
  Sp = 1;
  var e = sn(), t = lg();
  function r() {
    if (!(this instanceof r))
      return new r();
    t.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(r, t), Ju = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(o) {
    return o === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, Ju;
}
var Ap;
function m7() {
  return Ap || (Ap = 1, Dn.sha1 = b7(), Dn.sha224 = y7(), Dn.sha256 = hg(), Dn.sha384 = g7(), Dn.sha512 = lg()), Dn;
}
var Xu = {}, Mp;
function w7() {
  if (Mp)
    return Xu;
  Mp = 1;
  var e = sn(), t = Sa(), r = e.rotl32, i = e.sum32, o = e.sum32_3, n = e.sum32_4, f = t.BlockHash;
  function u() {
    if (!(this instanceof u))
      return new u();
    f.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(u, f), Xu.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(I, B) {
    for (var T = this.h[0], j = this.h[1], N = this.h[2], k = this.h[3], q = this.h[4], $ = T, re = j, Q = N, fe = k, U = q, y = 0; y < 80; y++) {
      var v = i(
        r(
          n(T, c(y, j, N, k), I[b[y] + B], h(y)),
          m[y]
        ),
        q
      );
      T = q, q = k, k = r(N, 10), N = j, j = v, v = i(
        r(
          n($, c(79 - y, re, Q, fe), I[p[y] + B], s(y)),
          E[y]
        ),
        U
      ), $ = U, U = fe, fe = r(Q, 10), Q = re, re = v;
    }
    v = o(this.h[1], N, fe), this.h[1] = o(this.h[2], k, U), this.h[2] = o(this.h[3], q, $), this.h[3] = o(this.h[4], T, re), this.h[4] = o(this.h[0], j, Q), this.h[0] = v;
  }, u.prototype._digest = function(I) {
    return I === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function c(M, I, B, T) {
    return M <= 15 ? I ^ B ^ T : M <= 31 ? I & B | ~I & T : M <= 47 ? (I | ~B) ^ T : M <= 63 ? I & T | B & ~T : I ^ (B | ~T);
  }
  function h(M) {
    return M <= 15 ? 0 : M <= 31 ? 1518500249 : M <= 47 ? 1859775393 : M <= 63 ? 2400959708 : 2840853838;
  }
  function s(M) {
    return M <= 15 ? 1352829926 : M <= 31 ? 1548603684 : M <= 47 ? 1836072691 : M <= 63 ? 2053994217 : 0;
  }
  var b = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], p = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], m = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], E = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return Xu;
}
var Yu, Rp;
function _7() {
  if (Rp)
    return Yu;
  Rp = 1;
  var e = sn(), t = qr();
  function r(i, o, n) {
    if (!(this instanceof r))
      return new r(i, o, n);
    this.Hash = i, this.blockSize = i.blockSize / 8, this.outSize = i.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(o, n));
  }
  return Yu = r, r.prototype._init = function(o) {
    o.length > this.blockSize && (o = new this.Hash().update(o).digest()), t(o.length <= this.blockSize);
    for (var n = o.length; n < this.blockSize; n++)
      o.push(0);
    for (n = 0; n < o.length; n++)
      o[n] ^= 54;
    for (this.inner = new this.Hash().update(o), n = 0; n < o.length; n++)
      o[n] ^= 106;
    this.outer = new this.Hash().update(o);
  }, r.prototype.update = function(o, n) {
    return this.inner.update(o, n), this;
  }, r.prototype.digest = function(o) {
    return this.outer.update(this.inner.digest()), this.outer.digest(o);
  }, Yu;
}
var Bp;
function l0() {
  return Bp || (Bp = 1, function(e) {
    var t = e;
    t.utils = sn(), t.common = Sa(), t.sha = m7(), t.ripemd = w7(), t.hmac = _7(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
  }(Hu)), Hu;
}
var Qu, Ip;
function x7() {
  return Ip || (Ip = 1, Qu = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), Qu;
}
var Tp;
function d0() {
  return Tp || (Tp = 1, function(e) {
    var t = e, r = l0(), i = ug(), o = Dr(), n = o.assert;
    function f(h) {
      h.type === "short" ? this.curve = new i.short(h) : h.type === "edwards" ? this.curve = new i.edwards(h) : this.curve = new i.mont(h), this.g = this.curve.g, this.n = this.curve.n, this.hash = h.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = f;
    function u(h, s) {
      Object.defineProperty(t, h, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var b = new f(s);
          return Object.defineProperty(t, h, {
            configurable: !0,
            enumerable: !0,
            value: b
          }), b;
        }
      });
    }
    u("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: r.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), u("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: r.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), u("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: r.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), u("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: r.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), u("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: r.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), u("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: r.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), u("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: r.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var c;
    try {
      c = x7();
    } catch {
      c = void 0;
    }
    u("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: r.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        c
      ]
    });
  }(zu)), zu;
}
var ec, Op;
function E7() {
  if (Op)
    return ec;
  Op = 1;
  var e = l0(), t = sg(), r = qr();
  function i(o) {
    if (!(this instanceof i))
      return new i(o);
    this.hash = o.hash, this.predResist = !!o.predResist, this.outLen = this.hash.outSize, this.minEntropy = o.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var n = t.toArray(o.entropy, o.entropyEnc || "hex"), f = t.toArray(o.nonce, o.nonceEnc || "hex"), u = t.toArray(o.pers, o.persEnc || "hex");
    r(
      n.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(n, f, u);
  }
  return ec = i, i.prototype._init = function(n, f, u) {
    var c = n.concat(f).concat(u);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var h = 0; h < this.V.length; h++)
      this.K[h] = 0, this.V[h] = 1;
    this._update(c), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, i.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, i.prototype._update = function(n) {
    var f = this._hmac().update(this.V).update([0]);
    n && (f = f.update(n)), this.K = f.digest(), this.V = this._hmac().update(this.V).digest(), n && (this.K = this._hmac().update(this.V).update([1]).update(n).digest(), this.V = this._hmac().update(this.V).digest());
  }, i.prototype.reseed = function(n, f, u, c) {
    typeof f != "string" && (c = u, u = f, f = null), n = t.toArray(n, f), u = t.toArray(u, c), r(
      n.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(n.concat(u || [])), this._reseed = 1;
  }, i.prototype.generate = function(n, f, u, c) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof f != "string" && (c = u, u = f, f = null), u && (u = t.toArray(u, c || "hex"), this._update(u));
    for (var h = []; h.length < n; )
      this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
    var s = h.slice(0, n);
    return this._update(u), this._reseed++, t.encode(s, f);
  }, ec;
}
var tc, Pp;
function S7() {
  if (Pp)
    return tc;
  Pp = 1;
  var e = tr, t = Dr(), r = t.assert;
  function i(o, n) {
    this.ec = o, this.priv = null, this.pub = null, n.priv && this._importPrivate(n.priv, n.privEnc), n.pub && this._importPublic(n.pub, n.pubEnc);
  }
  return tc = i, i.fromPublic = function(n, f, u) {
    return f instanceof i ? f : new i(n, {
      pub: f,
      pubEnc: u
    });
  }, i.fromPrivate = function(n, f, u) {
    return f instanceof i ? f : new i(n, {
      priv: f,
      privEnc: u
    });
  }, i.prototype.validate = function() {
    var n = this.getPublic();
    return n.isInfinity() ? { result: !1, reason: "Invalid public key" } : n.validate() ? n.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, i.prototype.getPublic = function(n, f) {
    return typeof n == "string" && (f = n, n = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), f ? this.pub.encode(f, n) : this.pub;
  }, i.prototype.getPrivate = function(n) {
    return n === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, i.prototype._importPrivate = function(n, f) {
    this.priv = new e(n, f || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, i.prototype._importPublic = function(n, f) {
    if (n.x || n.y) {
      this.ec.curve.type === "mont" ? r(n.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && r(n.x && n.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(n.x, n.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(n, f);
  }, i.prototype.derive = function(n) {
    return n.validate() || r(n.validate(), "public point not validated"), n.mul(this.priv).getX();
  }, i.prototype.sign = function(n, f, u) {
    return this.ec.sign(n, this, f, u);
  }, i.prototype.verify = function(n, f) {
    return this.ec.verify(n, f, this);
  }, i.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, tc;
}
var rc, Cp;
function A7() {
  if (Cp)
    return rc;
  Cp = 1;
  var e = tr, t = Dr(), r = t.assert;
  function i(c, h) {
    if (c instanceof i)
      return c;
    this._importDER(c, h) || (r(c.r && c.s, "Signature without r or s"), this.r = new e(c.r, 16), this.s = new e(c.s, 16), c.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = c.recoveryParam);
  }
  rc = i;
  function o() {
    this.place = 0;
  }
  function n(c, h) {
    var s = c[h.place++];
    if (!(s & 128))
      return s;
    var b = s & 15;
    if (b === 0 || b > 4)
      return !1;
    for (var p = 0, m = 0, E = h.place; m < b; m++, E++)
      p <<= 8, p |= c[E], p >>>= 0;
    return p <= 127 ? !1 : (h.place = E, p);
  }
  function f(c) {
    for (var h = 0, s = c.length - 1; !c[h] && !(c[h + 1] & 128) && h < s; )
      h++;
    return h === 0 ? c : c.slice(h);
  }
  i.prototype._importDER = function(h, s) {
    h = t.toArray(h, s);
    var b = new o();
    if (h[b.place++] !== 48)
      return !1;
    var p = n(h, b);
    if (p === !1 || p + b.place !== h.length || h[b.place++] !== 2)
      return !1;
    var m = n(h, b);
    if (m === !1)
      return !1;
    var E = h.slice(b.place, m + b.place);
    if (b.place += m, h[b.place++] !== 2)
      return !1;
    var M = n(h, b);
    if (M === !1 || h.length !== M + b.place)
      return !1;
    var I = h.slice(b.place, M + b.place);
    if (E[0] === 0)
      if (E[1] & 128)
        E = E.slice(1);
      else
        return !1;
    if (I[0] === 0)
      if (I[1] & 128)
        I = I.slice(1);
      else
        return !1;
    return this.r = new e(E), this.s = new e(I), this.recoveryParam = null, !0;
  };
  function u(c, h) {
    if (h < 128) {
      c.push(h);
      return;
    }
    var s = 1 + (Math.log(h) / Math.LN2 >>> 3);
    for (c.push(s | 128); --s; )
      c.push(h >>> (s << 3) & 255);
    c.push(h);
  }
  return i.prototype.toDER = function(h) {
    var s = this.r.toArray(), b = this.s.toArray();
    for (s[0] & 128 && (s = [0].concat(s)), b[0] & 128 && (b = [0].concat(b)), s = f(s), b = f(b); !b[0] && !(b[1] & 128); )
      b = b.slice(1);
    var p = [2];
    u(p, s.length), p = p.concat(s), p.push(2), u(p, b.length);
    var m = p.concat(b), E = [48];
    return u(E, m.length), E = E.concat(m), t.encode(E, h);
  }, rc;
}
var nc, Np;
function M7() {
  if (Np)
    return nc;
  Np = 1;
  var e = tr, t = E7(), r = Dr(), i = d0(), o = c0(), n = r.assert, f = S7(), u = A7();
  function c(h) {
    if (!(this instanceof c))
      return new c(h);
    typeof h == "string" && (n(
      Object.prototype.hasOwnProperty.call(i, h),
      "Unknown curve " + h
    ), h = i[h]), h instanceof i.PresetCurve && (h = { curve: h }), this.curve = h.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = h.curve.g, this.g.precompute(h.curve.n.bitLength() + 1), this.hash = h.hash || h.curve.hash;
  }
  return nc = c, c.prototype.keyPair = function(s) {
    return new f(this, s);
  }, c.prototype.keyFromPrivate = function(s, b) {
    return f.fromPrivate(this, s, b);
  }, c.prototype.keyFromPublic = function(s, b) {
    return f.fromPublic(this, s, b);
  }, c.prototype.genKeyPair = function(s) {
    s || (s = {});
    for (var b = new t({
      hash: this.hash,
      pers: s.pers,
      persEnc: s.persEnc || "utf8",
      entropy: s.entropy || o(this.hash.hmacStrength),
      entropyEnc: s.entropy && s.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), p = this.n.byteLength(), m = this.n.sub(new e(2)); ; ) {
      var E = new e(b.generate(p));
      if (!(E.cmp(m) > 0))
        return E.iaddn(1), this.keyFromPrivate(E);
    }
  }, c.prototype._truncateToN = function(s, b) {
    var p = s.byteLength() * 8 - this.n.bitLength();
    return p > 0 && (s = s.ushrn(p)), !b && s.cmp(this.n) >= 0 ? s.sub(this.n) : s;
  }, c.prototype.sign = function(s, b, p, m) {
    typeof p == "object" && (m = p, p = null), m || (m = {}), b = this.keyFromPrivate(b, p), s = this._truncateToN(new e(s, 16));
    for (var E = this.n.byteLength(), M = b.getPrivate().toArray("be", E), I = s.toArray("be", E), B = new t({
      hash: this.hash,
      entropy: M,
      nonce: I,
      pers: m.pers,
      persEnc: m.persEnc || "utf8"
    }), T = this.n.sub(new e(1)), j = 0; ; j++) {
      var N = m.k ? m.k(j) : new e(B.generate(this.n.byteLength()));
      if (N = this._truncateToN(N, !0), !(N.cmpn(1) <= 0 || N.cmp(T) >= 0)) {
        var k = this.g.mul(N);
        if (!k.isInfinity()) {
          var q = k.getX(), $ = q.umod(this.n);
          if ($.cmpn(0) !== 0) {
            var re = N.invm(this.n).mul($.mul(b.getPrivate()).iadd(s));
            if (re = re.umod(this.n), re.cmpn(0) !== 0) {
              var Q = (k.getY().isOdd() ? 1 : 0) | (q.cmp($) !== 0 ? 2 : 0);
              return m.canonical && re.cmp(this.nh) > 0 && (re = this.n.sub(re), Q ^= 1), new u({ r: $, s: re, recoveryParam: Q });
            }
          }
        }
      }
    }
  }, c.prototype.verify = function(s, b, p, m) {
    s = this._truncateToN(new e(s, 16)), p = this.keyFromPublic(p, m), b = new u(b, "hex");
    var E = b.r, M = b.s;
    if (E.cmpn(1) < 0 || E.cmp(this.n) >= 0 || M.cmpn(1) < 0 || M.cmp(this.n) >= 0)
      return !1;
    var I = M.invm(this.n), B = I.mul(s).umod(this.n), T = I.mul(E).umod(this.n), j;
    return this.curve._maxwellTrick ? (j = this.g.jmulAdd(B, p.getPublic(), T), j.isInfinity() ? !1 : j.eqXToP(E)) : (j = this.g.mulAdd(B, p.getPublic(), T), j.isInfinity() ? !1 : j.getX().umod(this.n).cmp(E) === 0);
  }, c.prototype.recoverPubKey = function(h, s, b, p) {
    n((3 & b) === b, "The recovery param is more than two bits"), s = new u(s, p);
    var m = this.n, E = new e(h), M = s.r, I = s.s, B = b & 1, T = b >> 1;
    if (M.cmp(this.curve.p.umod(this.curve.n)) >= 0 && T)
      throw new Error("Unable to find sencond key candinate");
    T ? M = this.curve.pointFromX(M.add(this.curve.n), B) : M = this.curve.pointFromX(M, B);
    var j = s.r.invm(m), N = m.sub(E).mul(j).umod(m), k = I.mul(j).umod(m);
    return this.g.mulAdd(N, M, k);
  }, c.prototype.getKeyRecoveryParam = function(h, s, b, p) {
    if (s = new u(s, p), s.recoveryParam !== null)
      return s.recoveryParam;
    for (var m = 0; m < 4; m++) {
      var E;
      try {
        E = this.recoverPubKey(h, s, m);
      } catch {
        continue;
      }
      if (E.eq(b))
        return m;
    }
    throw new Error("Unable to find valid recovery factor");
  }, nc;
}
var ic, Lp;
function R7() {
  if (Lp)
    return ic;
  Lp = 1;
  var e = Dr(), t = e.assert, r = e.parseBytes, i = e.cachedProperty;
  function o(n, f) {
    this.eddsa = n, this._secret = r(f.secret), n.isPoint(f.pub) ? this._pub = f.pub : this._pubBytes = r(f.pub);
  }
  return o.fromPublic = function(f, u) {
    return u instanceof o ? u : new o(f, { pub: u });
  }, o.fromSecret = function(f, u) {
    return u instanceof o ? u : new o(f, { secret: u });
  }, o.prototype.secret = function() {
    return this._secret;
  }, i(o, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), i(o, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), i(o, "privBytes", function() {
    var f = this.eddsa, u = this.hash(), c = f.encodingLength - 1, h = u.slice(0, f.encodingLength);
    return h[0] &= 248, h[c] &= 127, h[c] |= 64, h;
  }), i(o, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), i(o, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), i(o, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), o.prototype.sign = function(f) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(f, this);
  }, o.prototype.verify = function(f, u) {
    return this.eddsa.verify(f, u, this);
  }, o.prototype.getSecret = function(f) {
    return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), f);
  }, o.prototype.getPublic = function(f) {
    return e.encode(this.pubBytes(), f);
  }, ic = o, ic;
}
var ac, kp;
function B7() {
  if (kp)
    return ac;
  kp = 1;
  var e = tr, t = Dr(), r = t.assert, i = t.cachedProperty, o = t.parseBytes;
  function n(f, u) {
    this.eddsa = f, typeof u != "object" && (u = o(u)), Array.isArray(u) && (u = {
      R: u.slice(0, f.encodingLength),
      S: u.slice(f.encodingLength)
    }), r(u.R && u.S, "Signature without R or S"), f.isPoint(u.R) && (this._R = u.R), u.S instanceof e && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
  }
  return i(n, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), i(n, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), i(n, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), i(n, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), n.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, n.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, ac = n, ac;
}
var oc, jp;
function I7() {
  if (jp)
    return oc;
  jp = 1;
  var e = l0(), t = d0(), r = Dr(), i = r.assert, o = r.parseBytes, n = R7(), f = B7();
  function u(c) {
    if (i(c === "ed25519", "only tested with ed25519 so far"), !(this instanceof u))
      return new u(c);
    c = t[c].curve, this.curve = c, this.g = c.g, this.g.precompute(c.n.bitLength() + 1), this.pointClass = c.point().constructor, this.encodingLength = Math.ceil(c.n.bitLength() / 8), this.hash = e.sha512;
  }
  return oc = u, u.prototype.sign = function(h, s) {
    h = o(h);
    var b = this.keyFromSecret(s), p = this.hashInt(b.messagePrefix(), h), m = this.g.mul(p), E = this.encodePoint(m), M = this.hashInt(E, b.pubBytes(), h).mul(b.priv()), I = p.add(M).umod(this.curve.n);
    return this.makeSignature({ R: m, S: I, Rencoded: E });
  }, u.prototype.verify = function(h, s, b) {
    h = o(h), s = this.makeSignature(s);
    var p = this.keyFromPublic(b), m = this.hashInt(s.Rencoded(), p.pubBytes(), h), E = this.g.mul(s.S()), M = s.R().add(p.pub().mul(m));
    return M.eq(E);
  }, u.prototype.hashInt = function() {
    for (var h = this.hash(), s = 0; s < arguments.length; s++)
      h.update(arguments[s]);
    return r.intFromLE(h.digest()).umod(this.curve.n);
  }, u.prototype.keyFromPublic = function(h) {
    return n.fromPublic(this, h);
  }, u.prototype.keyFromSecret = function(h) {
    return n.fromSecret(this, h);
  }, u.prototype.makeSignature = function(h) {
    return h instanceof f ? h : new f(this, h);
  }, u.prototype.encodePoint = function(h) {
    var s = h.getY().toArray("le", this.encodingLength);
    return s[this.encodingLength - 1] |= h.getX().isOdd() ? 128 : 0, s;
  }, u.prototype.decodePoint = function(h) {
    h = r.parseBytes(h);
    var s = h.length - 1, b = h.slice(0, s).concat(h[s] & -129), p = (h[s] & 128) !== 0, m = r.intFromLE(b);
    return this.curve.pointFromY(m, p);
  }, u.prototype.encodeInt = function(h) {
    return h.toArray("le", this.encodingLength);
  }, u.prototype.decodeInt = function(h) {
    return r.intFromLE(h);
  }, u.prototype.isPoint = function(h) {
    return h instanceof this.pointClass;
  }, oc;
}
var qp;
function p0() {
  return qp || (qp = 1, function(e) {
    var t = e;
    t.version = l7.version, t.utils = Dr(), t.rand = c0(), t.curve = ug(), t.curves = d0(), t.ec = M7(), t.eddsa = I7();
  }(Lu)), Lu;
}
var eo = { exports: {} };
eo.exports;
var Dp;
function dg() {
  return Dp || (Dp = 1, function(e) {
    (function(t, r) {
      function i(v, a) {
        if (!v)
          throw new Error(a || "Assertion failed");
      }
      function o(v, a) {
        v.super_ = a;
        var d = function() {
        };
        d.prototype = a.prototype, v.prototype = new d(), v.prototype.constructor = v;
      }
      function n(v, a, d) {
        if (n.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((a === "le" || a === "be") && (d = a, a = 10), this._init(v || 0, a || 10, d || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var f;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? f = window.Buffer : f = Le.Buffer;
      } catch {
      }
      n.isBN = function(a) {
        return a instanceof n ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words);
      }, n.max = function(a, d) {
        return a.cmp(d) > 0 ? a : d;
      }, n.min = function(a, d) {
        return a.cmp(d) < 0 ? a : d;
      }, n.prototype._init = function(a, d, w) {
        if (typeof a == "number")
          return this._initNumber(a, d, w);
        if (typeof a == "object")
          return this._initArray(a, d, w);
        d === "hex" && (d = 16), i(d === (d | 0) && d >= 2 && d <= 36), a = a.toString().replace(/\s+/g, "");
        var x = 0;
        a[0] === "-" && (x++, this.negative = 1), x < a.length && (d === 16 ? this._parseHex(a, x, w) : (this._parseBase(a, d, x), w === "le" && this._initArray(this.toArray(), d, w)));
      }, n.prototype._initNumber = function(a, d, w) {
        a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
          a & 67108863,
          a / 67108864 & 67108863
        ], this.length = 2) : (i(a < 9007199254740992), this.words = [
          a & 67108863,
          a / 67108864 & 67108863,
          1
        ], this.length = 3), w === "le" && this._initArray(this.toArray(), d, w);
      }, n.prototype._initArray = function(a, d, w) {
        if (i(typeof a.length == "number"), a.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A, S, g = 0;
        if (w === "be")
          for (x = a.length - 1, A = 0; x >= 0; x -= 3)
            S = a[x] | a[x - 1] << 8 | a[x - 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        else if (w === "le")
          for (x = 0, A = 0; x < a.length; x += 3)
            S = a[x] | a[x + 1] << 8 | a[x + 2] << 16, this.words[A] |= S << g & 67108863, this.words[A + 1] = S >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, A++);
        return this._strip();
      };
      function u(v, a) {
        var d = v.charCodeAt(a);
        if (d >= 48 && d <= 57)
          return d - 48;
        if (d >= 65 && d <= 70)
          return d - 55;
        if (d >= 97 && d <= 102)
          return d - 87;
        i(!1, "Invalid character in " + v);
      }
      function c(v, a, d) {
        var w = u(v, d);
        return d - 1 >= a && (w |= u(v, d - 1) << 4), w;
      }
      n.prototype._parseHex = function(a, d, w) {
        this.length = Math.ceil((a.length - d) / 6), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A = 0, S = 0, g;
        if (w === "be")
          for (x = a.length - 1; x >= d; x -= 2)
            g = c(a, d, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        else {
          var _ = a.length - d;
          for (x = _ % 2 === 0 ? d + 1 : d; x < a.length; x += 2)
            g = c(a, d, x) << A, this.words[S] |= g & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= g >>> 26) : A += 8;
        }
        this._strip();
      };
      function h(v, a, d, w) {
        for (var x = 0, A = 0, S = Math.min(v.length, d), g = a; g < S; g++) {
          var _ = v.charCodeAt(g) - 48;
          x *= w, _ >= 49 ? A = _ - 49 + 10 : _ >= 17 ? A = _ - 17 + 10 : A = _, i(_ >= 0 && A < w, "Invalid character"), x += A;
        }
        return x;
      }
      n.prototype._parseBase = function(a, d, w) {
        this.words = [0], this.length = 1;
        for (var x = 0, A = 1; A <= 67108863; A *= d)
          x++;
        x--, A = A / d | 0;
        for (var S = a.length - w, g = S % x, _ = Math.min(S, S - g) + w, l = 0, R = w; R < _; R += x)
          l = h(a, R, R + x, d), this.imuln(A), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        if (g !== 0) {
          var Y = 1;
          for (l = h(a, R, a.length, d), R = 0; R < g; R++)
            Y *= d;
          this.imuln(Y), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        }
        this._strip();
      }, n.prototype.copy = function(a) {
        a.words = new Array(this.length);
        for (var d = 0; d < this.length; d++)
          a.words[d] = this.words[d];
        a.length = this.length, a.negative = this.negative, a.red = this.red;
      };
      function s(v, a) {
        v.words = a.words, v.length = a.length, v.negative = a.negative, v.red = a.red;
      }
      if (n.prototype._move = function(a) {
        s(a, this);
      }, n.prototype.clone = function() {
        var a = new n(null);
        return this.copy(a), a;
      }, n.prototype._expand = function(a) {
        for (; this.length < a; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = b;
        } catch {
          n.prototype.inspect = b;
        }
      else
        n.prototype.inspect = b;
      function b() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var p = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], E = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(a, d) {
        a = a || 10, d = d | 0 || 1;
        var w;
        if (a === 16 || a === "hex") {
          w = "";
          for (var x = 0, A = 0, S = 0; S < this.length; S++) {
            var g = this.words[S], _ = ((g << x | A) & 16777215).toString(16);
            A = g >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), A !== 0 || S !== this.length - 1 ? w = p[6 - _.length] + _ + w : w = _ + w;
          }
          for (A !== 0 && (w = A.toString(16) + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        if (a === (a | 0) && a >= 2 && a <= 36) {
          var l = m[a], R = E[a];
          w = "";
          var Y = this.clone();
          for (Y.negative = 0; !Y.isZero(); ) {
            var oe = Y.modrn(R).toString(a);
            Y = Y.idivn(R), Y.isZero() ? w = oe + w : w = p[l - oe.length] + oe + w;
          }
          for (this.isZero() && (w = "0" + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        i(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var a = this.words[0];
        return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, f && (n.prototype.toBuffer = function(a, d) {
        return this.toArrayLike(f, a, d);
      }), n.prototype.toArray = function(a, d) {
        return this.toArrayLike(Array, a, d);
      };
      var M = function(a, d) {
        return a.allocUnsafe ? a.allocUnsafe(d) : new a(d);
      };
      n.prototype.toArrayLike = function(a, d, w) {
        this._strip();
        var x = this.byteLength(), A = w || Math.max(1, x);
        i(x <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var S = M(a, A), g = d === "le" ? "LE" : "BE";
        return this["_toArrayLike" + g](S, x), S;
      }, n.prototype._toArrayLikeLE = function(a, d) {
        for (var w = 0, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[w++] = g & 255, w < a.length && (a[w++] = g >> 8 & 255), w < a.length && (a[w++] = g >> 16 & 255), S === 6 ? (w < a.length && (a[w++] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (w < a.length)
          for (a[w++] = x; w < a.length; )
            a[w++] = 0;
      }, n.prototype._toArrayLikeBE = function(a, d) {
        for (var w = a.length - 1, x = 0, A = 0, S = 0; A < this.length; A++) {
          var g = this.words[A] << S | x;
          a[w--] = g & 255, w >= 0 && (a[w--] = g >> 8 & 255), w >= 0 && (a[w--] = g >> 16 & 255), S === 6 ? (w >= 0 && (a[w--] = g >> 24 & 255), x = 0, S = 0) : (x = g >>> 24, S += 2);
        }
        if (w >= 0)
          for (a[w--] = x; w >= 0; )
            a[w--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(a) {
        return 32 - Math.clz32(a);
      } : n.prototype._countBits = function(a) {
        var d = a, w = 0;
        return d >= 4096 && (w += 13, d >>>= 13), d >= 64 && (w += 7, d >>>= 7), d >= 8 && (w += 4, d >>>= 4), d >= 2 && (w += 2, d >>>= 2), w + d;
      }, n.prototype._zeroBits = function(a) {
        if (a === 0)
          return 26;
        var d = a, w = 0;
        return d & 8191 || (w += 13, d >>>= 13), d & 127 || (w += 7, d >>>= 7), d & 15 || (w += 4, d >>>= 4), d & 3 || (w += 2, d >>>= 2), d & 1 || w++, w;
      }, n.prototype.bitLength = function() {
        var a = this.words[this.length - 1], d = this._countBits(a);
        return (this.length - 1) * 26 + d;
      };
      function I(v) {
        for (var a = new Array(v.bitLength()), d = 0; d < a.length; d++) {
          var w = d / 26 | 0, x = d % 26;
          a[d] = v.words[w] >>> x & 1;
        }
        return a;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var a = 0, d = 0; d < this.length; d++) {
          var w = this._zeroBits(this.words[d]);
          if (a += w, w !== 26)
            break;
        }
        return a;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(a) {
        return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(a) {
        return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(a) {
        for (; this.length < a.length; )
          this.words[this.length++] = 0;
        for (var d = 0; d < a.length; d++)
          this.words[d] = this.words[d] | a.words[d];
        return this._strip();
      }, n.prototype.ior = function(a) {
        return i((this.negative | a.negative) === 0), this.iuor(a);
      }, n.prototype.or = function(a) {
        return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
      }, n.prototype.uor = function(a) {
        return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
      }, n.prototype.iuand = function(a) {
        var d;
        this.length > a.length ? d = a : d = this;
        for (var w = 0; w < d.length; w++)
          this.words[w] = this.words[w] & a.words[w];
        return this.length = d.length, this._strip();
      }, n.prototype.iand = function(a) {
        return i((this.negative | a.negative) === 0), this.iuand(a);
      }, n.prototype.and = function(a) {
        return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
      }, n.prototype.uand = function(a) {
        return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
      }, n.prototype.iuxor = function(a) {
        var d, w;
        this.length > a.length ? (d = this, w = a) : (d = a, w = this);
        for (var x = 0; x < w.length; x++)
          this.words[x] = d.words[x] ^ w.words[x];
        if (this !== d)
          for (; x < d.length; x++)
            this.words[x] = d.words[x];
        return this.length = d.length, this._strip();
      }, n.prototype.ixor = function(a) {
        return i((this.negative | a.negative) === 0), this.iuxor(a);
      }, n.prototype.xor = function(a) {
        return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
      }, n.prototype.uxor = function(a) {
        return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
      }, n.prototype.inotn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = Math.ceil(a / 26) | 0, w = a % 26;
        this._expand(d), w > 0 && d--;
        for (var x = 0; x < d; x++)
          this.words[x] = ~this.words[x] & 67108863;
        return w > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - w), this._strip();
      }, n.prototype.notn = function(a) {
        return this.clone().inotn(a);
      }, n.prototype.setn = function(a, d) {
        i(typeof a == "number" && a >= 0);
        var w = a / 26 | 0, x = a % 26;
        return this._expand(w + 1), d ? this.words[w] = this.words[w] | 1 << x : this.words[w] = this.words[w] & ~(1 << x), this._strip();
      }, n.prototype.iadd = function(a) {
        var d;
        if (this.negative !== 0 && a.negative === 0)
          return this.negative = 0, d = this.isub(a), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && a.negative !== 0)
          return a.negative = 0, d = this.isub(a), a.negative = 1, d._normSign();
        var w, x;
        this.length > a.length ? (w = this, x = a) : (w = a, x = this);
        for (var A = 0, S = 0; S < x.length; S++)
          d = (w.words[S] | 0) + (x.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        for (; A !== 0 && S < w.length; S++)
          d = (w.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        if (this.length = w.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (w !== this)
          for (; S < w.length; S++)
            this.words[S] = w.words[S];
        return this;
      }, n.prototype.add = function(a) {
        var d;
        return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, d = this.sub(a), a.negative ^= 1, d) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, d = a.sub(this), this.negative = 1, d) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
      }, n.prototype.isub = function(a) {
        if (a.negative !== 0) {
          a.negative = 0;
          var d = this.iadd(a);
          return a.negative = 1, d._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
        var w = this.cmp(a);
        if (w === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var x, A;
        w > 0 ? (x = this, A = a) : (x = a, A = this);
        for (var S = 0, g = 0; g < A.length; g++)
          d = (x.words[g] | 0) - (A.words[g] | 0) + S, S = d >> 26, this.words[g] = d & 67108863;
        for (; S !== 0 && g < x.length; g++)
          d = (x.words[g] | 0) + S, S = d >> 26, this.words[g] = d & 67108863;
        if (S === 0 && g < x.length && x !== this)
          for (; g < x.length; g++)
            this.words[g] = x.words[g];
        return this.length = Math.max(this.length, g), x !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(a) {
        return this.clone().isub(a);
      };
      function B(v, a, d) {
        d.negative = a.negative ^ v.negative;
        var w = v.length + a.length | 0;
        d.length = w, w = w - 1 | 0;
        var x = v.words[0] | 0, A = a.words[0] | 0, S = x * A, g = S & 67108863, _ = S / 67108864 | 0;
        d.words[0] = g;
        for (var l = 1; l < w; l++) {
          for (var R = _ >>> 26, Y = _ & 67108863, oe = Math.min(l, a.length - 1), H = Math.max(0, l - v.length + 1); H <= oe; H++) {
            var V = l - H | 0;
            x = v.words[V] | 0, A = a.words[H] | 0, S = x * A + Y, R += S / 67108864 | 0, Y = S & 67108863;
          }
          d.words[l] = Y | 0, _ = R | 0;
        }
        return _ !== 0 ? d.words[l] = _ | 0 : d.length--, d._strip();
      }
      var T = function(a, d, w) {
        var x = a.words, A = d.words, S = w.words, g = 0, _, l, R, Y = x[0] | 0, oe = Y & 8191, H = Y >>> 13, V = x[1] | 0, F = V & 8191, te = V >>> 13, he = x[2] | 0, K = he & 8191, W = he >>> 13, ce = x[3] | 0, ve = ce & 8191, Be = ce >>> 13, ee = x[4] | 0, C = ee & 8191, L = ee >>> 13, Z = x[5] | 0, de = Z & 8191, me = Z >>> 13, Te = x[6] | 0, ze = Te & 8191, z = Te >>> 13, ue = x[7] | 0, se = ue & 8191, _e = ue >>> 13, Ce = x[8] | 0, Ve = Ce & 8191, ke = Ce >>> 13, X = x[9] | 0, Se = X & 8191, Ae = X >>> 13, qe = A[0] | 0, pe = qe & 8191, Ee = qe >>> 13, G = A[1] | 0, Ie = G & 8191, je = G >>> 13, P = A[2] | 0, Me = P & 8191, be = P >>> 13, ie = A[3] | 0, le = ie & 8191, ge = ie >>> 13, Ge = A[4] | 0, $e = Ge & 8191, Ne = Ge >>> 13, nt = A[5] | 0, st = nt & 8191, Je = nt >>> 13, ft = A[6] | 0, D = ft & 8191, J = ft >>> 13, ne = A[7] | 0, O = ne & 8191, ae = ne >>> 13, we = A[8] | 0, xe = we & 8191, Re = we >>> 13, De = A[9] | 0, He = De & 8191, Ue = De >>> 13;
        w.negative = a.negative ^ d.negative, w.length = 19, _ = Math.imul(oe, pe), l = Math.imul(oe, Ee), l = l + Math.imul(H, pe) | 0, R = Math.imul(H, Ee);
        var yt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, _ = Math.imul(F, pe), l = Math.imul(F, Ee), l = l + Math.imul(te, pe) | 0, R = Math.imul(te, Ee), _ = _ + Math.imul(oe, Ie) | 0, l = l + Math.imul(oe, je) | 0, l = l + Math.imul(H, Ie) | 0, R = R + Math.imul(H, je) | 0;
        var et = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _ = Math.imul(K, pe), l = Math.imul(K, Ee), l = l + Math.imul(W, pe) | 0, R = Math.imul(W, Ee), _ = _ + Math.imul(F, Ie) | 0, l = l + Math.imul(F, je) | 0, l = l + Math.imul(te, Ie) | 0, R = R + Math.imul(te, je) | 0, _ = _ + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, be) | 0, l = l + Math.imul(H, Me) | 0, R = R + Math.imul(H, be) | 0;
        var ut = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, _ = Math.imul(ve, pe), l = Math.imul(ve, Ee), l = l + Math.imul(Be, pe) | 0, R = Math.imul(Be, Ee), _ = _ + Math.imul(K, Ie) | 0, l = l + Math.imul(K, je) | 0, l = l + Math.imul(W, Ie) | 0, R = R + Math.imul(W, je) | 0, _ = _ + Math.imul(F, Me) | 0, l = l + Math.imul(F, be) | 0, l = l + Math.imul(te, Me) | 0, R = R + Math.imul(te, be) | 0, _ = _ + Math.imul(oe, le) | 0, l = l + Math.imul(oe, ge) | 0, l = l + Math.imul(H, le) | 0, R = R + Math.imul(H, ge) | 0;
        var ct = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, _ = Math.imul(C, pe), l = Math.imul(C, Ee), l = l + Math.imul(L, pe) | 0, R = Math.imul(L, Ee), _ = _ + Math.imul(ve, Ie) | 0, l = l + Math.imul(ve, je) | 0, l = l + Math.imul(Be, Ie) | 0, R = R + Math.imul(Be, je) | 0, _ = _ + Math.imul(K, Me) | 0, l = l + Math.imul(K, be) | 0, l = l + Math.imul(W, Me) | 0, R = R + Math.imul(W, be) | 0, _ = _ + Math.imul(F, le) | 0, l = l + Math.imul(F, ge) | 0, l = l + Math.imul(te, le) | 0, R = R + Math.imul(te, ge) | 0, _ = _ + Math.imul(oe, $e) | 0, l = l + Math.imul(oe, Ne) | 0, l = l + Math.imul(H, $e) | 0, R = R + Math.imul(H, Ne) | 0;
        var vt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, _ = Math.imul(de, pe), l = Math.imul(de, Ee), l = l + Math.imul(me, pe) | 0, R = Math.imul(me, Ee), _ = _ + Math.imul(C, Ie) | 0, l = l + Math.imul(C, je) | 0, l = l + Math.imul(L, Ie) | 0, R = R + Math.imul(L, je) | 0, _ = _ + Math.imul(ve, Me) | 0, l = l + Math.imul(ve, be) | 0, l = l + Math.imul(Be, Me) | 0, R = R + Math.imul(Be, be) | 0, _ = _ + Math.imul(K, le) | 0, l = l + Math.imul(K, ge) | 0, l = l + Math.imul(W, le) | 0, R = R + Math.imul(W, ge) | 0, _ = _ + Math.imul(F, $e) | 0, l = l + Math.imul(F, Ne) | 0, l = l + Math.imul(te, $e) | 0, R = R + Math.imul(te, Ne) | 0, _ = _ + Math.imul(oe, st) | 0, l = l + Math.imul(oe, Je) | 0, l = l + Math.imul(H, st) | 0, R = R + Math.imul(H, Je) | 0;
        var pt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, _ = Math.imul(ze, pe), l = Math.imul(ze, Ee), l = l + Math.imul(z, pe) | 0, R = Math.imul(z, Ee), _ = _ + Math.imul(de, Ie) | 0, l = l + Math.imul(de, je) | 0, l = l + Math.imul(me, Ie) | 0, R = R + Math.imul(me, je) | 0, _ = _ + Math.imul(C, Me) | 0, l = l + Math.imul(C, be) | 0, l = l + Math.imul(L, Me) | 0, R = R + Math.imul(L, be) | 0, _ = _ + Math.imul(ve, le) | 0, l = l + Math.imul(ve, ge) | 0, l = l + Math.imul(Be, le) | 0, R = R + Math.imul(Be, ge) | 0, _ = _ + Math.imul(K, $e) | 0, l = l + Math.imul(K, Ne) | 0, l = l + Math.imul(W, $e) | 0, R = R + Math.imul(W, Ne) | 0, _ = _ + Math.imul(F, st) | 0, l = l + Math.imul(F, Je) | 0, l = l + Math.imul(te, st) | 0, R = R + Math.imul(te, Je) | 0, _ = _ + Math.imul(oe, D) | 0, l = l + Math.imul(oe, J) | 0, l = l + Math.imul(H, D) | 0, R = R + Math.imul(H, J) | 0;
        var ht = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, _ = Math.imul(se, pe), l = Math.imul(se, Ee), l = l + Math.imul(_e, pe) | 0, R = Math.imul(_e, Ee), _ = _ + Math.imul(ze, Ie) | 0, l = l + Math.imul(ze, je) | 0, l = l + Math.imul(z, Ie) | 0, R = R + Math.imul(z, je) | 0, _ = _ + Math.imul(de, Me) | 0, l = l + Math.imul(de, be) | 0, l = l + Math.imul(me, Me) | 0, R = R + Math.imul(me, be) | 0, _ = _ + Math.imul(C, le) | 0, l = l + Math.imul(C, ge) | 0, l = l + Math.imul(L, le) | 0, R = R + Math.imul(L, ge) | 0, _ = _ + Math.imul(ve, $e) | 0, l = l + Math.imul(ve, Ne) | 0, l = l + Math.imul(Be, $e) | 0, R = R + Math.imul(Be, Ne) | 0, _ = _ + Math.imul(K, st) | 0, l = l + Math.imul(K, Je) | 0, l = l + Math.imul(W, st) | 0, R = R + Math.imul(W, Je) | 0, _ = _ + Math.imul(F, D) | 0, l = l + Math.imul(F, J) | 0, l = l + Math.imul(te, D) | 0, R = R + Math.imul(te, J) | 0, _ = _ + Math.imul(oe, O) | 0, l = l + Math.imul(oe, ae) | 0, l = l + Math.imul(H, O) | 0, R = R + Math.imul(H, ae) | 0;
        var dt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, _ = Math.imul(Ve, pe), l = Math.imul(Ve, Ee), l = l + Math.imul(ke, pe) | 0, R = Math.imul(ke, Ee), _ = _ + Math.imul(se, Ie) | 0, l = l + Math.imul(se, je) | 0, l = l + Math.imul(_e, Ie) | 0, R = R + Math.imul(_e, je) | 0, _ = _ + Math.imul(ze, Me) | 0, l = l + Math.imul(ze, be) | 0, l = l + Math.imul(z, Me) | 0, R = R + Math.imul(z, be) | 0, _ = _ + Math.imul(de, le) | 0, l = l + Math.imul(de, ge) | 0, l = l + Math.imul(me, le) | 0, R = R + Math.imul(me, ge) | 0, _ = _ + Math.imul(C, $e) | 0, l = l + Math.imul(C, Ne) | 0, l = l + Math.imul(L, $e) | 0, R = R + Math.imul(L, Ne) | 0, _ = _ + Math.imul(ve, st) | 0, l = l + Math.imul(ve, Je) | 0, l = l + Math.imul(Be, st) | 0, R = R + Math.imul(Be, Je) | 0, _ = _ + Math.imul(K, D) | 0, l = l + Math.imul(K, J) | 0, l = l + Math.imul(W, D) | 0, R = R + Math.imul(W, J) | 0, _ = _ + Math.imul(F, O) | 0, l = l + Math.imul(F, ae) | 0, l = l + Math.imul(te, O) | 0, R = R + Math.imul(te, ae) | 0, _ = _ + Math.imul(oe, xe) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(H, xe) | 0, R = R + Math.imul(H, Re) | 0;
        var lt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, _ = Math.imul(Se, pe), l = Math.imul(Se, Ee), l = l + Math.imul(Ae, pe) | 0, R = Math.imul(Ae, Ee), _ = _ + Math.imul(Ve, Ie) | 0, l = l + Math.imul(Ve, je) | 0, l = l + Math.imul(ke, Ie) | 0, R = R + Math.imul(ke, je) | 0, _ = _ + Math.imul(se, Me) | 0, l = l + Math.imul(se, be) | 0, l = l + Math.imul(_e, Me) | 0, R = R + Math.imul(_e, be) | 0, _ = _ + Math.imul(ze, le) | 0, l = l + Math.imul(ze, ge) | 0, l = l + Math.imul(z, le) | 0, R = R + Math.imul(z, ge) | 0, _ = _ + Math.imul(de, $e) | 0, l = l + Math.imul(de, Ne) | 0, l = l + Math.imul(me, $e) | 0, R = R + Math.imul(me, Ne) | 0, _ = _ + Math.imul(C, st) | 0, l = l + Math.imul(C, Je) | 0, l = l + Math.imul(L, st) | 0, R = R + Math.imul(L, Je) | 0, _ = _ + Math.imul(ve, D) | 0, l = l + Math.imul(ve, J) | 0, l = l + Math.imul(Be, D) | 0, R = R + Math.imul(Be, J) | 0, _ = _ + Math.imul(K, O) | 0, l = l + Math.imul(K, ae) | 0, l = l + Math.imul(W, O) | 0, R = R + Math.imul(W, ae) | 0, _ = _ + Math.imul(F, xe) | 0, l = l + Math.imul(F, Re) | 0, l = l + Math.imul(te, xe) | 0, R = R + Math.imul(te, Re) | 0, _ = _ + Math.imul(oe, He) | 0, l = l + Math.imul(oe, Ue) | 0, l = l + Math.imul(H, He) | 0, R = R + Math.imul(H, Ue) | 0;
        var tt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, _ = Math.imul(Se, Ie), l = Math.imul(Se, je), l = l + Math.imul(Ae, Ie) | 0, R = Math.imul(Ae, je), _ = _ + Math.imul(Ve, Me) | 0, l = l + Math.imul(Ve, be) | 0, l = l + Math.imul(ke, Me) | 0, R = R + Math.imul(ke, be) | 0, _ = _ + Math.imul(se, le) | 0, l = l + Math.imul(se, ge) | 0, l = l + Math.imul(_e, le) | 0, R = R + Math.imul(_e, ge) | 0, _ = _ + Math.imul(ze, $e) | 0, l = l + Math.imul(ze, Ne) | 0, l = l + Math.imul(z, $e) | 0, R = R + Math.imul(z, Ne) | 0, _ = _ + Math.imul(de, st) | 0, l = l + Math.imul(de, Je) | 0, l = l + Math.imul(me, st) | 0, R = R + Math.imul(me, Je) | 0, _ = _ + Math.imul(C, D) | 0, l = l + Math.imul(C, J) | 0, l = l + Math.imul(L, D) | 0, R = R + Math.imul(L, J) | 0, _ = _ + Math.imul(ve, O) | 0, l = l + Math.imul(ve, ae) | 0, l = l + Math.imul(Be, O) | 0, R = R + Math.imul(Be, ae) | 0, _ = _ + Math.imul(K, xe) | 0, l = l + Math.imul(K, Re) | 0, l = l + Math.imul(W, xe) | 0, R = R + Math.imul(W, Re) | 0, _ = _ + Math.imul(F, He) | 0, l = l + Math.imul(F, Ue) | 0, l = l + Math.imul(te, He) | 0, R = R + Math.imul(te, Ue) | 0;
        var ot = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, _ = Math.imul(Se, Me), l = Math.imul(Se, be), l = l + Math.imul(Ae, Me) | 0, R = Math.imul(Ae, be), _ = _ + Math.imul(Ve, le) | 0, l = l + Math.imul(Ve, ge) | 0, l = l + Math.imul(ke, le) | 0, R = R + Math.imul(ke, ge) | 0, _ = _ + Math.imul(se, $e) | 0, l = l + Math.imul(se, Ne) | 0, l = l + Math.imul(_e, $e) | 0, R = R + Math.imul(_e, Ne) | 0, _ = _ + Math.imul(ze, st) | 0, l = l + Math.imul(ze, Je) | 0, l = l + Math.imul(z, st) | 0, R = R + Math.imul(z, Je) | 0, _ = _ + Math.imul(de, D) | 0, l = l + Math.imul(de, J) | 0, l = l + Math.imul(me, D) | 0, R = R + Math.imul(me, J) | 0, _ = _ + Math.imul(C, O) | 0, l = l + Math.imul(C, ae) | 0, l = l + Math.imul(L, O) | 0, R = R + Math.imul(L, ae) | 0, _ = _ + Math.imul(ve, xe) | 0, l = l + Math.imul(ve, Re) | 0, l = l + Math.imul(Be, xe) | 0, R = R + Math.imul(Be, Re) | 0, _ = _ + Math.imul(K, He) | 0, l = l + Math.imul(K, Ue) | 0, l = l + Math.imul(W, He) | 0, R = R + Math.imul(W, Ue) | 0;
        var Qe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, _ = Math.imul(Se, le), l = Math.imul(Se, ge), l = l + Math.imul(Ae, le) | 0, R = Math.imul(Ae, ge), _ = _ + Math.imul(Ve, $e) | 0, l = l + Math.imul(Ve, Ne) | 0, l = l + Math.imul(ke, $e) | 0, R = R + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(se, st) | 0, l = l + Math.imul(se, Je) | 0, l = l + Math.imul(_e, st) | 0, R = R + Math.imul(_e, Je) | 0, _ = _ + Math.imul(ze, D) | 0, l = l + Math.imul(ze, J) | 0, l = l + Math.imul(z, D) | 0, R = R + Math.imul(z, J) | 0, _ = _ + Math.imul(de, O) | 0, l = l + Math.imul(de, ae) | 0, l = l + Math.imul(me, O) | 0, R = R + Math.imul(me, ae) | 0, _ = _ + Math.imul(C, xe) | 0, l = l + Math.imul(C, Re) | 0, l = l + Math.imul(L, xe) | 0, R = R + Math.imul(L, Re) | 0, _ = _ + Math.imul(ve, He) | 0, l = l + Math.imul(ve, Ue) | 0, l = l + Math.imul(Be, He) | 0, R = R + Math.imul(Be, Ue) | 0;
        var rt = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, _ = Math.imul(Se, $e), l = Math.imul(Se, Ne), l = l + Math.imul(Ae, $e) | 0, R = Math.imul(Ae, Ne), _ = _ + Math.imul(Ve, st) | 0, l = l + Math.imul(Ve, Je) | 0, l = l + Math.imul(ke, st) | 0, R = R + Math.imul(ke, Je) | 0, _ = _ + Math.imul(se, D) | 0, l = l + Math.imul(se, J) | 0, l = l + Math.imul(_e, D) | 0, R = R + Math.imul(_e, J) | 0, _ = _ + Math.imul(ze, O) | 0, l = l + Math.imul(ze, ae) | 0, l = l + Math.imul(z, O) | 0, R = R + Math.imul(z, ae) | 0, _ = _ + Math.imul(de, xe) | 0, l = l + Math.imul(de, Re) | 0, l = l + Math.imul(me, xe) | 0, R = R + Math.imul(me, Re) | 0, _ = _ + Math.imul(C, He) | 0, l = l + Math.imul(C, Ue) | 0, l = l + Math.imul(L, He) | 0, R = R + Math.imul(L, Ue) | 0;
        var it = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, _ = Math.imul(Se, st), l = Math.imul(Se, Je), l = l + Math.imul(Ae, st) | 0, R = Math.imul(Ae, Je), _ = _ + Math.imul(Ve, D) | 0, l = l + Math.imul(Ve, J) | 0, l = l + Math.imul(ke, D) | 0, R = R + Math.imul(ke, J) | 0, _ = _ + Math.imul(se, O) | 0, l = l + Math.imul(se, ae) | 0, l = l + Math.imul(_e, O) | 0, R = R + Math.imul(_e, ae) | 0, _ = _ + Math.imul(ze, xe) | 0, l = l + Math.imul(ze, Re) | 0, l = l + Math.imul(z, xe) | 0, R = R + Math.imul(z, Re) | 0, _ = _ + Math.imul(de, He) | 0, l = l + Math.imul(de, Ue) | 0, l = l + Math.imul(me, He) | 0, R = R + Math.imul(me, Ue) | 0;
        var Ye = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, _ = Math.imul(Se, D), l = Math.imul(Se, J), l = l + Math.imul(Ae, D) | 0, R = Math.imul(Ae, J), _ = _ + Math.imul(Ve, O) | 0, l = l + Math.imul(Ve, ae) | 0, l = l + Math.imul(ke, O) | 0, R = R + Math.imul(ke, ae) | 0, _ = _ + Math.imul(se, xe) | 0, l = l + Math.imul(se, Re) | 0, l = l + Math.imul(_e, xe) | 0, R = R + Math.imul(_e, Re) | 0, _ = _ + Math.imul(ze, He) | 0, l = l + Math.imul(ze, Ue) | 0, l = l + Math.imul(z, He) | 0, R = R + Math.imul(z, Ue) | 0;
        var Oe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, _ = Math.imul(Se, O), l = Math.imul(Se, ae), l = l + Math.imul(Ae, O) | 0, R = Math.imul(Ae, ae), _ = _ + Math.imul(Ve, xe) | 0, l = l + Math.imul(Ve, Re) | 0, l = l + Math.imul(ke, xe) | 0, R = R + Math.imul(ke, Re) | 0, _ = _ + Math.imul(se, He) | 0, l = l + Math.imul(se, Ue) | 0, l = l + Math.imul(_e, He) | 0, R = R + Math.imul(_e, Ue) | 0;
        var Pe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, _ = Math.imul(Se, xe), l = Math.imul(Se, Re), l = l + Math.imul(Ae, xe) | 0, R = Math.imul(Ae, Re), _ = _ + Math.imul(Ve, He) | 0, l = l + Math.imul(Ve, Ue) | 0, l = l + Math.imul(ke, He) | 0, R = R + Math.imul(ke, Ue) | 0;
        var Ke = (g + _ | 0) + ((l & 8191) << 13) | 0;
        g = (R + (l >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, _ = Math.imul(Se, He), l = Math.imul(Se, Ue), l = l + Math.imul(Ae, He) | 0, R = Math.imul(Ae, Ue);
        var Fe = (g + _ | 0) + ((l & 8191) << 13) | 0;
        return g = (R + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, S[0] = yt, S[1] = et, S[2] = ut, S[3] = ct, S[4] = vt, S[5] = pt, S[6] = ht, S[7] = dt, S[8] = lt, S[9] = tt, S[10] = ot, S[11] = Qe, S[12] = rt, S[13] = it, S[14] = Ye, S[15] = Oe, S[16] = Pe, S[17] = Ke, S[18] = Fe, g !== 0 && (S[19] = g, w.length++), w;
      };
      Math.imul || (T = B);
      function j(v, a, d) {
        d.negative = a.negative ^ v.negative, d.length = v.length + a.length;
        for (var w = 0, x = 0, A = 0; A < d.length - 1; A++) {
          var S = x;
          x = 0;
          for (var g = w & 67108863, _ = Math.min(A, a.length - 1), l = Math.max(0, A - v.length + 1); l <= _; l++) {
            var R = A - l, Y = v.words[R] | 0, oe = a.words[l] | 0, H = Y * oe, V = H & 67108863;
            S = S + (H / 67108864 | 0) | 0, V = V + g | 0, g = V & 67108863, S = S + (V >>> 26) | 0, x += S >>> 26, S &= 67108863;
          }
          d.words[A] = g, w = S, S = x;
        }
        return w !== 0 ? d.words[A] = w : d.length--, d._strip();
      }
      function N(v, a, d) {
        return j(v, a, d);
      }
      n.prototype.mulTo = function(a, d) {
        var w, x = this.length + a.length;
        return this.length === 10 && a.length === 10 ? w = T(this, a, d) : x < 63 ? w = B(this, a, d) : x < 1024 ? w = j(this, a, d) : w = N(this, a, d), w;
      }, n.prototype.mul = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), this.mulTo(a, d);
      }, n.prototype.mulf = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), N(this, a, d);
      }, n.prototype.imul = function(a) {
        return this.clone().mulTo(a, this);
      }, n.prototype.imuln = function(a) {
        var d = a < 0;
        d && (a = -a), i(typeof a == "number"), i(a < 67108864);
        for (var w = 0, x = 0; x < this.length; x++) {
          var A = (this.words[x] | 0) * a, S = (A & 67108863) + (w & 67108863);
          w >>= 26, w += A / 67108864 | 0, w += S >>> 26, this.words[x] = S & 67108863;
        }
        return w !== 0 && (this.words[x] = w, this.length++), d ? this.ineg() : this;
      }, n.prototype.muln = function(a) {
        return this.clone().imuln(a);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(a) {
        var d = I(a);
        if (d.length === 0)
          return new n(1);
        for (var w = this, x = 0; x < d.length && d[x] === 0; x++, w = w.sqr())
          ;
        if (++x < d.length)
          for (var A = w.sqr(); x < d.length; x++, A = A.sqr())
            d[x] !== 0 && (w = w.mul(A));
        return w;
      }, n.prototype.iushln = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 67108863 >>> 26 - d << 26 - d, A;
        if (d !== 0) {
          var S = 0;
          for (A = 0; A < this.length; A++) {
            var g = this.words[A] & x, _ = (this.words[A] | 0) - g << d;
            this.words[A] = _ | S, S = g >>> 26 - d;
          }
          S && (this.words[A] = S, this.length++);
        }
        if (w !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + w] = this.words[A];
          for (A = 0; A < w; A++)
            this.words[A] = 0;
          this.length += w;
        }
        return this._strip();
      }, n.prototype.ishln = function(a) {
        return i(this.negative === 0), this.iushln(a);
      }, n.prototype.iushrn = function(a, d, w) {
        i(typeof a == "number" && a >= 0);
        var x;
        d ? x = (d - d % 26) / 26 : x = 0;
        var A = a % 26, S = Math.min((a - A) / 26, this.length), g = 67108863 ^ 67108863 >>> A << A, _ = w;
        if (x -= S, x = Math.max(0, x), _) {
          for (var l = 0; l < S; l++)
            _.words[l] = this.words[l];
          _.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, l = 0; l < this.length; l++)
              this.words[l] = this.words[l + S];
          else
            this.words[0] = 0, this.length = 1;
        var R = 0;
        for (l = this.length - 1; l >= 0 && (R !== 0 || l >= x); l--) {
          var Y = this.words[l] | 0;
          this.words[l] = R << 26 - A | Y >>> A, R = Y & g;
        }
        return _ && R !== 0 && (_.words[_.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(a, d, w) {
        return i(this.negative === 0), this.iushrn(a, d, w);
      }, n.prototype.shln = function(a) {
        return this.clone().ishln(a);
      }, n.prototype.ushln = function(a) {
        return this.clone().iushln(a);
      }, n.prototype.shrn = function(a) {
        return this.clone().ishrn(a);
      }, n.prototype.ushrn = function(a) {
        return this.clone().iushrn(a);
      }, n.prototype.testn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return !1;
        var A = this.words[w];
        return !!(A & x);
      }, n.prototype.imaskn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w)
          return this;
        if (d !== 0 && w++, this.length = Math.min(w, this.length), d !== 0) {
          var x = 67108863 ^ 67108863 >>> d << d;
          this.words[this.length - 1] &= x;
        }
        return this._strip();
      }, n.prototype.maskn = function(a) {
        return this.clone().imaskn(a);
      }, n.prototype.iaddn = function(a) {
        return i(typeof a == "number"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
      }, n.prototype._iaddn = function(a) {
        this.words[0] += a;
        for (var d = 0; d < this.length && this.words[d] >= 67108864; d++)
          this.words[d] -= 67108864, d === this.length - 1 ? this.words[d + 1] = 1 : this.words[d + 1]++;
        return this.length = Math.max(this.length, d + 1), this;
      }, n.prototype.isubn = function(a) {
        if (i(typeof a == "number"), i(a < 67108864), a < 0)
          return this.iaddn(-a);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(a), this.negative = 1, this;
        if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var d = 0; d < this.length && this.words[d] < 0; d++)
            this.words[d] += 67108864, this.words[d + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(a) {
        return this.clone().iaddn(a);
      }, n.prototype.subn = function(a) {
        return this.clone().isubn(a);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(a, d, w) {
        var x = a.length + w, A;
        this._expand(x);
        var S, g = 0;
        for (A = 0; A < a.length; A++) {
          S = (this.words[A + w] | 0) + g;
          var _ = (a.words[A] | 0) * d;
          S -= _ & 67108863, g = (S >> 26) - (_ / 67108864 | 0), this.words[A + w] = S & 67108863;
        }
        for (; A < this.length - w; A++)
          S = (this.words[A + w] | 0) + g, g = S >> 26, this.words[A + w] = S & 67108863;
        if (g === 0)
          return this._strip();
        for (i(g === -1), g = 0, A = 0; A < this.length; A++)
          S = -(this.words[A] | 0) + g, g = S >> 26, this.words[A] = S & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(a, d) {
        var w = this.length - a.length, x = this.clone(), A = a, S = A.words[A.length - 1] | 0, g = this._countBits(S);
        w = 26 - g, w !== 0 && (A = A.ushln(w), x.iushln(w), S = A.words[A.length - 1] | 0);
        var _ = x.length - A.length, l;
        if (d !== "mod") {
          l = new n(null), l.length = _ + 1, l.words = new Array(l.length);
          for (var R = 0; R < l.length; R++)
            l.words[R] = 0;
        }
        var Y = x.clone()._ishlnsubmul(A, 1, _);
        Y.negative === 0 && (x = Y, l && (l.words[_] = 1));
        for (var oe = _ - 1; oe >= 0; oe--) {
          var H = (x.words[A.length + oe] | 0) * 67108864 + (x.words[A.length + oe - 1] | 0);
          for (H = Math.min(H / S | 0, 67108863), x._ishlnsubmul(A, H, oe); x.negative !== 0; )
            H--, x.negative = 0, x._ishlnsubmul(A, 1, oe), x.isZero() || (x.negative ^= 1);
          l && (l.words[oe] = H);
        }
        return l && l._strip(), x._strip(), d !== "div" && w !== 0 && x.iushrn(w), {
          div: l || null,
          mod: x
        };
      }, n.prototype.divmod = function(a, d, w) {
        if (i(!a.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var x, A, S;
        return this.negative !== 0 && a.negative === 0 ? (S = this.neg().divmod(a, d), d !== "mod" && (x = S.div.neg()), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.iadd(a)), {
          div: x,
          mod: A
        }) : this.negative === 0 && a.negative !== 0 ? (S = this.divmod(a.neg(), d), d !== "mod" && (x = S.div.neg()), {
          div: x,
          mod: S.mod
        }) : this.negative & a.negative ? (S = this.neg().divmod(a.neg(), d), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.isub(a)), {
          div: S.div,
          mod: A
        }) : a.length > this.length || this.cmp(a) < 0 ? {
          div: new n(0),
          mod: this
        } : a.length === 1 ? d === "div" ? {
          div: this.divn(a.words[0]),
          mod: null
        } : d === "mod" ? {
          div: null,
          mod: new n(this.modrn(a.words[0]))
        } : {
          div: this.divn(a.words[0]),
          mod: new n(this.modrn(a.words[0]))
        } : this._wordDiv(a, d);
      }, n.prototype.div = function(a) {
        return this.divmod(a, "div", !1).div;
      }, n.prototype.mod = function(a) {
        return this.divmod(a, "mod", !1).mod;
      }, n.prototype.umod = function(a) {
        return this.divmod(a, "mod", !0).mod;
      }, n.prototype.divRound = function(a) {
        var d = this.divmod(a);
        if (d.mod.isZero())
          return d.div;
        var w = d.div.negative !== 0 ? d.mod.isub(a) : d.mod, x = a.ushrn(1), A = a.andln(1), S = w.cmp(x);
        return S < 0 || A === 1 && S === 0 ? d.div : d.div.negative !== 0 ? d.div.isubn(1) : d.div.iaddn(1);
      }, n.prototype.modrn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = (1 << 26) % a, x = 0, A = this.length - 1; A >= 0; A--)
          x = (w * x + (this.words[A] | 0)) % a;
        return d ? -x : x;
      }, n.prototype.modn = function(a) {
        return this.modrn(a);
      }, n.prototype.idivn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = 0, x = this.length - 1; x >= 0; x--) {
          var A = (this.words[x] | 0) + w * 67108864;
          this.words[x] = A / a | 0, w = A % a;
        }
        return this._strip(), d ? this.ineg() : this;
      }, n.prototype.divn = function(a) {
        return this.clone().idivn(a);
      }, n.prototype.egcd = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = new n(0), g = new n(1), _ = 0; d.isEven() && w.isEven(); )
          d.iushrn(1), w.iushrn(1), ++_;
        for (var l = w.clone(), R = d.clone(); !d.isZero(); ) {
          for (var Y = 0, oe = 1; !(d.words[0] & oe) && Y < 26; ++Y, oe <<= 1)
            ;
          if (Y > 0)
            for (d.iushrn(Y); Y-- > 0; )
              (x.isOdd() || A.isOdd()) && (x.iadd(l), A.isub(R)), x.iushrn(1), A.iushrn(1);
          for (var H = 0, V = 1; !(w.words[0] & V) && H < 26; ++H, V <<= 1)
            ;
          if (H > 0)
            for (w.iushrn(H); H-- > 0; )
              (S.isOdd() || g.isOdd()) && (S.iadd(l), g.isub(R)), S.iushrn(1), g.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(S), A.isub(g)) : (w.isub(d), S.isub(x), g.isub(A));
        }
        return {
          a: S,
          b: g,
          gcd: w.iushln(_)
        };
      }, n.prototype._invmp = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = w.clone(); d.cmpn(1) > 0 && w.cmpn(1) > 0; ) {
          for (var g = 0, _ = 1; !(d.words[0] & _) && g < 26; ++g, _ <<= 1)
            ;
          if (g > 0)
            for (d.iushrn(g); g-- > 0; )
              x.isOdd() && x.iadd(S), x.iushrn(1);
          for (var l = 0, R = 1; !(w.words[0] & R) && l < 26; ++l, R <<= 1)
            ;
          if (l > 0)
            for (w.iushrn(l); l-- > 0; )
              A.isOdd() && A.iadd(S), A.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(A)) : (w.isub(d), A.isub(x));
        }
        var Y;
        return d.cmpn(1) === 0 ? Y = x : Y = A, Y.cmpn(0) < 0 && Y.iadd(a), Y;
      }, n.prototype.gcd = function(a) {
        if (this.isZero())
          return a.abs();
        if (a.isZero())
          return this.abs();
        var d = this.clone(), w = a.clone();
        d.negative = 0, w.negative = 0;
        for (var x = 0; d.isEven() && w.isEven(); x++)
          d.iushrn(1), w.iushrn(1);
        do {
          for (; d.isEven(); )
            d.iushrn(1);
          for (; w.isEven(); )
            w.iushrn(1);
          var A = d.cmp(w);
          if (A < 0) {
            var S = d;
            d = w, w = S;
          } else if (A === 0 || w.cmpn(1) === 0)
            break;
          d.isub(w);
        } while (!0);
        return w.iushln(x);
      }, n.prototype.invm = function(a) {
        return this.egcd(a).a.umod(a);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(a) {
        return this.words[0] & a;
      }, n.prototype.bincn = function(a) {
        i(typeof a == "number");
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return this._expand(w + 1), this.words[w] |= x, this;
        for (var A = x, S = w; A !== 0 && S < this.length; S++) {
          var g = this.words[S] | 0;
          g += A, A = g >>> 26, g &= 67108863, this.words[S] = g;
        }
        return A !== 0 && (this.words[S] = A, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(a) {
        var d = a < 0;
        if (this.negative !== 0 && !d)
          return -1;
        if (this.negative === 0 && d)
          return 1;
        this._strip();
        var w;
        if (this.length > 1)
          w = 1;
        else {
          d && (a = -a), i(a <= 67108863, "Number is too big");
          var x = this.words[0] | 0;
          w = x === a ? 0 : x < a ? -1 : 1;
        }
        return this.negative !== 0 ? -w | 0 : w;
      }, n.prototype.cmp = function(a) {
        if (this.negative !== 0 && a.negative === 0)
          return -1;
        if (this.negative === 0 && a.negative !== 0)
          return 1;
        var d = this.ucmp(a);
        return this.negative !== 0 ? -d | 0 : d;
      }, n.prototype.ucmp = function(a) {
        if (this.length > a.length)
          return 1;
        if (this.length < a.length)
          return -1;
        for (var d = 0, w = this.length - 1; w >= 0; w--) {
          var x = this.words[w] | 0, A = a.words[w] | 0;
          if (x !== A) {
            x < A ? d = -1 : x > A && (d = 1);
            break;
          }
        }
        return d;
      }, n.prototype.gtn = function(a) {
        return this.cmpn(a) === 1;
      }, n.prototype.gt = function(a) {
        return this.cmp(a) === 1;
      }, n.prototype.gten = function(a) {
        return this.cmpn(a) >= 0;
      }, n.prototype.gte = function(a) {
        return this.cmp(a) >= 0;
      }, n.prototype.ltn = function(a) {
        return this.cmpn(a) === -1;
      }, n.prototype.lt = function(a) {
        return this.cmp(a) === -1;
      }, n.prototype.lten = function(a) {
        return this.cmpn(a) <= 0;
      }, n.prototype.lte = function(a) {
        return this.cmp(a) <= 0;
      }, n.prototype.eqn = function(a) {
        return this.cmpn(a) === 0;
      }, n.prototype.eq = function(a) {
        return this.cmp(a) === 0;
      }, n.red = function(a) {
        return new U(a);
      }, n.prototype.toRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
      }, n.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(a) {
        return this.red = a, this;
      }, n.prototype.forceRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(a);
      }, n.prototype.redAdd = function(a) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
      }, n.prototype.redIAdd = function(a) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
      }, n.prototype.redSub = function(a) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
      }, n.prototype.redISub = function(a) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
      }, n.prototype.redShl = function(a) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
      }, n.prototype.redMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
      }, n.prototype.redIMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
      }, n.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(a) {
        return i(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
      };
      var k = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function q(v, a) {
        this.name = v, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      q.prototype._tmp = function() {
        var a = new n(null);
        return a.words = new Array(Math.ceil(this.n / 13)), a;
      }, q.prototype.ireduce = function(a) {
        var d = a, w;
        do
          this.split(d, this.tmp), d = this.imulK(d), d = d.iadd(this.tmp), w = d.bitLength();
        while (w > this.n);
        var x = w < this.n ? -1 : d.ucmp(this.p);
        return x === 0 ? (d.words[0] = 0, d.length = 1) : x > 0 ? d.isub(this.p) : d.strip !== void 0 ? d.strip() : d._strip(), d;
      }, q.prototype.split = function(a, d) {
        a.iushrn(this.n, 0, d);
      }, q.prototype.imulK = function(a) {
        return a.imul(this.k);
      };
      function $() {
        q.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      o($, q), $.prototype.split = function(a, d) {
        for (var w = 4194303, x = Math.min(a.length, 9), A = 0; A < x; A++)
          d.words[A] = a.words[A];
        if (d.length = x, a.length <= 9) {
          a.words[0] = 0, a.length = 1;
          return;
        }
        var S = a.words[9];
        for (d.words[d.length++] = S & w, A = 10; A < a.length; A++) {
          var g = a.words[A] | 0;
          a.words[A - 10] = (g & w) << 4 | S >>> 22, S = g;
        }
        S >>>= 22, a.words[A - 10] = S, S === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
      }, $.prototype.imulK = function(a) {
        a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = a.words[w] | 0;
          d += x * 977, a.words[w] = d & 67108863, d = x * 64 + (d / 67108864 | 0);
        }
        return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
      };
      function re() {
        q.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      o(re, q);
      function Q() {
        q.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      o(Q, q);
      function fe() {
        q.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      o(fe, q), fe.prototype.imulK = function(a) {
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = (a.words[w] | 0) * 19 + d, A = x & 67108863;
          x >>>= 26, a.words[w] = A, d = x;
        }
        return d !== 0 && (a.words[a.length++] = d), a;
      }, n._prime = function(a) {
        if (k[a])
          return k[a];
        var d;
        if (a === "k256")
          d = new $();
        else if (a === "p224")
          d = new re();
        else if (a === "p192")
          d = new Q();
        else if (a === "p25519")
          d = new fe();
        else
          throw new Error("Unknown prime " + a);
        return k[a] = d, d;
      };
      function U(v) {
        if (typeof v == "string") {
          var a = n._prime(v);
          this.m = a.p, this.prime = a;
        } else
          i(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      U.prototype._verify1 = function(a) {
        i(a.negative === 0, "red works only with positives"), i(a.red, "red works only with red numbers");
      }, U.prototype._verify2 = function(a, d) {
        i((a.negative | d.negative) === 0, "red works only with positives"), i(
          a.red && a.red === d.red,
          "red works only with red numbers"
        );
      }, U.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : (s(a, a.umod(this.m)._forceRed(this)), a);
      }, U.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      }, U.prototype.add = function(a, d) {
        this._verify2(a, d);
        var w = a.add(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
      }, U.prototype.iadd = function(a, d) {
        this._verify2(a, d);
        var w = a.iadd(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w;
      }, U.prototype.sub = function(a, d) {
        this._verify2(a, d);
        var w = a.sub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
      }, U.prototype.isub = function(a, d) {
        this._verify2(a, d);
        var w = a.isub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w;
      }, U.prototype.shl = function(a, d) {
        return this._verify1(a), this.imod(a.ushln(d));
      }, U.prototype.imul = function(a, d) {
        return this._verify2(a, d), this.imod(a.imul(d));
      }, U.prototype.mul = function(a, d) {
        return this._verify2(a, d), this.imod(a.mul(d));
      }, U.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      }, U.prototype.sqr = function(a) {
        return this.mul(a, a);
      }, U.prototype.sqrt = function(a) {
        if (a.isZero())
          return a.clone();
        var d = this.m.andln(3);
        if (i(d % 2 === 1), d === 3) {
          var w = this.m.add(new n(1)).iushrn(2);
          return this.pow(a, w);
        }
        for (var x = this.m.subn(1), A = 0; !x.isZero() && x.andln(1) === 0; )
          A++, x.iushrn(1);
        i(!x.isZero());
        var S = new n(1).toRed(this), g = S.redNeg(), _ = this.m.subn(1).iushrn(1), l = this.m.bitLength();
        for (l = new n(2 * l * l).toRed(this); this.pow(l, _).cmp(g) !== 0; )
          l.redIAdd(g);
        for (var R = this.pow(l, x), Y = this.pow(a, x.addn(1).iushrn(1)), oe = this.pow(a, x), H = A; oe.cmp(S) !== 0; ) {
          for (var V = oe, F = 0; V.cmp(S) !== 0; F++)
            V = V.redSqr();
          i(F < H);
          var te = this.pow(R, new n(1).iushln(H - F - 1));
          Y = Y.redMul(te), R = te.redSqr(), oe = oe.redMul(R), H = F;
        }
        return Y;
      }, U.prototype.invm = function(a) {
        var d = a._invmp(this.m);
        return d.negative !== 0 ? (d.negative = 0, this.imod(d).redNeg()) : this.imod(d);
      }, U.prototype.pow = function(a, d) {
        if (d.isZero())
          return new n(1).toRed(this);
        if (d.cmpn(1) === 0)
          return a.clone();
        var w = 4, x = new Array(1 << w);
        x[0] = new n(1).toRed(this), x[1] = a;
        for (var A = 2; A < x.length; A++)
          x[A] = this.mul(x[A - 1], a);
        var S = x[0], g = 0, _ = 0, l = d.bitLength() % 26;
        for (l === 0 && (l = 26), A = d.length - 1; A >= 0; A--) {
          for (var R = d.words[A], Y = l - 1; Y >= 0; Y--) {
            var oe = R >> Y & 1;
            if (S !== x[0] && (S = this.sqr(S)), oe === 0 && g === 0) {
              _ = 0;
              continue;
            }
            g <<= 1, g |= oe, _++, !(_ !== w && (A !== 0 || Y !== 0)) && (S = this.mul(S, x[g]), _ = 0, g = 0);
          }
          l = 26;
        }
        return S;
      }, U.prototype.convertTo = function(a) {
        var d = a.umod(this.m);
        return d === a ? d.clone() : d;
      }, U.prototype.convertFrom = function(a) {
        var d = a.clone();
        return d.red = null, d;
      }, n.mont = function(a) {
        return new y(a);
      };
      function y(v) {
        U.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(y, U), y.prototype.convertTo = function(a) {
        return this.imod(a.ushln(this.shift));
      }, y.prototype.convertFrom = function(a) {
        var d = this.imod(a.mul(this.rinv));
        return d.red = null, d;
      }, y.prototype.imul = function(a, d) {
        if (a.isZero() || d.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var w = a.imul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.mul = function(a, d) {
        if (a.isZero() || d.isZero())
          return new n(0)._forceRed(this);
        var w = a.mul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, y.prototype.invm = function(a) {
        var d = this.imod(a._invmp(this.m).mul(this.r2));
        return d._forceRed(this);
      };
    })(e, Ze);
  }(eo)), eo.exports;
}
var Br = {}, fc = {}, sc = {}, uc = {}, cc, $p;
function v0() {
  if ($p)
    return cc;
  $p = 1;
  var e = Le, t = e.Buffer, r = {}, i;
  for (i in e)
    e.hasOwnProperty(i) && (i === "SlowBuffer" || i === "Buffer" || (r[i] = e[i]));
  var o = r.Buffer = {};
  for (i in t)
    t.hasOwnProperty(i) && (i === "allocUnsafe" || i === "allocUnsafeSlow" || (o[i] = t[i]));
  if (r.Buffer.prototype = t.prototype, (!o.from || o.from === Uint8Array.from) && (o.from = function(n, f, u) {
    if (typeof n == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof n);
    if (n && typeof n.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n);
    return t(n, f, u);
  }), o.alloc || (o.alloc = function(n, f, u) {
    if (typeof n != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof n);
    if (n < 0 || n >= 2 * (1 << 30))
      throw new RangeError('The value "' + n + '" is invalid for option "size"');
    var c = t(n);
    return !f || f.length === 0 ? c.fill(0) : typeof u == "string" ? c.fill(f, u) : c.fill(f), c;
  }), !r.kStringMaxLength)
    try {
      r.kStringMaxLength = at.binding("buffer").kStringMaxLength;
    } catch {
    }
  return r.constants || (r.constants = {
    MAX_LENGTH: r.kMaxLength
  }, r.kStringMaxLength && (r.constants.MAX_STRING_LENGTH = r.kStringMaxLength)), cc = r, cc;
}
var hc = {}, Up;
function b0() {
  if (Up)
    return hc;
  Up = 1;
  const e = _t();
  function t(i) {
    this._reporterState = {
      obj: null,
      path: [],
      options: i || {},
      errors: []
    };
  }
  hc.Reporter = t, t.prototype.isError = function(o) {
    return o instanceof r;
  }, t.prototype.save = function() {
    const o = this._reporterState;
    return { obj: o.obj, pathLen: o.path.length };
  }, t.prototype.restore = function(o) {
    const n = this._reporterState;
    n.obj = o.obj, n.path = n.path.slice(0, o.pathLen);
  }, t.prototype.enterKey = function(o) {
    return this._reporterState.path.push(o);
  }, t.prototype.exitKey = function(o) {
    const n = this._reporterState;
    n.path = n.path.slice(0, o - 1);
  }, t.prototype.leaveKey = function(o, n, f) {
    const u = this._reporterState;
    this.exitKey(o), u.obj !== null && (u.obj[n] = f);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    const o = this._reporterState, n = o.obj;
    return o.obj = {}, n;
  }, t.prototype.leaveObject = function(o) {
    const n = this._reporterState, f = n.obj;
    return n.obj = o, f;
  }, t.prototype.error = function(o) {
    let n;
    const f = this._reporterState, u = o instanceof r;
    if (u ? n = o : n = new r(f.path.map(function(c) {
      return "[" + JSON.stringify(c) + "]";
    }).join(""), o.message || o, o.stack), !f.options.partial)
      throw n;
    return u || f.errors.push(n), n;
  }, t.prototype.wrapResult = function(o) {
    const n = this._reporterState;
    return n.options.partial ? {
      result: this.isError(o) ? null : o,
      errors: n.errors
    } : o;
  };
  function r(i, o) {
    this.path = i, this.rethrow(o);
  }
  return e(r, Error), r.prototype.rethrow = function(o) {
    if (this.message = o + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, r), !this.stack)
      try {
        throw new Error(this.message);
      } catch (n) {
        this.stack = n.stack;
      }
    return this;
  }, hc;
}
var Za = {}, Fp;
function ua() {
  if (Fp)
    return Za;
  Fp = 1;
  const e = _t(), t = b0().Reporter, r = v0().Buffer;
  function i(n, f) {
    if (t.call(this, f), !r.isBuffer(n)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = n, this.offset = 0, this.length = n.length;
  }
  e(i, t), Za.DecoderBuffer = i, i.isDecoderBuffer = function(f) {
    return f instanceof i ? !0 : typeof f == "object" && r.isBuffer(f.base) && f.constructor.name === "DecoderBuffer" && typeof f.offset == "number" && typeof f.length == "number" && typeof f.save == "function" && typeof f.restore == "function" && typeof f.isEmpty == "function" && typeof f.readUInt8 == "function" && typeof f.skip == "function" && typeof f.raw == "function";
  }, i.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, i.prototype.restore = function(f) {
    const u = new i(this.base);
    return u.offset = f.offset, u.length = this.offset, this.offset = f.offset, t.prototype.restore.call(this, f.reporter), u;
  }, i.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, i.prototype.readUInt8 = function(f) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(f || "DecoderBuffer overrun");
  }, i.prototype.skip = function(f, u) {
    if (!(this.offset + f <= this.length))
      return this.error(u || "DecoderBuffer overrun");
    const c = new i(this.base);
    return c._reporterState = this._reporterState, c.offset = this.offset, c.length = this.offset + f, this.offset += f, c;
  }, i.prototype.raw = function(f) {
    return this.base.slice(f ? f.offset : this.offset, this.length);
  };
  function o(n, f) {
    if (Array.isArray(n))
      this.length = 0, this.value = n.map(function(u) {
        return o.isEncoderBuffer(u) || (u = new o(u, f)), this.length += u.length, u;
      }, this);
    else if (typeof n == "number") {
      if (!(0 <= n && n <= 255))
        return f.error("non-byte EncoderBuffer value");
      this.value = n, this.length = 1;
    } else if (typeof n == "string")
      this.value = n, this.length = r.byteLength(n);
    else if (r.isBuffer(n))
      this.value = n, this.length = n.length;
    else
      return f.error("Unsupported type: " + typeof n);
  }
  return Za.EncoderBuffer = o, o.isEncoderBuffer = function(f) {
    return f instanceof o ? !0 : typeof f == "object" && f.constructor.name === "EncoderBuffer" && typeof f.length == "number" && typeof f.join == "function";
  }, o.prototype.join = function(f, u) {
    return f || (f = r.alloc(this.length)), u || (u = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(c) {
      c.join(f, u), u += c.length;
    }) : (typeof this.value == "number" ? f[u] = this.value : typeof this.value == "string" ? f.write(this.value, u) : r.isBuffer(this.value) && this.value.copy(f, u), u += this.length)), f;
  }, Za;
}
var lc, zp;
function y0() {
  if (zp)
    return lc;
  zp = 1;
  const e = b0().Reporter, t = ua().EncoderBuffer, r = ua().DecoderBuffer, i = qr(), o = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], n = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(o), f = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function u(h, s, b) {
    const p = {};
    this._baseState = p, p.name = b, p.enc = h, p.parent = s || null, p.children = null, p.tag = null, p.args = null, p.reverseArgs = null, p.choice = null, p.optional = !1, p.any = !1, p.obj = !1, p.use = null, p.useDecoder = null, p.key = null, p.default = null, p.explicit = null, p.implicit = null, p.contains = null, p.parent || (p.children = [], this._wrap());
  }
  lc = u;
  const c = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return u.prototype.clone = function() {
    const s = this._baseState, b = {};
    c.forEach(function(m) {
      b[m] = s[m];
    });
    const p = new this.constructor(b.parent);
    return p._baseState = b, p;
  }, u.prototype._wrap = function() {
    const s = this._baseState;
    n.forEach(function(b) {
      this[b] = function() {
        const m = new this.constructor(this);
        return s.children.push(m), m[b].apply(m, arguments);
      };
    }, this);
  }, u.prototype._init = function(s) {
    const b = this._baseState;
    i(b.parent === null), s.call(this), b.children = b.children.filter(function(p) {
      return p._baseState.parent === this;
    }, this), i.equal(b.children.length, 1, "Root node can have only one child");
  }, u.prototype._useArgs = function(s) {
    const b = this._baseState, p = s.filter(function(m) {
      return m instanceof this.constructor;
    }, this);
    s = s.filter(function(m) {
      return !(m instanceof this.constructor);
    }, this), p.length !== 0 && (i(b.children === null), b.children = p, p.forEach(function(m) {
      m._baseState.parent = this;
    }, this)), s.length !== 0 && (i(b.args === null), b.args = s, b.reverseArgs = s.map(function(m) {
      if (typeof m != "object" || m.constructor !== Object)
        return m;
      const E = {};
      return Object.keys(m).forEach(function(M) {
        M == (M | 0) && (M |= 0);
        const I = m[M];
        E[I] = M;
      }), E;
    }));
  }, f.forEach(function(h) {
    u.prototype[h] = function() {
      const b = this._baseState;
      throw new Error(h + " not implemented for encoding: " + b.enc);
    };
  }), o.forEach(function(h) {
    u.prototype[h] = function() {
      const b = this._baseState, p = Array.prototype.slice.call(arguments);
      return i(b.tag === null), b.tag = h, this._useArgs(p), this;
    };
  }), u.prototype.use = function(s) {
    i(s);
    const b = this._baseState;
    return i(b.use === null), b.use = s, this;
  }, u.prototype.optional = function() {
    const s = this._baseState;
    return s.optional = !0, this;
  }, u.prototype.def = function(s) {
    const b = this._baseState;
    return i(b.default === null), b.default = s, b.optional = !0, this;
  }, u.prototype.explicit = function(s) {
    const b = this._baseState;
    return i(b.explicit === null && b.implicit === null), b.explicit = s, this;
  }, u.prototype.implicit = function(s) {
    const b = this._baseState;
    return i(b.explicit === null && b.implicit === null), b.implicit = s, this;
  }, u.prototype.obj = function() {
    const s = this._baseState, b = Array.prototype.slice.call(arguments);
    return s.obj = !0, b.length !== 0 && this._useArgs(b), this;
  }, u.prototype.key = function(s) {
    const b = this._baseState;
    return i(b.key === null), b.key = s, this;
  }, u.prototype.any = function() {
    const s = this._baseState;
    return s.any = !0, this;
  }, u.prototype.choice = function(s) {
    const b = this._baseState;
    return i(b.choice === null), b.choice = s, this._useArgs(Object.keys(s).map(function(p) {
      return s[p];
    })), this;
  }, u.prototype.contains = function(s) {
    const b = this._baseState;
    return i(b.use === null), b.contains = s, this;
  }, u.prototype._decode = function(s, b) {
    const p = this._baseState;
    if (p.parent === null)
      return s.wrapResult(p.children[0]._decode(s, b));
    let m = p.default, E = !0, M = null;
    if (p.key !== null && (M = s.enterKey(p.key)), p.optional) {
      let B = null;
      if (p.explicit !== null ? B = p.explicit : p.implicit !== null ? B = p.implicit : p.tag !== null && (B = p.tag), B === null && !p.any) {
        const T = s.save();
        try {
          p.choice === null ? this._decodeGeneric(p.tag, s, b) : this._decodeChoice(s, b), E = !0;
        } catch {
          E = !1;
        }
        s.restore(T);
      } else if (E = this._peekTag(s, B, p.any), s.isError(E))
        return E;
    }
    let I;
    if (p.obj && E && (I = s.enterObject()), E) {
      if (p.explicit !== null) {
        const T = this._decodeTag(s, p.explicit);
        if (s.isError(T))
          return T;
        s = T;
      }
      const B = s.offset;
      if (p.use === null && p.choice === null) {
        let T;
        p.any && (T = s.save());
        const j = this._decodeTag(
          s,
          p.implicit !== null ? p.implicit : p.tag,
          p.any
        );
        if (s.isError(j))
          return j;
        p.any ? m = s.raw(T) : s = j;
      }
      if (b && b.track && p.tag !== null && b.track(s.path(), B, s.length, "tagged"), b && b.track && p.tag !== null && b.track(s.path(), s.offset, s.length, "content"), p.any || (p.choice === null ? m = this._decodeGeneric(p.tag, s, b) : m = this._decodeChoice(s, b)), s.isError(m))
        return m;
      if (!p.any && p.choice === null && p.children !== null && p.children.forEach(function(j) {
        j._decode(s, b);
      }), p.contains && (p.tag === "octstr" || p.tag === "bitstr")) {
        const T = new r(m);
        m = this._getUse(p.contains, s._reporterState.obj)._decode(T, b);
      }
    }
    return p.obj && E && (m = s.leaveObject(I)), p.key !== null && (m !== null || E === !0) ? s.leaveKey(M, p.key, m) : M !== null && s.exitKey(M), m;
  }, u.prototype._decodeGeneric = function(s, b, p) {
    const m = this._baseState;
    return s === "seq" || s === "set" ? null : s === "seqof" || s === "setof" ? this._decodeList(b, s, m.args[0], p) : /str$/.test(s) ? this._decodeStr(b, s, p) : s === "objid" && m.args ? this._decodeObjid(b, m.args[0], m.args[1], p) : s === "objid" ? this._decodeObjid(b, null, null, p) : s === "gentime" || s === "utctime" ? this._decodeTime(b, s, p) : s === "null_" ? this._decodeNull(b, p) : s === "bool" ? this._decodeBool(b, p) : s === "objDesc" ? this._decodeStr(b, s, p) : s === "int" || s === "enum" ? this._decodeInt(b, m.args && m.args[0], p) : m.use !== null ? this._getUse(m.use, b._reporterState.obj)._decode(b, p) : b.error("unknown tag: " + s);
  }, u.prototype._getUse = function(s, b) {
    const p = this._baseState;
    return p.useDecoder = this._use(s, b), i(p.useDecoder._baseState.parent === null), p.useDecoder = p.useDecoder._baseState.children[0], p.implicit !== p.useDecoder._baseState.implicit && (p.useDecoder = p.useDecoder.clone(), p.useDecoder._baseState.implicit = p.implicit), p.useDecoder;
  }, u.prototype._decodeChoice = function(s, b) {
    const p = this._baseState;
    let m = null, E = !1;
    return Object.keys(p.choice).some(function(M) {
      const I = s.save(), B = p.choice[M];
      try {
        const T = B._decode(s, b);
        if (s.isError(T))
          return !1;
        m = { type: M, value: T }, E = !0;
      } catch {
        return s.restore(I), !1;
      }
      return !0;
    }, this), E ? m : s.error("Choice not matched");
  }, u.prototype._createEncoderBuffer = function(s) {
    return new t(s, this.reporter);
  }, u.prototype._encode = function(s, b, p) {
    const m = this._baseState;
    if (m.default !== null && m.default === s)
      return;
    const E = this._encodeValue(s, b, p);
    if (E !== void 0 && !this._skipDefault(E, b, p))
      return E;
  }, u.prototype._encodeValue = function(s, b, p) {
    const m = this._baseState;
    if (m.parent === null)
      return m.children[0]._encode(s, b || new e());
    let E = null;
    if (this.reporter = b, m.optional && s === void 0)
      if (m.default !== null)
        s = m.default;
      else
        return;
    let M = null, I = !1;
    if (m.any)
      E = this._createEncoderBuffer(s);
    else if (m.choice)
      E = this._encodeChoice(s, b);
    else if (m.contains)
      M = this._getUse(m.contains, p)._encode(s, b), I = !0;
    else if (m.children)
      M = m.children.map(function(B) {
        if (B._baseState.tag === "null_")
          return B._encode(null, b, s);
        if (B._baseState.key === null)
          return b.error("Child should have a key");
        const T = b.enterKey(B._baseState.key);
        if (typeof s != "object")
          return b.error("Child expected, but input is not object");
        const j = B._encode(s[B._baseState.key], b, s);
        return b.leaveKey(T), j;
      }, this).filter(function(B) {
        return B;
      }), M = this._createEncoderBuffer(M);
    else if (m.tag === "seqof" || m.tag === "setof") {
      if (!(m.args && m.args.length === 1))
        return b.error("Too many args for : " + m.tag);
      if (!Array.isArray(s))
        return b.error("seqof/setof, but data is not Array");
      const B = this.clone();
      B._baseState.implicit = null, M = this._createEncoderBuffer(s.map(function(T) {
        const j = this._baseState;
        return this._getUse(j.args[0], s)._encode(T, b);
      }, B));
    } else
      m.use !== null ? E = this._getUse(m.use, p)._encode(s, b) : (M = this._encodePrimitive(m.tag, s), I = !0);
    if (!m.any && m.choice === null) {
      const B = m.implicit !== null ? m.implicit : m.tag, T = m.implicit === null ? "universal" : "context";
      B === null ? m.use === null && b.error("Tag could be omitted only for .use()") : m.use === null && (E = this._encodeComposite(B, I, T, M));
    }
    return m.explicit !== null && (E = this._encodeComposite(m.explicit, !1, "context", E)), E;
  }, u.prototype._encodeChoice = function(s, b) {
    const p = this._baseState, m = p.choice[s.type];
    return m || i(
      !1,
      s.type + " not found in " + JSON.stringify(Object.keys(p.choice))
    ), m._encode(s.value, b);
  }, u.prototype._encodePrimitive = function(s, b) {
    const p = this._baseState;
    if (/str$/.test(s))
      return this._encodeStr(b, s);
    if (s === "objid" && p.args)
      return this._encodeObjid(b, p.reverseArgs[0], p.args[1]);
    if (s === "objid")
      return this._encodeObjid(b, null, null);
    if (s === "gentime" || s === "utctime")
      return this._encodeTime(b, s);
    if (s === "null_")
      return this._encodeNull();
    if (s === "int" || s === "enum")
      return this._encodeInt(b, p.args && p.reverseArgs[0]);
    if (s === "bool")
      return this._encodeBool(b);
    if (s === "objDesc")
      return this._encodeStr(b, s);
    throw new Error("Unsupported tag: " + s);
  }, u.prototype._isNumstr = function(s) {
    return /^[0-9 ]*$/.test(s);
  }, u.prototype._isPrintstr = function(s) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(s);
  }, lc;
}
var dc = {}, Hp;
function g0() {
  return Hp || (Hp = 1, function(e) {
    function t(r) {
      const i = {};
      return Object.keys(r).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        const n = r[o];
        i[n] = o;
      }), i;
    }
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t(e.tag);
  }(dc)), dc;
}
var pc, Vp;
function pg() {
  if (Vp)
    return pc;
  Vp = 1;
  const e = _t(), t = v0().Buffer, r = y0(), i = g0();
  function o(c) {
    this.enc = "der", this.name = c.name, this.entity = c, this.tree = new n(), this.tree._init(c.body);
  }
  pc = o, o.prototype.encode = function(h, s) {
    return this.tree._encode(h, s).join();
  };
  function n(c) {
    r.call(this, "der", c);
  }
  e(n, r), n.prototype._encodeComposite = function(h, s, b, p) {
    const m = u(h, s, b, this.reporter);
    if (p.length < 128) {
      const I = t.alloc(2);
      return I[0] = m, I[1] = p.length, this._createEncoderBuffer([I, p]);
    }
    let E = 1;
    for (let I = p.length; I >= 256; I >>= 8)
      E++;
    const M = t.alloc(2 + E);
    M[0] = m, M[1] = 128 | E;
    for (let I = 1 + E, B = p.length; B > 0; I--, B >>= 8)
      M[I] = B & 255;
    return this._createEncoderBuffer([M, p]);
  }, n.prototype._encodeStr = function(h, s) {
    if (s === "bitstr")
      return this._createEncoderBuffer([h.unused | 0, h.data]);
    if (s === "bmpstr") {
      const b = t.alloc(h.length * 2);
      for (let p = 0; p < h.length; p++)
        b.writeUInt16BE(h.charCodeAt(p), p * 2);
      return this._createEncoderBuffer(b);
    } else
      return s === "numstr" ? this._isNumstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : s === "printstr" ? this._isPrintstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(s) ? this._createEncoderBuffer(h) : s === "objDesc" ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: " + s + " unsupported");
  }, n.prototype._encodeObjid = function(h, s, b) {
    if (typeof h == "string") {
      if (!s)
        return this.reporter.error("string objid given, but no values map found");
      if (!s.hasOwnProperty(h))
        return this.reporter.error("objid not found in values map");
      h = s[h].split(/[\s.]+/g);
      for (let M = 0; M < h.length; M++)
        h[M] |= 0;
    } else if (Array.isArray(h)) {
      h = h.slice();
      for (let M = 0; M < h.length; M++)
        h[M] |= 0;
    }
    if (!Array.isArray(h))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(h));
    if (!b) {
      if (h[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      h.splice(0, 2, h[0] * 40 + h[1]);
    }
    let p = 0;
    for (let M = 0; M < h.length; M++) {
      let I = h[M];
      for (p++; I >= 128; I >>= 7)
        p++;
    }
    const m = t.alloc(p);
    let E = m.length - 1;
    for (let M = h.length - 1; M >= 0; M--) {
      let I = h[M];
      for (m[E--] = I & 127; (I >>= 7) > 0; )
        m[E--] = 128 | I & 127;
    }
    return this._createEncoderBuffer(m);
  };
  function f(c) {
    return c < 10 ? "0" + c : c;
  }
  n.prototype._encodeTime = function(h, s) {
    let b;
    const p = new Date(h);
    return s === "gentime" ? b = [
      f(p.getUTCFullYear()),
      f(p.getUTCMonth() + 1),
      f(p.getUTCDate()),
      f(p.getUTCHours()),
      f(p.getUTCMinutes()),
      f(p.getUTCSeconds()),
      "Z"
    ].join("") : s === "utctime" ? b = [
      f(p.getUTCFullYear() % 100),
      f(p.getUTCMonth() + 1),
      f(p.getUTCDate()),
      f(p.getUTCHours()),
      f(p.getUTCMinutes()),
      f(p.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + s + " time is not supported yet"), this._encodeStr(b, "octstr");
  }, n.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, n.prototype._encodeInt = function(h, s) {
    if (typeof h == "string") {
      if (!s)
        return this.reporter.error("String int or enum given, but no values map");
      if (!s.hasOwnProperty(h))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(h));
      h = s[h];
    }
    if (typeof h != "number" && !t.isBuffer(h)) {
      const m = h.toArray();
      !h.sign && m[0] & 128 && m.unshift(0), h = t.from(m);
    }
    if (t.isBuffer(h)) {
      let m = h.length;
      h.length === 0 && m++;
      const E = t.alloc(m);
      return h.copy(E), h.length === 0 && (E[0] = 0), this._createEncoderBuffer(E);
    }
    if (h < 128)
      return this._createEncoderBuffer(h);
    if (h < 256)
      return this._createEncoderBuffer([0, h]);
    let b = 1;
    for (let m = h; m >= 256; m >>= 8)
      b++;
    const p = new Array(b);
    for (let m = p.length - 1; m >= 0; m--)
      p[m] = h & 255, h >>= 8;
    return p[0] & 128 && p.unshift(0), this._createEncoderBuffer(t.from(p));
  }, n.prototype._encodeBool = function(h) {
    return this._createEncoderBuffer(h ? 255 : 0);
  }, n.prototype._use = function(h, s) {
    return typeof h == "function" && (h = h(s)), h._getEncoder("der").tree;
  }, n.prototype._skipDefault = function(h, s, b) {
    const p = this._baseState;
    let m;
    if (p.default === null)
      return !1;
    const E = h.join();
    if (p.defaultBuffer === void 0 && (p.defaultBuffer = this._encodeValue(p.default, s, b).join()), E.length !== p.defaultBuffer.length)
      return !1;
    for (m = 0; m < E.length; m++)
      if (E[m] !== p.defaultBuffer[m])
        return !1;
    return !0;
  };
  function u(c, h, s, b) {
    let p;
    if (c === "seqof" ? c = "seq" : c === "setof" && (c = "set"), i.tagByName.hasOwnProperty(c))
      p = i.tagByName[c];
    else if (typeof c == "number" && (c | 0) === c)
      p = c;
    else
      return b.error("Unknown tag: " + c);
    return p >= 31 ? b.error("Multi-octet tag encoding unsupported") : (h || (p |= 32), p |= i.tagClassByName[s || "universal"] << 6, p);
  }
  return pc;
}
var vc, Wp;
function T7() {
  if (Wp)
    return vc;
  Wp = 1;
  const e = _t(), t = pg();
  function r(i) {
    t.call(this, i), this.enc = "pem";
  }
  return e(r, t), vc = r, r.prototype.encode = function(o, n) {
    const u = t.prototype.encode.call(this, o).toString("base64"), c = ["-----BEGIN " + n.label + "-----"];
    for (let h = 0; h < u.length; h += 64)
      c.push(u.slice(h, h + 64));
    return c.push("-----END " + n.label + "-----"), c.join(`
`);
  }, vc;
}
var Kp;
function vg() {
  return Kp || (Kp = 1, function(e) {
    const t = e;
    t.der = pg(), t.pem = T7();
  }(uc)), uc;
}
var bc = {}, yc, Zp;
function bg() {
  if (Zp)
    return yc;
  Zp = 1;
  const e = _t(), t = tr, r = ua().DecoderBuffer, i = y0(), o = g0();
  function n(h) {
    this.enc = "der", this.name = h.name, this.entity = h, this.tree = new f(), this.tree._init(h.body);
  }
  yc = n, n.prototype.decode = function(s, b) {
    return r.isDecoderBuffer(s) || (s = new r(s, b)), this.tree._decode(s, b);
  };
  function f(h) {
    i.call(this, "der", h);
  }
  e(f, i), f.prototype._peekTag = function(s, b, p) {
    if (s.isEmpty())
      return !1;
    const m = s.save(), E = u(s, 'Failed to peek tag: "' + b + '"');
    return s.isError(E) ? E : (s.restore(m), E.tag === b || E.tagStr === b || E.tagStr + "of" === b || p);
  }, f.prototype._decodeTag = function(s, b, p) {
    const m = u(
      s,
      'Failed to decode tag of "' + b + '"'
    );
    if (s.isError(m))
      return m;
    let E = c(
      s,
      m.primitive,
      'Failed to get length of "' + b + '"'
    );
    if (s.isError(E))
      return E;
    if (!p && m.tag !== b && m.tagStr !== b && m.tagStr + "of" !== b)
      return s.error('Failed to match tag: "' + b + '"');
    if (m.primitive || E !== null)
      return s.skip(E, 'Failed to match body of: "' + b + '"');
    const M = s.save(), I = this._skipUntilEnd(
      s,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return s.isError(I) ? I : (E = s.offset - M.offset, s.restore(M), s.skip(E, 'Failed to match body of: "' + b + '"'));
  }, f.prototype._skipUntilEnd = function(s, b) {
    for (; ; ) {
      const p = u(s, b);
      if (s.isError(p))
        return p;
      const m = c(s, p.primitive, b);
      if (s.isError(m))
        return m;
      let E;
      if (p.primitive || m !== null ? E = s.skip(m) : E = this._skipUntilEnd(s, b), s.isError(E))
        return E;
      if (p.tagStr === "end")
        break;
    }
  }, f.prototype._decodeList = function(s, b, p, m) {
    const E = [];
    for (; !s.isEmpty(); ) {
      const M = this._peekTag(s, "end");
      if (s.isError(M))
        return M;
      const I = p.decode(s, "der", m);
      if (s.isError(I) && M)
        break;
      E.push(I);
    }
    return E;
  }, f.prototype._decodeStr = function(s, b) {
    if (b === "bitstr") {
      const p = s.readUInt8();
      return s.isError(p) ? p : { unused: p, data: s.raw() };
    } else if (b === "bmpstr") {
      const p = s.raw();
      if (p.length % 2 === 1)
        return s.error("Decoding of string type: bmpstr length mismatch");
      let m = "";
      for (let E = 0; E < p.length / 2; E++)
        m += String.fromCharCode(p.readUInt16BE(E * 2));
      return m;
    } else if (b === "numstr") {
      const p = s.raw().toString("ascii");
      return this._isNumstr(p) ? p : s.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (b === "octstr")
        return s.raw();
      if (b === "objDesc")
        return s.raw();
      if (b === "printstr") {
        const p = s.raw().toString("ascii");
        return this._isPrintstr(p) ? p : s.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(b) ? s.raw().toString() : s.error("Decoding of string type: " + b + " unsupported");
    }
  }, f.prototype._decodeObjid = function(s, b, p) {
    let m;
    const E = [];
    let M = 0, I = 0;
    for (; !s.isEmpty(); )
      I = s.readUInt8(), M <<= 7, M |= I & 127, I & 128 || (E.push(M), M = 0);
    I & 128 && E.push(M);
    const B = E[0] / 40 | 0, T = E[0] % 40;
    if (p ? m = E : m = [B, T].concat(E.slice(1)), b) {
      let j = b[m.join(" ")];
      j === void 0 && (j = b[m.join(".")]), j !== void 0 && (m = j);
    }
    return m;
  }, f.prototype._decodeTime = function(s, b) {
    const p = s.raw().toString();
    let m, E, M, I, B, T;
    if (b === "gentime")
      m = p.slice(0, 4) | 0, E = p.slice(4, 6) | 0, M = p.slice(6, 8) | 0, I = p.slice(8, 10) | 0, B = p.slice(10, 12) | 0, T = p.slice(12, 14) | 0;
    else if (b === "utctime")
      m = p.slice(0, 2) | 0, E = p.slice(2, 4) | 0, M = p.slice(4, 6) | 0, I = p.slice(6, 8) | 0, B = p.slice(8, 10) | 0, T = p.slice(10, 12) | 0, m < 70 ? m = 2e3 + m : m = 1900 + m;
    else
      return s.error("Decoding " + b + " time is not supported yet");
    return Date.UTC(m, E - 1, M, I, B, T, 0);
  }, f.prototype._decodeNull = function() {
    return null;
  }, f.prototype._decodeBool = function(s) {
    const b = s.readUInt8();
    return s.isError(b) ? b : b !== 0;
  }, f.prototype._decodeInt = function(s, b) {
    const p = s.raw();
    let m = new t(p);
    return b && (m = b[m.toString(10)] || m), m;
  }, f.prototype._use = function(s, b) {
    return typeof s == "function" && (s = s(b)), s._getDecoder("der").tree;
  };
  function u(h, s) {
    let b = h.readUInt8(s);
    if (h.isError(b))
      return b;
    const p = o.tagClass[b >> 6], m = (b & 32) === 0;
    if ((b & 31) === 31) {
      let M = b;
      for (b = 0; (M & 128) === 128; ) {
        if (M = h.readUInt8(s), h.isError(M))
          return M;
        b <<= 7, b |= M & 127;
      }
    } else
      b &= 31;
    const E = o.tag[b];
    return {
      cls: p,
      primitive: m,
      tag: b,
      tagStr: E
    };
  }
  function c(h, s, b) {
    let p = h.readUInt8(b);
    if (h.isError(p))
      return p;
    if (!s && p === 128)
      return null;
    if (!(p & 128))
      return p;
    const m = p & 127;
    if (m > 4)
      return h.error("length octect is too long");
    p = 0;
    for (let E = 0; E < m; E++) {
      p <<= 8;
      const M = h.readUInt8(b);
      if (h.isError(M))
        return M;
      p |= M;
    }
    return p;
  }
  return yc;
}
var gc, Gp;
function O7() {
  if (Gp)
    return gc;
  Gp = 1;
  const e = _t(), t = v0().Buffer, r = bg();
  function i(o) {
    r.call(this, o), this.enc = "pem";
  }
  return e(i, r), gc = i, i.prototype.decode = function(n, f) {
    const u = n.toString().split(/[\r\n]+/g), c = f.label.toUpperCase(), h = /^-----(BEGIN|END) ([^-]+)-----$/;
    let s = -1, b = -1;
    for (let E = 0; E < u.length; E++) {
      const M = u[E].match(h);
      if (M !== null && M[2] === c)
        if (s === -1) {
          if (M[1] !== "BEGIN")
            break;
          s = E;
        } else {
          if (M[1] !== "END")
            break;
          b = E;
          break;
        }
    }
    if (s === -1 || b === -1)
      throw new Error("PEM section not found for: " + c);
    const p = u.slice(s + 1, b).join("");
    p.replace(/[^a-z0-9+/=]+/gi, "");
    const m = t.from(p, "base64");
    return r.prototype.decode.call(this, m, f);
  }, gc;
}
var Jp;
function yg() {
  return Jp || (Jp = 1, function(e) {
    const t = e;
    t.der = bg(), t.pem = O7();
  }(bc)), bc;
}
var Xp;
function P7() {
  return Xp || (Xp = 1, function(e) {
    const t = vg(), r = yg(), i = _t(), o = e;
    o.define = function(u, c) {
      return new n(u, c);
    };
    function n(f, u) {
      this.name = f, this.body = u, this.decoders = {}, this.encoders = {};
    }
    n.prototype._createNamed = function(u) {
      const c = this.name;
      function h(s) {
        this._initNamed(s, c);
      }
      return i(h, u), h.prototype._initNamed = function(b, p) {
        u.call(this, b, p);
      }, new h(this);
    }, n.prototype._getDecoder = function(u) {
      return u = u || "der", this.decoders.hasOwnProperty(u) || (this.decoders[u] = this._createNamed(r[u])), this.decoders[u];
    }, n.prototype.decode = function(u, c, h) {
      return this._getDecoder(c).decode(u, h);
    }, n.prototype._getEncoder = function(u) {
      return u = u || "der", this.encoders.hasOwnProperty(u) || (this.encoders[u] = this._createNamed(t[u])), this.encoders[u];
    }, n.prototype.encode = function(u, c, h) {
      return this._getEncoder(c).encode(u, h);
    };
  }(sc)), sc;
}
var mc = {}, Yp;
function C7() {
  return Yp || (Yp = 1, function(e) {
    const t = e;
    t.Reporter = b0().Reporter, t.DecoderBuffer = ua().DecoderBuffer, t.EncoderBuffer = ua().EncoderBuffer, t.Node = y0();
  }(mc)), mc;
}
var wc = {}, Qp;
function N7() {
  return Qp || (Qp = 1, function(e) {
    const t = e;
    t._reverse = function(i) {
      const o = {};
      return Object.keys(i).forEach(function(n) {
        (n | 0) == n && (n = n | 0);
        const f = i[n];
        o[f] = n;
      }), o;
    }, t.der = g0();
  }(wc)), wc;
}
var ev;
function gg() {
  return ev || (ev = 1, function(e) {
    const t = e;
    t.bignum = tr, t.define = P7().define, t.base = C7(), t.constants = N7(), t.decoders = yg(), t.encoders = vg();
  }(fc)), fc;
}
var _c, tv;
function L7() {
  if (tv)
    return _c;
  tv = 1;
  var e = gg(), t = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), r = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), i = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), o = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(i),
      this.key("subjectPublicKey").bitstr()
    );
  }), n = e.define("RelativeDistinguishedName", function() {
    this.setof(r);
  }), f = e.define("RDNSequence", function() {
    this.seqof(n);
  }), u = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(f)
    });
  }), c = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), h = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), s = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(i),
      this.key("issuer").use(u),
      this.key("validity").use(c),
      this.key("subject").use(u),
      this.key("subjectPublicKeyInfo").use(o),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(h).optional()
    );
  }), b = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(s),
      this.key("signatureAlgorithm").use(i),
      this.key("signatureValue").bitstr()
    );
  });
  return _c = b, _c;
}
var rv;
function k7() {
  if (rv)
    return Br;
  rv = 1;
  var e = gg();
  Br.certificate = L7();
  var t = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  Br.RSAPrivateKey = t;
  var r = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  Br.RSAPublicKey = r;
  var i = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(o),
      this.key("subjectPublicKey").bitstr()
    );
  });
  Br.PublicKey = i;
  var o = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), n = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(o),
      this.key("subjectPrivateKey").octstr()
    );
  });
  Br.PrivateKey = n;
  var f = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  Br.EncryptedPrivateKey = f;
  var u = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  Br.DSAPrivateKey = u, Br.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var c = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(h),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  Br.ECPrivateKey = c;
  var h = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  return Br.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), Br;
}
const j7 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var xc, nv;
function q7() {
  if (nv)
    return xc;
  nv = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, i = sf(), o = u0(), n = Rt().Buffer;
  return xc = function(f, u) {
    var c = f.toString(), h = c.match(e), s;
    if (h) {
      var p = "aes" + h[1], m = n.from(h[2], "hex"), E = n.from(h[3].replace(/[\r\n]/g, ""), "base64"), M = i(u, m.slice(0, 8), parseInt(h[1], 10)).key, I = [], B = o.createDecipheriv(p, M, m);
      I.push(B.update(E)), I.push(B.final()), s = n.concat(I);
    } else {
      var b = c.match(r);
      s = n.from(b[2].replace(/[\r\n]/g, ""), "base64");
    }
    var T = c.match(t)[1];
    return {
      tag: T,
      data: s
    };
  }, xc;
}
var Ec, iv;
function cf() {
  if (iv)
    return Ec;
  iv = 1;
  var e = k7(), t = j7, r = q7(), i = u0(), o = Qy(), n = Rt().Buffer;
  Ec = f;
  function f(c) {
    var h;
    typeof c == "object" && !n.isBuffer(c) && (h = c.passphrase, c = c.key), typeof c == "string" && (c = n.from(c));
    var s = r(c, h), b = s.tag, p = s.data, m, E;
    switch (b) {
      case "CERTIFICATE":
        E = e.certificate.decode(p, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (E || (E = e.PublicKey.decode(p, "der")), m = E.algorithm.algorithm.join("."), m) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(E.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return E.subjectPrivateKey = E.subjectPublicKey, {
              type: "ec",
              data: E
            };
          case "1.2.840.10040.4.1":
            return E.algorithm.params.pub_key = e.DSAparam.decode(E.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: E.algorithm.params
            };
          default:
            throw new Error("unknown key id " + m);
        }
      case "ENCRYPTED PRIVATE KEY":
        p = e.EncryptedPrivateKey.decode(p, "der"), p = u(p, h);
      case "PRIVATE KEY":
        switch (E = e.PrivateKey.decode(p, "der"), m = E.algorithm.algorithm.join("."), m) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(E.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: E.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(E.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return E.algorithm.params.priv_key = e.DSAparam.decode(E.subjectPrivateKey, "der"), {
              type: "dsa",
              params: E.algorithm.params
            };
          default:
            throw new Error("unknown key id " + m);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(p, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(p, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(p, "der")
        };
      case "EC PRIVATE KEY":
        return p = e.ECPrivateKey.decode(p, "der"), {
          curve: p.parameters.value,
          privateKey: p.privateKey
        };
      default:
        throw new Error("unknown key type " + b);
    }
  }
  f.signature = e.signature;
  function u(c, h) {
    var s = c.algorithm.decrypt.kde.kdeparams.salt, b = parseInt(c.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), p = t[c.algorithm.decrypt.cipher.algo.join(".")], m = c.algorithm.decrypt.cipher.iv, E = c.subjectPrivateKey, M = parseInt(p.split("-")[1], 10) / 8, I = o.pbkdf2Sync(h, s, b, M, "sha1"), B = i.createDecipheriv(p, I, m), T = [];
    return T.push(B.update(E)), T.push(B.final()), n.concat(T);
  }
  return Ec;
}
const mg = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var av;
function D7() {
  if (av)
    return Gi.exports;
  av = 1;
  var e = Rt().Buffer, t = Ky(), r = h0(), i = p0().ec, o = dg(), n = cf(), f = mg, u = 1;
  function c(B, T, j, N, k) {
    var q = n(T);
    if (q.curve) {
      if (N !== "ecdsa" && N !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return h(B, q);
    } else if (q.type === "dsa") {
      if (N !== "dsa")
        throw new Error("wrong private key type");
      return s(B, q, j);
    }
    if (N !== "rsa" && N !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (T.padding !== void 0 && T.padding !== u)
      throw new Error("illegal or unsupported padding mode");
    B = e.concat([k, B]);
    for (var $ = q.modulus.byteLength(), re = [0, 1]; B.length + re.length + 1 < $; )
      re.push(255);
    re.push(0);
    for (var Q = -1; ++Q < B.length; )
      re.push(B[Q]);
    var fe = r(re, q);
    return fe;
  }
  function h(B, T) {
    var j = f[T.curve.join(".")];
    if (!j)
      throw new Error("unknown curve " + T.curve.join("."));
    var N = new i(j), k = N.keyFromPrivate(T.privateKey), q = k.sign(B);
    return e.from(q.toDER());
  }
  function s(B, T, j) {
    for (var N = T.params.priv_key, k = T.params.p, q = T.params.q, $ = T.params.g, re = new o(0), Q, fe = m(B, q).mod(q), U = !1, y = p(N, q, B, j); U === !1; )
      Q = M(q, y, j), re = I($, Q, k, q), U = Q.invm(q).imul(fe.add(N.mul(re))).mod(q), U.cmpn(0) === 0 && (U = !1, re = new o(0));
    return b(re, U);
  }
  function b(B, T) {
    B = B.toArray(), T = T.toArray(), B[0] & 128 && (B = [0].concat(B)), T[0] & 128 && (T = [0].concat(T));
    var j = B.length + T.length + 4, N = [
      48,
      j,
      2,
      B.length
    ];
    return N = N.concat(B, [2, T.length], T), e.from(N);
  }
  function p(B, T, j, N) {
    if (B = e.from(B.toArray()), B.length < T.byteLength()) {
      var k = e.alloc(T.byteLength() - B.length);
      B = e.concat([k, B]);
    }
    var q = j.length, $ = E(j, T), re = e.alloc(q);
    re.fill(1);
    var Q = e.alloc(q);
    return Q = t(N, Q).update(re).update(e.from([0])).update(B).update($).digest(), re = t(N, Q).update(re).digest(), Q = t(N, Q).update(re).update(e.from([1])).update(B).update($).digest(), re = t(N, Q).update(re).digest(), { k: Q, v: re };
  }
  function m(B, T) {
    var j = new o(B), N = (B.length << 3) - T.bitLength();
    return N > 0 && j.ishrn(N), j;
  }
  function E(B, T) {
    B = m(B, T), B = B.mod(T);
    var j = e.from(B.toArray());
    if (j.length < T.byteLength()) {
      var N = e.alloc(T.byteLength() - j.length);
      j = e.concat([N, j]);
    }
    return j;
  }
  function M(B, T, j) {
    var N, k;
    do {
      for (N = e.alloc(0); N.length * 8 < B.bitLength(); )
        T.v = t(j, T.k).update(T.v).digest(), N = e.concat([N, T.v]);
      k = m(N, B), T.k = t(j, T.k).update(T.v).update(e.from([0])).digest(), T.v = t(j, T.k).update(T.v).digest();
    } while (k.cmp(B) !== -1);
    return k;
  }
  function I(B, T, j, N) {
    return B.toRed(o.mont(j)).redPow(T).fromRed().mod(N);
  }
  return Gi.exports = c, Gi.exports.getKey = p, Gi.exports.makeKey = M, Gi.exports;
}
var Sc, ov;
function $7() {
  if (ov)
    return Sc;
  ov = 1;
  var e = Rt().Buffer, t = dg(), r = p0().ec, i = cf(), o = mg;
  function n(h, s, b, p, m) {
    var E = i(b);
    if (E.type === "ec") {
      if (p !== "ecdsa" && p !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return f(h, s, E);
    } else if (E.type === "dsa") {
      if (p !== "dsa")
        throw new Error("wrong public key type");
      return u(h, s, E);
    }
    if (p !== "rsa" && p !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    s = e.concat([m, s]);
    for (var M = E.modulus.byteLength(), I = [1], B = 0; s.length + I.length + 2 < M; )
      I.push(255), B += 1;
    I.push(0);
    for (var T = -1; ++T < s.length; )
      I.push(s[T]);
    I = e.from(I);
    var j = t.mont(E.modulus);
    h = new t(h).toRed(j), h = h.redPow(new t(E.publicExponent)), h = e.from(h.fromRed().toArray());
    var N = B < 8 ? 1 : 0;
    for (M = Math.min(h.length, I.length), h.length !== I.length && (N = 1), T = -1; ++T < M; )
      N |= h[T] ^ I[T];
    return N === 0;
  }
  function f(h, s, b) {
    var p = o[b.data.algorithm.curve.join(".")];
    if (!p)
      throw new Error("unknown curve " + b.data.algorithm.curve.join("."));
    var m = new r(p), E = b.data.subjectPrivateKey.data;
    return m.verify(s, h, E);
  }
  function u(h, s, b) {
    var p = b.data.p, m = b.data.q, E = b.data.g, M = b.data.pub_key, I = i.signature.decode(h, "der"), B = I.s, T = I.r;
    c(B, m), c(T, m);
    var j = t.mont(p), N = B.invm(m), k = E.toRed(j).redPow(new t(s).mul(N).mod(m)).fromRed().mul(M.toRed(j).redPow(T.mul(N).mod(m)).fromRed()).mod(p).mod(m);
    return k.cmp(T) === 0;
  }
  function c(h, s) {
    if (h.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (h.cmp(s) >= 0)
      throw new Error("invalid sig");
  }
  return Sc = n, Sc;
}
var Ac, fv;
function U7() {
  if (fv)
    return Ac;
  fv = 1;
  var e = Rt().Buffer, t = xa(), r = tf(), i = _t(), o = D7(), n = $7(), f = Zy;
  Object.keys(f).forEach(function(b) {
    f[b].id = e.from(f[b].id, "hex"), f[b.toLowerCase()] = f[b];
  });
  function u(b) {
    r.Writable.call(this);
    var p = f[b];
    if (!p)
      throw new Error("Unknown message digest");
    this._hashType = p.hash, this._hash = t(p.hash), this._tag = p.id, this._signType = p.sign;
  }
  i(u, r.Writable), u.prototype._write = function(p, m, E) {
    this._hash.update(p), E();
  }, u.prototype.update = function(p, m) {
    return this._hash.update(typeof p == "string" ? e.from(p, m) : p), this;
  }, u.prototype.sign = function(p, m) {
    this.end();
    var E = this._hash.digest(), M = o(E, p, this._hashType, this._signType, this._tag);
    return m ? M.toString(m) : M;
  };
  function c(b) {
    r.Writable.call(this);
    var p = f[b];
    if (!p)
      throw new Error("Unknown message digest");
    this._hash = t(p.hash), this._tag = p.id, this._signType = p.sign;
  }
  i(c, r.Writable), c.prototype._write = function(p, m, E) {
    this._hash.update(p), E();
  }, c.prototype.update = function(p, m) {
    return this._hash.update(typeof p == "string" ? e.from(p, m) : p), this;
  }, c.prototype.verify = function(p, m, E) {
    var M = typeof m == "string" ? e.from(m, E) : m;
    this.end();
    var I = this._hash.digest();
    return n(M, I, p, this._signType, this._tag);
  };
  function h(b) {
    return new u(b);
  }
  function s(b) {
    return new c(b);
  }
  return Ac = {
    Sign: h,
    Verify: s,
    createSign: h,
    createVerify: s
  }, Ac;
}
var Mc, sv;
function F7() {
  if (sv)
    return Mc;
  sv = 1;
  var e = p0(), t = tr;
  Mc = function(f) {
    return new i(f);
  };
  var r = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
  function i(n) {
    this.curveType = r[n], this.curveType || (this.curveType = {
      name: n
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  i.prototype.generateKeys = function(n, f) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(n, f);
  }, i.prototype.computeSecret = function(n, f, u) {
    f = f || "utf8", Le.Buffer.isBuffer(n) || (n = new Le.Buffer(n, f));
    var c = this.curve.keyFromPublic(n).getPublic(), h = c.mul(this.keys.getPrivate()).getX();
    return o(h, u, this.curveType.byteLength);
  }, i.prototype.getPublicKey = function(n, f) {
    var u = this.keys.getPublic(f === "compressed", !0);
    return f === "hybrid" && (u[u.length - 1] % 2 ? u[0] = 7 : u[0] = 6), o(u, n);
  }, i.prototype.getPrivateKey = function(n) {
    return o(this.keys.getPrivate(), n);
  }, i.prototype.setPublicKey = function(n, f) {
    return f = f || "utf8", Le.Buffer.isBuffer(n) || (n = new Le.Buffer(n, f)), this.keys._importPublic(n), this;
  }, i.prototype.setPrivateKey = function(n, f) {
    f = f || "utf8", Le.Buffer.isBuffer(n) || (n = new Le.Buffer(n, f));
    var u = new t(n);
    return u = u.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(u), this;
  };
  function o(n, f, u) {
    Array.isArray(n) || (n = n.toArray());
    var c = new Le.Buffer(n);
    if (u && c.length < u) {
      var h = new Le.Buffer(u - c.length);
      h.fill(0), c = Le.Buffer.concat([h, c]);
    }
    return f ? c.toString(f) : c;
  }
  return Mc;
}
var Rc = {}, Bc, uv;
function wg() {
  if (uv)
    return Bc;
  uv = 1;
  var e = xa(), t = Rt().Buffer;
  Bc = function(i, o) {
    for (var n = t.alloc(0), f = 0, u; n.length < o; )
      u = r(f++), n = t.concat([n, e("sha1").update(i).update(u).digest()]);
    return n.slice(0, o);
  };
  function r(i) {
    var o = t.allocUnsafe(4);
    return o.writeUInt32BE(i, 0), o;
  }
  return Bc;
}
var Ic, cv;
function _g() {
  return cv || (cv = 1, Ic = function(t, r) {
    for (var i = t.length, o = -1; ++o < i; )
      t[o] ^= r[o];
    return t;
  }), Ic;
}
var Tc, hv;
function xg() {
  if (hv)
    return Tc;
  hv = 1;
  var e = tr, t = Rt().Buffer;
  function r(i, o) {
    return t.from(i.toRed(e.mont(o.modulus)).redPow(new e(o.publicExponent)).fromRed().toArray());
  }
  return Tc = r, Tc;
}
var Oc, lv;
function z7() {
  if (lv)
    return Oc;
  lv = 1;
  var e = cf(), t = $i(), r = xa(), i = wg(), o = _g(), n = tr, f = xg(), u = h0(), c = Rt().Buffer;
  Oc = function(m, E, M) {
    var I;
    m.padding ? I = m.padding : M ? I = 1 : I = 4;
    var B = e(m), T;
    if (I === 4)
      T = h(B, E);
    else if (I === 1)
      T = s(B, E, M);
    else if (I === 3) {
      if (T = new n(E), T.cmp(B.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return M ? u(T, B) : f(T, B);
  };
  function h(p, m) {
    var E = p.modulus.byteLength(), M = m.length, I = r("sha1").update(c.alloc(0)).digest(), B = I.length, T = 2 * B;
    if (M > E - T - 2)
      throw new Error("message too long");
    var j = c.alloc(E - M - T - 2), N = E - B - 1, k = t(B), q = o(c.concat([I, j, c.alloc(1, 1), m], N), i(k, N)), $ = o(k, i(q, B));
    return new n(c.concat([c.alloc(1), $, q], E));
  }
  function s(p, m, E) {
    var M = m.length, I = p.modulus.byteLength();
    if (M > I - 11)
      throw new Error("message too long");
    var B;
    return E ? B = c.alloc(I - M - 3, 255) : B = b(I - M - 3), new n(c.concat([c.from([0, E ? 1 : 2]), B, c.alloc(1), m], I));
  }
  function b(p) {
    for (var m = c.allocUnsafe(p), E = 0, M = t(p * 2), I = 0, B; E < p; )
      I === M.length && (M = t(p * 2), I = 0), B = M[I++], B && (m[E++] = B);
    return m;
  }
  return Oc;
}
var Pc, dv;
function H7() {
  if (dv)
    return Pc;
  dv = 1;
  var e = cf(), t = wg(), r = _g(), i = tr, o = h0(), n = xa(), f = xg(), u = Rt().Buffer;
  Pc = function(p, m, E) {
    var M;
    p.padding ? M = p.padding : E ? M = 1 : M = 4;
    var I = e(p), B = I.modulus.byteLength();
    if (m.length > B || new i(m).cmp(I.modulus) >= 0)
      throw new Error("decryption error");
    var T;
    E ? T = f(new i(m), I) : T = o(m, I);
    var j = u.alloc(B - T.length);
    if (T = u.concat([j, T], B), M === 4)
      return c(I, T);
    if (M === 1)
      return h(I, T, E);
    if (M === 3)
      return T;
    throw new Error("unknown padding");
  };
  function c(b, p) {
    var m = b.modulus.byteLength(), E = n("sha1").update(u.alloc(0)).digest(), M = E.length;
    if (p[0] !== 0)
      throw new Error("decryption error");
    var I = p.slice(1, M + 1), B = p.slice(M + 1), T = r(I, t(B, M)), j = r(B, t(T, m - M - 1));
    if (s(E, j.slice(0, M)))
      throw new Error("decryption error");
    for (var N = M; j[N] === 0; )
      N++;
    if (j[N++] !== 1)
      throw new Error("decryption error");
    return j.slice(N);
  }
  function h(b, p, m) {
    for (var E = p.slice(0, 2), M = 2, I = 0; p[M++] !== 0; )
      if (M >= p.length) {
        I++;
        break;
      }
    var B = p.slice(2, M - 1);
    if ((E.toString("hex") !== "0002" && !m || E.toString("hex") !== "0001" && m) && I++, B.length < 8 && I++, I)
      throw new Error("decryption error");
    return p.slice(M);
  }
  function s(b, p) {
    b = u.from(b), p = u.from(p);
    var m = 0, E = b.length;
    b.length !== p.length && (m++, E = Math.min(b.length, p.length));
    for (var M = -1; ++M < E; )
      m += b[M] ^ p[M];
    return m;
  }
  return Pc;
}
var pv;
function V7() {
  return pv || (pv = 1, function(e) {
    e.publicEncrypt = z7(), e.privateDecrypt = H7(), e.privateEncrypt = function(r, i) {
      return e.publicEncrypt(r, i, !0);
    }, e.publicDecrypt = function(r, i) {
      return e.privateDecrypt(r, i, !0);
    };
  }(Rc)), Rc;
}
var li = {}, vv;
function W7() {
  if (vv)
    return li;
  vv = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = Rt(), r = $i(), i = t.Buffer, o = t.kMaxLength, n = Ze.crypto || Ze.msCrypto, f = Math.pow(2, 32) - 1;
  function u(p, m) {
    if (typeof p != "number" || p !== p)
      throw new TypeError("offset must be a number");
    if (p > f || p < 0)
      throw new TypeError("offset must be a uint32");
    if (p > o || p > m)
      throw new RangeError("offset out of range");
  }
  function c(p, m, E) {
    if (typeof p != "number" || p !== p)
      throw new TypeError("size must be a number");
    if (p > f || p < 0)
      throw new TypeError("size must be a uint32");
    if (p + m > E || p > o)
      throw new RangeError("buffer too small");
  }
  n && n.getRandomValues || !at.browser ? (li.randomFill = h, li.randomFillSync = b) : (li.randomFill = e, li.randomFillSync = e);
  function h(p, m, E, M) {
    if (!i.isBuffer(p) && !(p instanceof Ze.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof m == "function")
      M = m, m = 0, E = p.length;
    else if (typeof E == "function")
      M = E, E = p.length - m;
    else if (typeof M != "function")
      throw new TypeError('"cb" argument must be a function');
    return u(m, p.length), c(E, m, p.length), s(p, m, E, M);
  }
  function s(p, m, E, M) {
    if (at.browser) {
      var I = p.buffer, B = new Uint8Array(I, m, E);
      if (n.getRandomValues(B), M) {
        at.nextTick(function() {
          M(null, p);
        });
        return;
      }
      return p;
    }
    if (M) {
      r(E, function(j, N) {
        if (j)
          return M(j);
        N.copy(p, m), M(null, p);
      });
      return;
    }
    var T = r(E);
    return T.copy(p, m), p;
  }
  function b(p, m, E) {
    if (typeof m > "u" && (m = 0), !i.isBuffer(p) && !(p instanceof Ze.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return u(m, p.length), E === void 0 && (E = p.length - m), c(E, m, p.length), s(p, m, E);
  }
  return li;
}
var bv;
function Eg() {
  if (bv)
    return Et;
  bv = 1, Et.randomBytes = Et.rng = Et.pseudoRandomBytes = Et.prng = $i(), Et.createHash = Et.Hash = xa(), Et.createHmac = Et.Hmac = Ky();
  var e = wE(), t = Object.keys(e), r = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  Et.getHashes = function() {
    return r;
  };
  var i = Qy();
  Et.pbkdf2 = i.pbkdf2, Et.pbkdf2Sync = i.pbkdf2Sync;
  var o = DE();
  Et.Cipher = o.Cipher, Et.createCipher = o.createCipher, Et.Cipheriv = o.Cipheriv, Et.createCipheriv = o.createCipheriv, Et.Decipher = o.Decipher, Et.createDecipher = o.createDecipher, Et.Decipheriv = o.Decipheriv, Et.createDecipheriv = o.createDecipheriv, Et.getCiphers = o.getCiphers, Et.listCiphers = o.listCiphers;
  var n = JE();
  Et.DiffieHellmanGroup = n.DiffieHellmanGroup, Et.createDiffieHellmanGroup = n.createDiffieHellmanGroup, Et.getDiffieHellman = n.getDiffieHellman, Et.createDiffieHellman = n.createDiffieHellman, Et.DiffieHellman = n.DiffieHellman;
  var f = U7();
  Et.createSign = f.createSign, Et.Sign = f.Sign, Et.createVerify = f.createVerify, Et.Verify = f.Verify, Et.createECDH = F7();
  var u = V7();
  Et.publicEncrypt = u.publicEncrypt, Et.privateEncrypt = u.privateEncrypt, Et.publicDecrypt = u.publicDecrypt, Et.privateDecrypt = u.privateDecrypt;
  var c = W7();
  return Et.randomFill = c.randomFill, Et.randomFillSync = c.randomFillSync, Et.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, Et.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, Et;
}
(function(e) {
  (function(t) {
    var r = function(D) {
      var J, ne = new Float64Array(16);
      if (D)
        for (J = 0; J < D.length; J++)
          ne[J] = D[J];
      return ne;
    }, i = function() {
      throw new Error("no PRNG");
    }, o = new Uint8Array(16), n = new Uint8Array(32);
    n[0] = 9;
    var f = r(), u = r([1]), c = r([56129, 1]), h = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), s = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), b = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), p = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), m = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function E(D, J, ne, O) {
      D[J] = ne >> 24 & 255, D[J + 1] = ne >> 16 & 255, D[J + 2] = ne >> 8 & 255, D[J + 3] = ne & 255, D[J + 4] = O >> 24 & 255, D[J + 5] = O >> 16 & 255, D[J + 6] = O >> 8 & 255, D[J + 7] = O & 255;
    }
    function M(D, J, ne, O, ae) {
      var we, xe = 0;
      for (we = 0; we < ae; we++)
        xe |= D[J + we] ^ ne[O + we];
      return (1 & xe - 1 >>> 8) - 1;
    }
    function I(D, J, ne, O) {
      return M(D, J, ne, O, 16);
    }
    function B(D, J, ne, O) {
      return M(D, J, ne, O, 32);
    }
    function T(D, J, ne, O) {
      for (var ae = O[0] & 255 | (O[1] & 255) << 8 | (O[2] & 255) << 16 | (O[3] & 255) << 24, we = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, xe = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, Re = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, De = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, He = O[4] & 255 | (O[5] & 255) << 8 | (O[6] & 255) << 16 | (O[7] & 255) << 24, Ue = J[0] & 255 | (J[1] & 255) << 8 | (J[2] & 255) << 16 | (J[3] & 255) << 24, yt = J[4] & 255 | (J[5] & 255) << 8 | (J[6] & 255) << 16 | (J[7] & 255) << 24, et = J[8] & 255 | (J[9] & 255) << 8 | (J[10] & 255) << 16 | (J[11] & 255) << 24, ut = J[12] & 255 | (J[13] & 255) << 8 | (J[14] & 255) << 16 | (J[15] & 255) << 24, ct = O[8] & 255 | (O[9] & 255) << 8 | (O[10] & 255) << 16 | (O[11] & 255) << 24, vt = ne[16] & 255 | (ne[17] & 255) << 8 | (ne[18] & 255) << 16 | (ne[19] & 255) << 24, pt = ne[20] & 255 | (ne[21] & 255) << 8 | (ne[22] & 255) << 16 | (ne[23] & 255) << 24, ht = ne[24] & 255 | (ne[25] & 255) << 8 | (ne[26] & 255) << 16 | (ne[27] & 255) << 24, dt = ne[28] & 255 | (ne[29] & 255) << 8 | (ne[30] & 255) << 16 | (ne[31] & 255) << 24, lt = O[12] & 255 | (O[13] & 255) << 8 | (O[14] & 255) << 16 | (O[15] & 255) << 24, tt = ae, ot = we, Qe = xe, rt = Re, it = De, Ye = He, Oe = Ue, Pe = yt, Ke = et, Fe = ut, We = ct, Xe = vt, bt = pt, mt = ht, xt = dt, wt = lt, ye, At = 0; At < 20; At += 2)
        ye = tt + bt | 0, it ^= ye << 7 | ye >>> 25, ye = it + tt | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + it | 0, bt ^= ye << 13 | ye >>> 19, ye = bt + Ke | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + ot | 0, Fe ^= ye << 7 | ye >>> 25, ye = Fe + Ye | 0, mt ^= ye << 9 | ye >>> 23, ye = mt + Fe | 0, ot ^= ye << 13 | ye >>> 19, ye = ot + mt | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Oe | 0, xt ^= ye << 7 | ye >>> 25, ye = xt + We | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + xt | 0, Oe ^= ye << 13 | ye >>> 19, ye = Oe + Qe | 0, We ^= ye << 18 | ye >>> 14, ye = wt + Xe | 0, rt ^= ye << 7 | ye >>> 25, ye = rt + wt | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + rt | 0, Xe ^= ye << 13 | ye >>> 19, ye = Xe + Pe | 0, wt ^= ye << 18 | ye >>> 14, ye = tt + rt | 0, ot ^= ye << 7 | ye >>> 25, ye = ot + tt | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + ot | 0, rt ^= ye << 13 | ye >>> 19, ye = rt + Qe | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + it | 0, Oe ^= ye << 7 | ye >>> 25, ye = Oe + Ye | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + Oe | 0, it ^= ye << 13 | ye >>> 19, ye = it + Pe | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Fe | 0, Xe ^= ye << 7 | ye >>> 25, ye = Xe + We | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + Xe | 0, Fe ^= ye << 13 | ye >>> 19, ye = Fe + Ke | 0, We ^= ye << 18 | ye >>> 14, ye = wt + xt | 0, bt ^= ye << 7 | ye >>> 25, ye = bt + wt | 0, mt ^= ye << 9 | ye >>> 23, ye = mt + bt | 0, xt ^= ye << 13 | ye >>> 19, ye = xt + mt | 0, wt ^= ye << 18 | ye >>> 14;
      tt = tt + ae | 0, ot = ot + we | 0, Qe = Qe + xe | 0, rt = rt + Re | 0, it = it + De | 0, Ye = Ye + He | 0, Oe = Oe + Ue | 0, Pe = Pe + yt | 0, Ke = Ke + et | 0, Fe = Fe + ut | 0, We = We + ct | 0, Xe = Xe + vt | 0, bt = bt + pt | 0, mt = mt + ht | 0, xt = xt + dt | 0, wt = wt + lt | 0, D[0] = tt >>> 0 & 255, D[1] = tt >>> 8 & 255, D[2] = tt >>> 16 & 255, D[3] = tt >>> 24 & 255, D[4] = ot >>> 0 & 255, D[5] = ot >>> 8 & 255, D[6] = ot >>> 16 & 255, D[7] = ot >>> 24 & 255, D[8] = Qe >>> 0 & 255, D[9] = Qe >>> 8 & 255, D[10] = Qe >>> 16 & 255, D[11] = Qe >>> 24 & 255, D[12] = rt >>> 0 & 255, D[13] = rt >>> 8 & 255, D[14] = rt >>> 16 & 255, D[15] = rt >>> 24 & 255, D[16] = it >>> 0 & 255, D[17] = it >>> 8 & 255, D[18] = it >>> 16 & 255, D[19] = it >>> 24 & 255, D[20] = Ye >>> 0 & 255, D[21] = Ye >>> 8 & 255, D[22] = Ye >>> 16 & 255, D[23] = Ye >>> 24 & 255, D[24] = Oe >>> 0 & 255, D[25] = Oe >>> 8 & 255, D[26] = Oe >>> 16 & 255, D[27] = Oe >>> 24 & 255, D[28] = Pe >>> 0 & 255, D[29] = Pe >>> 8 & 255, D[30] = Pe >>> 16 & 255, D[31] = Pe >>> 24 & 255, D[32] = Ke >>> 0 & 255, D[33] = Ke >>> 8 & 255, D[34] = Ke >>> 16 & 255, D[35] = Ke >>> 24 & 255, D[36] = Fe >>> 0 & 255, D[37] = Fe >>> 8 & 255, D[38] = Fe >>> 16 & 255, D[39] = Fe >>> 24 & 255, D[40] = We >>> 0 & 255, D[41] = We >>> 8 & 255, D[42] = We >>> 16 & 255, D[43] = We >>> 24 & 255, D[44] = Xe >>> 0 & 255, D[45] = Xe >>> 8 & 255, D[46] = Xe >>> 16 & 255, D[47] = Xe >>> 24 & 255, D[48] = bt >>> 0 & 255, D[49] = bt >>> 8 & 255, D[50] = bt >>> 16 & 255, D[51] = bt >>> 24 & 255, D[52] = mt >>> 0 & 255, D[53] = mt >>> 8 & 255, D[54] = mt >>> 16 & 255, D[55] = mt >>> 24 & 255, D[56] = xt >>> 0 & 255, D[57] = xt >>> 8 & 255, D[58] = xt >>> 16 & 255, D[59] = xt >>> 24 & 255, D[60] = wt >>> 0 & 255, D[61] = wt >>> 8 & 255, D[62] = wt >>> 16 & 255, D[63] = wt >>> 24 & 255;
    }
    function j(D, J, ne, O) {
      for (var ae = O[0] & 255 | (O[1] & 255) << 8 | (O[2] & 255) << 16 | (O[3] & 255) << 24, we = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, xe = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, Re = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, De = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, He = O[4] & 255 | (O[5] & 255) << 8 | (O[6] & 255) << 16 | (O[7] & 255) << 24, Ue = J[0] & 255 | (J[1] & 255) << 8 | (J[2] & 255) << 16 | (J[3] & 255) << 24, yt = J[4] & 255 | (J[5] & 255) << 8 | (J[6] & 255) << 16 | (J[7] & 255) << 24, et = J[8] & 255 | (J[9] & 255) << 8 | (J[10] & 255) << 16 | (J[11] & 255) << 24, ut = J[12] & 255 | (J[13] & 255) << 8 | (J[14] & 255) << 16 | (J[15] & 255) << 24, ct = O[8] & 255 | (O[9] & 255) << 8 | (O[10] & 255) << 16 | (O[11] & 255) << 24, vt = ne[16] & 255 | (ne[17] & 255) << 8 | (ne[18] & 255) << 16 | (ne[19] & 255) << 24, pt = ne[20] & 255 | (ne[21] & 255) << 8 | (ne[22] & 255) << 16 | (ne[23] & 255) << 24, ht = ne[24] & 255 | (ne[25] & 255) << 8 | (ne[26] & 255) << 16 | (ne[27] & 255) << 24, dt = ne[28] & 255 | (ne[29] & 255) << 8 | (ne[30] & 255) << 16 | (ne[31] & 255) << 24, lt = O[12] & 255 | (O[13] & 255) << 8 | (O[14] & 255) << 16 | (O[15] & 255) << 24, tt = ae, ot = we, Qe = xe, rt = Re, it = De, Ye = He, Oe = Ue, Pe = yt, Ke = et, Fe = ut, We = ct, Xe = vt, bt = pt, mt = ht, xt = dt, wt = lt, ye, At = 0; At < 20; At += 2)
        ye = tt + bt | 0, it ^= ye << 7 | ye >>> 25, ye = it + tt | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + it | 0, bt ^= ye << 13 | ye >>> 19, ye = bt + Ke | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + ot | 0, Fe ^= ye << 7 | ye >>> 25, ye = Fe + Ye | 0, mt ^= ye << 9 | ye >>> 23, ye = mt + Fe | 0, ot ^= ye << 13 | ye >>> 19, ye = ot + mt | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Oe | 0, xt ^= ye << 7 | ye >>> 25, ye = xt + We | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + xt | 0, Oe ^= ye << 13 | ye >>> 19, ye = Oe + Qe | 0, We ^= ye << 18 | ye >>> 14, ye = wt + Xe | 0, rt ^= ye << 7 | ye >>> 25, ye = rt + wt | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + rt | 0, Xe ^= ye << 13 | ye >>> 19, ye = Xe + Pe | 0, wt ^= ye << 18 | ye >>> 14, ye = tt + rt | 0, ot ^= ye << 7 | ye >>> 25, ye = ot + tt | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + ot | 0, rt ^= ye << 13 | ye >>> 19, ye = rt + Qe | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + it | 0, Oe ^= ye << 7 | ye >>> 25, ye = Oe + Ye | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + Oe | 0, it ^= ye << 13 | ye >>> 19, ye = it + Pe | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Fe | 0, Xe ^= ye << 7 | ye >>> 25, ye = Xe + We | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + Xe | 0, Fe ^= ye << 13 | ye >>> 19, ye = Fe + Ke | 0, We ^= ye << 18 | ye >>> 14, ye = wt + xt | 0, bt ^= ye << 7 | ye >>> 25, ye = bt + wt | 0, mt ^= ye << 9 | ye >>> 23, ye = mt + bt | 0, xt ^= ye << 13 | ye >>> 19, ye = xt + mt | 0, wt ^= ye << 18 | ye >>> 14;
      D[0] = tt >>> 0 & 255, D[1] = tt >>> 8 & 255, D[2] = tt >>> 16 & 255, D[3] = tt >>> 24 & 255, D[4] = Ye >>> 0 & 255, D[5] = Ye >>> 8 & 255, D[6] = Ye >>> 16 & 255, D[7] = Ye >>> 24 & 255, D[8] = We >>> 0 & 255, D[9] = We >>> 8 & 255, D[10] = We >>> 16 & 255, D[11] = We >>> 24 & 255, D[12] = wt >>> 0 & 255, D[13] = wt >>> 8 & 255, D[14] = wt >>> 16 & 255, D[15] = wt >>> 24 & 255, D[16] = Oe >>> 0 & 255, D[17] = Oe >>> 8 & 255, D[18] = Oe >>> 16 & 255, D[19] = Oe >>> 24 & 255, D[20] = Pe >>> 0 & 255, D[21] = Pe >>> 8 & 255, D[22] = Pe >>> 16 & 255, D[23] = Pe >>> 24 & 255, D[24] = Ke >>> 0 & 255, D[25] = Ke >>> 8 & 255, D[26] = Ke >>> 16 & 255, D[27] = Ke >>> 24 & 255, D[28] = Fe >>> 0 & 255, D[29] = Fe >>> 8 & 255, D[30] = Fe >>> 16 & 255, D[31] = Fe >>> 24 & 255;
    }
    function N(D, J, ne, O) {
      T(D, J, ne, O);
    }
    function k(D, J, ne, O) {
      j(D, J, ne, O);
    }
    var q = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function $(D, J, ne, O, ae, we, xe) {
      var Re = new Uint8Array(16), De = new Uint8Array(64), He, Ue;
      for (Ue = 0; Ue < 16; Ue++)
        Re[Ue] = 0;
      for (Ue = 0; Ue < 8; Ue++)
        Re[Ue] = we[Ue];
      for (; ae >= 64; ) {
        for (N(De, Re, xe, q), Ue = 0; Ue < 64; Ue++)
          D[J + Ue] = ne[O + Ue] ^ De[Ue];
        for (He = 1, Ue = 8; Ue < 16; Ue++)
          He = He + (Re[Ue] & 255) | 0, Re[Ue] = He & 255, He >>>= 8;
        ae -= 64, J += 64, O += 64;
      }
      if (ae > 0)
        for (N(De, Re, xe, q), Ue = 0; Ue < ae; Ue++)
          D[J + Ue] = ne[O + Ue] ^ De[Ue];
      return 0;
    }
    function re(D, J, ne, O, ae) {
      var we = new Uint8Array(16), xe = new Uint8Array(64), Re, De;
      for (De = 0; De < 16; De++)
        we[De] = 0;
      for (De = 0; De < 8; De++)
        we[De] = O[De];
      for (; ne >= 64; ) {
        for (N(xe, we, ae, q), De = 0; De < 64; De++)
          D[J + De] = xe[De];
        for (Re = 1, De = 8; De < 16; De++)
          Re = Re + (we[De] & 255) | 0, we[De] = Re & 255, Re >>>= 8;
        ne -= 64, J += 64;
      }
      if (ne > 0)
        for (N(xe, we, ae, q), De = 0; De < ne; De++)
          D[J + De] = xe[De];
      return 0;
    }
    function Q(D, J, ne, O, ae) {
      var we = new Uint8Array(32);
      k(we, O, ae, q);
      for (var xe = new Uint8Array(8), Re = 0; Re < 8; Re++)
        xe[Re] = O[Re + 16];
      return re(D, J, ne, xe, we);
    }
    function fe(D, J, ne, O, ae, we, xe) {
      var Re = new Uint8Array(32);
      k(Re, we, xe, q);
      for (var De = new Uint8Array(8), He = 0; He < 8; He++)
        De[He] = we[He + 16];
      return $(D, J, ne, O, ae, De, Re);
    }
    var U = function(D) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var J, ne, O, ae, we, xe, Re, De;
      J = D[0] & 255 | (D[1] & 255) << 8, this.r[0] = J & 8191, ne = D[2] & 255 | (D[3] & 255) << 8, this.r[1] = (J >>> 13 | ne << 3) & 8191, O = D[4] & 255 | (D[5] & 255) << 8, this.r[2] = (ne >>> 10 | O << 6) & 7939, ae = D[6] & 255 | (D[7] & 255) << 8, this.r[3] = (O >>> 7 | ae << 9) & 8191, we = D[8] & 255 | (D[9] & 255) << 8, this.r[4] = (ae >>> 4 | we << 12) & 255, this.r[5] = we >>> 1 & 8190, xe = D[10] & 255 | (D[11] & 255) << 8, this.r[6] = (we >>> 14 | xe << 2) & 8191, Re = D[12] & 255 | (D[13] & 255) << 8, this.r[7] = (xe >>> 11 | Re << 5) & 8065, De = D[14] & 255 | (D[15] & 255) << 8, this.r[8] = (Re >>> 8 | De << 8) & 8191, this.r[9] = De >>> 5 & 127, this.pad[0] = D[16] & 255 | (D[17] & 255) << 8, this.pad[1] = D[18] & 255 | (D[19] & 255) << 8, this.pad[2] = D[20] & 255 | (D[21] & 255) << 8, this.pad[3] = D[22] & 255 | (D[23] & 255) << 8, this.pad[4] = D[24] & 255 | (D[25] & 255) << 8, this.pad[5] = D[26] & 255 | (D[27] & 255) << 8, this.pad[6] = D[28] & 255 | (D[29] & 255) << 8, this.pad[7] = D[30] & 255 | (D[31] & 255) << 8;
    };
    U.prototype.blocks = function(D, J, ne) {
      for (var O = this.fin ? 0 : 2048, ae, we, xe, Re, De, He, Ue, yt, et, ut, ct, vt, pt, ht, dt, lt, tt, ot, Qe, rt = this.h[0], it = this.h[1], Ye = this.h[2], Oe = this.h[3], Pe = this.h[4], Ke = this.h[5], Fe = this.h[6], We = this.h[7], Xe = this.h[8], bt = this.h[9], mt = this.r[0], xt = this.r[1], wt = this.r[2], ye = this.r[3], At = this.r[4], Ot = this.r[5], Pt = this.r[6], St = this.r[7], It = this.r[8], Tt = this.r[9]; ne >= 16; )
        ae = D[J + 0] & 255 | (D[J + 1] & 255) << 8, rt += ae & 8191, we = D[J + 2] & 255 | (D[J + 3] & 255) << 8, it += (ae >>> 13 | we << 3) & 8191, xe = D[J + 4] & 255 | (D[J + 5] & 255) << 8, Ye += (we >>> 10 | xe << 6) & 8191, Re = D[J + 6] & 255 | (D[J + 7] & 255) << 8, Oe += (xe >>> 7 | Re << 9) & 8191, De = D[J + 8] & 255 | (D[J + 9] & 255) << 8, Pe += (Re >>> 4 | De << 12) & 8191, Ke += De >>> 1 & 8191, He = D[J + 10] & 255 | (D[J + 11] & 255) << 8, Fe += (De >>> 14 | He << 2) & 8191, Ue = D[J + 12] & 255 | (D[J + 13] & 255) << 8, We += (He >>> 11 | Ue << 5) & 8191, yt = D[J + 14] & 255 | (D[J + 15] & 255) << 8, Xe += (Ue >>> 8 | yt << 8) & 8191, bt += yt >>> 5 | O, et = 0, ut = et, ut += rt * mt, ut += it * (5 * Tt), ut += Ye * (5 * It), ut += Oe * (5 * St), ut += Pe * (5 * Pt), et = ut >>> 13, ut &= 8191, ut += Ke * (5 * Ot), ut += Fe * (5 * At), ut += We * (5 * ye), ut += Xe * (5 * wt), ut += bt * (5 * xt), et += ut >>> 13, ut &= 8191, ct = et, ct += rt * xt, ct += it * mt, ct += Ye * (5 * Tt), ct += Oe * (5 * It), ct += Pe * (5 * St), et = ct >>> 13, ct &= 8191, ct += Ke * (5 * Pt), ct += Fe * (5 * Ot), ct += We * (5 * At), ct += Xe * (5 * ye), ct += bt * (5 * wt), et += ct >>> 13, ct &= 8191, vt = et, vt += rt * wt, vt += it * xt, vt += Ye * mt, vt += Oe * (5 * Tt), vt += Pe * (5 * It), et = vt >>> 13, vt &= 8191, vt += Ke * (5 * St), vt += Fe * (5 * Pt), vt += We * (5 * Ot), vt += Xe * (5 * At), vt += bt * (5 * ye), et += vt >>> 13, vt &= 8191, pt = et, pt += rt * ye, pt += it * wt, pt += Ye * xt, pt += Oe * mt, pt += Pe * (5 * Tt), et = pt >>> 13, pt &= 8191, pt += Ke * (5 * It), pt += Fe * (5 * St), pt += We * (5 * Pt), pt += Xe * (5 * Ot), pt += bt * (5 * At), et += pt >>> 13, pt &= 8191, ht = et, ht += rt * At, ht += it * ye, ht += Ye * wt, ht += Oe * xt, ht += Pe * mt, et = ht >>> 13, ht &= 8191, ht += Ke * (5 * Tt), ht += Fe * (5 * It), ht += We * (5 * St), ht += Xe * (5 * Pt), ht += bt * (5 * Ot), et += ht >>> 13, ht &= 8191, dt = et, dt += rt * Ot, dt += it * At, dt += Ye * ye, dt += Oe * wt, dt += Pe * xt, et = dt >>> 13, dt &= 8191, dt += Ke * mt, dt += Fe * (5 * Tt), dt += We * (5 * It), dt += Xe * (5 * St), dt += bt * (5 * Pt), et += dt >>> 13, dt &= 8191, lt = et, lt += rt * Pt, lt += it * Ot, lt += Ye * At, lt += Oe * ye, lt += Pe * wt, et = lt >>> 13, lt &= 8191, lt += Ke * xt, lt += Fe * mt, lt += We * (5 * Tt), lt += Xe * (5 * It), lt += bt * (5 * St), et += lt >>> 13, lt &= 8191, tt = et, tt += rt * St, tt += it * Pt, tt += Ye * Ot, tt += Oe * At, tt += Pe * ye, et = tt >>> 13, tt &= 8191, tt += Ke * wt, tt += Fe * xt, tt += We * mt, tt += Xe * (5 * Tt), tt += bt * (5 * It), et += tt >>> 13, tt &= 8191, ot = et, ot += rt * It, ot += it * St, ot += Ye * Pt, ot += Oe * Ot, ot += Pe * At, et = ot >>> 13, ot &= 8191, ot += Ke * ye, ot += Fe * wt, ot += We * xt, ot += Xe * mt, ot += bt * (5 * Tt), et += ot >>> 13, ot &= 8191, Qe = et, Qe += rt * Tt, Qe += it * It, Qe += Ye * St, Qe += Oe * Pt, Qe += Pe * Ot, et = Qe >>> 13, Qe &= 8191, Qe += Ke * At, Qe += Fe * ye, Qe += We * wt, Qe += Xe * xt, Qe += bt * mt, et += Qe >>> 13, Qe &= 8191, et = (et << 2) + et | 0, et = et + ut | 0, ut = et & 8191, et = et >>> 13, ct += et, rt = ut, it = ct, Ye = vt, Oe = pt, Pe = ht, Ke = dt, Fe = lt, We = tt, Xe = ot, bt = Qe, J += 16, ne -= 16;
      this.h[0] = rt, this.h[1] = it, this.h[2] = Ye, this.h[3] = Oe, this.h[4] = Pe, this.h[5] = Ke, this.h[6] = Fe, this.h[7] = We, this.h[8] = Xe, this.h[9] = bt;
    }, U.prototype.finish = function(D, J) {
      var ne = new Uint16Array(10), O, ae, we, xe;
      if (this.leftover) {
        for (xe = this.leftover, this.buffer[xe++] = 1; xe < 16; xe++)
          this.buffer[xe] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (O = this.h[1] >>> 13, this.h[1] &= 8191, xe = 2; xe < 10; xe++)
        this.h[xe] += O, O = this.h[xe] >>> 13, this.h[xe] &= 8191;
      for (this.h[0] += O * 5, O = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += O, O = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += O, ne[0] = this.h[0] + 5, O = ne[0] >>> 13, ne[0] &= 8191, xe = 1; xe < 10; xe++)
        ne[xe] = this.h[xe] + O, O = ne[xe] >>> 13, ne[xe] &= 8191;
      for (ne[9] -= 8192, ae = (O ^ 1) - 1, xe = 0; xe < 10; xe++)
        ne[xe] &= ae;
      for (ae = ~ae, xe = 0; xe < 10; xe++)
        this.h[xe] = this.h[xe] & ae | ne[xe];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, we = this.h[0] + this.pad[0], this.h[0] = we & 65535, xe = 1; xe < 8; xe++)
        we = (this.h[xe] + this.pad[xe] | 0) + (we >>> 16) | 0, this.h[xe] = we & 65535;
      D[J + 0] = this.h[0] >>> 0 & 255, D[J + 1] = this.h[0] >>> 8 & 255, D[J + 2] = this.h[1] >>> 0 & 255, D[J + 3] = this.h[1] >>> 8 & 255, D[J + 4] = this.h[2] >>> 0 & 255, D[J + 5] = this.h[2] >>> 8 & 255, D[J + 6] = this.h[3] >>> 0 & 255, D[J + 7] = this.h[3] >>> 8 & 255, D[J + 8] = this.h[4] >>> 0 & 255, D[J + 9] = this.h[4] >>> 8 & 255, D[J + 10] = this.h[5] >>> 0 & 255, D[J + 11] = this.h[5] >>> 8 & 255, D[J + 12] = this.h[6] >>> 0 & 255, D[J + 13] = this.h[6] >>> 8 & 255, D[J + 14] = this.h[7] >>> 0 & 255, D[J + 15] = this.h[7] >>> 8 & 255;
    }, U.prototype.update = function(D, J, ne) {
      var O, ae;
      if (this.leftover) {
        for (ae = 16 - this.leftover, ae > ne && (ae = ne), O = 0; O < ae; O++)
          this.buffer[this.leftover + O] = D[J + O];
        if (ne -= ae, J += ae, this.leftover += ae, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (ne >= 16 && (ae = ne - ne % 16, this.blocks(D, J, ae), J += ae, ne -= ae), ne) {
        for (O = 0; O < ne; O++)
          this.buffer[this.leftover + O] = D[J + O];
        this.leftover += ne;
      }
    };
    function y(D, J, ne, O, ae, we) {
      var xe = new U(we);
      return xe.update(ne, O, ae), xe.finish(D, J), 0;
    }
    function v(D, J, ne, O, ae, we) {
      var xe = new Uint8Array(16);
      return y(xe, 0, ne, O, ae, we), I(D, J, xe, 0);
    }
    function a(D, J, ne, O, ae) {
      var we;
      if (ne < 32)
        return -1;
      for (fe(D, 0, J, 0, ne, O, ae), y(D, 16, D, 32, ne - 32, D), we = 0; we < 16; we++)
        D[we] = 0;
      return 0;
    }
    function d(D, J, ne, O, ae) {
      var we, xe = new Uint8Array(32);
      if (ne < 32 || (Q(xe, 0, 32, O, ae), v(J, 16, J, 32, ne - 32, xe) !== 0))
        return -1;
      for (fe(D, 0, J, 0, ne, O, ae), we = 0; we < 32; we++)
        D[we] = 0;
      return 0;
    }
    function w(D, J) {
      var ne;
      for (ne = 0; ne < 16; ne++)
        D[ne] = J[ne] | 0;
    }
    function x(D) {
      var J, ne, O = 1;
      for (J = 0; J < 16; J++)
        ne = D[J] + O + 65535, O = Math.floor(ne / 65536), D[J] = ne - O * 65536;
      D[0] += O - 1 + 37 * (O - 1);
    }
    function A(D, J, ne) {
      for (var O, ae = ~(ne - 1), we = 0; we < 16; we++)
        O = ae & (D[we] ^ J[we]), D[we] ^= O, J[we] ^= O;
    }
    function S(D, J) {
      var ne, O, ae, we = r(), xe = r();
      for (ne = 0; ne < 16; ne++)
        xe[ne] = J[ne];
      for (x(xe), x(xe), x(xe), O = 0; O < 2; O++) {
        for (we[0] = xe[0] - 65517, ne = 1; ne < 15; ne++)
          we[ne] = xe[ne] - 65535 - (we[ne - 1] >> 16 & 1), we[ne - 1] &= 65535;
        we[15] = xe[15] - 32767 - (we[14] >> 16 & 1), ae = we[15] >> 16 & 1, we[14] &= 65535, A(xe, we, 1 - ae);
      }
      for (ne = 0; ne < 16; ne++)
        D[2 * ne] = xe[ne] & 255, D[2 * ne + 1] = xe[ne] >> 8;
    }
    function g(D, J) {
      var ne = new Uint8Array(32), O = new Uint8Array(32);
      return S(ne, D), S(O, J), B(ne, 0, O, 0);
    }
    function _(D) {
      var J = new Uint8Array(32);
      return S(J, D), J[0] & 1;
    }
    function l(D, J) {
      var ne;
      for (ne = 0; ne < 16; ne++)
        D[ne] = J[2 * ne] + (J[2 * ne + 1] << 8);
      D[15] &= 32767;
    }
    function R(D, J, ne) {
      for (var O = 0; O < 16; O++)
        D[O] = J[O] + ne[O];
    }
    function Y(D, J, ne) {
      for (var O = 0; O < 16; O++)
        D[O] = J[O] - ne[O];
    }
    function oe(D, J, ne) {
      var O, ae, we = 0, xe = 0, Re = 0, De = 0, He = 0, Ue = 0, yt = 0, et = 0, ut = 0, ct = 0, vt = 0, pt = 0, ht = 0, dt = 0, lt = 0, tt = 0, ot = 0, Qe = 0, rt = 0, it = 0, Ye = 0, Oe = 0, Pe = 0, Ke = 0, Fe = 0, We = 0, Xe = 0, bt = 0, mt = 0, xt = 0, wt = 0, ye = ne[0], At = ne[1], Ot = ne[2], Pt = ne[3], St = ne[4], It = ne[5], Tt = ne[6], Zt = ne[7], Lt = ne[8], zt = ne[9], Ht = ne[10], Vt = ne[11], Yt = ne[12], ur = ne[13], cr = ne[14], hr = ne[15];
      O = J[0], we += O * ye, xe += O * At, Re += O * Ot, De += O * Pt, He += O * St, Ue += O * It, yt += O * Tt, et += O * Zt, ut += O * Lt, ct += O * zt, vt += O * Ht, pt += O * Vt, ht += O * Yt, dt += O * ur, lt += O * cr, tt += O * hr, O = J[1], xe += O * ye, Re += O * At, De += O * Ot, He += O * Pt, Ue += O * St, yt += O * It, et += O * Tt, ut += O * Zt, ct += O * Lt, vt += O * zt, pt += O * Ht, ht += O * Vt, dt += O * Yt, lt += O * ur, tt += O * cr, ot += O * hr, O = J[2], Re += O * ye, De += O * At, He += O * Ot, Ue += O * Pt, yt += O * St, et += O * It, ut += O * Tt, ct += O * Zt, vt += O * Lt, pt += O * zt, ht += O * Ht, dt += O * Vt, lt += O * Yt, tt += O * ur, ot += O * cr, Qe += O * hr, O = J[3], De += O * ye, He += O * At, Ue += O * Ot, yt += O * Pt, et += O * St, ut += O * It, ct += O * Tt, vt += O * Zt, pt += O * Lt, ht += O * zt, dt += O * Ht, lt += O * Vt, tt += O * Yt, ot += O * ur, Qe += O * cr, rt += O * hr, O = J[4], He += O * ye, Ue += O * At, yt += O * Ot, et += O * Pt, ut += O * St, ct += O * It, vt += O * Tt, pt += O * Zt, ht += O * Lt, dt += O * zt, lt += O * Ht, tt += O * Vt, ot += O * Yt, Qe += O * ur, rt += O * cr, it += O * hr, O = J[5], Ue += O * ye, yt += O * At, et += O * Ot, ut += O * Pt, ct += O * St, vt += O * It, pt += O * Tt, ht += O * Zt, dt += O * Lt, lt += O * zt, tt += O * Ht, ot += O * Vt, Qe += O * Yt, rt += O * ur, it += O * cr, Ye += O * hr, O = J[6], yt += O * ye, et += O * At, ut += O * Ot, ct += O * Pt, vt += O * St, pt += O * It, ht += O * Tt, dt += O * Zt, lt += O * Lt, tt += O * zt, ot += O * Ht, Qe += O * Vt, rt += O * Yt, it += O * ur, Ye += O * cr, Oe += O * hr, O = J[7], et += O * ye, ut += O * At, ct += O * Ot, vt += O * Pt, pt += O * St, ht += O * It, dt += O * Tt, lt += O * Zt, tt += O * Lt, ot += O * zt, Qe += O * Ht, rt += O * Vt, it += O * Yt, Ye += O * ur, Oe += O * cr, Pe += O * hr, O = J[8], ut += O * ye, ct += O * At, vt += O * Ot, pt += O * Pt, ht += O * St, dt += O * It, lt += O * Tt, tt += O * Zt, ot += O * Lt, Qe += O * zt, rt += O * Ht, it += O * Vt, Ye += O * Yt, Oe += O * ur, Pe += O * cr, Ke += O * hr, O = J[9], ct += O * ye, vt += O * At, pt += O * Ot, ht += O * Pt, dt += O * St, lt += O * It, tt += O * Tt, ot += O * Zt, Qe += O * Lt, rt += O * zt, it += O * Ht, Ye += O * Vt, Oe += O * Yt, Pe += O * ur, Ke += O * cr, Fe += O * hr, O = J[10], vt += O * ye, pt += O * At, ht += O * Ot, dt += O * Pt, lt += O * St, tt += O * It, ot += O * Tt, Qe += O * Zt, rt += O * Lt, it += O * zt, Ye += O * Ht, Oe += O * Vt, Pe += O * Yt, Ke += O * ur, Fe += O * cr, We += O * hr, O = J[11], pt += O * ye, ht += O * At, dt += O * Ot, lt += O * Pt, tt += O * St, ot += O * It, Qe += O * Tt, rt += O * Zt, it += O * Lt, Ye += O * zt, Oe += O * Ht, Pe += O * Vt, Ke += O * Yt, Fe += O * ur, We += O * cr, Xe += O * hr, O = J[12], ht += O * ye, dt += O * At, lt += O * Ot, tt += O * Pt, ot += O * St, Qe += O * It, rt += O * Tt, it += O * Zt, Ye += O * Lt, Oe += O * zt, Pe += O * Ht, Ke += O * Vt, Fe += O * Yt, We += O * ur, Xe += O * cr, bt += O * hr, O = J[13], dt += O * ye, lt += O * At, tt += O * Ot, ot += O * Pt, Qe += O * St, rt += O * It, it += O * Tt, Ye += O * Zt, Oe += O * Lt, Pe += O * zt, Ke += O * Ht, Fe += O * Vt, We += O * Yt, Xe += O * ur, bt += O * cr, mt += O * hr, O = J[14], lt += O * ye, tt += O * At, ot += O * Ot, Qe += O * Pt, rt += O * St, it += O * It, Ye += O * Tt, Oe += O * Zt, Pe += O * Lt, Ke += O * zt, Fe += O * Ht, We += O * Vt, Xe += O * Yt, bt += O * ur, mt += O * cr, xt += O * hr, O = J[15], tt += O * ye, ot += O * At, Qe += O * Ot, rt += O * Pt, it += O * St, Ye += O * It, Oe += O * Tt, Pe += O * Zt, Ke += O * Lt, Fe += O * zt, We += O * Ht, Xe += O * Vt, bt += O * Yt, mt += O * ur, xt += O * cr, wt += O * hr, we += 38 * ot, xe += 38 * Qe, Re += 38 * rt, De += 38 * it, He += 38 * Ye, Ue += 38 * Oe, yt += 38 * Pe, et += 38 * Ke, ut += 38 * Fe, ct += 38 * We, vt += 38 * Xe, pt += 38 * bt, ht += 38 * mt, dt += 38 * xt, lt += 38 * wt, ae = 1, O = we + ae + 65535, ae = Math.floor(O / 65536), we = O - ae * 65536, O = xe + ae + 65535, ae = Math.floor(O / 65536), xe = O - ae * 65536, O = Re + ae + 65535, ae = Math.floor(O / 65536), Re = O - ae * 65536, O = De + ae + 65535, ae = Math.floor(O / 65536), De = O - ae * 65536, O = He + ae + 65535, ae = Math.floor(O / 65536), He = O - ae * 65536, O = Ue + ae + 65535, ae = Math.floor(O / 65536), Ue = O - ae * 65536, O = yt + ae + 65535, ae = Math.floor(O / 65536), yt = O - ae * 65536, O = et + ae + 65535, ae = Math.floor(O / 65536), et = O - ae * 65536, O = ut + ae + 65535, ae = Math.floor(O / 65536), ut = O - ae * 65536, O = ct + ae + 65535, ae = Math.floor(O / 65536), ct = O - ae * 65536, O = vt + ae + 65535, ae = Math.floor(O / 65536), vt = O - ae * 65536, O = pt + ae + 65535, ae = Math.floor(O / 65536), pt = O - ae * 65536, O = ht + ae + 65535, ae = Math.floor(O / 65536), ht = O - ae * 65536, O = dt + ae + 65535, ae = Math.floor(O / 65536), dt = O - ae * 65536, O = lt + ae + 65535, ae = Math.floor(O / 65536), lt = O - ae * 65536, O = tt + ae + 65535, ae = Math.floor(O / 65536), tt = O - ae * 65536, we += ae - 1 + 37 * (ae - 1), ae = 1, O = we + ae + 65535, ae = Math.floor(O / 65536), we = O - ae * 65536, O = xe + ae + 65535, ae = Math.floor(O / 65536), xe = O - ae * 65536, O = Re + ae + 65535, ae = Math.floor(O / 65536), Re = O - ae * 65536, O = De + ae + 65535, ae = Math.floor(O / 65536), De = O - ae * 65536, O = He + ae + 65535, ae = Math.floor(O / 65536), He = O - ae * 65536, O = Ue + ae + 65535, ae = Math.floor(O / 65536), Ue = O - ae * 65536, O = yt + ae + 65535, ae = Math.floor(O / 65536), yt = O - ae * 65536, O = et + ae + 65535, ae = Math.floor(O / 65536), et = O - ae * 65536, O = ut + ae + 65535, ae = Math.floor(O / 65536), ut = O - ae * 65536, O = ct + ae + 65535, ae = Math.floor(O / 65536), ct = O - ae * 65536, O = vt + ae + 65535, ae = Math.floor(O / 65536), vt = O - ae * 65536, O = pt + ae + 65535, ae = Math.floor(O / 65536), pt = O - ae * 65536, O = ht + ae + 65535, ae = Math.floor(O / 65536), ht = O - ae * 65536, O = dt + ae + 65535, ae = Math.floor(O / 65536), dt = O - ae * 65536, O = lt + ae + 65535, ae = Math.floor(O / 65536), lt = O - ae * 65536, O = tt + ae + 65535, ae = Math.floor(O / 65536), tt = O - ae * 65536, we += ae - 1 + 37 * (ae - 1), D[0] = we, D[1] = xe, D[2] = Re, D[3] = De, D[4] = He, D[5] = Ue, D[6] = yt, D[7] = et, D[8] = ut, D[9] = ct, D[10] = vt, D[11] = pt, D[12] = ht, D[13] = dt, D[14] = lt, D[15] = tt;
    }
    function H(D, J) {
      oe(D, J, J);
    }
    function V(D, J) {
      var ne = r(), O;
      for (O = 0; O < 16; O++)
        ne[O] = J[O];
      for (O = 253; O >= 0; O--)
        H(ne, ne), O !== 2 && O !== 4 && oe(ne, ne, J);
      for (O = 0; O < 16; O++)
        D[O] = ne[O];
    }
    function F(D, J) {
      var ne = r(), O;
      for (O = 0; O < 16; O++)
        ne[O] = J[O];
      for (O = 250; O >= 0; O--)
        H(ne, ne), O !== 1 && oe(ne, ne, J);
      for (O = 0; O < 16; O++)
        D[O] = ne[O];
    }
    function te(D, J, ne) {
      var O = new Uint8Array(32), ae = new Float64Array(80), we, xe, Re = r(), De = r(), He = r(), Ue = r(), yt = r(), et = r();
      for (xe = 0; xe < 31; xe++)
        O[xe] = J[xe];
      for (O[31] = J[31] & 127 | 64, O[0] &= 248, l(ae, ne), xe = 0; xe < 16; xe++)
        De[xe] = ae[xe], Ue[xe] = Re[xe] = He[xe] = 0;
      for (Re[0] = Ue[0] = 1, xe = 254; xe >= 0; --xe)
        we = O[xe >>> 3] >>> (xe & 7) & 1, A(Re, De, we), A(He, Ue, we), R(yt, Re, He), Y(Re, Re, He), R(He, De, Ue), Y(De, De, Ue), H(Ue, yt), H(et, Re), oe(Re, He, Re), oe(He, De, yt), R(yt, Re, He), Y(Re, Re, He), H(De, Re), Y(He, Ue, et), oe(Re, He, c), R(Re, Re, Ue), oe(He, He, Re), oe(Re, Ue, et), oe(Ue, De, ae), H(De, yt), A(Re, De, we), A(He, Ue, we);
      for (xe = 0; xe < 16; xe++)
        ae[xe + 16] = Re[xe], ae[xe + 32] = He[xe], ae[xe + 48] = De[xe], ae[xe + 64] = Ue[xe];
      var ut = ae.subarray(32), ct = ae.subarray(16);
      return V(ut, ut), oe(ct, ct, ut), S(D, ct), 0;
    }
    function he(D, J) {
      return te(D, J, n);
    }
    function K(D, J) {
      return i(J, 32), he(D, J);
    }
    function W(D, J, ne) {
      var O = new Uint8Array(32);
      return te(O, ne, J), k(D, o, O, q);
    }
    var ce = a, ve = d;
    function Be(D, J, ne, O, ae, we) {
      var xe = new Uint8Array(32);
      return W(xe, ae, we), ce(D, J, ne, O, xe);
    }
    function ee(D, J, ne, O, ae, we) {
      var xe = new Uint8Array(32);
      return W(xe, ae, we), ve(D, J, ne, O, xe);
    }
    var C = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function L(D, J, ne, O) {
      for (var ae = new Int32Array(16), we = new Int32Array(16), xe, Re, De, He, Ue, yt, et, ut, ct, vt, pt, ht, dt, lt, tt, ot, Qe, rt, it, Ye, Oe, Pe, Ke, Fe, We, Xe, bt = D[0], mt = D[1], xt = D[2], wt = D[3], ye = D[4], At = D[5], Ot = D[6], Pt = D[7], St = J[0], It = J[1], Tt = J[2], Zt = J[3], Lt = J[4], zt = J[5], Ht = J[6], Vt = J[7], Yt = 0; O >= 128; ) {
        for (it = 0; it < 16; it++)
          Ye = 8 * it + Yt, ae[it] = ne[Ye + 0] << 24 | ne[Ye + 1] << 16 | ne[Ye + 2] << 8 | ne[Ye + 3], we[it] = ne[Ye + 4] << 24 | ne[Ye + 5] << 16 | ne[Ye + 6] << 8 | ne[Ye + 7];
        for (it = 0; it < 80; it++)
          if (xe = bt, Re = mt, De = xt, He = wt, Ue = ye, yt = At, et = Ot, ut = Pt, ct = St, vt = It, pt = Tt, ht = Zt, dt = Lt, lt = zt, tt = Ht, ot = Vt, Oe = Pt, Pe = Vt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = (ye >>> 14 | Lt << 18) ^ (ye >>> 18 | Lt << 14) ^ (Lt >>> 9 | ye << 23), Pe = (Lt >>> 14 | ye << 18) ^ (Lt >>> 18 | ye << 14) ^ (ye >>> 9 | Lt << 23), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = ye & At ^ ~ye & Ot, Pe = Lt & zt ^ ~Lt & Ht, Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = C[it * 2], Pe = C[it * 2 + 1], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = ae[it % 16], Pe = we[it % 16], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, Qe = We & 65535 | Xe << 16, rt = Ke & 65535 | Fe << 16, Oe = Qe, Pe = rt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = (bt >>> 28 | St << 4) ^ (St >>> 2 | bt << 30) ^ (St >>> 7 | bt << 25), Pe = (St >>> 28 | bt << 4) ^ (bt >>> 2 | St << 30) ^ (bt >>> 7 | St << 25), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = bt & mt ^ bt & xt ^ mt & xt, Pe = St & It ^ St & Tt ^ It & Tt, Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, ut = We & 65535 | Xe << 16, ot = Ke & 65535 | Fe << 16, Oe = He, Pe = ht, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = Qe, Pe = rt, Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, He = We & 65535 | Xe << 16, ht = Ke & 65535 | Fe << 16, mt = xe, xt = Re, wt = De, ye = He, At = Ue, Ot = yt, Pt = et, bt = ut, It = ct, Tt = vt, Zt = pt, Lt = ht, zt = dt, Ht = lt, Vt = tt, St = ot, it % 16 === 15)
            for (Ye = 0; Ye < 16; Ye++)
              Oe = ae[Ye], Pe = we[Ye], Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = ae[(Ye + 9) % 16], Pe = we[(Ye + 9) % 16], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Qe = ae[(Ye + 1) % 16], rt = we[(Ye + 1) % 16], Oe = (Qe >>> 1 | rt << 31) ^ (Qe >>> 8 | rt << 24) ^ Qe >>> 7, Pe = (rt >>> 1 | Qe << 31) ^ (rt >>> 8 | Qe << 24) ^ (rt >>> 7 | Qe << 25), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Qe = ae[(Ye + 14) % 16], rt = we[(Ye + 14) % 16], Oe = (Qe >>> 19 | rt << 13) ^ (rt >>> 29 | Qe << 3) ^ Qe >>> 6, Pe = (rt >>> 19 | Qe << 13) ^ (Qe >>> 29 | rt << 3) ^ (rt >>> 6 | Qe << 26), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, ae[Ye] = We & 65535 | Xe << 16, we[Ye] = Ke & 65535 | Fe << 16;
        Oe = bt, Pe = St, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[0], Pe = J[0], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[0] = bt = We & 65535 | Xe << 16, J[0] = St = Ke & 65535 | Fe << 16, Oe = mt, Pe = It, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[1], Pe = J[1], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[1] = mt = We & 65535 | Xe << 16, J[1] = It = Ke & 65535 | Fe << 16, Oe = xt, Pe = Tt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[2], Pe = J[2], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[2] = xt = We & 65535 | Xe << 16, J[2] = Tt = Ke & 65535 | Fe << 16, Oe = wt, Pe = Zt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[3], Pe = J[3], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[3] = wt = We & 65535 | Xe << 16, J[3] = Zt = Ke & 65535 | Fe << 16, Oe = ye, Pe = Lt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[4], Pe = J[4], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[4] = ye = We & 65535 | Xe << 16, J[4] = Lt = Ke & 65535 | Fe << 16, Oe = At, Pe = zt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[5], Pe = J[5], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[5] = At = We & 65535 | Xe << 16, J[5] = zt = Ke & 65535 | Fe << 16, Oe = Ot, Pe = Ht, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[6], Pe = J[6], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[6] = Ot = We & 65535 | Xe << 16, J[6] = Ht = Ke & 65535 | Fe << 16, Oe = Pt, Pe = Vt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = D[7], Pe = J[7], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, D[7] = Pt = We & 65535 | Xe << 16, J[7] = Vt = Ke & 65535 | Fe << 16, Yt += 128, O -= 128;
      }
      return O;
    }
    function Z(D, J, ne) {
      var O = new Int32Array(8), ae = new Int32Array(8), we = new Uint8Array(256), xe, Re = ne;
      for (O[0] = 1779033703, O[1] = 3144134277, O[2] = 1013904242, O[3] = 2773480762, O[4] = 1359893119, O[5] = 2600822924, O[6] = 528734635, O[7] = 1541459225, ae[0] = 4089235720, ae[1] = 2227873595, ae[2] = 4271175723, ae[3] = 1595750129, ae[4] = 2917565137, ae[5] = 725511199, ae[6] = 4215389547, ae[7] = 327033209, L(O, ae, J, ne), ne %= 128, xe = 0; xe < ne; xe++)
        we[xe] = J[Re - ne + xe];
      for (we[ne] = 128, ne = 256 - 128 * (ne < 112 ? 1 : 0), we[ne - 9] = 0, E(we, ne - 8, Re / 536870912 | 0, Re << 3), L(O, ae, we, ne), xe = 0; xe < 8; xe++)
        E(D, 8 * xe, O[xe], ae[xe]);
      return 0;
    }
    function de(D, J) {
      var ne = r(), O = r(), ae = r(), we = r(), xe = r(), Re = r(), De = r(), He = r(), Ue = r();
      Y(ne, D[1], D[0]), Y(Ue, J[1], J[0]), oe(ne, ne, Ue), R(O, D[0], D[1]), R(Ue, J[0], J[1]), oe(O, O, Ue), oe(ae, D[3], J[3]), oe(ae, ae, s), oe(we, D[2], J[2]), R(we, we, we), Y(xe, O, ne), Y(Re, we, ae), R(De, we, ae), R(He, O, ne), oe(D[0], xe, Re), oe(D[1], He, De), oe(D[2], De, Re), oe(D[3], xe, He);
    }
    function me(D, J, ne) {
      var O;
      for (O = 0; O < 4; O++)
        A(D[O], J[O], ne);
    }
    function Te(D, J) {
      var ne = r(), O = r(), ae = r();
      V(ae, J[2]), oe(ne, J[0], ae), oe(O, J[1], ae), S(D, O), D[31] ^= _(ne) << 7;
    }
    function ze(D, J, ne) {
      var O, ae;
      for (w(D[0], f), w(D[1], u), w(D[2], u), w(D[3], f), ae = 255; ae >= 0; --ae)
        O = ne[ae / 8 | 0] >> (ae & 7) & 1, me(D, J, O), de(J, D), de(D, D), me(D, J, O);
    }
    function z(D, J) {
      var ne = [r(), r(), r(), r()];
      w(ne[0], b), w(ne[1], p), w(ne[2], u), oe(ne[3], b, p), ze(D, ne, J);
    }
    function ue(D, J, ne) {
      var O = new Uint8Array(64), ae = [r(), r(), r(), r()], we;
      for (ne || i(J, 32), Z(O, J, 32), O[0] &= 248, O[31] &= 127, O[31] |= 64, z(ae, O), Te(D, ae), we = 0; we < 32; we++)
        J[we + 32] = D[we];
      return 0;
    }
    var se = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function _e(D, J) {
      var ne, O, ae, we;
      for (O = 63; O >= 32; --O) {
        for (ne = 0, ae = O - 32, we = O - 12; ae < we; ++ae)
          J[ae] += ne - 16 * J[O] * se[ae - (O - 32)], ne = Math.floor((J[ae] + 128) / 256), J[ae] -= ne * 256;
        J[ae] += ne, J[O] = 0;
      }
      for (ne = 0, ae = 0; ae < 32; ae++)
        J[ae] += ne - (J[31] >> 4) * se[ae], ne = J[ae] >> 8, J[ae] &= 255;
      for (ae = 0; ae < 32; ae++)
        J[ae] -= ne * se[ae];
      for (O = 0; O < 32; O++)
        J[O + 1] += J[O] >> 8, D[O] = J[O] & 255;
    }
    function Ce(D) {
      var J = new Float64Array(64), ne;
      for (ne = 0; ne < 64; ne++)
        J[ne] = D[ne];
      for (ne = 0; ne < 64; ne++)
        D[ne] = 0;
      _e(D, J);
    }
    function Ve(D, J, ne, O) {
      var ae = new Uint8Array(64), we = new Uint8Array(64), xe = new Uint8Array(64), Re, De, He = new Float64Array(64), Ue = [r(), r(), r(), r()];
      Z(ae, O, 32), ae[0] &= 248, ae[31] &= 127, ae[31] |= 64;
      var yt = ne + 64;
      for (Re = 0; Re < ne; Re++)
        D[64 + Re] = J[Re];
      for (Re = 0; Re < 32; Re++)
        D[32 + Re] = ae[32 + Re];
      for (Z(xe, D.subarray(32), ne + 32), Ce(xe), z(Ue, xe), Te(D, Ue), Re = 32; Re < 64; Re++)
        D[Re] = O[Re];
      for (Z(we, D, ne + 64), Ce(we), Re = 0; Re < 64; Re++)
        He[Re] = 0;
      for (Re = 0; Re < 32; Re++)
        He[Re] = xe[Re];
      for (Re = 0; Re < 32; Re++)
        for (De = 0; De < 32; De++)
          He[Re + De] += we[Re] * ae[De];
      return _e(D.subarray(32), He), yt;
    }
    function ke(D, J) {
      var ne = r(), O = r(), ae = r(), we = r(), xe = r(), Re = r(), De = r();
      return w(D[2], u), l(D[1], J), H(ae, D[1]), oe(we, ae, h), Y(ae, ae, D[2]), R(we, D[2], we), H(xe, we), H(Re, xe), oe(De, Re, xe), oe(ne, De, ae), oe(ne, ne, we), F(ne, ne), oe(ne, ne, ae), oe(ne, ne, we), oe(ne, ne, we), oe(D[0], ne, we), H(O, D[0]), oe(O, O, we), g(O, ae) && oe(D[0], D[0], m), H(O, D[0]), oe(O, O, we), g(O, ae) ? -1 : (_(D[0]) === J[31] >> 7 && Y(D[0], f, D[0]), oe(D[3], D[0], D[1]), 0);
    }
    function X(D, J, ne, O) {
      var ae, we = new Uint8Array(32), xe = new Uint8Array(64), Re = [r(), r(), r(), r()], De = [r(), r(), r(), r()];
      if (ne < 64 || ke(De, O))
        return -1;
      for (ae = 0; ae < ne; ae++)
        D[ae] = J[ae];
      for (ae = 0; ae < 32; ae++)
        D[ae + 32] = O[ae];
      if (Z(xe, D, ne), Ce(xe), ze(Re, De, xe), z(De, J.subarray(32)), de(Re, De), Te(we, Re), ne -= 64, B(J, 0, we, 0)) {
        for (ae = 0; ae < ne; ae++)
          D[ae] = 0;
        return -1;
      }
      for (ae = 0; ae < ne; ae++)
        D[ae] = J[ae + 64];
      return ne;
    }
    var Se = 32, Ae = 24, qe = 32, pe = 16, Ee = 32, G = 32, Ie = 32, je = 32, P = 32, Me = Ae, be = qe, ie = pe, le = 64, ge = 32, Ge = 64, $e = 32, Ne = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: k,
      crypto_stream_xor: fe,
      crypto_stream: Q,
      crypto_stream_salsa20_xor: $,
      crypto_stream_salsa20: re,
      crypto_onetimeauth: y,
      crypto_onetimeauth_verify: v,
      crypto_verify_16: I,
      crypto_verify_32: B,
      crypto_secretbox: a,
      crypto_secretbox_open: d,
      crypto_scalarmult: te,
      crypto_scalarmult_base: he,
      crypto_box_beforenm: W,
      crypto_box_afternm: ce,
      crypto_box: Be,
      crypto_box_open: ee,
      crypto_box_keypair: K,
      crypto_hash: Z,
      crypto_sign: Ve,
      crypto_sign_keypair: ue,
      crypto_sign_open: X,
      crypto_secretbox_KEYBYTES: Se,
      crypto_secretbox_NONCEBYTES: Ae,
      crypto_secretbox_ZEROBYTES: qe,
      crypto_secretbox_BOXZEROBYTES: pe,
      crypto_scalarmult_BYTES: Ee,
      crypto_scalarmult_SCALARBYTES: G,
      crypto_box_PUBLICKEYBYTES: Ie,
      crypto_box_SECRETKEYBYTES: je,
      crypto_box_BEFORENMBYTES: P,
      crypto_box_NONCEBYTES: Me,
      crypto_box_ZEROBYTES: be,
      crypto_box_BOXZEROBYTES: ie,
      crypto_sign_BYTES: le,
      crypto_sign_PUBLICKEYBYTES: ge,
      crypto_sign_SECRETKEYBYTES: Ge,
      crypto_sign_SEEDBYTES: $e,
      crypto_hash_BYTES: Ne,
      gf: r,
      D: h,
      L: se,
      pack25519: S,
      unpack25519: l,
      M: oe,
      A: R,
      S: H,
      Z: Y,
      pow2523: F,
      add: de,
      set25519: w,
      modL: _e,
      scalarmult: ze,
      scalarbase: z
    };
    function nt(D, J) {
      if (D.length !== Se)
        throw new Error("bad key size");
      if (J.length !== Ae)
        throw new Error("bad nonce size");
    }
    function st(D, J) {
      if (D.length !== Ie)
        throw new Error("bad public key size");
      if (J.length !== je)
        throw new Error("bad secret key size");
    }
    function Je() {
      for (var D = 0; D < arguments.length; D++)
        if (!(arguments[D] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function ft(D) {
      for (var J = 0; J < D.length; J++)
        D[J] = 0;
    }
    t.randomBytes = function(D) {
      var J = new Uint8Array(D);
      return i(J, D), J;
    }, t.secretbox = function(D, J, ne) {
      Je(D, J, ne), nt(ne, J);
      for (var O = new Uint8Array(qe + D.length), ae = new Uint8Array(O.length), we = 0; we < D.length; we++)
        O[we + qe] = D[we];
      return a(ae, O, O.length, J, ne), ae.subarray(pe);
    }, t.secretbox.open = function(D, J, ne) {
      Je(D, J, ne), nt(ne, J);
      for (var O = new Uint8Array(pe + D.length), ae = new Uint8Array(O.length), we = 0; we < D.length; we++)
        O[we + pe] = D[we];
      return O.length < 32 || d(ae, O, O.length, J, ne) !== 0 ? null : ae.subarray(qe);
    }, t.secretbox.keyLength = Se, t.secretbox.nonceLength = Ae, t.secretbox.overheadLength = pe, t.scalarMult = function(D, J) {
      if (Je(D, J), D.length !== G)
        throw new Error("bad n size");
      if (J.length !== Ee)
        throw new Error("bad p size");
      var ne = new Uint8Array(Ee);
      return te(ne, D, J), ne;
    }, t.scalarMult.base = function(D) {
      if (Je(D), D.length !== G)
        throw new Error("bad n size");
      var J = new Uint8Array(Ee);
      return he(J, D), J;
    }, t.scalarMult.scalarLength = G, t.scalarMult.groupElementLength = Ee, t.box = function(D, J, ne, O) {
      var ae = t.box.before(ne, O);
      return t.secretbox(D, J, ae);
    }, t.box.before = function(D, J) {
      Je(D, J), st(D, J);
      var ne = new Uint8Array(P);
      return W(ne, D, J), ne;
    }, t.box.after = t.secretbox, t.box.open = function(D, J, ne, O) {
      var ae = t.box.before(ne, O);
      return t.secretbox.open(D, J, ae);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var D = new Uint8Array(Ie), J = new Uint8Array(je);
      return K(D, J), { publicKey: D, secretKey: J };
    }, t.box.keyPair.fromSecretKey = function(D) {
      if (Je(D), D.length !== je)
        throw new Error("bad secret key size");
      var J = new Uint8Array(Ie);
      return he(J, D), { publicKey: J, secretKey: new Uint8Array(D) };
    }, t.box.publicKeyLength = Ie, t.box.secretKeyLength = je, t.box.sharedKeyLength = P, t.box.nonceLength = Me, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(D, J) {
      if (Je(D, J), J.length !== Ge)
        throw new Error("bad secret key size");
      var ne = new Uint8Array(le + D.length);
      return Ve(ne, D, D.length, J), ne;
    }, t.sign.open = function(D, J) {
      if (Je(D, J), J.length !== ge)
        throw new Error("bad public key size");
      var ne = new Uint8Array(D.length), O = X(ne, D, D.length, J);
      if (O < 0)
        return null;
      for (var ae = new Uint8Array(O), we = 0; we < ae.length; we++)
        ae[we] = ne[we];
      return ae;
    }, t.sign.detached = function(D, J) {
      for (var ne = t.sign(D, J), O = new Uint8Array(le), ae = 0; ae < O.length; ae++)
        O[ae] = ne[ae];
      return O;
    }, t.sign.detached.verify = function(D, J, ne) {
      if (Je(D, J, ne), J.length !== le)
        throw new Error("bad signature size");
      if (ne.length !== ge)
        throw new Error("bad public key size");
      var O = new Uint8Array(le + D.length), ae = new Uint8Array(le + D.length), we;
      for (we = 0; we < le; we++)
        O[we] = J[we];
      for (we = 0; we < D.length; we++)
        O[we + le] = D[we];
      return X(ae, O, O.length, ne) >= 0;
    }, t.sign.keyPair = function() {
      var D = new Uint8Array(ge), J = new Uint8Array(Ge);
      return ue(D, J), { publicKey: D, secretKey: J };
    }, t.sign.keyPair.fromSecretKey = function(D) {
      if (Je(D), D.length !== Ge)
        throw new Error("bad secret key size");
      for (var J = new Uint8Array(ge), ne = 0; ne < J.length; ne++)
        J[ne] = D[32 + ne];
      return { publicKey: J, secretKey: new Uint8Array(D) };
    }, t.sign.keyPair.fromSeed = function(D) {
      if (Je(D), D.length !== $e)
        throw new Error("bad seed size");
      for (var J = new Uint8Array(ge), ne = new Uint8Array(Ge), O = 0; O < 32; O++)
        ne[O] = D[O];
      return ue(J, ne, !0), { publicKey: J, secretKey: ne };
    }, t.sign.publicKeyLength = ge, t.sign.secretKeyLength = Ge, t.sign.seedLength = $e, t.sign.signatureLength = le, t.hash = function(D) {
      Je(D);
      var J = new Uint8Array(Ne);
      return Z(J, D, D.length), J;
    }, t.hash.hashLength = Ne, t.verify = function(D, J) {
      return Je(D, J), D.length === 0 || J.length === 0 || D.length !== J.length ? !1 : M(D, 0, J, 0, D.length) === 0;
    }, t.setPRNG = function(D) {
      i = D;
    }, function() {
      var D = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (D && D.getRandomValues) {
        var J = 65536;
        t.setPRNG(function(ne, O) {
          var ae, we = new Uint8Array(O);
          for (ae = 0; ae < O; ae += J)
            D.getRandomValues(we.subarray(ae, ae + Math.min(O - ae, J)));
          for (ae = 0; ae < O; ae++)
            ne[ae] = we[ae];
          ft(we);
        });
      } else
        typeof eh < "u" && (D = Eg(), D && D.randomBytes && t.setPRNG(function(ne, O) {
          var ae, we = D.randomBytes(O);
          for (ae = 0; ae < O; ae++)
            ne[ae] = we[ae];
          ft(we);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(Fy);
var K7 = Fy.exports, Sg = { exports: {} };
(function(e) {
  (function(t, r) {
    e.exports ? e.exports = r() : (t.nacl || (t.nacl = {}), t.nacl.util = r());
  })(Ze, function() {
    var t = {};
    function r(i) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(i))
        throw new TypeError("invalid encoding");
    }
    return t.decodeUTF8 = function(i) {
      if (typeof i != "string")
        throw new TypeError("expected string");
      var o, n = unescape(encodeURIComponent(i)), f = new Uint8Array(n.length);
      for (o = 0; o < n.length; o++)
        f[o] = n.charCodeAt(o);
      return f;
    }, t.encodeUTF8 = function(i) {
      var o, n = [];
      for (o = 0; o < i.length; o++)
        n.push(String.fromCharCode(i[o]));
      return decodeURIComponent(escape(n.join("")));
    }, typeof atob > "u" ? typeof Le.Buffer.from < "u" ? (t.encodeBase64 = function(i) {
      return Le.Buffer.from(i).toString("base64");
    }, t.decodeBase64 = function(i) {
      return r(i), new Uint8Array(Array.prototype.slice.call(Le.Buffer.from(i, "base64"), 0));
    }) : (t.encodeBase64 = function(i) {
      return new Le.Buffer(i).toString("base64");
    }, t.decodeBase64 = function(i) {
      return r(i), new Uint8Array(Array.prototype.slice.call(new Le.Buffer(i, "base64"), 0));
    }) : (t.encodeBase64 = function(i) {
      var o, n = [], f = i.length;
      for (o = 0; o < f; o++)
        n.push(String.fromCharCode(i[o]));
      return btoa(n.join(""));
    }, t.decodeBase64 = function(i) {
      r(i);
      var o, n = atob(i), f = new Uint8Array(n.length);
      for (o = 0; o < n.length; o++)
        f[o] = n.charCodeAt(o);
      return f;
    }), t;
  });
})(Sg);
var Z7 = Sg.exports, G7 = Ze && Ze.__createBinding || (Object.create ? function(e, t, r, i) {
  i === void 0 && (i = r);
  var o = Object.getOwnPropertyDescriptor(t, r);
  (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
    return t[r];
  } }), Object.defineProperty(e, i, o);
} : function(e, t, r, i) {
  i === void 0 && (i = r), e[i] = t[r];
}), J7 = Ze && Ze.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), Ag = Ze && Ze.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && G7(t, e, r);
  return J7(t, e), t;
};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.getEncryptionPublicKey = Nr.decryptSafely = Nr.decrypt = Nr.encryptSafely = Nr.encrypt = void 0;
const Kn = Ag(K7), Wr = Ag(Z7), fn = Xt;
function Mg({ publicKey: e, data: t, version: r }) {
  if ((0, fn.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, fn.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, fn.isNullish)(r))
    throw new Error("Missing version parameter");
  switch (r) {
    case "x25519-xsalsa20-poly1305": {
      if (typeof t != "string")
        throw new Error("Message data must be given as a string");
      const i = Kn.box.keyPair();
      let o;
      try {
        o = Wr.decodeBase64(e);
      } catch {
        throw new Error("Bad public key");
      }
      const n = Wr.decodeUTF8(t), f = Kn.randomBytes(Kn.box.nonceLength), u = Kn.box(n, f, o, i.secretKey);
      return {
        version: "x25519-xsalsa20-poly1305",
        nonce: Wr.encodeBase64(f),
        ephemPublicKey: Wr.encodeBase64(i.publicKey),
        ciphertext: Wr.encodeBase64(u)
      };
    }
    default:
      throw new Error("Encryption type/version not supported");
  }
}
Nr.encrypt = Mg;
function X7({ publicKey: e, data: t, version: r }) {
  if ((0, fn.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, fn.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, fn.isNullish)(r))
    throw new Error("Missing version parameter");
  const i = 2 ** 11, o = 16;
  if (typeof t == "object" && t && "toJSON" in t)
    throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
  const n = {
    data: t,
    padding: ""
  }, u = Le.Buffer.byteLength(JSON.stringify(n), "utf-8") % i;
  let c = 0;
  u > 0 && (c = i - u - o), n.padding = "0".repeat(c);
  const h = JSON.stringify(n);
  return Mg({ publicKey: e, data: h, version: r });
}
Nr.encryptSafely = X7;
function Rg({ encryptedData: e, privateKey: t }) {
  if ((0, fn.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, fn.isNullish)(t))
    throw new Error("Missing privateKey parameter");
  switch (e.version) {
    case "x25519-xsalsa20-poly1305": {
      const r = Bg(t), i = Kn.box.keyPair.fromSecretKey(r).secretKey, o = Wr.decodeBase64(e.nonce), n = Wr.decodeBase64(e.ciphertext), f = Wr.decodeBase64(e.ephemPublicKey), u = Kn.box.open(n, o, f, i);
      try {
        if (!u)
          throw new Error();
        const c = Wr.encodeUTF8(u);
        if (!c)
          throw new Error();
        return c;
      } catch (c) {
        throw c && typeof c.message == "string" && c.message.length ? new Error(`Decryption failed: ${c.message}`) : new Error("Decryption failed.");
      }
    }
    default:
      throw new Error("Encryption type/version not supported.");
  }
}
Nr.decrypt = Rg;
function Y7({ encryptedData: e, privateKey: t }) {
  if ((0, fn.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, fn.isNullish)(t))
    throw new Error("Missing privateKey parameter");
  return JSON.parse(Rg({ encryptedData: e, privateKey: t })).data;
}
Nr.decryptSafely = Y7;
function Q7(e) {
  const t = Bg(e), r = Kn.box.keyPair.fromSecretKey(t).publicKey;
  return Wr.encodeBase64(r);
}
Nr.getEncryptionPublicKey = Q7;
function Bg(e) {
  const t = Le.Buffer.from(e, "hex").toString("base64");
  return Wr.decodeBase64(t);
}
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(o, n, f, u) {
    u === void 0 && (u = f);
    var c = Object.getOwnPropertyDescriptor(n, f);
    (!c || ("get" in c ? !n.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return n[f];
    } }), Object.defineProperty(o, u, c);
  } : function(o, n, f, u) {
    u === void 0 && (u = f), o[u] = n[f];
  }), r = Ze && Ze.__exportStar || function(o, n) {
    for (var f in o)
      f !== "default" && !Object.prototype.hasOwnProperty.call(n, f) && t(n, o, f);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.concatSig = void 0, r(Tn, e), r(qy, e), r(Nr, e);
  var i = Xt;
  Object.defineProperty(e, "concatSig", { enumerable: !0, get: function() {
    return i.concatSig;
  } }), Object.defineProperty(e, "normalize", { enumerable: !0, get: function() {
    return i.normalize;
  } });
})(Cb);
var e9 = Ze && Ze.__createBinding || (Object.create ? function(e, t, r, i) {
  i === void 0 && (i = r), Object.defineProperty(e, i, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, i) {
  i === void 0 && (i = r), e[i] = t[r];
}), t9 = Ze && Ze.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), r9 = Ze && Ze.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && e9(t, e, r);
  return t9(t, e), t;
};
Object.defineProperty(qo, "__esModule", { value: !0 });
qo.createWalletMiddleware = void 0;
const wr = xr, n9 = r9(Cb), zr = Kt;
function i9({ getAccounts: e, processDecryptMessage: t, processEncryptionPublicKey: r, processEthSignMessage: i, processPersonalMessage: o, processTransaction: n, processSignTransaction: f, processTypedMessage: u, processTypedMessageV3: c, processTypedMessageV4: h }) {
  if (!e)
    throw new Error("opts.getAccounts is required");
  return wr.createScaffoldMiddleware({
    // account lookups
    eth_accounts: wr.createAsyncMiddleware(s),
    eth_coinbase: wr.createAsyncMiddleware(b),
    // tx signatures
    eth_sendTransaction: wr.createAsyncMiddleware(p),
    eth_signTransaction: wr.createAsyncMiddleware(m),
    // message signatures
    eth_sign: wr.createAsyncMiddleware(E),
    eth_signTypedData: wr.createAsyncMiddleware(M),
    eth_signTypedData_v3: wr.createAsyncMiddleware(I),
    eth_signTypedData_v4: wr.createAsyncMiddleware(B),
    personal_sign: wr.createAsyncMiddleware(T),
    eth_getEncryptionPublicKey: wr.createAsyncMiddleware(N),
    eth_decrypt: wr.createAsyncMiddleware(k),
    personal_ecRecover: wr.createAsyncMiddleware(j)
  });
  async function s($, re) {
    re.result = await e($);
  }
  async function b($, re) {
    const Q = await e($);
    re.result = Q[0] || null;
  }
  async function p($, re) {
    if (!n)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = $.params[0] || {};
    Q.from = await q(Q.from, $), re.result = await n(Q, $);
  }
  async function m($, re) {
    if (!f)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = $.params[0] || {};
    Q.from = await q(Q.from, $), re.result = await f(Q, $);
  }
  async function E($, re) {
    if (!i)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = await q($.params[0], $), fe = $.params[1], U = $.params[2] || {}, y = Object.assign(Object.assign({}, U), { from: Q, data: fe });
    re.result = await i(y, $);
  }
  async function M($, re) {
    if (!u)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = $.params[0], fe = await q($.params[1], $), U = "V1", y = $.params[2] || {}, v = Object.assign(Object.assign({}, y), { from: fe, data: Q });
    re.result = await u(v, $, U);
  }
  async function I($, re) {
    if (!c)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = await q($.params[0], $), fe = $.params[1], U = "V3", y = {
      data: fe,
      from: Q,
      version: U
    };
    re.result = await c(y, $, U);
  }
  async function B($, re) {
    if (!h)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = await q($.params[0], $), fe = $.params[1], U = "V4", y = {
      data: fe,
      from: Q,
      version: U
    };
    re.result = await h(y, $, U);
  }
  async function T($, re) {
    if (!o)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = $.params[0], fe = $.params[1], U = $.params[2] || {};
    let y, v;
    if (Cc(Q) && !Cc(fe)) {
      let d = "The eth_personalSign method requires params ordered ";
      d += "[message, address]. This was previously handled incorrectly, ", d += "and has been corrected automatically. ", d += "Please switch this param order for smooth behavior in the future.", re.warning = d, y = Q, v = fe;
    } else
      v = Q, y = fe;
    y = await q(y, $);
    const a = Object.assign(Object.assign({}, U), { from: y, data: v });
    re.result = await o(a, $);
  }
  async function j($, re) {
    const Q = $.params[0], fe = $.params[1], U = n9.recoverPersonalSignature({
      data: Q,
      signature: fe
    });
    re.result = U;
  }
  async function N($, re) {
    if (!r)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = await q($.params[0], $);
    re.result = await r(Q, $);
  }
  async function k($, re) {
    if (!t)
      throw zr.ethErrors.rpc.methodNotSupported();
    const Q = $.params[0], fe = await q($.params[1], $), U = $.params[2] || {}, y = Object.assign(Object.assign({}, U), { from: fe, data: Q });
    re.result = await t(y, $);
  }
  async function q($, re) {
    if (typeof $ == "string" && $.length > 0 && Cc($)) {
      const fe = (await e(re, {
        suppressUnauthorized: !1
      })).map((y) => y.toLowerCase()), U = $.toLowerCase();
      if (fe.includes(U))
        return U;
      throw zr.ethErrors.provider.unauthorized();
    }
    throw zr.ethErrors.rpc.invalidParams({
      message: "Invalid parameters: must provide an Ethereum address."
    });
  }
}
qo.createWalletMiddleware = i9;
function Cc(e) {
  return e.length === 2 + 20 * 2;
}
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, o, n, f) {
    f === void 0 && (f = n), Object.defineProperty(i, f, { enumerable: !0, get: function() {
      return o[n];
    } });
  } : function(i, o, n, f) {
    f === void 0 && (f = n), i[f] = o[n];
  }), r = Ze && Ze.__exportStar || function(i, o) {
    for (var n in i)
      n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, i, n);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(xo, e), r(Po, e), r(Co, e), r(No, e), r(Ri, e), r(Lo, e), r(Bi, e), r(ga, e), r(ko, e), r(jo, e), r(qo, e);
})(lh);
let Ig = class Tg extends no {
  constructor({
    network: t,
    wepin: r
  }) {
    const i = Pm({ wepin: r, network: t }), { rpcUrl: o, chainId: n } = ch(t), f = lh.createFetchMiddleware({
      rpcUrl: o
    });
    super({
      rpcMiddleware: [i, f]
    }), this._initializeState({
      accounts: [],
      chainId: n
    });
  }
  static generate(t) {
    const r = new Tg(t);
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[r.name] = r, window.evmproviders[r.name].selectedAddress = t.address, r;
  }
};
const a9 = () => (/* @__PURE__ */ new Date()).getTime(), Fi = ({
  wepin: e,
  network: t,
  req: r,
  res: i,
  next: o,
  end: n,
  command: f,
  parameter: u
}) => {
  var s;
  const c = a9();
  e.once(c.toString(), (b) => {
    if (b.body.data === "User Cancel")
      n(Kt.ethErrors.provider.userRejectedRequest());
    else {
      if (i.result = b.body.data === "User Cancel" ? "" : b.body.data, b.body.command === "wallet_switchEthereumChain") {
        const p = i.result.network.toLowerCase(), m = window.Wepin;
        switch (p) {
          case "ethereum":
          case "evmeth-goerli":
          case "evmsongbird":
          case "evmpolygon":
          case "evmpolygon-testnet":
          case "evmtime-elizabeth":
            hf.generate({
              address: i.result.address,
              network: p,
              wepin: m
            }), n();
            return;
          case "klaytn":
          case "klaytn-testnet":
            Ig.generate({
              address: i.result.address,
              network: p,
              wepin: m
            }), n();
            return;
          default:
            n(`Can not resolve network name: ${t}`);
        }
      }
      n();
    }
  });
  const h = {
    header: {
      request_from: "web",
      request_to: "wepin_widget",
      id: c
    },
    body: {
      command: f,
      parameter: u
    }
  };
  try {
    e.queue.push(h), (s = e.Widget) != null && s.isOpen || e.openWidget().catch((b) => {
      n(b);
    });
  } catch (b) {
    n(b);
  }
}, vi = ({ wepin: e, network: t }) => (r, i, o, n) => {
  if (!e._isInitialized) {
    n(Kt.ethErrors.provider.unauthorized());
    return;
  }
  const f = {
    network: t
  }, { evmproviders: u } = window;
  u.Wepin.selectedAddress ? (i.result = [u.Wepin.selectedAddress], n()) : Fi({
    wepin: e,
    network: t,
    req: r,
    res: i,
    next: o,
    end: n,
    command: "request_enable",
    parameter: f
  });
}, o9 = ({
  wepin: e,
  network: t
}) => xr.createScaffoldMiddleware({
  eth_requestAccounts: vi({ wepin: e, network: t }),
  eth_accounts: vi({ wepin: e, network: t }),
  eth_signTransaction: Dc({ wepin: e, network: t }),
  eth_sendTransaction: $c({ wepin: e, network: t }),
  eth_signTypedData_v1: ln({ wepin: e, network: t, version: "V1" }),
  eth_signTypedData_v3: ln({ wepin: e, network: t, version: "V3" }),
  eth_signTypedData_v4: ln({ wepin: e, network: t, version: "V4" }),
  eth_sign: Xi({ wepin: e, network: t, isPersonal: !1 }),
  personal_sign: Xi({ wepin: e, network: t, isPersonal: !0 }),
  wallet_switchEthereumChain: kv({ wepin: e, network: t })
});
class hf extends no {
  constructor({
    network: t,
    wepin: r
  }) {
    const i = o9({ wepin: r, network: t }), { rpcUrl: o, chainId: n } = ch(t), f = lh.createFetchMiddleware({
      rpcUrl: o
    });
    super({ rpcMiddleware: [i, f] }), this._initializeState({
      accounts: [],
      chainId: n
    });
  }
  static generate(t) {
    const r = new hf(t);
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[r.name] = r, window.evmproviders[r.name].selectedAddress = t.address, r;
  }
}
function f9({
  network: e,
  wepin: t
}) {
  var i, o, n;
  if ((i = window.evmproviders) != null && i.Wepin) {
    const f = (o = window.evmproviders) == null ? void 0 : o.Wepin.chainId, u = hh(f), c = (n = window.evmproviders) == null ? void 0 : n.Wepin.selectedAddress;
    if (((t == null ? void 0 : t.accountInfo) ?? []).filter(
      (b) => b.address === c && b.network.toLowerCase() === u
    ).length)
      return window.evmproviders.Wepin;
  }
  const r = e.toLowerCase();
  switch (r) {
    case "ethereum":
    case "evmeth-goerli":
    case "evmsongbird":
    case "evmpolygon":
    case "evmpolygon-testnet":
    case "evmtime-elizabeth":
      return hf.generate({ network: r, wepin: t });
    case "klaytn":
    case "klaytn-testnet":
      return Ig.generate({
        network: r,
        wepin: t
      });
    default:
      throw new Error(`Can not resolve network name: ${e}`);
  }
}
const Nc = {
  getProvider: f9,
  getNetworkInfoByName: ch,
  getNetworkByChainId: hh
};
var Rn, pn, fr;
class s9 extends Rv {
  constructor() {
    super();
    Aa(this, Rn, void 0);
    Aa(this, pn, void 0);
    Aa(this, fr, void 0);
    this.getNetworkByChainId = Nc.getNetworkByChainId, this.getNetworkInfoByName = Nc.getNetworkInfoByName, this.version = um.version, console.log(`WepinJavaScript SDK v${this.version} Initialized`), this._isInitialized = !1, lr(this, fr, "not_initialized"), this._initQueue();
  }
  setAccountInfo(r) {
    this.accountInfo = r, this.emit("onAccountSet", r);
  }
  get Widget() {
    return this._widget;
  }
  setModeByAppKey(r) {
    if (r.slice(0, 8) === "ak_live_") {
      this._modeByAppKey = "production";
      return;
    } else if (r.slice(0, 8) === "ak_test_") {
      this._modeByAppKey = "test";
      return;
    } else if (r.slice(0, 7) === "ak_dev_") {
      this._modeByAppKey = "development";
      return;
    } else
      throw new Error("Wepin.setModeByAppKey: Invalid appKey");
  }
  get modeByAppKey() {
    if (this._modeByAppKey === void 0)
      throw new Error("Wepin.modeByAppKey: wepin widget has to be initialized");
    return this._modeByAppKey;
  }
  toJSON() {
    return "";
  }
  /**
   * Initialize Wepin Object. It returns widget instance.
   */
  async init(r, i, o = {
    type: "hide",
    defaultLanguage: window.navigator.language.slice(0, 2) ?? Og,
    defaultCurrency: Pg
  }) {
    if ($t.debug("Wepin init starts with Key", i), this._isInitialized)
      throw new Error("Wepin is already initialized!");
    return this.setModeByAppKey(i), this.wepinAppId = r, lr(this, Rn, i), this.wepinAppAttributes = o, this.wepinDomain = window.location.origin, this._isInitialized = !1, lr(this, fr, "initializing"), o.type !== "show" ? await this._open({ isInit: !0, url: "/sdk/init" }) : await this._open({ isInit: !0 }), new Promise((n, f) => {
      this.once("widgetOpened", () => {
        try {
          this._isInitialized ? this.isLogedIn() ? lr(this, fr, "login") : lr(this, fr, "initialized") : lr(this, fr, "not_initialized"), this.wepinAppAttributes.type !== "show" ? (this._close(), $t.debug("this.widget", this._widget), n(this)) : n(this);
        } catch (u) {
          f(new Error(u));
        }
      });
    });
  }
  isLogedIn() {
    var r;
    try {
      const o = (r = Qt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) == null ? void 0 : r.refreshToken;
      return !!(!Qt.isExpired(o) && $r(this, pn) && $r(this, pn).status === "success");
    } catch {
      return !1;
    }
  }
  /**
   * Check if wepin is initialized.
   *
   * @returns
   */
  isInitialized() {
    return this._isInitialized;
  }
  //init, login되지 않으면 open 못하게!
  /**
   * It opens widget window.
   */
  async openWidget() {
    if (this.getStatus() !== "login")
      throw this.queue.length && this._initQueue(), new Error(
        "Wepin.openWidget: You can open it only if you are logged in to the wepin."
      );
    await this._open();
  }
  async _open(r) {
    try {
      let i = Qt.getUrls(this.modeByAppKey).wepinWebview;
      if (this._widget && this._widget.isOpen) {
        $t.debug("already opend widget", this._widget);
        return;
      }
      r != null && r.url && (i += r.url), (r == null ? void 0 : r.type) === "IFRAME" || this.wepinAppAttributes.type !== "show" && (r != null && r.isInit) ? this._widget = await zn.openNew(
        i,
        this,
        $r(this, Rn),
        {
          isHide: !0,
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ) : (r == null ? void 0 : r.type) === "WINDOW" ? this._widget = await Fn.openNew(
        i,
        this,
        $r(this, Rn),
        void 0,
        {
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ) : Qt.isMobile() ? this._widget = await zn.openNew(
        i,
        this,
        $r(this, Rn),
        {
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ) : this._widget = await Fn.openNew(
        i,
        this,
        $r(this, Rn),
        void 0,
        {
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ), $t.debug("openWidget this._widget", this._widget);
    } catch (i) {
      throw $t.error(i), new Error("Wepin.openWidget: Can't open wepin sdk widget");
    }
  }
  /**
   * It closes widget itself.
   */
  closeWidget() {
    if ($t.debug("closeWidget this._widget", this._widget), !this._isInitialized)
      throw new Error(
        "Wepin.closeWidget: wepin sdk widget has to be initialized"
      );
    if (this._widget)
      this._close();
    else
      throw new Error("Wepin.closeWidget: wepin sdk widget is not exist");
  }
  _close() {
    $t.debug("close this._widget", this._widget), this._widget && (this._widget.close(), this._widget = void 0);
  }
  /**
   * Returns available account list. It can be only usable after widget login.
   * It returns all the accounts once parameter is empty.
   *
   * @param networks list of network wanted to get return
   * @returns
   */
  async getAccounts(r) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getAccounts: wepin sdk widget has to be initialized"
      );
    return this.accountInfo ? r !== void 0 && r.length > 0 ? this.accountInfo.filter(
      (o) => r.includes(o.network)
    ) : this.accountInfo : (await this.openWidget(), new Promise((i, o) => {
      this.once("onAccountSet", (n) => {
        try {
          if (this._close(), r !== void 0 && r.length > 0) {
            const f = n.filter(
              (u) => r.includes(u.network)
            );
            i(f);
          } else
            i(n);
        } catch (f) {
          o(new Error(f));
        }
      });
    }));
  }
  setUserInfo(r, i) {
    lr(this, pn, r), r && r.status === "success" ? lr(this, fr, "login") : lr(this, fr, "initialized"), i && this.emit("onUserInfoSet", r);
  }
  /**
   * Returns lifecycle of wepin.
   * The lifecycle of the wepin is defined as follows.
   *  - 'not_initialized': if wepin is not initialized
   *  - 'initializing': if wepin is initializing
   *  - 'initialized': if wepin is initialized
   *  - 'before_login': if wepin is initialized but the user is not logged in
   *  - 'login': if the user is logged in
   *
   * @returns WepinLifeCycle
   */
  getStatus() {
    var r;
    if ($r(this, fr) === "login") {
      const i = (r = Qt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) == null ? void 0 : r.refreshToken;
      Qt.isExpired(i) && lr(this, fr, "initialized");
    }
    return $r(this, fr);
  }
  /**
   * Returns the user's login information. It can be only usable after widget login.
   *
   * @param email Encourage users to log in with the email specified in the app.
   * @returns
   */
  async login(r) {
    var i, o, n;
    if (!this._isInitialized)
      throw new Error("Wepin.login: wepin sdk widget has to be initialized");
    if (r && !cm.test(r))
      throw new Error("The email does not match the correct format.");
    if (lr(this, fr, "before_login"), $t.debug("cookie: ", Qt.getLocalStorage(this.wepinAppId)), Qt.getLocalStorage(this.wepinAppId) && ((i = Qt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) != null && i.refreshToken) && ((o = Qt.getLocalStorage(this.wepinAppId)["firebase:wepin"]) != null && o.refreshToken)) {
      const f = (n = Qt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) == null ? void 0 : n.refreshToken, u = Qt.getLocalStorage(this.wepinAppId).user_login_info;
      if ($t.debug("currentUserInfo", u), !Qt.isExpired(f) && u && u.status === "success")
        return await this._open({ url: "/wepin-sdk-login/login", type: "IFRAME" }), new Promise((c, h) => {
          this.once("onUserInfoSet", (s) => {
            try {
              this._close(), c(s);
            } catch (b) {
              h(new Error(b));
            }
          });
        });
    }
    return await this._open({ specifiedEmail: r }), new Promise((f, u) => {
      this.once("widgetClosed", () => {
        try {
          this._widget.type === "Window" && (this.removeAllListeners("onUserInfoSet"), $r(this, pn) ? f($r(this, pn)) : u(new Error("User cancled")));
        } catch (c) {
          u(new Error(c));
        }
      }), this.once("onUserInfoSet", (c) => {
        try {
          this._close(), this.removeAllListeners("widgetClosed"), f(c);
        } catch (h) {
          u(new Error(h));
        }
      });
    });
  }
  /**
   * Function to handle user logout.
   *
   * @returns {Promise<void>}
   */
  async logout() {
    if (!this._isInitialized && this.getStatus() !== "login")
      throw new Error(
        "Wepin.logout: wepin sdk widget has to be initialized and logined"
      );
    return await this._open({ url: "/wepin-sdk-login/logout", type: "IFRAME" }), new Promise((r, i) => {
      this.once("onLogout", async (o) => {
        try {
          o.status !== "success" ? (o.message == "Already logout" && (lr(this, fr, "initialized"), this.setAccountInfo([])), i(new Error(o.message ?? "Internal error"))) : (this.setAccountInfo([]), lr(this, fr, "initialized")), this._close(), r();
        } catch (n) {
          i(new Error(n));
        }
      });
    });
  }
  _initQueue() {
    this.queue = new Proxy([], {
      set: (r, i, o) => {
        const n = Reflect.set(r, i, o);
        return this.Widget && this.Widget.isOpen && this.Widget.request({
          header: {
            request_from: "web",
            request_to: "wepin_widget",
            id: (/* @__PURE__ */ new Date()).getTime()
            // default
          },
          body: {
            command: "provider_request",
            parameter: ""
          }
        }), n;
      }
    });
  }
  finalize() {
    this._close(), Qt.clearLocalStorage(this.wepinAppId), this._isInitialized = !1, lr(this, fr, "not_initialized"), lr(this, pn, void 0), this._initQueue();
  }
  /**
   * It returns a Provider by given network, chainId.
   *
   * @reference https://docs.wepin.io/kr/wepin/supported-blockchain
   * @param options - An options bag
   * @param options.network - Available chains Wepin helps provide.
   *  It should be lowercase.
   * @returns A EIP-1193 provider
   */
  getProvider({ network: r }) {
    if (!this._isInitialized)
      throw new Error("Wepin must be initialized to get Provider.");
    return Nc.getProvider({
      network: r,
      wepin: this
    });
  }
  //====================
}
Rn = new WeakMap(), pn = new WeakMap(), fr = new WeakMap();
const u9 = new s9();
typeof window < "u" && (window.Wepin = u9);
export {
  no as BaseProvider,
  s9 as Wepin
};
