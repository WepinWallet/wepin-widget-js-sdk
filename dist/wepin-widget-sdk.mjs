var T0 = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var tr = (e, t, r) => (T0(e, t, "read from private field"), r ? r.call(e) : t.get(e)), fi = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, qt = (e, t, r, i) => (T0(e, t, "write to private field"), i ? i.call(e, r) : t.set(e, r), r);
const lm = "ko", dm = "krw", Ca = "wepin:widget:", Cn = "provider:", pm = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/, I0 = class I0 {
  static closeOverlay(t) {
    const r = document.querySelector(`#${t}`);
    r && r.parentNode && r.parentNode.removeChild(r);
  }
  static openOverlay(t) {
    const r = document.createElement("div");
    r.id = t, r.classList.add(this.CONST.overlayClassName), r.style.zIndex = "2147483647", r.style.display = "flex", r.style.alignItems = "center", r.style.justifyContent = "center", r.style.textAlign = "center", r.style.position = "fixed", r.style.left = "0px", r.style.right = "0px", r.style.top = "0px", r.style.bottom = "0px", r.style.left = "0px", r.style.background = "rgba(0,0,0,0.6)", r.style.color = "white", r.style.border = "2px solid #f1f1f1";
    const i = document.getElementsByClassName(
      this.CONST.overlayClassName
    );
    for (let o = 0; o < i.length; o++) {
      const n = i.item(o);
      n && n.remove();
    }
    document.body.appendChild(r);
  }
};
I0.CONST = {
  overlayClassName: "wepin-widget__overlay"
};
let Fc = I0;
function Hc(e) {
  this.message = e;
}
Hc.prototype = new Error(), Hc.prototype.name = "InvalidCharacterError";
var O0 = typeof window < "u" && window.atob && window.atob.bind(window) || function(e) {
  var t = String(e).replace(/=+$/, "");
  if (t.length % 4 == 1)
    throw new Hc("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var r, i, o = 0, n = 0, f = ""; i = t.charAt(n++); ~i && (r = o % 4 ? 64 * r + i : i, o++ % 4) ? f += String.fromCharCode(255 & r >> (-2 * o & 6)) : 0)
    i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i);
  return f;
};
function vm(e) {
  var t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(r) {
      return decodeURIComponent(O0(r).replace(/(.)/g, function(i, o) {
        var n = o.charCodeAt(0).toString(16).toUpperCase();
        return n.length < 2 && (n = "0" + n), "%" + n;
      }));
    }(t);
  } catch {
    return O0(t);
  }
}
function uo(e) {
  this.message = e;
}
function bm(e, t) {
  if (typeof e != "string")
    throw new uo("Invalid token specified");
  var r = (t = t || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(vm(e.split(".")[r]));
  } catch (i) {
    throw new uo("Invalid token specified: " + i.message);
  }
}
uo.prototype = new Error(), uo.prototype.name = "InvalidTokenError";
const Mn = class Mn {
};
Mn.test = console.warn.bind(window.console, "[SDK][test] "), Mn.warn = console.warn.bind(window.console, "[SDK][warn] "), Mn.error = console.error.bind(window.console, "[SDK][error] "), Mn.todo = console.warn.bind(window.console, "[SDK][todo] "), Mn.assert = console.assert.bind(window.console), Mn.debug = () => {
};
let It = Mn;
const xo = class xo {
  static isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }
  static messages(t) {
    return {
      hasValidOrigin: (r) => r.origin === xo.getUrls(t).wepinWebview
      // hasCorrectCorrelationID(message: MessageEvent,
      //                         correlationID: string | undefined) {
      //     return correlationID && message.data && message.data.correlationID === correlationID;
      // }
    };
  }
  static getUrls(t) {
    switch (t) {
      case "production":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://widget.wepin.io"
        };
      case "test":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://stage-widget.wepin.io"
        };
      case "development":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://dev-widget.wepin.io"
        };
      default:
        throw new Error("Utils.getUrls: invalid mode");
    }
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function(t) {
        const r = Math.random() * 16 | 0;
        return (t == "x" ? r : r & 3 | 8).toString(16);
      }
    );
  }
  static getLocalStorgeEnabled() {
    let t = !1;
    try {
      t = window.localStorage && !0;
    } catch {
      t = !1;
    }
    return t;
  }
  static setLocalStorage(t, r) {
    if (!this.getLocalStorgeEnabled()) {
      It.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const i = JSON.stringify(r);
    localStorage.setItem(Ca + t, i);
  }
  static getLocalStorage(t) {
    if (!this.getLocalStorgeEnabled()) {
      It.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    return localStorage.getItem(Ca + t) ? JSON.parse(localStorage.getItem(Ca + t)) : void 0;
  }
  static clearLocalStorage(t) {
    if (!this.getLocalStorgeEnabled()) {
      It.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(Ca + t);
  }
  static isExpired(t) {
    var i;
    if (!t)
      return !0;
    const r = (i = bm(t)) == null ? void 0 : i.exp;
    return It.debug("isExpiredRefreshToken expired", r), It.debug("Date.now()", Date.now()), It.debug(
      " Math.floor(Date.now()/1000) + (60*60)",
      Math.floor(Date.now() / 1e3)
    ), r <= Math.floor(Date.now() / 1e3) + 60;
  }
};
xo.checkSameNumber = (t, r, i) => {
  if (i)
    return !1;
  const o = [...Array(10)].map(Number.prototype.valueOf, 0);
  let n = !1;
  return [...t].forEach((u) => {
    if (o[Number(u)]++, o[Number(u)] >= r) {
      n = !0;
      return;
    }
  }), n;
};
let jt = xo;
const ym = 1, gm = (e, t, r) => {
  var n, f;
  const i = {
    header: {
      response_from: "web",
      response_to: "wepin_widget",
      id: e.header.id
    }
  };
  switch (e.body.command) {
    case "ready_to_widget":
      It.debug("ready_to_widget"), i.body = {
        command: "ready_to_widget",
        state: "SUCCESS",
        data: {
          appKey: r,
          domain: t.Wepin.wepinDomain,
          platform: ym,
          attributes: t.Wepin.wepinAppAttributes,
          version: t.Wepin.version.includes("-alpha") ? t.Wepin.version.substring(
            0,
            t.Wepin.version.indexOf("-")
          ) : t.Wepin.version,
          localDate: jt.getLocalStorage(t.Wepin.wepinAppId) ?? {}
        }
      }, t.Wepin.emit("startAdminRequest");
      break;
    case "initialized_widget":
      {
        const u = e.body.parameter;
        It.debug("initialized_widget resulte =>", u.result), t.Wepin._isInitialized = u.result, i.body = {
          command: "initialized_widget",
          state: "SUCCESS",
          data: ""
        }, t.Wepin.emit("widgetOpened", u);
      }
      break;
    case "set_accounts":
      It.debug("set_accounts", e.body.parameter), t.Wepin.setAccountInfo(
        (n = e.body.parameter) == null ? void 0 : n.accounts,
        (f = e.body.parameter) == null ? void 0 : f.detailAccount
      ), i.body = {
        command: "set_accounts",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "close_wepin_widget":
      t.close();
      break;
    case "dequeue_request":
      t.Wepin.queue[0] ? (o(), i.body = {
        command: e.body.command,
        state: "SUCCESS",
        data: t.Wepin.queue[0]
        // 요청이 실제로 처리된 후 제거하기 때문에 실제 dequeue 하지 않는다.
      }) : i.body = {
        command: e.body.command,
        state: "ERROR",
        data: null
      };
      break;
    case "set_user_info":
      t.Wepin.setUserInfo(e.body.parameter, !0), i.body = {
        command: "set_user_info",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "wepin_logout":
      It.debug("wepin_logout"), t.Wepin.emit("onLogout", e.body.parameter), i.body = {
        command: "wepin_logout",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "set_local_storage":
      jt.setLocalStorage(
        t.Wepin.wepinAppId,
        e.body.parameter.data
      ), t.Wepin.setUserInfo(e.body.parameter.data.user_login_info), i.body = {
        command: "set_local_storage",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "set_user_email":
      i.body = {
        command: "set_user_email",
        state: "SUCCESS",
        data: {
          email: t.specifiedEmail
        }
      };
      break;
    default:
      throw new Error(`Command ${e.body.command} is not supported.`);
  }
  t.isOpen && t.response(i);
  function o() {
    if (t.type === "Window") {
      const u = t.Wepin.queue[0].header.id, c = setInterval(() => {
        try {
          if (t.Webview.closed) {
            clearInterval(c), t.close();
            const h = t.Wepin.queue[0];
            h.header.id === u && (t.Wepin.emit(h.header.id.toString(), {
              header: {
                response_from: "wepin_widget",
                response_to: "web",
                id: h.header.id
              },
              body: {
                command: h.body.command,
                state: "ERROR",
                data: "User Cancel"
              }
            }), t.Wepin.queue.shift());
          }
        } catch {
          clearInterval(c), t.close();
        }
      }, 200);
    }
  }
}, mm = (e, t) => {
  It.debug("Got Response from webview =>", e), t.queue.shift(), t.emit(e.header.id.toString(), e);
}, wm = (e, t) => {
  const r = (i) => !(!(e.url.includes("/wepin-sdk-login") || e.url.includes(i.origin)) && i.origin !== e.url || !Object.prototype.hasOwnProperty.call(i.data, "header") || !Object.prototype.hasOwnProperty.call(i.data, "body"));
  return (i) => {
    r(i) && _m(
      i.data,
      e,
      t
    );
  };
}, _m = (e, t, r) => {
  e.header.request_to === "web" ? gm(e, t, r) : e.header.response_to === "web" ? mm(e, t.Wepin) : It.error("Failed to handle message:", e);
};
class ua extends Fc {
  get isOpen() {
    return this._open;
  }
  get Wepin() {
    return this._wepin;
  }
  get Webview() {
    return this._webview;
  }
  clearWebview() {
    this._webview = null;
  }
  constructor(t, r, i, o, n, f, u) {
    super(), this.url = t, this.id = `id-${jt.uuidv4()}`, this.isHide = f, this.specifiedEmail = u, f || ua.openOverlay(this.id), this._wepin = r, this._webview = i, this.type = o, this.EL = wm(this, n), window.addEventListener("message", this.EL), this._open = !0, It.debug(`Widget(${this.id}) is succefully created. The url is: ${t}`);
  }
  close() {
    this.isHide || ua.closeOverlay(this.id), window.removeEventListener("message", this.EL), this.Wepin.removeAllListeners("onAccountSet"), this.Wepin.removeAllListeners("widgetOpened"), this.Wepin.emit("widgetClosed"), this.Wepin.removeAllListeners(), this._open = !1, this._closeWebview();
  }
  response(t) {
    try {
      this._post(t);
    } catch (r) {
      It.error("Can not response message to the webview", r);
    }
  }
  request(t) {
    try {
      this._post(t);
    } catch (r) {
      It.error("Can not send message to the webview", r);
    }
  }
}
const xm = (e) => {
  const t = (e == null ? void 0 : e.width) || 375, r = (e == null ? void 0 : e.height) || 604, i = e != null && e.sLeft ? e == null ? void 0 : e.sLeft : window.screenLeft ? window.screenLeft : window.screenX ? window.screenX : 0, o = e != null && e.sTop ? e == null ? void 0 : e.sTop : window.screenTop ? window.screenTop : window.screenY ? window.screenY : 0, n = screen.width / 2 - t / 2 + i, f = screen.height / 2 - r / 2 + o;
  return `width=${t}, height=${r}, left=${n}, top=${f}scrollbars=yes, resizable=1, menubar=no, toolbar=no`;
}, Em = (e) => {
  const t = document.createElement("iframe");
  return t.classList.add("wepin-sdk-widget-iframe"), t.setAttribute("frameborder", "0"), t.setAttribute("marginwidth", "0"), t.setAttribute("marginheight", "0"), t.style.width = "100%", e && (e != null && e.isHide) ? t.style.height = "0" : t.style.height = "100%", t.style.maxHeight = "100%", t.style.position = "fixed", t.style.bottom = "0", t.style.left = "0", t.style.zIndex = "408888000000", t.title = "wepin sdk webview", t.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", t.allowFullscreen = !0, t;
};
class zn extends ua {
  // is it necessary ?
  constructor({
    url: t,
    wepin: r,
    frame: i,
    wepinAppKey: o,
    isHide: n,
    specifiedEmail: f
  }) {
    super(t, r, i, "Frame", o, n, f), i.src = t, i.id = this.id;
    const u = document.querySelector("body");
    zn.scrollPosition = window.pageYOffset, u.style.overflow = "hidden", u.style.position = "fixed", u.style.top = `-${zn.scrollPosition}px`, u.style.width = "100%", document.body.appendChild(i);
  }
  static async openNew(t, r, i, o) {
    const n = Em({ isHide: o == null ? void 0 : o.isHide });
    return new zn({
      url: t,
      wepin: r,
      frame: n,
      wepinAppKey: i,
      isHide: o == null ? void 0 : o.isHide,
      specifiedEmail: o == null ? void 0 : o.specifiedEmail
    });
  }
  expand() {
    this.Webview.style.height = "100%", this.Webview.style.borderRadius = "0";
  }
  shrink() {
    this.Webview.style.height = "604px", this.Webview.style.borderRadius = "12px 12px 0 0 ";
  }
  _closeWebview() {
    const t = setTimeout(() => {
      It.debug("this.timer", t);
      const r = document.querySelector("body");
      r.style.removeProperty("overflow"), r.style.removeProperty("position"), r.style.removeProperty("top"), r.style.removeProperty("width"), window.scrollTo(0, zn.scrollPosition), this.Webview && document.body.removeChild(this.Webview), this.clearWebview();
    }, 500);
  }
  _post(t) {
    this.Webview.contentWindow.postMessage(
      t,
      this.url
    );
  }
}
class mi extends ua {
  constructor({
    url: t,
    wepin: r,
    webview: i,
    wepinAppKey: o,
    isHide: n,
    specifiedEmail: f
  }) {
    super(t, r, i, "Window", o, n, f);
  }
  //: NodeJS.Timer | number
  static async openNew(t, r, i, o, n) {
    const f = xm(o), c = window.open(t, "Wepin_Widget", f), h = await new mi({
      url: t,
      wepin: r,
      webview: c,
      wepinAppKey: i,
      isHide: n == null ? void 0 : n.isHide,
      specifiedEmail: n == null ? void 0 : n.specifiedEmail
    });
    if (!c)
      throw h.close(), new Error("popup window blocked");
    return this.timer = setInterval(() => {
      try {
        c && c.closed && (clearInterval(this.timer), h.close());
      } catch {
        clearInterval(this.timer), h.close();
      }
    }, 200), h;
  }
  expand() {
  }
  shrink() {
  }
  _closeWebview() {
    mi.timer && (clearInterval(mi.timer), mi.timer = void 0), this.Webview && this.Webview.close(), this.clearWebview();
  }
  _post(t) {
    this.Webview.postMessage(t, this.url);
  }
}
var Ze = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Bv(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Iv(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var o = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(r, i, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), r;
}
var ph = { exports: {} }, xi = typeof Reflect == "object" ? Reflect : null, P0 = xi && typeof xi.apply == "function" ? xi.apply : function(t, r, i) {
  return Function.prototype.apply.call(t, r, i);
}, no;
xi && typeof xi.ownKeys == "function" ? no = xi.ownKeys : Object.getOwnPropertySymbols ? no = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : no = function(t) {
  return Object.getOwnPropertyNames(t);
};
function Sm(e) {
  console && console.warn && console.warn(e);
}
var Tv = Number.isNaN || function(t) {
  return t !== t;
};
function Ut() {
  Ut.init.call(this);
}
ph.exports = Ut;
ph.exports.once = Bm;
Ut.EventEmitter = Ut;
Ut.prototype._events = void 0;
Ut.prototype._eventsCount = 0;
Ut.prototype._maxListeners = void 0;
var C0 = 10;
function So(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Ut, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return C0;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || Tv(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    C0 = e;
  }
});
Ut.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Ut.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || Tv(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function Ov(e) {
  return e._maxListeners === void 0 ? Ut.defaultMaxListeners : e._maxListeners;
}
Ut.prototype.getMaxListeners = function() {
  return Ov(this);
};
Ut.prototype.emit = function(t) {
  for (var r = [], i = 1; i < arguments.length; i++)
    r.push(arguments[i]);
  var o = t === "error", n = this._events;
  if (n !== void 0)
    o = o && n.error === void 0;
  else if (!o)
    return !1;
  if (o) {
    var f;
    if (r.length > 0 && (f = r[0]), f instanceof Error)
      throw f;
    var u = new Error("Unhandled error." + (f ? " (" + f.message + ")" : ""));
    throw u.context = f, u;
  }
  var c = n[t];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    P0(c, this, r);
  else
    for (var h = c.length, s = kv(c, h), i = 0; i < h; ++i)
      P0(s[i], this, r);
  return !0;
};
function Pv(e, t, r, i) {
  var o, n, f;
  if (So(r), n = e._events, n === void 0 ? (n = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (n.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), n = e._events), f = n[t]), f === void 0)
    f = n[t] = r, ++e._eventsCount;
  else if (typeof f == "function" ? f = n[t] = i ? [r, f] : [f, r] : i ? f.unshift(r) : f.push(r), o = Ov(e), o > 0 && f.length > o && !f.warned) {
    f.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + f.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = f.length, Sm(u);
  }
  return e;
}
Ut.prototype.addListener = function(t, r) {
  return Pv(this, t, r, !1);
};
Ut.prototype.on = Ut.prototype.addListener;
Ut.prototype.prependListener = function(t, r) {
  return Pv(this, t, r, !0);
};
function Am() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Cv(e, t, r) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, o = Am.bind(i);
  return o.listener = r, i.wrapFn = o, o;
}
Ut.prototype.once = function(t, r) {
  return So(r), this.on(t, Cv(this, t, r)), this;
};
Ut.prototype.prependOnceListener = function(t, r) {
  return So(r), this.prependListener(t, Cv(this, t, r)), this;
};
Ut.prototype.removeListener = function(t, r) {
  var i, o, n, f, u;
  if (So(r), o = this._events, o === void 0)
    return this;
  if (i = o[t], i === void 0)
    return this;
  if (i === r || i.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete o[t], o.removeListener && this.emit("removeListener", t, i.listener || r));
  else if (typeof i != "function") {
    for (n = -1, f = i.length - 1; f >= 0; f--)
      if (i[f] === r || i[f].listener === r) {
        u = i[f].listener, n = f;
        break;
      }
    if (n < 0)
      return this;
    n === 0 ? i.shift() : Mm(i, n), i.length === 1 && (o[t] = i[0]), o.removeListener !== void 0 && this.emit("removeListener", t, u || r);
  }
  return this;
};
Ut.prototype.off = Ut.prototype.removeListener;
Ut.prototype.removeAllListeners = function(t) {
  var r, i, o;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var n = Object.keys(i), f;
    for (o = 0; o < n.length; ++o)
      f = n[o], f !== "removeListener" && this.removeAllListeners(f);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = i[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (o = r.length - 1; o >= 0; o--)
      this.removeListener(t, r[o]);
  return this;
};
function Nv(e, t, r) {
  var i = e._events;
  if (i === void 0)
    return [];
  var o = i[t];
  return o === void 0 ? [] : typeof o == "function" ? r ? [o.listener || o] : [o] : r ? Rm(o) : kv(o, o.length);
}
Ut.prototype.listeners = function(t) {
  return Nv(this, t, !0);
};
Ut.prototype.rawListeners = function(t) {
  return Nv(this, t, !1);
};
Ut.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Lv.call(e, t);
};
Ut.prototype.listenerCount = Lv;
function Lv(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Ut.prototype.eventNames = function() {
  return this._eventsCount > 0 ? no(this._events) : [];
};
function kv(e, t) {
  for (var r = new Array(t), i = 0; i < t; ++i)
    r[i] = e[i];
  return r;
}
function Mm(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Rm(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function Bm(e, t) {
  return new Promise(function(r, i) {
    function o(f) {
      e.removeListener(t, n), i(f);
    }
    function n() {
      typeof e.removeListener == "function" && e.removeListener("error", o), r([].slice.call(arguments));
    }
    qv(e, t, n, { once: !0 }), t !== "error" && Im(e, o, { once: !0 });
  });
}
function Im(e, t, r) {
  typeof e.on == "function" && qv(e, "error", t, r);
}
function qv(e, t, r, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function o(n) {
      i.once && e.removeEventListener(t, o), r(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var Di = ph.exports;
function N0(e, t, r) {
  try {
    Reflect.apply(e, t, r);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function Tm(e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i += 1)
    r[i] = e[i];
  return r;
}
let $v = class extends Di.EventEmitter {
  emit(t, ...r) {
    let i = t === "error";
    const o = this._events;
    if (o !== void 0)
      i = i && o.error === void 0;
    else if (!i)
      return !1;
    if (i) {
      let f;
      if (r.length > 0 && ([f] = r), f instanceof Error)
        throw f;
      const u = new Error(`Unhandled error.${f ? ` (${f.message})` : ""}`);
      throw u.context = f, u;
    }
    const n = o[t];
    if (n === void 0)
      return !1;
    if (typeof n == "function")
      N0(n, this, r);
    else {
      const f = n.length, u = Tm(n);
      for (let c = 0; c < f; c += 1)
        N0(u[c], this, r);
    }
    return !0;
  }
};
const Om = "@wepin/widget-sdk", Pm = "0.5.2", Cm = "Wepin Widget Javascript SDK for Web", Nm = "./dist/wepin-widget-sdk.umd.js", Lm = "./dist/src/index.d.ts", km = "IoTrust, Co., Ltd.", qm = "https://github.com/WepinWallet/wepin-widget-js-sdk/", $m = [
  "dist"
], Dm = {
  type: "git",
  url: "git+https://github.com/WepinWallet/wepin-widget-js-sdk.git"
}, jm = {
  "build-ts": "tsc --project tsconfig.json && tsc-alias -p tsconfig.json",
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  start: "npm run bundle && npm run watch",
  test: 'echo "Error: no test specified" && exit 1',
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, Um = [
  "wepin",
  "wepinwallet",
  "wallet"
], Fm = "MIT", Hm = {
  "@types/events": "^3.0.3",
  "@types/lodash": "^4.14.189",
  "@types/ua-parser-js": "^0.7.36",
  "@typescript-eslint/eslint-plugin": "^5.46.1",
  "@typescript-eslint/parser": "^5.46.1",
  "@wepin/types": "^0.0.11",
  eslint: "^8.29.0",
  "eslint-config-prettier": "^8.5.0",
  "eslint-plugin-prettier": "^4.2.1",
  "node-stdlib-browser": "^1.2.0",
  prettier: "^2.8.1",
  "ts-loader": "^9.4.1",
  "tsc-alias": "^1.8.2",
  typescript: "^4.9.3",
  vite: "^5.0.2",
  "vite-plugin-dts": "^3.6.3",
  "vite-plugin-node-stdlib-browser": "^0.2.1"
}, zm = {
  "eth-json-rpc-middleware": "^9.0.1",
  "json-rpc-engine": "^6.1.0",
  "jwt-decode": "^3.1.2"
}, Vm = {
  name: Om,
  version: Pm,
  description: Cm,
  main: Nm,
  types: Lm,
  author: km,
  homepage: qm,
  files: $m,
  repository: Dm,
  scripts: jm,
  keywords: Um,
  license: Fm,
  devDependencies: Hm,
  dependencies: zm
};
var Wt = {}, Nn = {}, Wm = ca;
ca.default = ca;
ca.stable = Uv;
ca.stableStringify = Uv;
var co = "[...]", Dv = "[Circular]", ei = [], Vn = [];
function jv() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function ca(e, t, r, i) {
  typeof i > "u" && (i = jv()), zc(e, "", 0, [], void 0, 0, i);
  var o;
  try {
    Vn.length === 0 ? o = JSON.stringify(e, t, r) : o = JSON.stringify(e, Fv(t), r);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; ei.length !== 0; ) {
      var n = ei.pop();
      n.length === 4 ? Object.defineProperty(n[0], n[1], n[3]) : n[0][n[1]] = n[2];
    }
  }
  return o;
}
function Ei(e, t, r, i) {
  var o = Object.getOwnPropertyDescriptor(i, r);
  o.get !== void 0 ? o.configurable ? (Object.defineProperty(i, r, { value: e }), ei.push([i, r, t, o])) : Vn.push([t, r, e]) : (i[r] = e, ei.push([i, r, t]));
}
function zc(e, t, r, i, o, n, f) {
  n += 1;
  var u;
  if (typeof e == "object" && e !== null) {
    for (u = 0; u < i.length; u++)
      if (i[u] === e) {
        Ei(Dv, e, t, o);
        return;
      }
    if (typeof f.depthLimit < "u" && n > f.depthLimit) {
      Ei(co, e, t, o);
      return;
    }
    if (typeof f.edgesLimit < "u" && r + 1 > f.edgesLimit) {
      Ei(co, e, t, o);
      return;
    }
    if (i.push(e), Array.isArray(e))
      for (u = 0; u < e.length; u++)
        zc(e[u], u, u, i, e, n, f);
    else {
      var c = Object.keys(e);
      for (u = 0; u < c.length; u++) {
        var h = c[u];
        zc(e[h], h, u, i, e, n, f);
      }
    }
    i.pop();
  }
}
function Km(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Uv(e, t, r, i) {
  typeof i > "u" && (i = jv());
  var o = Vc(e, "", 0, [], void 0, 0, i) || e, n;
  try {
    Vn.length === 0 ? n = JSON.stringify(o, t, r) : n = JSON.stringify(o, Fv(t), r);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; ei.length !== 0; ) {
      var f = ei.pop();
      f.length === 4 ? Object.defineProperty(f[0], f[1], f[3]) : f[0][f[1]] = f[2];
    }
  }
  return n;
}
function Vc(e, t, r, i, o, n, f) {
  n += 1;
  var u;
  if (typeof e == "object" && e !== null) {
    for (u = 0; u < i.length; u++)
      if (i[u] === e) {
        Ei(Dv, e, t, o);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof f.depthLimit < "u" && n > f.depthLimit) {
      Ei(co, e, t, o);
      return;
    }
    if (typeof f.edgesLimit < "u" && r + 1 > f.edgesLimit) {
      Ei(co, e, t, o);
      return;
    }
    if (i.push(e), Array.isArray(e))
      for (u = 0; u < e.length; u++)
        Vc(e[u], u, u, i, e, n, f);
    else {
      var c = {}, h = Object.keys(e).sort(Km);
      for (u = 0; u < h.length; u++) {
        var s = h[u];
        Vc(e[s], s, u, i, e, n, f), c[s] = e[s];
      }
      if (typeof o < "u")
        ei.push([o, t, e]), o[t] = c;
      else
        return c;
    }
    i.pop();
  }
}
function Fv(e) {
  return e = typeof e < "u" ? e : function(t, r) {
    return r;
  }, function(t, r) {
    if (Vn.length > 0)
      for (var i = 0; i < Vn.length; i++) {
        var o = Vn[i];
        if (o[1] === t && o[0] === r) {
          r = o[2], Vn.splice(i, 1);
          break;
        }
      }
    return e.call(this, t, r);
  };
}
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.EthereumProviderError = Nn.EthereumRpcError = void 0;
const Zm = Wm;
class Hv extends Error {
  constructor(t, r, i) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = t, i !== void 0 && (this.data = i);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return Zm.default(this.serialize(), Xm, 2);
  }
}
Nn.EthereumRpcError = Hv;
class Gm extends Hv {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(t, r, i) {
    if (!Jm(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, r, i);
  }
}
Nn.EthereumProviderError = Gm;
function Jm(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function Xm(e, t) {
  if (t !== "[Circular]")
    return t;
}
var vh = {}, Ln = {};
Object.defineProperty(Ln, "__esModule", { value: !0 });
Ln.errorValues = Ln.errorCodes = void 0;
Ln.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
Ln.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = Ln, r = Nn, i = t.errorCodes.rpc.internal, o = "Unspecified error message. This is a bug, please report it.", n = {
    code: i,
    message: f(i)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function f(v, m = o) {
    if (Number.isInteger(v)) {
      const E = v.toString();
      if (p(t.errorValues, E))
        return t.errorValues[E].message;
      if (h(v))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return m;
  }
  e.getMessageFromCode = f;
  function u(v) {
    if (!Number.isInteger(v))
      return !1;
    const m = v.toString();
    return !!(t.errorValues[m] || h(v));
  }
  e.isValidCode = u;
  function c(v, { fallbackError: m = n, shouldIncludeStack: E = !1 } = {}) {
    var M, I;
    if (!m || !Number.isInteger(m.code) || typeof m.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (v instanceof r.EthereumRpcError)
      return v.serialize();
    const B = {};
    if (v && typeof v == "object" && !Array.isArray(v) && p(v, "code") && u(v.code)) {
      const k = v;
      B.code = k.code, k.message && typeof k.message == "string" ? (B.message = k.message, p(k, "data") && (B.data = k.data)) : (B.message = f(B.code), B.data = { originalError: s(v) });
    } else {
      B.code = m.code;
      const k = (M = v) === null || M === void 0 ? void 0 : M.message;
      B.message = k && typeof k == "string" ? k : m.message, B.data = { originalError: s(v) };
    }
    const T = (I = v) === null || I === void 0 ? void 0 : I.stack;
    return E && v && T && typeof T == "string" && (B.stack = T), B;
  }
  e.serializeError = c;
  function h(v) {
    return v >= -32099 && v <= -32e3;
  }
  function s(v) {
    return v && typeof v == "object" && !Array.isArray(v) ? Object.assign({}, v) : v;
  }
  function p(v, m) {
    return Object.prototype.hasOwnProperty.call(v, m);
  }
})(vh);
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.ethErrors = void 0;
const bh = Nn, zv = vh, vr = Ln;
Ao.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => Ir(vr.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => Ir(vr.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => Ir(vr.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => Ir(vr.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => Ir(vr.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: t } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Ir(t, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => Ir(vr.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => Ir(vr.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => Ir(vr.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => Ir(vr.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => Ir(vr.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => Ir(vr.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => Ji(vr.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => Ji(vr.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => Ji(vr.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => Ji(vr.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => Ji(vr.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: t, message: r, data: i } = e;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new bh.EthereumProviderError(t, r, i);
    }
  }
};
function Ir(e, t) {
  const [r, i] = Vv(t);
  return new bh.EthereumRpcError(e, r || zv.getMessageFromCode(e), i);
}
function Ji(e, t) {
  const [r, i] = Vv(t);
  return new bh.EthereumProviderError(e, r || zv.getMessageFromCode(e), i);
}
function Vv(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: t, data: r } = e;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t || void 0, r];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = Nn;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return t.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return t.EthereumProviderError;
  } });
  const r = vh;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return r.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return r.getMessageFromCode;
  } });
  const i = Ao;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return i.ethErrors;
  } });
  const o = Ln;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return o.errorCodes;
  } });
})(Wt);
var Ym = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var i, o, n;
    if (Array.isArray(t)) {
      if (i = t.length, i != r.length)
        return !1;
      for (o = i; o-- !== 0; )
        if (!e(t[o], r[o]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (n = Object.keys(t), i = n.length, i !== Object.keys(r).length)
      return !1;
    for (o = i; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, n[o]))
        return !1;
    for (o = i; o-- !== 0; ) {
      var f = n[o];
      if (!e(t[f], r[f]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
};
const Qm = /* @__PURE__ */ Bv(Ym);
var Br = {}, Mo = {}, ya = {};
Object.defineProperty(ya, "__esModule", { value: !0 });
ya.getUniqueId = void 0;
const Wv = 4294967295;
let mf = Math.floor(Math.random() * Wv);
function e2() {
  return mf = (mf + 1) % Wv, mf;
}
ya.getUniqueId = e2;
Object.defineProperty(Mo, "__esModule", { value: !0 });
Mo.createIdRemapMiddleware = void 0;
const t2 = ya;
function r2() {
  return (e, t, r, i) => {
    const o = e.id, n = t2.getUniqueId();
    e.id = n, t.id = n, r((f) => {
      e.id = o, t.id = o, f();
    });
  };
}
Mo.createIdRemapMiddleware = r2;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.createAsyncMiddleware = void 0;
function n2(e) {
  return async (t, r, i, o) => {
    let n;
    const f = new Promise((s) => {
      n = s;
    });
    let u = null, c = !1;
    const h = async () => {
      c = !0, i((s) => {
        u = s, n();
      }), await f;
    };
    try {
      await e(t, r, h), c ? (await f, u(null)) : o(null);
    } catch (s) {
      u ? u(s) : o(s);
    }
  };
}
Ro.createAsyncMiddleware = n2;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.createScaffoldMiddleware = void 0;
function i2(e) {
  return (t, r, i, o) => {
    const n = e[t.method];
    return n === void 0 ? i() : typeof n == "function" ? n(t, r, i, o) : (r.result = n, o());
  };
}
Bo.createScaffoldMiddleware = i2;
var ga = {}, Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
const a2 = Di;
function L0(e, t, r) {
  try {
    Reflect.apply(e, t, r);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function o2(e) {
  const t = e.length, r = new Array(t);
  for (let i = 0; i < t; i += 1)
    r[i] = e[i];
  return r;
}
class f2 extends a2.EventEmitter {
  emit(t, ...r) {
    let i = t === "error";
    const o = this._events;
    if (o !== void 0)
      i = i && o.error === void 0;
    else if (!i)
      return !1;
    if (i) {
      let f;
      if (r.length > 0 && ([f] = r), f instanceof Error)
        throw f;
      const u = new Error(`Unhandled error.${f ? ` (${f.message})` : ""}`);
      throw u.context = f, u;
    }
    const n = o[t];
    if (n === void 0)
      return !1;
    if (typeof n == "function")
      L0(n, this, r);
    else {
      const f = n.length, u = o2(n);
      for (let c = 0; c < f; c += 1)
        L0(u[c], this, r);
    }
    return !0;
  }
}
Io.default = f2;
var s2 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.JsonRpcEngine = void 0;
const u2 = s2(Io), Tr = Wt;
class pn extends u2.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  handle(t, r) {
    if (r && typeof r != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? r ? this._handleBatch(t, r) : this._handleBatch(t) : r ? this._handle(t, r) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, r, i, o) => {
      try {
        const [n, f, u] = await pn._runAllMiddleware(t, r, this._middleware);
        return f ? (await pn._runReturnHandlers(u), o(n)) : i(async (c) => {
          try {
            await pn._runReturnHandlers(u);
          } catch (h) {
            return c(h);
          }
          return c();
        });
      } catch (n) {
        return o(n);
      }
    };
  }
  async _handleBatch(t, r) {
    try {
      const i = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return r ? r(null, i) : i;
    } catch (i) {
      if (r)
        return r(i);
      throw i;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((r) => {
      this._handle(t, (i, o) => {
        r(o);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, r) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const f = new Tr.EthereumRpcError(Tr.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof t}`, { request: t });
      return r(f, { id: void 0, jsonrpc: "2.0", error: f });
    }
    if (typeof t.method != "string") {
      const f = new Tr.EthereumRpcError(Tr.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof t.method}`, { request: t });
      return r(f, { id: t.id, jsonrpc: "2.0", error: f });
    }
    const i = Object.assign({}, t), o = {
      id: i.id,
      jsonrpc: i.jsonrpc
    };
    let n = null;
    try {
      await this._processRequest(i, o);
    } catch (f) {
      n = f;
    }
    return n && (delete o.result, o.error || (o.error = Tr.serializeError(n))), r(n, o);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, r) {
    const [i, o, n] = await pn._runAllMiddleware(t, r, this._middleware);
    if (pn._checkForCompletion(t, r, o), await pn._runReturnHandlers(n), i)
      throw i;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, r, i) {
    const o = [];
    let n = null, f = !1;
    for (const u of i)
      if ([n, f] = await pn._runMiddleware(t, r, u, o), f)
        break;
    return [n, f, o.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, r, i, o) {
    return new Promise((n) => {
      const f = (c) => {
        const h = c || r.error;
        h && (r.error = Tr.serializeError(h)), n([h, !0]);
      }, u = (c) => {
        r.error ? f(r.error) : (c && (typeof c != "function" && f(new Tr.EthereumRpcError(Tr.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof c}" for request:
${wf(t)}`, { request: t })), o.push(c)), n([null, !1]));
      };
      try {
        i(t, r, u, f);
      } catch (c) {
        f(c);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const r of t)
      await new Promise((i, o) => {
        r((n) => n ? o(n) : i());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, r, i) {
    if (!("result" in r) && !("error" in r))
      throw new Tr.EthereumRpcError(Tr.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${wf(t)}`, { request: t });
    if (!i)
      throw new Tr.EthereumRpcError(Tr.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${wf(t)}`, { request: t });
  }
}
ga.JsonRpcEngine = pn;
function wf(e) {
  return JSON.stringify(e, null, 2);
}
var To = {};
Object.defineProperty(To, "__esModule", { value: !0 });
To.mergeMiddleware = void 0;
const c2 = ga;
function h2(e) {
  const t = new c2.JsonRpcEngine();
  return e.forEach((r) => t.push(r)), t.asMiddleware();
}
To.mergeMiddleware = h2;
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, o, n, f) {
    f === void 0 && (f = n), Object.defineProperty(i, f, { enumerable: !0, get: function() {
      return o[n];
    } });
  } : function(i, o, n, f) {
    f === void 0 && (f = n), i[f] = o[n];
  }), r = Ze && Ze.__exportStar || function(i, o) {
    for (var n in i)
      n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, i, n);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Mo, e), r(Ro, e), r(Bo, e), r(ya, e), r(ga, e), r(To, e);
})(Br);
const l2 = (e, t, r = !0) => (i, o) => {
  i || o.error ? t(i || o.error) : !r || Array.isArray(o) ? e(o) : e(o.result);
}, yh = (e) => !!e && typeof e == "string" && e.startsWith("0x"), Eo = class Eo extends $v {
  constructor({
    logger: t = console,
    maxEventListeners: r = 100,
    rpcMiddleware: i = []
  } = {}) {
    super(), this.uuid = "wepinprovider", this.name = "Wepin", this._log = t, this.setMaxListeners(r), this._state = {
      ...Eo._defaultState
    }, this.selectedAddress = null, this.chainId = null, this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const o = new Br.JsonRpcEngine();
    i.forEach((n) => o.push(n)), this._rpcEngine = o;
  }
  async request(t) {
    if (!t || typeof t != "object" || Array.isArray(t))
      throw Wt.ethErrors.rpc.invalidRequest({
        message: "Invalid request arguments",
        data: t
      });
    this._log.debug("[RPC Request]: requesting args", t);
    const { method: r, params: i, id: o = (/* @__PURE__ */ new Date()).getTime() } = t;
    if (typeof r != "string" || r.length === 0)
      throw Wt.ethErrors.rpc.invalidRequest({
        message: "Invalid request methods",
        data: t
      });
    if (i !== void 0 && !Array.isArray(i) && (typeof i != "object" || i === null))
      throw Wt.ethErrors.rpc.invalidRequest({
        message: "Invalid request params",
        data: t
      });
    return new Promise((n, f) => {
      this._rpcRequest(
        { method: r, params: i, id: o },
        l2(n, f)
      );
    });
  }
  /**
   * Initialize provider
   *
   * @param initialState
   */
  _initializeState(t) {
    if (this._state.initialized === !0)
      throw new Error("Provider already initialized.");
    if (t) {
      const { accounts: r, chainId: i, networkVersion: o } = t;
      this._handleConnect(i), this._handleChainChanged({ chainId: i, networkVersion: o }), this._handleAccountsChanged(r);
    }
    this._state.initialized = !0, this.emit("_initialized");
  }
  _rpcRequest(t, r) {
    let i = r;
    return Array.isArray(t) ? this._rpcEngine.handle(t, i) : (t.jsonrpc || (t.jsonrpc = "2.0"), (t.method === "eth_accounts" || t.method === "klay_accounts" || t.method === "eth_requestAccounts" || t.method === "klay_requestAccounts") && (i = (o, n) => {
      this._log.debug("_rpcRequest to handler account changes", o, n), this._handleAccountsChanged(n.result || []), r(o, n);
    }), t.method === "wallet_switchEthereumChain" && (i = (o, n) => {
      var f;
      this._log.debug("_rpcRequest to handler chain changes", o, n), (f = n.result) != null && f.chainId && this._handleChainChanged({ chainId: n.result.chainId }), r(o, n);
    }), this._rpcEngine.handle(t, i));
  }
  _handleConnect(t) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", { chainId: t }));
  }
  _handleDisconnect(t, r) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !t) {
      this._state.isConnected = !1;
      let i;
      t ? (i = new Wt.EthereumRpcError(
        1013,
        // Try again later
        r || "Provider diconnected"
      ), this._log.debug(i)) : (i = new Wt.EthereumRpcError(
        1011,
        // Internal error
        r || "Provider permenantly disconnected"
      ), this._log.error(i), this.chainId = null, this._state.accounts = null, this.selectedAddress = null, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", i);
    }
  }
  _handleChainChanged({
    chainId: t
  } = {}) {
    if (!yh(t)) {
      this._log.error("Invalid network params", { chainId: t });
      return;
    }
    this._handleConnect(t), t !== this.chainId && (this.chainId = t, this._state.initialized && this.emit("chainChanged", this.chainId));
  }
  _handleAccountsChanged(t) {
    let r = t;
    Array.isArray(t) || (this._log.error(
      "Received invalid accounts parameter. Please report this bug.",
      t
    ), r = []);
    for (const i of t)
      if (typeof i != "string") {
        this._log.error(
          "Received non-string account. Please report this bug.",
          t
        ), r = [];
        break;
      }
    Qm(this._state.accounts, r) || (this._state.accounts = r, this.selectedAddress !== r[0] && (this.selectedAddress = r[0] || null), this._state.initialized && this.emit("accountsChanged", r));
  }
};
Eo._defaultState = {
  accounts: null,
  isConnected: !1,
  initialized: !1,
  isPermanentlyDisconnected: !1
};
let ho = Eo;
const Wc = ({ wepin: e, network: t }) => (r, i, o, n) => {
  var s;
  if (!e._isInitialized) {
    n(Wt.ethErrors.provider.unauthorized());
    return;
  }
  let f = !1;
  const u = Array.isArray(r.params) ? r.params[0] : r.params;
  Object.values(u).forEach((p) => {
    p && !p.startsWith("0x") && (console.error(`${p} is not start with '0x'`), n(Wt.ethErrors.rpc.invalidParams()), f = !0);
  });
  const c = r.params[0].from;
  if (((s = jt.getLocalStorage(
    Cn + e.wepinAppId
  )) == null ? void 0 : s.selectedAddress) !== c) {
    n(Wt.ethErrors.provider.unauthorized());
    return;
  }
  if (!f) {
    const p = {
      account: {
        address: r.params[0].from,
        network: t
      },
      ...r.params[0]
    };
    Gi({
      wepin: e,
      network: t,
      req: r,
      res: i,
      next: o,
      end: n,
      command: "sign_transaction",
      parameter: p
    });
  }
}, Kc = ({ wepin: e, network: t }) => (r, i, o, n) => {
  var s;
  if (!e._isInitialized) {
    n(Wt.ethErrors.provider.unauthorized());
    return;
  }
  const f = Array.isArray(r.params) ? r.params[0] : r.params;
  let u = !1;
  Object.values(f).forEach((p) => {
    p && !p.startsWith("0x") && (console.error(`${p} is not start with '0x'`), n(Wt.ethErrors.rpc.invalidParams()), u = !0);
  });
  const c = r.params[0].from;
  if (((s = jt.getLocalStorage(
    Cn + e.wepinAppId
  )) == null ? void 0 : s.selectedAddress) !== c) {
    n(Wt.ethErrors.provider.unauthorized());
    return;
  }
  u || Gi({
    wepin: e,
    network: t,
    req: r,
    res: i,
    next: o,
    end: n,
    command: "send_transaction",
    parameter: {
      account: {
        address: c,
        network: t
      },
      ...r.params[0]
    }
  });
}, yn = ({
  wepin: e,
  network: t,
  version: r
}) => (i, o, n, f) => {
  var p;
  if (!e._isInitialized) {
    f(Wt.ethErrors.provider.unauthorized());
    return;
  }
  if (i.params.length !== 2) {
    f(Wt.ethErrors.rpc.invalidParams());
    return;
  }
  const [u, c] = i.params;
  if (((p = jt.getLocalStorage(
    Cn + e.wepinAppId
  )) == null ? void 0 : p.selectedAddress) !== u) {
    f(Wt.ethErrors.provider.unauthorized());
    return;
  }
  Gi({
    wepin: e,
    network: t,
    req: i,
    res: o,
    next: n,
    end: f,
    command: "sign_typed_data",
    parameter: {
      account: {
        network: t,
        address: u
      },
      data: c,
      version: r
    }
  });
}, ia = ({
  wepin: e,
  network: t,
  isPersonal: r
}) => (i, o, n, f) => {
  var m;
  if (!e._isInitialized) {
    f(Wt.ethErrors.provider.unauthorized());
    return;
  }
  if (i.params.length !== 2) {
    f(Wt.ethErrors.rpc.invalidParams());
    return;
  }
  const [u, c] = i.params, [h, s] = r ? [c, u] : [u, c];
  if (((m = jt.getLocalStorage(
    Cn + e.wepinAppId
  )) == null ? void 0 : m.selectedAddress) !== h) {
    f(Wt.ethErrors.provider.unauthorized());
    return;
  }
  Gi({
    wepin: e,
    network: t,
    req: i,
    res: o,
    next: n,
    end: f,
    command: "sign",
    parameter: {
      account: {
        address: h,
        network: t
      },
      data: s
    }
  });
}, ln = {
  Gateway: "https://gateway.wepin.io"
}, gh = (e) => {
  switch (e) {
    case "ethereum":
      return {
        rpcUrl: ln.Gateway + "/alchemy/eth",
        chainId: "0x1"
      };
    case "evmeth-goerli":
      return {
        rpcUrl: ln.Gateway + "/infura/goerli",
        chainId: "0x5"
      };
    case "klaytn":
      return {
        rpcUrl: ln.Gateway + "/klaytn/mainnet",
        chainId: "0x2019"
      };
    case "klaytn-testnet":
      return {
        rpcUrl: ln.Gateway + "/klaytn/testnet",
        chainId: "0x3e9"
      };
    case "evmsongbird":
      return {
        rpcUrl: ln.Gateway + "/songbird/api-portal/mainnet",
        chainId: "0x13"
      };
    case "evmpolygon":
      return {
        rpcUrl: ln.Gateway + "/matic/alchemy/mainnet",
        chainId: "0x89"
      };
    case "evmpolygon-testnet":
      return {
        rpcUrl: ln.Gateway + "/matic/testnet",
        chainId: "0x13881"
      };
    case "evmtime-elizabeth":
      return {
        rpcUrl: ln.Gateway + "/timenetwork/testnet",
        chainId: "0xaab"
      };
    case "evmeth sepolia":
      return {
        rpcUrl: ln.Gateway + "/sepolia/alchemy/testnet",
        chainId: "0xaa36a7"
      };
    default:
      throw new Error(
        `There is No network info about provided network : ${e}`
      );
  }
}, mh = (e) => {
  if (!yh(e))
    throw new Error(`Invalid chain ID: ${e}`);
  return {
    "0x1": "ethereum",
    "0x5": "evmeth-goerli",
    "0x13": "evmsongbird",
    "0x89": "evmpolygon",
    "0x3e9": "klaytn-testnet",
    "0x2019": "klaytn",
    "0x13881": "evmpolygon-testnet",
    "0xaab": "evmtime-elizabeth",
    //'evmtimenetwork-testnet', //'evmanttime-testnet', //
    "0xaa36a7": "evmeth sepolia"
  }[e];
}, Kv = ({ wepin: e, network: t }) => (r, i, o, n) => {
  if (!e._isInitialized) {
    n(Wt.ethErrors.provider.unauthorized());
    return;
  }
  const f = Array.isArray(r.params) ? r.params[0] : r.params;
  if (!(f != null && f.chainId) || !(f != null && f.chainId.startsWith("0x"))) {
    n(Wt.ethErrors.rpc.invalidParams());
    return;
  }
  if (!yh(f.chainId))
    return n(Wt.ethErrors.rpc.invalidParams());
  const u = {
    account: {
      network: t
    },
    toNetwork: mh(f.chainId),
    ...r.params[0]
  };
  Gi({
    wepin: e,
    network: t,
    req: r,
    res: i,
    next: o,
    end: n,
    command: "wallet_switchEthereumChain",
    parameter: u
  });
}, d2 = ({
  wepin: e,
  network: t
}) => Br.createScaffoldMiddleware({
  //for web3, ethers
  eth_requestAccounts: _i({ wepin: e, network: t }),
  eth_accounts: _i({ wepin: e, network: t }),
  eth_signTransaction: Wc({ wepin: e, network: t }),
  eth_sendTransaction: Kc({ wepin: e, network: t }),
  eth_signTypedData_v1: yn({ wepin: e, network: t, version: "V1" }),
  eth_signTypedData_v3: yn({ wepin: e, network: t, version: "V3" }),
  eth_signTypedData_v4: yn({ wepin: e, network: t, version: "V4" }),
  eth_sign: ia({ wepin: e, network: t, isPersonal: !1 }),
  //for caver
  klay_requestAccounts: _i({ wepin: e, network: t }),
  klay_accounts: _i({ wepin: e, network: t }),
  klay_signTransaction: Wc({ wepin: e, network: t }),
  klay_sendTransaction: Kc({ wepin: e, network: t }),
  klay_signTypedData_v1: yn({ wepin: e, network: t, version: "V1" }),
  klay_signTypedData_v3: yn({ wepin: e, network: t, version: "V3" }),
  klay_signTypedData_v4: yn({ wepin: e, network: t, version: "V4" }),
  klay_sign: ia({ wepin: e, network: t, isPersonal: !1 }),
  personal_sign: ia({ wepin: e, network: t, isPersonal: !0 }),
  wallet_switchEthereumChain: Kv({ wepin: e, network: t })
});
var wh = {}, Oo = {}, ji = {}, Zv = {}, hr = {};
class Gv extends TypeError {
  constructor(t, r) {
    let i;
    const { message: o, explanation: n, ...f } = t, { path: u } = t, c = u.length === 0 ? o : `At path: ${u.join(".")} -- ${o}`;
    super(n ?? c), n != null && (this.cause = c), Object.assign(this, f), this.name = this.constructor.name, this.failures = () => i ?? (i = [t, ...r()]);
  }
}
function p2(e) {
  return Fr(e) && typeof e[Symbol.iterator] == "function";
}
function Fr(e) {
  return typeof e == "object" && e != null;
}
function k0(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function ir(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function v2(e) {
  const { done: t, value: r } = e.next();
  return t ? void 0 : r;
}
function b2(e, t, r, i) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: o, branch: n } = t, { type: f } = r, { refinement: u, message: c = `Expected a value of type \`${f}\`${u ? ` with refinement \`${u}\`` : ""}, but received: \`${ir(i)}\`` } = e;
  return {
    value: i,
    type: f,
    refinement: u,
    key: o[o.length - 1],
    path: o,
    branch: n,
    ...e,
    message: c
  };
}
function* Zc(e, t, r, i) {
  p2(e) || (e = [e]);
  for (const o of e) {
    const n = b2(o, t, r, i);
    n && (yield n);
  }
}
function* _h(e, t, r = {}) {
  const { path: i = [], branch: o = [e], coerce: n = !1, mask: f = !1 } = r, u = { path: i, branch: o };
  if (n && (e = t.coercer(e, u), f && t.type !== "type" && Fr(t.schema) && Fr(e) && !Array.isArray(e)))
    for (const h in e)
      t.schema[h] === void 0 && delete e[h];
  let c = "valid";
  for (const h of t.validator(e, u))
    h.explanation = r.message, c = "not_valid", yield [h, void 0];
  for (let [h, s, p] of t.entries(e, u)) {
    const v = _h(s, p, {
      path: h === void 0 ? i : [...i, h],
      branch: h === void 0 ? o : [...o, s],
      coerce: n,
      mask: f,
      message: r.message
    });
    for (const m of v)
      m[0] ? (c = m[0].refinement != null ? "not_refined" : "not_valid", yield [m[0], void 0]) : n && (s = m[1], h === void 0 ? e = s : e instanceof Map ? e.set(h, s) : e instanceof Set ? e.add(s) : Fr(e) && (s !== void 0 || h in e) && (e[h] = s));
  }
  if (c !== "not_valid")
    for (const h of t.refiner(e, u))
      h.explanation = r.message, c = "not_refined", yield [h, void 0];
  c === "valid" && (yield [void 0, e]);
}
class Qt {
  constructor(t) {
    const { type: r, schema: i, validator: o, refiner: n, coercer: f = (c) => c, entries: u = function* () {
    } } = t;
    this.type = r, this.schema = i, this.entries = u, this.coercer = f, o ? this.validator = (c, h) => {
      const s = o(c, h);
      return Zc(s, h, this, c);
    } : this.validator = () => [], n ? this.refiner = (c, h) => {
      const s = n(c, h);
      return Zc(s, h, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, r) {
    return Jv(t, this, r);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, r) {
    return Xv(t, this, r);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return xh(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, r) {
    return Yv(t, this, r);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, r = {}) {
    return Ui(t, this, r);
  }
}
function Jv(e, t, r) {
  const i = Ui(e, t, { message: r });
  if (i[0])
    throw i[0];
}
function Xv(e, t, r) {
  const i = Ui(e, t, { coerce: !0, message: r });
  if (i[0])
    throw i[0];
  return i[1];
}
function Yv(e, t, r) {
  const i = Ui(e, t, { coerce: !0, mask: !0, message: r });
  if (i[0])
    throw i[0];
  return i[1];
}
function xh(e, t) {
  return !Ui(e, t)[0];
}
function Ui(e, t, r = {}) {
  const i = _h(e, t, r), o = v2(i);
  return o[0] ? [new Gv(o[0], function* () {
    for (const f of i)
      f[0] && (yield f[0]);
  }), void 0] : [void 0, o[1]];
}
function y2(...e) {
  const t = e[0].type === "type", r = e.map((o) => o.schema), i = Object.assign({}, ...r);
  return t ? Sh(i) : ma(i);
}
function _r(e, t) {
  return new Qt({ type: e, schema: null, validator: t });
}
function g2(e, t) {
  return new Qt({
    ...e,
    refiner: (r, i) => r === void 0 || e.refiner(r, i),
    validator(r, i) {
      return r === void 0 ? !0 : (t(r, i), e.validator(r, i));
    }
  });
}
function m2(e) {
  return new Qt({
    type: "dynamic",
    schema: null,
    *entries(t, r) {
      yield* e(t, r).entries(t, r);
    },
    validator(t, r) {
      return e(t, r).validator(t, r);
    },
    coercer(t, r) {
      return e(t, r).coercer(t, r);
    },
    refiner(t, r) {
      return e(t, r).refiner(t, r);
    }
  });
}
function w2(e) {
  let t;
  return new Qt({
    type: "lazy",
    schema: null,
    *entries(r, i) {
      t ?? (t = e()), yield* t.entries(r, i);
    },
    validator(r, i) {
      return t ?? (t = e()), t.validator(r, i);
    },
    coercer(r, i) {
      return t ?? (t = e()), t.coercer(r, i);
    },
    refiner(r, i) {
      return t ?? (t = e()), t.refiner(r, i);
    }
  });
}
function _2(e, t) {
  const { schema: r } = e, i = { ...r };
  for (const o of t)
    delete i[o];
  switch (e.type) {
    case "type":
      return Sh(i);
    default:
      return ma(i);
  }
}
function x2(e) {
  const t = e instanceof Qt ? { ...e.schema } : { ...e };
  for (const r in t)
    t[r] = Qv(t[r]);
  return ma(t);
}
function E2(e, t) {
  const { schema: r } = e, i = {};
  for (const o of t)
    i[o] = r[o];
  return ma(i);
}
function S2(e, t) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), _r(e, t);
}
function A2() {
  return _r("any", () => !0);
}
function M2(e) {
  return new Qt({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [r, i] of t.entries())
          yield [r, i, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${ir(t)}`;
    }
  });
}
function R2() {
  return _r("bigint", (e) => typeof e == "bigint");
}
function B2() {
  return _r("boolean", (e) => typeof e == "boolean");
}
function I2() {
  return _r("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${ir(e)}`);
}
function T2(e) {
  const t = {}, r = e.map((i) => ir(i)).join();
  for (const i of e)
    t[i] = i;
  return new Qt({
    type: "enums",
    schema: t,
    validator(i) {
      return e.includes(i) || `Expected one of \`${r}\`, but received: ${ir(i)}`;
    }
  });
}
function O2() {
  return _r("func", (e) => typeof e == "function" || `Expected a function, but received: ${ir(e)}`);
}
function P2(e) {
  return _r("instance", (t) => t instanceof e || `Expected a \`${e.name}\` instance, but received: ${ir(t)}`);
}
function C2() {
  return _r("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${ir(e)}`);
}
function N2(e) {
  return new Qt({
    type: "intersection",
    schema: null,
    *entries(t, r) {
      for (const i of e)
        yield* i.entries(t, r);
    },
    *validator(t, r) {
      for (const i of e)
        yield* i.validator(t, r);
    },
    *refiner(t, r) {
      for (const i of e)
        yield* i.refiner(t, r);
    }
  });
}
function L2(e) {
  const t = ir(e), r = typeof e;
  return new Qt({
    type: "literal",
    schema: r === "string" || r === "number" || r === "boolean" ? e : null,
    validator(i) {
      return i === e || `Expected the literal \`${t}\`, but received: ${ir(i)}`;
    }
  });
}
function k2(e, t) {
  return new Qt({
    type: "map",
    schema: null,
    *entries(r) {
      if (e && t && r instanceof Map)
        for (const [i, o] of r.entries())
          yield [i, i, e], yield [i, o, t];
    },
    coercer(r) {
      return r instanceof Map ? new Map(r) : r;
    },
    validator(r) {
      return r instanceof Map || `Expected a \`Map\` object, but received: ${ir(r)}`;
    }
  });
}
function Eh() {
  return _r("never", () => !1);
}
function q2(e) {
  return new Qt({
    ...e,
    validator: (t, r) => t === null || e.validator(t, r),
    refiner: (t, r) => t === null || e.refiner(t, r)
  });
}
function $2() {
  return _r("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${ir(e)}`);
}
function ma(e) {
  const t = e ? Object.keys(e) : [], r = Eh();
  return new Qt({
    type: "object",
    schema: e || null,
    *entries(i) {
      if (e && Fr(i)) {
        const o = new Set(Object.keys(i));
        for (const n of t)
          o.delete(n), yield [n, i[n], e[n]];
        for (const n of o)
          yield [n, i[n], r];
      }
    },
    validator(i) {
      return Fr(i) || `Expected an object, but received: ${ir(i)}`;
    },
    coercer(i) {
      return Fr(i) ? { ...i } : i;
    }
  });
}
function Qv(e) {
  return new Qt({
    ...e,
    validator: (t, r) => t === void 0 || e.validator(t, r),
    refiner: (t, r) => t === void 0 || e.refiner(t, r)
  });
}
function D2(e, t) {
  return new Qt({
    type: "record",
    schema: null,
    *entries(r) {
      if (Fr(r))
        for (const i in r) {
          const o = r[i];
          yield [i, i, e], yield [i, o, t];
        }
    },
    validator(r) {
      return Fr(r) || `Expected an object, but received: ${ir(r)}`;
    }
  });
}
function j2() {
  return _r("regexp", (e) => e instanceof RegExp);
}
function U2(e) {
  return new Qt({
    type: "set",
    schema: null,
    *entries(t) {
      if (e && t instanceof Set)
        for (const r of t)
          yield [r, r, e];
    },
    coercer(t) {
      return t instanceof Set ? new Set(t) : t;
    },
    validator(t) {
      return t instanceof Set || `Expected a \`Set\` object, but received: ${ir(t)}`;
    }
  });
}
function eb() {
  return _r("string", (e) => typeof e == "string" || `Expected a string, but received: ${ir(e)}`);
}
function F2(e) {
  const t = Eh();
  return new Qt({
    type: "tuple",
    schema: null,
    *entries(r) {
      if (Array.isArray(r)) {
        const i = Math.max(e.length, r.length);
        for (let o = 0; o < i; o++)
          yield [o, r[o], e[o] || t];
      }
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array, but received: ${ir(r)}`;
    }
  });
}
function Sh(e) {
  const t = Object.keys(e);
  return new Qt({
    type: "type",
    schema: e,
    *entries(r) {
      if (Fr(r))
        for (const i of t)
          yield [i, r[i], e[i]];
    },
    validator(r) {
      return Fr(r) || `Expected an object, but received: ${ir(r)}`;
    },
    coercer(r) {
      return Fr(r) ? { ...r } : r;
    }
  });
}
function H2(e) {
  const t = e.map((r) => r.type).join(" | ");
  return new Qt({
    type: "union",
    schema: null,
    coercer(r) {
      for (const i of e) {
        const [o, n] = i.validate(r, { coerce: !0 });
        if (!o)
          return n;
      }
      return r;
    },
    validator(r, i) {
      const o = [];
      for (const n of e) {
        const [...f] = _h(r, n, i), [u] = f;
        if (u[0])
          for (const [c] of f)
            c && o.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${ir(r)}`,
        ...o
      ];
    }
  });
}
function tb() {
  return _r("unknown", () => !0);
}
function Ah(e, t, r) {
  return new Qt({
    ...e,
    coercer: (i, o) => xh(i, t) ? e.coercer(r(i, o), o) : e.coercer(i, o)
  });
}
function z2(e, t, r = {}) {
  return Ah(e, tb(), (i) => {
    const o = typeof t == "function" ? t() : t;
    if (i === void 0)
      return o;
    if (!r.strict && k0(i) && k0(o)) {
      const n = { ...i };
      let f = !1;
      for (const u in o)
        n[u] === void 0 && (n[u] = o[u], f = !0);
      if (f)
        return n;
    }
    return i;
  });
}
function V2(e) {
  return Ah(e, eb(), (t) => t.trim());
}
function W2(e) {
  return ii(e, "empty", (t) => {
    const r = rb(t);
    return r === 0 || `Expected an empty ${e.type} but received one with a size of \`${r}\``;
  });
}
function rb(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function K2(e, t, r = {}) {
  const { exclusive: i } = r;
  return ii(e, "max", (o) => i ? o < t : o <= t || `Expected a ${e.type} less than ${i ? "" : "or equal to "}${t} but received \`${o}\``);
}
function Z2(e, t, r = {}) {
  const { exclusive: i } = r;
  return ii(e, "min", (o) => i ? o > t : o >= t || `Expected a ${e.type} greater than ${i ? "" : "or equal to "}${t} but received \`${o}\``);
}
function G2(e) {
  return ii(e, "nonempty", (t) => rb(t) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function J2(e, t) {
  return ii(e, "pattern", (r) => t.test(r) || `Expected a ${e.type} matching \`/${t.source}/\` but received "${r}"`);
}
function X2(e, t, r = t) {
  const i = `Expected a ${e.type}`, o = t === r ? `of \`${t}\`` : `between \`${t}\` and \`${r}\``;
  return ii(e, "size", (n) => {
    if (typeof n == "number" || n instanceof Date)
      return t <= n && n <= r || `${i} ${o} but received \`${n}\``;
    if (n instanceof Map || n instanceof Set) {
      const { size: f } = n;
      return t <= f && f <= r || `${i} with a size ${o} but received one with a size of \`${f}\``;
    } else {
      const { length: f } = n;
      return t <= f && f <= r || `${i} with a length ${o} but received one with a length of \`${f}\``;
    }
  });
}
function ii(e, t, r) {
  return new Qt({
    ...e,
    *refiner(i, o) {
      yield* e.refiner(i, o);
      const n = r(i, o), f = Zc(n, o, e, i);
      for (const u of f)
        yield { ...u, refinement: t };
    }
  });
}
const Y2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: Qt,
  StructError: Gv,
  any: A2,
  array: M2,
  assert: Jv,
  assign: y2,
  bigint: R2,
  boolean: B2,
  coerce: Ah,
  create: Xv,
  date: I2,
  defaulted: z2,
  define: _r,
  deprecated: g2,
  dynamic: m2,
  empty: W2,
  enums: T2,
  func: O2,
  instance: P2,
  integer: C2,
  intersection: N2,
  is: xh,
  lazy: w2,
  literal: L2,
  map: k2,
  mask: Yv,
  max: K2,
  min: Z2,
  never: Eh,
  nonempty: G2,
  nullable: q2,
  number: $2,
  object: ma,
  omit: _2,
  optional: Qv,
  partial: x2,
  pattern: J2,
  pick: E2,
  record: D2,
  refine: ii,
  regexp: j2,
  set: U2,
  size: X2,
  string: eb,
  struct: S2,
  trimmed: V2,
  tuple: F2,
  type: Sh,
  union: H2,
  unknown: tb,
  validate: Ui
}, Symbol.toStringTag, { value: "Module" })), ai = /* @__PURE__ */ Iv(Y2);
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.assertExhaustive = hr.assertStruct = hr.assert = hr.AssertionError = void 0;
const Q2 = ai;
function ew(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function tw(e) {
  var t, r;
  return typeof ((r = (t = e == null ? void 0 : e.prototype) === null || t === void 0 ? void 0 : t.constructor) === null || r === void 0 ? void 0 : r.name) == "string";
}
function rw(e) {
  const t = ew(e) ? e.message : String(e);
  return t.endsWith(".") ? t.slice(0, -1) : t;
}
function nb(e, t) {
  return tw(e) ? new e({
    message: t
  }) : e({
    message: t
  });
}
class Mh extends Error {
  constructor(t) {
    super(t.message), this.code = "ERR_ASSERTION";
  }
}
hr.AssertionError = Mh;
function nw(e, t = "Assertion failed.", r = Mh) {
  if (!e)
    throw t instanceof Error ? t : nb(r, t);
}
hr.assert = nw;
function iw(e, t, r = "Assertion failed", i = Mh) {
  try {
    (0, Q2.assert)(e, t);
  } catch (o) {
    throw nb(i, `${r}: ${rw(o)}.`);
  }
}
hr.assertStruct = iw;
function aw(e) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
hr.assertExhaustive = aw;
var wa = {};
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.base64 = void 0;
const ow = ai, fw = hr, sw = (e, t = {}) => {
  var r, i;
  const o = (r = t.paddingRequired) !== null && r !== void 0 ? r : !1, n = (i = t.characterSet) !== null && i !== void 0 ? i : "base64";
  let f;
  n === "base64" ? f = String.raw`[A-Za-z0-9+\/]` : ((0, fw.assert)(n === "base64url"), f = String.raw`[-_A-Za-z0-9]`);
  let u;
  return o ? u = new RegExp(`^(?:${f}{4})*(?:${f}{3}=|${f}{2}==)?$`, "u") : u = new RegExp(`^(?:${f}{4})*(?:${f}{2,3}|${f}{3}=|${f}{2}==)?$`, "u"), (0, ow.pattern)(e, u);
};
wa.base64 = sw;
var Le = {}, Po = {};
Po.byteLength = hw;
Po.toByteArray = dw;
Po.fromByteArray = bw;
var an = [], kr = [], uw = typeof Uint8Array < "u" ? Uint8Array : Array, _f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var si = 0, cw = _f.length; si < cw; ++si)
  an[si] = _f[si], kr[_f.charCodeAt(si)] = si;
kr[45] = 62;
kr[95] = 63;
function ib(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var i = r === t ? 0 : 4 - r % 4;
  return [r, i];
}
function hw(e) {
  var t = ib(e), r = t[0], i = t[1];
  return (r + i) * 3 / 4 - i;
}
function lw(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function dw(e) {
  var t, r = ib(e), i = r[0], o = r[1], n = new uw(lw(e, i, o)), f = 0, u = o > 0 ? i - 4 : i, c;
  for (c = 0; c < u; c += 4)
    t = kr[e.charCodeAt(c)] << 18 | kr[e.charCodeAt(c + 1)] << 12 | kr[e.charCodeAt(c + 2)] << 6 | kr[e.charCodeAt(c + 3)], n[f++] = t >> 16 & 255, n[f++] = t >> 8 & 255, n[f++] = t & 255;
  return o === 2 && (t = kr[e.charCodeAt(c)] << 2 | kr[e.charCodeAt(c + 1)] >> 4, n[f++] = t & 255), o === 1 && (t = kr[e.charCodeAt(c)] << 10 | kr[e.charCodeAt(c + 1)] << 4 | kr[e.charCodeAt(c + 2)] >> 2, n[f++] = t >> 8 & 255, n[f++] = t & 255), n;
}
function pw(e) {
  return an[e >> 18 & 63] + an[e >> 12 & 63] + an[e >> 6 & 63] + an[e & 63];
}
function vw(e, t, r) {
  for (var i, o = [], n = t; n < r; n += 3)
    i = (e[n] << 16 & 16711680) + (e[n + 1] << 8 & 65280) + (e[n + 2] & 255), o.push(pw(i));
  return o.join("");
}
function bw(e) {
  for (var t, r = e.length, i = r % 3, o = [], n = 16383, f = 0, u = r - i; f < u; f += n)
    o.push(vw(e, f, f + n > u ? u : f + n));
  return i === 1 ? (t = e[r - 1], o.push(
    an[t >> 2] + an[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    an[t >> 10] + an[t >> 4 & 63] + an[t << 2 & 63] + "="
  )), o.join("");
}
var Rh = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Rh.read = function(e, t, r, i, o) {
  var n, f, u = o * 8 - i - 1, c = (1 << u) - 1, h = c >> 1, s = -7, p = r ? o - 1 : 0, v = r ? -1 : 1, m = e[t + p];
  for (p += v, n = m & (1 << -s) - 1, m >>= -s, s += u; s > 0; n = n * 256 + e[t + p], p += v, s -= 8)
    ;
  for (f = n & (1 << -s) - 1, n >>= -s, s += i; s > 0; f = f * 256 + e[t + p], p += v, s -= 8)
    ;
  if (n === 0)
    n = 1 - h;
  else {
    if (n === c)
      return f ? NaN : (m ? -1 : 1) * (1 / 0);
    f = f + Math.pow(2, i), n = n - h;
  }
  return (m ? -1 : 1) * f * Math.pow(2, n - i);
};
Rh.write = function(e, t, r, i, o, n) {
  var f, u, c, h = n * 8 - o - 1, s = (1 << h) - 1, p = s >> 1, v = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = i ? 0 : n - 1, E = i ? 1 : -1, M = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, f = s) : (f = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -f)) < 1 && (f--, c *= 2), f + p >= 1 ? t += v / c : t += v * Math.pow(2, 1 - p), t * c >= 2 && (f++, c /= 2), f + p >= s ? (u = 0, f = s) : f + p >= 1 ? (u = (t * c - 1) * Math.pow(2, o), f = f + p) : (u = t * Math.pow(2, p - 1) * Math.pow(2, o), f = 0)); o >= 8; e[r + m] = u & 255, m += E, u /= 256, o -= 8)
    ;
  for (f = f << o | u, h += o; h > 0; e[r + m] = f & 255, m += E, f /= 256, h -= 8)
    ;
  e[r + m - E] |= M * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = Po, r = Rh, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = T, e.INSPECT_MAX_BYTES = 50;
  var o = 2147483647;
  e.kMaxLength = o, u.TYPED_ARRAY_SUPPORT = n(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function n() {
    try {
      var te = new Uint8Array(1), C = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(C, Uint8Array.prototype), Object.setPrototypeOf(te, C), te.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(te) {
    if (te > o)
      throw new RangeError('The value "' + te + '" is invalid for option "size"');
    var C = new Uint8Array(te);
    return Object.setPrototypeOf(C, u.prototype), C;
  }
  function u(te, C, L) {
    if (typeof te == "number") {
      if (typeof C == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(te);
    }
    return c(te, C, L);
  }
  u.poolSize = 8192;
  function c(te, C, L) {
    if (typeof te == "string")
      return v(te, C);
    if (ArrayBuffer.isView(te))
      return E(te);
    if (te == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof te
      );
    if (ce(te, ArrayBuffer) || te && ce(te.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ce(te, SharedArrayBuffer) || te && ce(te.buffer, SharedArrayBuffer)))
      return M(te, C, L);
    if (typeof te == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var G = te.valueOf && te.valueOf();
    if (G != null && G !== te)
      return u.from(G, C, L);
    var de = I(te);
    if (de)
      return de;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof te[Symbol.toPrimitive] == "function")
      return u.from(
        te[Symbol.toPrimitive]("string"),
        C,
        L
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof te
    );
  }
  u.from = function(te, C, L) {
    return c(te, C, L);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function h(te) {
    if (typeof te != "number")
      throw new TypeError('"size" argument must be of type number');
    if (te < 0)
      throw new RangeError('The value "' + te + '" is invalid for option "size"');
  }
  function s(te, C, L) {
    return h(te), te <= 0 ? f(te) : C !== void 0 ? typeof L == "string" ? f(te).fill(C, L) : f(te).fill(C) : f(te);
  }
  u.alloc = function(te, C, L) {
    return s(te, C, L);
  };
  function p(te) {
    return h(te), f(te < 0 ? 0 : B(te) | 0);
  }
  u.allocUnsafe = function(te) {
    return p(te);
  }, u.allocUnsafeSlow = function(te) {
    return p(te);
  };
  function v(te, C) {
    if ((typeof C != "string" || C === "") && (C = "utf8"), !u.isEncoding(C))
      throw new TypeError("Unknown encoding: " + C);
    var L = k(te, C) | 0, G = f(L), de = G.write(te, C);
    return de !== L && (G = G.slice(0, de)), G;
  }
  function m(te) {
    for (var C = te.length < 0 ? 0 : B(te.length) | 0, L = f(C), G = 0; G < C; G += 1)
      L[G] = te[G] & 255;
    return L;
  }
  function E(te) {
    if (ce(te, Uint8Array)) {
      var C = new Uint8Array(te);
      return M(C.buffer, C.byteOffset, C.byteLength);
    }
    return m(te);
  }
  function M(te, C, L) {
    if (C < 0 || te.byteLength < C)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (te.byteLength < C + (L || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var G;
    return C === void 0 && L === void 0 ? G = new Uint8Array(te) : L === void 0 ? G = new Uint8Array(te, C) : G = new Uint8Array(te, C, L), Object.setPrototypeOf(G, u.prototype), G;
  }
  function I(te) {
    if (u.isBuffer(te)) {
      var C = B(te.length) | 0, L = f(C);
      return L.length === 0 || te.copy(L, 0, 0, C), L;
    }
    if (te.length !== void 0)
      return typeof te.length != "number" || ve(te.length) ? f(0) : m(te);
    if (te.type === "Buffer" && Array.isArray(te.data))
      return m(te.data);
  }
  function B(te) {
    if (te >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return te | 0;
  }
  function T(te) {
    return +te != te && (te = 0), u.alloc(+te);
  }
  u.isBuffer = function(C) {
    return C != null && C._isBuffer === !0 && C !== u.prototype;
  }, u.compare = function(C, L) {
    if (ce(C, Uint8Array) && (C = u.from(C, C.offset, C.byteLength)), ce(L, Uint8Array) && (L = u.from(L, L.offset, L.byteLength)), !u.isBuffer(C) || !u.isBuffer(L))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (C === L)
      return 0;
    for (var G = C.length, de = L.length, me = 0, Te = Math.min(G, de); me < Te; ++me)
      if (C[me] !== L[me]) {
        G = C[me], de = L[me];
        break;
      }
    return G < de ? -1 : de < G ? 1 : 0;
  }, u.isEncoding = function(C) {
    switch (String(C).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(C, L) {
    if (!Array.isArray(C))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (C.length === 0)
      return u.alloc(0);
    var G;
    if (L === void 0)
      for (L = 0, G = 0; G < C.length; ++G)
        L += C[G].length;
    var de = u.allocUnsafe(L), me = 0;
    for (G = 0; G < C.length; ++G) {
      var Te = C[G];
      if (ce(Te, Uint8Array))
        me + Te.length > de.length ? u.from(Te).copy(de, me) : Uint8Array.prototype.set.call(
          de,
          Te,
          me
        );
      else if (u.isBuffer(Te))
        Te.copy(de, me);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      me += Te.length;
    }
    return de;
  };
  function k(te, C) {
    if (u.isBuffer(te))
      return te.length;
    if (ArrayBuffer.isView(te) || ce(te, ArrayBuffer))
      return te.byteLength;
    if (typeof te != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof te
      );
    var L = te.length, G = arguments.length > 2 && arguments[2] === !0;
    if (!G && L === 0)
      return 0;
    for (var de = !1; ; )
      switch (C) {
        case "ascii":
        case "latin1":
        case "binary":
          return L;
        case "utf8":
        case "utf-8":
          return F(te).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L * 2;
        case "hex":
          return L >>> 1;
        case "base64":
          return Z(te).length;
        default:
          if (de)
            return G ? -1 : F(te).length;
          C = ("" + C).toLowerCase(), de = !0;
      }
  }
  u.byteLength = k;
  function N(te, C, L) {
    var G = !1;
    if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((L === void 0 || L > this.length) && (L = this.length), L <= 0) || (L >>>= 0, C >>>= 0, L <= C))
      return "";
    for (te || (te = "utf8"); ; )
      switch (te) {
        case "hex":
          return S(this, C, L);
        case "utf8":
        case "utf-8":
          return a(this, C, L);
        case "ascii":
          return x(this, C, L);
        case "latin1":
        case "binary":
          return A(this, C, L);
        case "base64":
          return b(this, C, L);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return y(this, C, L);
        default:
          if (G)
            throw new TypeError("Unknown encoding: " + te);
          te = (te + "").toLowerCase(), G = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function q(te, C, L) {
    var G = te[C];
    te[C] = te[L], te[L] = G;
  }
  u.prototype.swap16 = function() {
    var C = this.length;
    if (C % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var L = 0; L < C; L += 2)
      q(this, L, L + 1);
    return this;
  }, u.prototype.swap32 = function() {
    var C = this.length;
    if (C % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var L = 0; L < C; L += 4)
      q(this, L, L + 3), q(this, L + 1, L + 2);
    return this;
  }, u.prototype.swap64 = function() {
    var C = this.length;
    if (C % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var L = 0; L < C; L += 8)
      q(this, L, L + 7), q(this, L + 1, L + 6), q(this, L + 2, L + 5), q(this, L + 3, L + 4);
    return this;
  }, u.prototype.toString = function() {
    var C = this.length;
    return C === 0 ? "" : arguments.length === 0 ? a(this, 0, C) : N.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(C) {
    if (!u.isBuffer(C))
      throw new TypeError("Argument must be a Buffer");
    return this === C ? !0 : u.compare(this, C) === 0;
  }, u.prototype.inspect = function() {
    var C = "", L = e.INSPECT_MAX_BYTES;
    return C = this.toString("hex", 0, L).replace(/(.{2})/g, "$1 ").trim(), this.length > L && (C += " ... "), "<Buffer " + C + ">";
  }, i && (u.prototype[i] = u.prototype.inspect), u.prototype.compare = function(C, L, G, de, me) {
    if (ce(C, Uint8Array) && (C = u.from(C, C.offset, C.byteLength)), !u.isBuffer(C))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C
      );
    if (L === void 0 && (L = 0), G === void 0 && (G = C ? C.length : 0), de === void 0 && (de = 0), me === void 0 && (me = this.length), L < 0 || G > C.length || de < 0 || me > this.length)
      throw new RangeError("out of range index");
    if (de >= me && L >= G)
      return 0;
    if (de >= me)
      return -1;
    if (L >= G)
      return 1;
    if (L >>>= 0, G >>>= 0, de >>>= 0, me >>>= 0, this === C)
      return 0;
    for (var Te = me - de, He = G - L, H = Math.min(Te, He), se = this.slice(de, me), fe = C.slice(L, G), _e = 0; _e < H; ++_e)
      if (se[_e] !== fe[_e]) {
        Te = se[_e], He = fe[_e];
        break;
      }
    return Te < He ? -1 : He < Te ? 1 : 0;
  };
  function D(te, C, L, G, de) {
    if (te.length === 0)
      return -1;
    if (typeof L == "string" ? (G = L, L = 0) : L > 2147483647 ? L = 2147483647 : L < -2147483648 && (L = -2147483648), L = +L, ve(L) && (L = de ? 0 : te.length - 1), L < 0 && (L = te.length + L), L >= te.length) {
      if (de)
        return -1;
      L = te.length - 1;
    } else if (L < 0)
      if (de)
        L = 0;
      else
        return -1;
    if (typeof C == "string" && (C = u.from(C, G)), u.isBuffer(C))
      return C.length === 0 ? -1 : U(te, C, L, G, de);
    if (typeof C == "number")
      return C = C & 255, typeof Uint8Array.prototype.indexOf == "function" ? de ? Uint8Array.prototype.indexOf.call(te, C, L) : Uint8Array.prototype.lastIndexOf.call(te, C, L) : U(te, [C], L, G, de);
    throw new TypeError("val must be string, number or Buffer");
  }
  function U(te, C, L, G, de) {
    var me = 1, Te = te.length, He = C.length;
    if (G !== void 0 && (G = String(G).toLowerCase(), G === "ucs2" || G === "ucs-2" || G === "utf16le" || G === "utf-16le")) {
      if (te.length < 2 || C.length < 2)
        return -1;
      me = 2, Te /= 2, He /= 2, L /= 2;
    }
    function H(Ve, ke) {
      return me === 1 ? Ve[ke] : Ve.readUInt16BE(ke * me);
    }
    var se;
    if (de) {
      var fe = -1;
      for (se = L; se < Te; se++)
        if (H(te, se) === H(C, fe === -1 ? 0 : se - fe)) {
          if (fe === -1 && (fe = se), se - fe + 1 === He)
            return fe * me;
        } else
          fe !== -1 && (se -= se - fe), fe = -1;
    } else
      for (L + He > Te && (L = Te - He), se = L; se >= 0; se--) {
        for (var _e = !0, Ce = 0; Ce < He; Ce++)
          if (H(te, se + Ce) !== H(C, Ce)) {
            _e = !1;
            break;
          }
        if (_e)
          return se;
      }
    return -1;
  }
  u.prototype.includes = function(C, L, G) {
    return this.indexOf(C, L, G) !== -1;
  }, u.prototype.indexOf = function(C, L, G) {
    return D(this, C, L, G, !0);
  }, u.prototype.lastIndexOf = function(C, L, G) {
    return D(this, C, L, G, !1);
  };
  function z(te, C, L, G) {
    L = Number(L) || 0;
    var de = te.length - L;
    G ? (G = Number(G), G > de && (G = de)) : G = de;
    var me = C.length;
    G > me / 2 && (G = me / 2);
    for (var Te = 0; Te < G; ++Te) {
      var He = parseInt(C.substr(Te * 2, 2), 16);
      if (ve(He))
        return Te;
      te[L + Te] = He;
    }
    return Te;
  }
  function Y(te, C, L, G) {
    return K(F(C, te.length - L), te, L, G);
  }
  function ue(te, C, L, G) {
    return K(re(C), te, L, G);
  }
  function j(te, C, L, G) {
    return K(Z(C), te, L, G);
  }
  function g(te, C, L, G) {
    return K(he(C, te.length - L), te, L, G);
  }
  u.prototype.write = function(C, L, G, de) {
    if (L === void 0)
      de = "utf8", G = this.length, L = 0;
    else if (G === void 0 && typeof L == "string")
      de = L, G = this.length, L = 0;
    else if (isFinite(L))
      L = L >>> 0, isFinite(G) ? (G = G >>> 0, de === void 0 && (de = "utf8")) : (de = G, G = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var me = this.length - L;
    if ((G === void 0 || G > me) && (G = me), C.length > 0 && (G < 0 || L < 0) || L > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    de || (de = "utf8");
    for (var Te = !1; ; )
      switch (de) {
        case "hex":
          return z(this, C, L, G);
        case "utf8":
        case "utf-8":
          return Y(this, C, L, G);
        case "ascii":
        case "latin1":
        case "binary":
          return ue(this, C, L, G);
        case "base64":
          return j(this, C, L, G);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return g(this, C, L, G);
        default:
          if (Te)
            throw new TypeError("Unknown encoding: " + de);
          de = ("" + de).toLowerCase(), Te = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function b(te, C, L) {
    return C === 0 && L === te.length ? t.fromByteArray(te) : t.fromByteArray(te.slice(C, L));
  }
  function a(te, C, L) {
    L = Math.min(te.length, L);
    for (var G = [], de = C; de < L; ) {
      var me = te[de], Te = null, He = me > 239 ? 4 : me > 223 ? 3 : me > 191 ? 2 : 1;
      if (de + He <= L) {
        var H, se, fe, _e;
        switch (He) {
          case 1:
            me < 128 && (Te = me);
            break;
          case 2:
            H = te[de + 1], (H & 192) === 128 && (_e = (me & 31) << 6 | H & 63, _e > 127 && (Te = _e));
            break;
          case 3:
            H = te[de + 1], se = te[de + 2], (H & 192) === 128 && (se & 192) === 128 && (_e = (me & 15) << 12 | (H & 63) << 6 | se & 63, _e > 2047 && (_e < 55296 || _e > 57343) && (Te = _e));
            break;
          case 4:
            H = te[de + 1], se = te[de + 2], fe = te[de + 3], (H & 192) === 128 && (se & 192) === 128 && (fe & 192) === 128 && (_e = (me & 15) << 18 | (H & 63) << 12 | (se & 63) << 6 | fe & 63, _e > 65535 && _e < 1114112 && (Te = _e));
        }
      }
      Te === null ? (Te = 65533, He = 1) : Te > 65535 && (Te -= 65536, G.push(Te >>> 10 & 1023 | 55296), Te = 56320 | Te & 1023), G.push(Te), de += He;
    }
    return w(G);
  }
  var d = 4096;
  function w(te) {
    var C = te.length;
    if (C <= d)
      return String.fromCharCode.apply(String, te);
    for (var L = "", G = 0; G < C; )
      L += String.fromCharCode.apply(
        String,
        te.slice(G, G += d)
      );
    return L;
  }
  function x(te, C, L) {
    var G = "";
    L = Math.min(te.length, L);
    for (var de = C; de < L; ++de)
      G += String.fromCharCode(te[de] & 127);
    return G;
  }
  function A(te, C, L) {
    var G = "";
    L = Math.min(te.length, L);
    for (var de = C; de < L; ++de)
      G += String.fromCharCode(te[de]);
    return G;
  }
  function S(te, C, L) {
    var G = te.length;
    (!C || C < 0) && (C = 0), (!L || L < 0 || L > G) && (L = G);
    for (var de = "", me = C; me < L; ++me)
      de += Be[te[me]];
    return de;
  }
  function y(te, C, L) {
    for (var G = te.slice(C, L), de = "", me = 0; me < G.length - 1; me += 2)
      de += String.fromCharCode(G[me] + G[me + 1] * 256);
    return de;
  }
  u.prototype.slice = function(C, L) {
    var G = this.length;
    C = ~~C, L = L === void 0 ? G : ~~L, C < 0 ? (C += G, C < 0 && (C = 0)) : C > G && (C = G), L < 0 ? (L += G, L < 0 && (L = 0)) : L > G && (L = G), L < C && (L = C);
    var de = this.subarray(C, L);
    return Object.setPrototypeOf(de, u.prototype), de;
  };
  function _(te, C, L) {
    if (te % 1 !== 0 || te < 0)
      throw new RangeError("offset is not uint");
    if (te + C > L)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(C, L, G) {
    C = C >>> 0, L = L >>> 0, G || _(C, L, this.length);
    for (var de = this[C], me = 1, Te = 0; ++Te < L && (me *= 256); )
      de += this[C + Te] * me;
    return de;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(C, L, G) {
    C = C >>> 0, L = L >>> 0, G || _(C, L, this.length);
    for (var de = this[C + --L], me = 1; L > 0 && (me *= 256); )
      de += this[C + --L] * me;
    return de;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(C, L) {
    return C = C >>> 0, L || _(C, 1, this.length), this[C];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(C, L) {
    return C = C >>> 0, L || _(C, 2, this.length), this[C] | this[C + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(C, L) {
    return C = C >>> 0, L || _(C, 2, this.length), this[C] << 8 | this[C + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
  }, u.prototype.readIntLE = function(C, L, G) {
    C = C >>> 0, L = L >>> 0, G || _(C, L, this.length);
    for (var de = this[C], me = 1, Te = 0; ++Te < L && (me *= 256); )
      de += this[C + Te] * me;
    return me *= 128, de >= me && (de -= Math.pow(2, 8 * L)), de;
  }, u.prototype.readIntBE = function(C, L, G) {
    C = C >>> 0, L = L >>> 0, G || _(C, L, this.length);
    for (var de = L, me = 1, Te = this[C + --de]; de > 0 && (me *= 256); )
      Te += this[C + --de] * me;
    return me *= 128, Te >= me && (Te -= Math.pow(2, 8 * L)), Te;
  }, u.prototype.readInt8 = function(C, L) {
    return C = C >>> 0, L || _(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
  }, u.prototype.readInt16LE = function(C, L) {
    C = C >>> 0, L || _(C, 2, this.length);
    var G = this[C] | this[C + 1] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, u.prototype.readInt16BE = function(C, L) {
    C = C >>> 0, L || _(C, 2, this.length);
    var G = this[C + 1] | this[C] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, u.prototype.readInt32LE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
  }, u.prototype.readInt32BE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
  }, u.prototype.readFloatLE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), r.read(this, C, !0, 23, 4);
  }, u.prototype.readFloatBE = function(C, L) {
    return C = C >>> 0, L || _(C, 4, this.length), r.read(this, C, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(C, L) {
    return C = C >>> 0, L || _(C, 8, this.length), r.read(this, C, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(C, L) {
    return C = C >>> 0, L || _(C, 8, this.length), r.read(this, C, !1, 52, 8);
  };
  function l(te, C, L, G, de, me) {
    if (!u.isBuffer(te))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (C > de || C < me)
      throw new RangeError('"value" argument is out of bounds');
    if (L + G > te.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(C, L, G, de) {
    if (C = +C, L = L >>> 0, G = G >>> 0, !de) {
      var me = Math.pow(2, 8 * G) - 1;
      l(this, C, L, G, me, 0);
    }
    var Te = 1, He = 0;
    for (this[L] = C & 255; ++He < G && (Te *= 256); )
      this[L + He] = C / Te & 255;
    return L + G;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(C, L, G, de) {
    if (C = +C, L = L >>> 0, G = G >>> 0, !de) {
      var me = Math.pow(2, 8 * G) - 1;
      l(this, C, L, G, me, 0);
    }
    var Te = G - 1, He = 1;
    for (this[L + Te] = C & 255; --Te >= 0 && (He *= 256); )
      this[L + Te] = C / He & 255;
    return L + G;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 1, 255, 0), this[L] = C & 255, L + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 2, 65535, 0), this[L] = C & 255, this[L + 1] = C >>> 8, L + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 2, 65535, 0), this[L] = C >>> 8, this[L + 1] = C & 255, L + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 4, 4294967295, 0), this[L + 3] = C >>> 24, this[L + 2] = C >>> 16, this[L + 1] = C >>> 8, this[L] = C & 255, L + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 4, 4294967295, 0), this[L] = C >>> 24, this[L + 1] = C >>> 16, this[L + 2] = C >>> 8, this[L + 3] = C & 255, L + 4;
  }, u.prototype.writeIntLE = function(C, L, G, de) {
    if (C = +C, L = L >>> 0, !de) {
      var me = Math.pow(2, 8 * G - 1);
      l(this, C, L, G, me - 1, -me);
    }
    var Te = 0, He = 1, H = 0;
    for (this[L] = C & 255; ++Te < G && (He *= 256); )
      C < 0 && H === 0 && this[L + Te - 1] !== 0 && (H = 1), this[L + Te] = (C / He >> 0) - H & 255;
    return L + G;
  }, u.prototype.writeIntBE = function(C, L, G, de) {
    if (C = +C, L = L >>> 0, !de) {
      var me = Math.pow(2, 8 * G - 1);
      l(this, C, L, G, me - 1, -me);
    }
    var Te = G - 1, He = 1, H = 0;
    for (this[L + Te] = C & 255; --Te >= 0 && (He *= 256); )
      C < 0 && H === 0 && this[L + Te + 1] !== 0 && (H = 1), this[L + Te] = (C / He >> 0) - H & 255;
    return L + G;
  }, u.prototype.writeInt8 = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[L] = C & 255, L + 1;
  }, u.prototype.writeInt16LE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 2, 32767, -32768), this[L] = C & 255, this[L + 1] = C >>> 8, L + 2;
  }, u.prototype.writeInt16BE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 2, 32767, -32768), this[L] = C >>> 8, this[L + 1] = C & 255, L + 2;
  }, u.prototype.writeInt32LE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 4, 2147483647, -2147483648), this[L] = C & 255, this[L + 1] = C >>> 8, this[L + 2] = C >>> 16, this[L + 3] = C >>> 24, L + 4;
  }, u.prototype.writeInt32BE = function(C, L, G) {
    return C = +C, L = L >>> 0, G || l(this, C, L, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[L] = C >>> 24, this[L + 1] = C >>> 16, this[L + 2] = C >>> 8, this[L + 3] = C & 255, L + 4;
  };
  function R(te, C, L, G, de, me) {
    if (L + G > te.length)
      throw new RangeError("Index out of range");
    if (L < 0)
      throw new RangeError("Index out of range");
  }
  function ee(te, C, L, G, de) {
    return C = +C, L = L >>> 0, de || R(te, C, L, 4), r.write(te, C, L, G, 23, 4), L + 4;
  }
  u.prototype.writeFloatLE = function(C, L, G) {
    return ee(this, C, L, !0, G);
  }, u.prototype.writeFloatBE = function(C, L, G) {
    return ee(this, C, L, !1, G);
  };
  function oe(te, C, L, G, de) {
    return C = +C, L = L >>> 0, de || R(te, C, L, 8), r.write(te, C, L, G, 52, 8), L + 8;
  }
  u.prototype.writeDoubleLE = function(C, L, G) {
    return oe(this, C, L, !0, G);
  }, u.prototype.writeDoubleBE = function(C, L, G) {
    return oe(this, C, L, !1, G);
  }, u.prototype.copy = function(C, L, G, de) {
    if (!u.isBuffer(C))
      throw new TypeError("argument should be a Buffer");
    if (G || (G = 0), !de && de !== 0 && (de = this.length), L >= C.length && (L = C.length), L || (L = 0), de > 0 && de < G && (de = G), de === G || C.length === 0 || this.length === 0)
      return 0;
    if (L < 0)
      throw new RangeError("targetStart out of bounds");
    if (G < 0 || G >= this.length)
      throw new RangeError("Index out of range");
    if (de < 0)
      throw new RangeError("sourceEnd out of bounds");
    de > this.length && (de = this.length), C.length - L < de - G && (de = C.length - L + G);
    var me = de - G;
    return this === C && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(L, G, de) : Uint8Array.prototype.set.call(
      C,
      this.subarray(G, de),
      L
    ), me;
  }, u.prototype.fill = function(C, L, G, de) {
    if (typeof C == "string") {
      if (typeof L == "string" ? (de = L, L = 0, G = this.length) : typeof G == "string" && (de = G, G = this.length), de !== void 0 && typeof de != "string")
        throw new TypeError("encoding must be a string");
      if (typeof de == "string" && !u.isEncoding(de))
        throw new TypeError("Unknown encoding: " + de);
      if (C.length === 1) {
        var me = C.charCodeAt(0);
        (de === "utf8" && me < 128 || de === "latin1") && (C = me);
      }
    } else
      typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
    if (L < 0 || this.length < L || this.length < G)
      throw new RangeError("Out of range index");
    if (G <= L)
      return this;
    L = L >>> 0, G = G === void 0 ? this.length : G >>> 0, C || (C = 0);
    var Te;
    if (typeof C == "number")
      for (Te = L; Te < G; ++Te)
        this[Te] = C;
    else {
      var He = u.isBuffer(C) ? C : u.from(C, de), H = He.length;
      if (H === 0)
        throw new TypeError('The value "' + C + '" is invalid for argument "value"');
      for (Te = 0; Te < G - L; ++Te)
        this[Te + L] = He[Te % H];
    }
    return this;
  };
  var V = /[^+/0-9A-Za-z-_]/g;
  function W(te) {
    if (te = te.split("=")[0], te = te.trim().replace(V, ""), te.length < 2)
      return "";
    for (; te.length % 4 !== 0; )
      te = te + "=";
    return te;
  }
  function F(te, C) {
    C = C || 1 / 0;
    for (var L, G = te.length, de = null, me = [], Te = 0; Te < G; ++Te) {
      if (L = te.charCodeAt(Te), L > 55295 && L < 57344) {
        if (!de) {
          if (L > 56319) {
            (C -= 3) > -1 && me.push(239, 191, 189);
            continue;
          } else if (Te + 1 === G) {
            (C -= 3) > -1 && me.push(239, 191, 189);
            continue;
          }
          de = L;
          continue;
        }
        if (L < 56320) {
          (C -= 3) > -1 && me.push(239, 191, 189), de = L;
          continue;
        }
        L = (de - 55296 << 10 | L - 56320) + 65536;
      } else
        de && (C -= 3) > -1 && me.push(239, 191, 189);
      if (de = null, L < 128) {
        if ((C -= 1) < 0)
          break;
        me.push(L);
      } else if (L < 2048) {
        if ((C -= 2) < 0)
          break;
        me.push(
          L >> 6 | 192,
          L & 63 | 128
        );
      } else if (L < 65536) {
        if ((C -= 3) < 0)
          break;
        me.push(
          L >> 12 | 224,
          L >> 6 & 63 | 128,
          L & 63 | 128
        );
      } else if (L < 1114112) {
        if ((C -= 4) < 0)
          break;
        me.push(
          L >> 18 | 240,
          L >> 12 & 63 | 128,
          L >> 6 & 63 | 128,
          L & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return me;
  }
  function re(te) {
    for (var C = [], L = 0; L < te.length; ++L)
      C.push(te.charCodeAt(L) & 255);
    return C;
  }
  function he(te, C) {
    for (var L, G, de, me = [], Te = 0; Te < te.length && !((C -= 2) < 0); ++Te)
      L = te.charCodeAt(Te), G = L >> 8, de = L % 256, me.push(de), me.push(G);
    return me;
  }
  function Z(te) {
    return t.toByteArray(W(te));
  }
  function K(te, C, L, G) {
    for (var de = 0; de < G && !(de + L >= C.length || de >= te.length); ++de)
      C[de + L] = te[de];
    return de;
  }
  function ce(te, C) {
    return te instanceof C || te != null && te.constructor != null && te.constructor.name != null && te.constructor.name === C.name;
  }
  function ve(te) {
    return te !== te;
  }
  var Be = function() {
    for (var te = "0123456789abcdef", C = new Array(256), L = 0; L < 16; ++L)
      for (var G = L * 16, de = 0; de < 16; ++de)
        C[G + de] = te[L] + te[de];
    return C;
  }();
})(Le);
var ab = { exports: {} }, er = ab.exports = {}, rn, nn;
function Gc() {
  throw new Error("setTimeout has not been defined");
}
function Jc() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? rn = setTimeout : rn = Gc;
  } catch {
    rn = Gc;
  }
  try {
    typeof clearTimeout == "function" ? nn = clearTimeout : nn = Jc;
  } catch {
    nn = Jc;
  }
})();
function ob(e) {
  if (rn === setTimeout)
    return setTimeout(e, 0);
  if ((rn === Gc || !rn) && setTimeout)
    return rn = setTimeout, setTimeout(e, 0);
  try {
    return rn(e, 0);
  } catch {
    try {
      return rn.call(null, e, 0);
    } catch {
      return rn.call(this, e, 0);
    }
  }
}
function yw(e) {
  if (nn === clearTimeout)
    return clearTimeout(e);
  if ((nn === Jc || !nn) && clearTimeout)
    return nn = clearTimeout, clearTimeout(e);
  try {
    return nn(e);
  } catch {
    try {
      return nn.call(null, e);
    } catch {
      return nn.call(this, e);
    }
  }
}
var mn = [], Si = !1, Wn, io = -1;
function gw() {
  !Si || !Wn || (Si = !1, Wn.length ? mn = Wn.concat(mn) : io = -1, mn.length && fb());
}
function fb() {
  if (!Si) {
    var e = ob(gw);
    Si = !0;
    for (var t = mn.length; t; ) {
      for (Wn = mn, mn = []; ++io < t; )
        Wn && Wn[io].run();
      io = -1, t = mn.length;
    }
    Wn = null, Si = !1, yw(e);
  }
}
er.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  mn.push(new sb(e, t)), mn.length === 1 && !Si && ob(fb);
};
function sb(e, t) {
  this.fun = e, this.array = t;
}
sb.prototype.run = function() {
  this.fun.apply(null, this.array);
};
er.title = "browser";
er.browser = !0;
er.env = {};
er.argv = [];
er.version = "";
er.versions = {};
function xn() {
}
er.on = xn;
er.addListener = xn;
er.once = xn;
er.off = xn;
er.removeListener = xn;
er.removeAllListeners = xn;
er.emit = xn;
er.prependListener = xn;
er.prependOnceListener = xn;
er.listeners = function(e) {
  return [];
};
er.binding = function(e) {
  throw new Error("process.binding is not supported");
};
er.cwd = function() {
  return "/";
};
er.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
er.umask = function() {
  return 0;
};
var mw = ab.exports;
const at = /* @__PURE__ */ Bv(mw);
(function(e) {
  function t() {
    var i = this || self;
    return delete e.prototype.__magic__, i;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var r = __magic__;
  return r;
})(Object);
var Lt = {}, _a = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
  const t = ai, r = hr;
  e.HexStruct = (0, t.pattern)((0, t.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, t.pattern)((0, t.string)(), /^0x[0-9a-f]+$/iu);
  function i(h) {
    return (0, t.is)(h, e.HexStruct);
  }
  e.isHexString = i;
  function o(h) {
    return (0, t.is)(h, e.StrictHexStruct);
  }
  e.isStrictHexString = o;
  function n(h) {
    (0, r.assert)(i(h), "Value must be a hexadecimal string.");
  }
  e.assertIsHexString = n;
  function f(h) {
    (0, r.assert)(o(h), 'Value must be a hexadecimal string, starting with "0x".');
  }
  e.assertIsStrictHexString = f;
  function u(h) {
    return h.startsWith("0x") ? h : h.startsWith("0X") ? `0x${h.substring(2)}` : `0x${h}`;
  }
  e.add0x = u;
  function c(h) {
    return h.startsWith("0x") || h.startsWith("0X") ? h.substring(2) : h;
  }
  e.remove0x = c;
})(_a);
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.createDataView = Lt.concatBytes = Lt.valueToBytes = Lt.stringToBytes = Lt.numberToBytes = Lt.signedBigIntToBytes = Lt.bigIntToBytes = Lt.hexToBytes = Lt.bytesToString = Lt.bytesToNumber = Lt.bytesToSignedBigInt = Lt.bytesToBigInt = Lt.bytesToHex = Lt.assertIsBytes = Lt.isBytes = void 0;
const Rr = hr, Xc = _a, q0 = 48, $0 = 58, D0 = 87;
function ww() {
  const e = [];
  return () => {
    if (e.length === 0)
      for (let t = 0; t < 256; t++)
        e.push(t.toString(16).padStart(2, "0"));
    return e;
  };
}
const _w = ww();
function Bh(e) {
  return e instanceof Uint8Array;
}
Lt.isBytes = Bh;
function Fi(e) {
  (0, Rr.assert)(Bh(e), "Value must be a Uint8Array.");
}
Lt.assertIsBytes = Fi;
function ub(e) {
  if (Fi(e), e.length === 0)
    return "0x";
  const t = _w(), r = new Array(e.length);
  for (let i = 0; i < e.length; i++)
    r[i] = t[e[i]];
  return (0, Xc.add0x)(r.join(""));
}
Lt.bytesToHex = ub;
function cb(e) {
  Fi(e);
  const t = ub(e);
  return BigInt(t);
}
Lt.bytesToBigInt = cb;
function xw(e) {
  Fi(e);
  let t = BigInt(0);
  for (const r of e)
    t = (t << BigInt(8)) + BigInt(r);
  return BigInt.asIntN(e.length * 8, t);
}
Lt.bytesToSignedBigInt = xw;
function Ew(e) {
  Fi(e);
  const t = cb(e);
  return (0, Rr.assert)(t <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(t);
}
Lt.bytesToNumber = Ew;
function Sw(e) {
  return Fi(e), new TextDecoder().decode(e);
}
Lt.bytesToString = Sw;
function Co(e) {
  var t;
  if (((t = e == null ? void 0 : e.toLowerCase) === null || t === void 0 ? void 0 : t.call(e)) === "0x")
    return new Uint8Array();
  (0, Xc.assertIsHexString)(e);
  const r = (0, Xc.remove0x)(e).toLowerCase(), i = r.length % 2 === 0 ? r : `0${r}`, o = new Uint8Array(i.length / 2);
  for (let n = 0; n < o.length; n++) {
    const f = i.charCodeAt(n * 2), u = i.charCodeAt(n * 2 + 1), c = f - (f < $0 ? q0 : D0), h = u - (u < $0 ? q0 : D0);
    o[n] = c * 16 + h;
  }
  return o;
}
Lt.hexToBytes = Co;
function hb(e) {
  (0, Rr.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Rr.assert)(e >= BigInt(0), "Value must be a non-negative bigint.");
  const t = e.toString(16);
  return Co(t);
}
Lt.bigIntToBytes = hb;
function Aw(e, t) {
  (0, Rr.assert)(t > 0);
  const r = e >> BigInt(31);
  return !((~e & r) + (e & ~r) >> BigInt(t * 8 + -1));
}
function Mw(e, t) {
  (0, Rr.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Rr.assert)(typeof t == "number", "Byte length must be a number."), (0, Rr.assert)(t > 0, "Byte length must be greater than 0."), (0, Rr.assert)(Aw(e, t), "Byte length is too small to represent the given value.");
  let r = e;
  const i = new Uint8Array(t);
  for (let o = 0; o < i.length; o++)
    i[o] = Number(BigInt.asUintN(8, r)), r >>= BigInt(8);
  return i.reverse();
}
Lt.signedBigIntToBytes = Mw;
function lb(e) {
  (0, Rr.assert)(typeof e == "number", "Value must be a number."), (0, Rr.assert)(e >= 0, "Value must be a non-negative number."), (0, Rr.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const t = e.toString(16);
  return Co(t);
}
Lt.numberToBytes = lb;
function db(e) {
  return (0, Rr.assert)(typeof e == "string", "Value must be a string."), new TextEncoder().encode(e);
}
Lt.stringToBytes = db;
function pb(e) {
  if (typeof e == "bigint")
    return hb(e);
  if (typeof e == "number")
    return lb(e);
  if (typeof e == "string")
    return e.startsWith("0x") ? Co(e) : db(e);
  if (Bh(e))
    return e;
  throw new TypeError(`Unsupported value type: "${typeof e}".`);
}
Lt.valueToBytes = pb;
function Rw(e) {
  const t = new Array(e.length);
  let r = 0;
  for (let o = 0; o < e.length; o++) {
    const n = pb(e[o]);
    t[o] = n, r += n.length;
  }
  const i = new Uint8Array(r);
  for (let o = 0, n = 0; o < t.length; o++)
    i.set(t[o], n), n += t[o].length;
  return i;
}
Lt.concatBytes = Rw;
function Bw(e) {
  if (typeof Le.Buffer < "u" && e instanceof Le.Buffer) {
    const t = e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
    return new DataView(t);
  }
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
Lt.createDataView = Bw;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.ChecksumStruct = void 0;
const j0 = ai, Iw = wa;
No.ChecksumStruct = (0, j0.size)((0, Iw.base64)((0, j0.string)(), { paddingRequired: !0 }), 44, 44);
var on = {};
Object.defineProperty(on, "__esModule", { value: !0 });
on.createHex = on.createBytes = on.createBigInt = on.createNumber = void 0;
const Kt = ai, Tw = hr, vb = Lt, Lo = _a, bb = (0, Kt.union)([(0, Kt.number)(), (0, Kt.bigint)(), (0, Kt.string)(), Lo.StrictHexStruct]), Ow = (0, Kt.coerce)((0, Kt.number)(), bb, Number), Pw = (0, Kt.coerce)((0, Kt.bigint)(), bb, BigInt);
(0, Kt.union)([Lo.StrictHexStruct, (0, Kt.instance)(Uint8Array)]);
const Cw = (0, Kt.coerce)((0, Kt.instance)(Uint8Array), (0, Kt.union)([Lo.StrictHexStruct]), vb.hexToBytes), Nw = (0, Kt.coerce)(Lo.StrictHexStruct, (0, Kt.instance)(Uint8Array), vb.bytesToHex);
function Lw(e) {
  try {
    const t = (0, Kt.create)(e, Ow);
    return (0, Tw.assert)(Number.isFinite(t), `Expected a number-like value, got "${e}".`), t;
  } catch (t) {
    throw t instanceof Kt.StructError ? new Error(`Expected a number-like value, got "${e}".`) : t;
  }
}
on.createNumber = Lw;
function kw(e) {
  try {
    return (0, Kt.create)(e, Pw);
  } catch (t) {
    throw t instanceof Kt.StructError ? new Error(`Expected a number-like value, got "${String(t.value)}".`) : t;
  }
}
on.createBigInt = kw;
function qw(e) {
  if (typeof e == "string" && e.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, Kt.create)(e, Cw);
  } catch (t) {
    throw t instanceof Kt.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
on.createBytes = qw;
function $w(e) {
  if (e instanceof Uint8Array && e.length === 0 || typeof e == "string" && e.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, Kt.create)(e, Nw);
  } catch (t) {
    throw t instanceof Kt.StructError ? new Error(`Expected a bytes-like value, got "${String(t.value)}".`) : t;
  }
}
on.createHex = $w;
var Ti = {}, yb = Ze && Ze.__classPrivateFieldSet || function(e, t, r, i, o) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !o : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? o.call(e, r) : o ? o.value = r : t.set(e, r), r;
}, gr = Ze && Ze.__classPrivateFieldGet || function(e, t, r, i) {
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? i : r === "a" ? i.call(e) : i ? i.value : t.get(e);
}, Vr, Yr;
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.FrozenSet = Ti.FrozenMap = void 0;
class Ih {
  constructor(t) {
    Vr.set(this, void 0), yb(this, Vr, new Map(t), "f"), Object.freeze(this);
  }
  get size() {
    return gr(this, Vr, "f").size;
  }
  [(Vr = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return gr(this, Vr, "f")[Symbol.iterator]();
  }
  entries() {
    return gr(this, Vr, "f").entries();
  }
  forEach(t, r) {
    return gr(this, Vr, "f").forEach((i, o, n) => t.call(r, i, o, this));
  }
  get(t) {
    return gr(this, Vr, "f").get(t);
  }
  has(t) {
    return gr(this, Vr, "f").has(t);
  }
  keys() {
    return gr(this, Vr, "f").keys();
  }
  values() {
    return gr(this, Vr, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([t, r]) => `${String(t)} => ${String(r)}`).join(", ")} ` : ""}}`;
  }
}
Ti.FrozenMap = Ih;
class Th {
  constructor(t) {
    Yr.set(this, void 0), yb(this, Yr, new Set(t), "f"), Object.freeze(this);
  }
  get size() {
    return gr(this, Yr, "f").size;
  }
  [(Yr = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return gr(this, Yr, "f")[Symbol.iterator]();
  }
  entries() {
    return gr(this, Yr, "f").entries();
  }
  forEach(t, r) {
    return gr(this, Yr, "f").forEach((i, o, n) => t.call(r, i, o, this));
  }
  has(t) {
    return gr(this, Yr, "f").has(t);
  }
  keys() {
    return gr(this, Yr, "f").keys();
  }
  values() {
    return gr(this, Yr, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((t) => String(t)).join(", ")} ` : ""}}`;
  }
}
Ti.FrozenSet = Th;
Object.freeze(Ih);
Object.freeze(Ih.prototype);
Object.freeze(Th);
Object.freeze(Th.prototype);
var gb = {}, Oh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
  function t(h) {
    return Array.isArray(h) && h.length > 0;
  }
  e.isNonEmptyArray = t;
  function r(h) {
    return h == null;
  }
  e.isNullOrUndefined = r;
  function i(h) {
    return !!h && typeof h == "object" && !Array.isArray(h);
  }
  e.isObject = i;
  const o = (h, s) => Object.hasOwnProperty.call(h, s);
  e.hasProperty = o, function(h) {
    h[h.Null = 4] = "Null", h[h.Comma = 1] = "Comma", h[h.Wrapper = 1] = "Wrapper", h[h.True = 4] = "True", h[h.False = 5] = "False", h[h.Quote = 1] = "Quote", h[h.Colon = 1] = "Colon", h[h.Date = 24] = "Date";
  }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function n(h) {
    if (typeof h != "object" || h === null)
      return !1;
    try {
      let s = h;
      for (; Object.getPrototypeOf(s) !== null; )
        s = Object.getPrototypeOf(s);
      return Object.getPrototypeOf(h) === s;
    } catch {
      return !1;
    }
  }
  e.isPlainObject = n;
  function f(h) {
    return h.charCodeAt(0) <= 127;
  }
  e.isASCII = f;
  function u(h) {
    var s;
    return h.split("").reduce((v, m) => f(m) ? v + 1 : v + 2, 0) + ((s = h.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && s !== void 0 ? s : []).length;
  }
  e.calculateStringSize = u;
  function c(h) {
    return h.toString().length;
  }
  e.calculateNumberSize = c;
})(Oh);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateJsonAndGetSize = e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.isValidJson = e.JsonStruct = void 0;
  const t = ai, r = hr, i = Oh;
  e.JsonStruct = (0, t.define)("Json", (q) => {
    const [D] = N(q, !0);
    return D ? !0 : "Expected a valid JSON-serializable value";
  });
  function o(q) {
    return (0, t.is)(q, e.JsonStruct);
  }
  e.isValidJson = o, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, t.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, t.nullable)((0, t.union)([(0, t.number)(), (0, t.string)()])), e.JsonRpcErrorStruct = (0, t.object)({
    code: (0, t.integer)(),
    message: (0, t.string)(),
    data: (0, t.optional)(e.JsonStruct),
    stack: (0, t.optional)((0, t.string)())
  }), e.JsonRpcParamsStruct = (0, t.optional)((0, t.union)([(0, t.record)((0, t.string)(), e.JsonStruct), (0, t.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    method: (0, t.string)(),
    params: e.JsonRpcParamsStruct
  }), e.JsonRpcNotificationStruct = (0, t.omit)(e.JsonRpcRequestStruct, ["id"]);
  function n(q) {
    return (0, t.is)(q, e.JsonRpcNotificationStruct);
  }
  e.isJsonRpcNotification = n;
  function f(q, D) {
    (0, r.assertStruct)(q, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", D);
  }
  e.assertIsJsonRpcNotification = f;
  function u(q) {
    return (0, t.is)(q, e.JsonRpcRequestStruct);
  }
  e.isJsonRpcRequest = u;
  function c(q, D) {
    (0, r.assertStruct)(q, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", D);
  }
  e.assertIsJsonRpcRequest = c, e.PendingJsonRpcResponseStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: (0, t.optional)((0, t.unknown)()),
    error: (0, t.optional)(e.JsonRpcErrorStruct)
  }), e.JsonRpcSuccessStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: e.JsonStruct
  }), e.JsonRpcFailureStruct = (0, t.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    error: e.JsonRpcErrorStruct
  }), e.JsonRpcResponseStruct = (0, t.union)([
    e.JsonRpcSuccessStruct,
    e.JsonRpcFailureStruct
  ]);
  function h(q) {
    return (0, t.is)(q, e.PendingJsonRpcResponseStruct);
  }
  e.isPendingJsonRpcResponse = h;
  function s(q, D) {
    (0, r.assertStruct)(q, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", D);
  }
  e.assertIsPendingJsonRpcResponse = s;
  function p(q) {
    return (0, t.is)(q, e.JsonRpcResponseStruct);
  }
  e.isJsonRpcResponse = p;
  function v(q, D) {
    (0, r.assertStruct)(q, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", D);
  }
  e.assertIsJsonRpcResponse = v;
  function m(q) {
    return (0, t.is)(q, e.JsonRpcSuccessStruct);
  }
  e.isJsonRpcSuccess = m;
  function E(q, D) {
    (0, r.assertStruct)(q, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", D);
  }
  e.assertIsJsonRpcSuccess = E;
  function M(q) {
    return (0, t.is)(q, e.JsonRpcFailureStruct);
  }
  e.isJsonRpcFailure = M;
  function I(q, D) {
    (0, r.assertStruct)(q, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", D);
  }
  e.assertIsJsonRpcFailure = I;
  function B(q) {
    return (0, t.is)(q, e.JsonRpcErrorStruct);
  }
  e.isJsonRpcError = B;
  function T(q, D) {
    (0, r.assertStruct)(q, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", D);
  }
  e.assertIsJsonRpcError = T;
  function k(q) {
    const { permitEmptyString: D, permitFractions: U, permitNull: z } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, q);
    return (ue) => !!(typeof ue == "number" && (U || Number.isInteger(ue)) || typeof ue == "string" && (D || ue.length > 0) || z && ue === null);
  }
  e.getJsonRpcIdValidator = k;
  function N(q, D = !1) {
    const U = /* @__PURE__ */ new Set();
    function z(Y, ue) {
      if (Y === void 0)
        return [!1, 0];
      if (Y === null)
        return [!0, ue ? 0 : i.JsonSize.Null];
      const j = typeof Y;
      try {
        if (j === "function")
          return [!1, 0];
        if (j === "string" || Y instanceof String)
          return [
            !0,
            ue ? 0 : (0, i.calculateStringSize)(Y) + i.JsonSize.Quote * 2
          ];
        if (j === "boolean" || Y instanceof Boolean)
          return ue ? [!0, 0] : [!0, Y == !0 ? i.JsonSize.True : i.JsonSize.False];
        if (j === "number" || Y instanceof Number)
          return ue ? [!0, 0] : [!0, (0, i.calculateNumberSize)(Y)];
        if (Y instanceof Date)
          return ue ? [!0, 0] : [
            !0,
            // Note: Invalid dates will serialize to null
            isNaN(Y.getDate()) ? i.JsonSize.Null : i.JsonSize.Date + i.JsonSize.Quote * 2
          ];
      } catch {
        return [!1, 0];
      }
      if (!(0, i.isPlainObject)(Y) && !Array.isArray(Y))
        return [!1, 0];
      if (U.has(Y))
        return [!1, 0];
      U.add(Y);
      try {
        return [
          !0,
          Object.entries(Y).reduce(
            (g, [b, a], d, w) => {
              let [x, A] = z(a, ue);
              if (!x)
                throw new Error("JSON validation did not pass. Validation process stopped.");
              if (U.delete(Y), ue)
                return 0;
              const S = Array.isArray(Y) ? 0 : b.length + i.JsonSize.Comma + i.JsonSize.Colon * 2, y = d < w.length - 1 ? i.JsonSize.Comma : 0;
              return g + S + A + y;
            },
            // Starts at 2 because the serialized JSON string data (plain text)
            // will minimally contain {}/[]
            ue ? 0 : i.JsonSize.Wrapper * 2
          )
        ];
      } catch {
        return [!1, 0];
      }
    }
    return z(q, D);
  }
  e.validateJsonAndGetSize = N;
})(gb);
var Oi = {}, Yc = { exports: {} }, xf, U0;
function Dw() {
  if (U0)
    return xf;
  U0 = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, o = i * 7, n = i * 365.25;
  xf = function(s, p) {
    p = p || {};
    var v = typeof s;
    if (v === "string" && s.length > 0)
      return f(s);
    if (v === "number" && isFinite(s))
      return p.long ? c(s) : u(s);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(s)
    );
  };
  function f(s) {
    if (s = String(s), !(s.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        s
      );
      if (p) {
        var v = parseFloat(p[1]), m = (p[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return v * n;
          case "weeks":
          case "week":
          case "w":
            return v * o;
          case "days":
          case "day":
          case "d":
            return v * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return v * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return v * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return v * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return v;
          default:
            return;
        }
      }
    }
  }
  function u(s) {
    var p = Math.abs(s);
    return p >= i ? Math.round(s / i) + "d" : p >= r ? Math.round(s / r) + "h" : p >= t ? Math.round(s / t) + "m" : p >= e ? Math.round(s / e) + "s" : s + "ms";
  }
  function c(s) {
    var p = Math.abs(s);
    return p >= i ? h(s, p, i, "day") : p >= r ? h(s, p, r, "hour") : p >= t ? h(s, p, t, "minute") : p >= e ? h(s, p, e, "second") : s + " ms";
  }
  function h(s, p, v, m) {
    var E = p >= v * 1.5;
    return Math.round(s / v) + " " + m + (E ? "s" : "");
  }
  return xf;
}
function jw(e) {
  r.debug = r, r.default = r, r.coerce = c, r.disable = n, r.enable = o, r.enabled = f, r.humanize = Dw(), r.destroy = h, Object.keys(e).forEach((s) => {
    r[s] = e[s];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(s) {
    let p = 0;
    for (let v = 0; v < s.length; v++)
      p = (p << 5) - p + s.charCodeAt(v), p |= 0;
    return r.colors[Math.abs(p) % r.colors.length];
  }
  r.selectColor = t;
  function r(s) {
    let p, v = null, m, E;
    function M(...I) {
      if (!M.enabled)
        return;
      const B = M, T = Number(/* @__PURE__ */ new Date()), k = T - (p || T);
      B.diff = k, B.prev = p, B.curr = T, p = T, I[0] = r.coerce(I[0]), typeof I[0] != "string" && I.unshift("%O");
      let N = 0;
      I[0] = I[0].replace(/%([a-zA-Z%])/g, (D, U) => {
        if (D === "%%")
          return "%";
        N++;
        const z = r.formatters[U];
        if (typeof z == "function") {
          const Y = I[N];
          D = z.call(B, Y), I.splice(N, 1), N--;
        }
        return D;
      }), r.formatArgs.call(B, I), (B.log || r.log).apply(B, I);
    }
    return M.namespace = s, M.useColors = r.useColors(), M.color = r.selectColor(s), M.extend = i, M.destroy = r.destroy, Object.defineProperty(M, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => v !== null ? v : (m !== r.namespaces && (m = r.namespaces, E = r.enabled(s)), E),
      set: (I) => {
        v = I;
      }
    }), typeof r.init == "function" && r.init(M), M;
  }
  function i(s, p) {
    const v = r(this.namespace + (typeof p > "u" ? ":" : p) + s);
    return v.log = this.log, v;
  }
  function o(s) {
    r.save(s), r.namespaces = s, r.names = [], r.skips = [];
    let p;
    const v = (typeof s == "string" ? s : "").split(/[\s,]+/), m = v.length;
    for (p = 0; p < m; p++)
      v[p] && (s = v[p].replace(/\*/g, ".*?"), s[0] === "-" ? r.skips.push(new RegExp("^" + s.slice(1) + "$")) : r.names.push(new RegExp("^" + s + "$")));
  }
  function n() {
    const s = [
      ...r.names.map(u),
      ...r.skips.map(u).map((p) => "-" + p)
    ].join(",");
    return r.enable(""), s;
  }
  function f(s) {
    if (s[s.length - 1] === "*")
      return !0;
    let p, v;
    for (p = 0, v = r.skips.length; p < v; p++)
      if (r.skips[p].test(s))
        return !1;
    for (p = 0, v = r.names.length; p < v; p++)
      if (r.names[p].test(s))
        return !0;
    return !1;
  }
  function u(s) {
    return s.toString().substring(2, s.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(s) {
    return s instanceof Error ? s.stack || s.message : s;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var Uw = jw;
(function(e, t) {
  t.formatArgs = i, t.save = o, t.load = n, t.useColors = r, t.storage = f(), t.destroy = /* @__PURE__ */ (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    c.splice(1, 0, h, "color: inherit");
    let s = 0, p = 0;
    c[0].replace(/%[a-zA-Z%]/g, (v) => {
      v !== "%%" && (s++, v === "%c" && (p = s));
    }), c.splice(p, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function o(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function n() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof at < "u" && "env" in at && (c = at.env.DEBUG), c;
  }
  function f() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = Uw(t);
  const { formatters: u } = e.exports;
  u.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(Yc, Yc.exports);
var Fw = Yc.exports, Hw = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.createModuleLogger = Oi.createProjectLogger = void 0;
const zw = Hw(Fw), Vw = (0, zw.default)("metamask");
function Ww(e) {
  return Vw.extend(e);
}
Oi.createProjectLogger = Ww;
function Kw(e, t) {
  return e.extend(t);
}
Oi.createModuleLogger = Kw;
var fn = {};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.hexToBigInt = fn.hexToNumber = fn.bigIntToHex = fn.numberToHex = void 0;
const Ai = hr, ha = _a, Zw = (e) => ((0, Ai.assert)(typeof e == "number", "Value must be a number."), (0, Ai.assert)(e >= 0, "Value must be a non-negative number."), (0, Ai.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, ha.add0x)(e.toString(16)));
fn.numberToHex = Zw;
const Gw = (e) => ((0, Ai.assert)(typeof e == "bigint", "Value must be a bigint."), (0, Ai.assert)(e >= 0, "Value must be a non-negative bigint."), (0, ha.add0x)(e.toString(16)));
fn.bigIntToHex = Gw;
const Jw = (e) => {
  (0, ha.assertIsHexString)(e);
  const t = parseInt(e, 16);
  return (0, Ai.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `hexToBigInt` instead."), t;
};
fn.hexToNumber = Jw;
const Xw = (e) => ((0, ha.assertIsHexString)(e), BigInt((0, ha.add0x)(e)));
fn.hexToBigInt = Xw;
var mb = {};
Object.defineProperty(mb, "__esModule", { value: !0 });
var wb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(n) {
    n[n.Millisecond = 1] = "Millisecond", n[n.Second = 1e3] = "Second", n[n.Minute = 6e4] = "Minute", n[n.Hour = 36e5] = "Hour", n[n.Day = 864e5] = "Day", n[n.Week = 6048e5] = "Week", n[n.Year = 31536e6] = "Year";
  }(e.Duration || (e.Duration = {}));
  const t = (n) => Number.isInteger(n) && n >= 0, r = (n, f) => {
    if (!t(n))
      throw new Error(`"${f}" must be a non-negative integer. Received: "${n}".`);
  };
  function i(n, f) {
    return r(n, "count"), n * f;
  }
  e.inMilliseconds = i;
  function o(n) {
    return r(n, "timestamp"), Date.now() - n;
  }
  e.timeSince = o;
})(wb);
var _b = {}, Qc = { exports: {} };
const Yw = "2.0.0", xb = 256, Qw = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, e6 = 16, t6 = xb - 6, r6 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var ko = {
  MAX_LENGTH: xb,
  MAX_SAFE_COMPONENT_LENGTH: e6,
  MAX_SAFE_BUILD_LENGTH: t6,
  MAX_SAFE_INTEGER: Qw,
  RELEASE_TYPES: r6,
  SEMVER_SPEC_VERSION: Yw,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const n6 = typeof at == "object" && at.env && at.env.NODE_DEBUG && /\bsemver\b/i.test(at.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var qo = n6;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_LENGTH: o
  } = ko, n = qo;
  t = e.exports = {};
  const f = t.re = [], u = t.safeRe = [], c = t.src = [], h = t.t = {};
  let s = 0;
  const p = "[a-zA-Z0-9-]", v = [
    ["\\s", 1],
    ["\\d", o],
    [p, i]
  ], m = (M) => {
    for (const [I, B] of v)
      M = M.split(`${I}*`).join(`${I}{0,${B}}`).split(`${I}+`).join(`${I}{1,${B}}`);
    return M;
  }, E = (M, I, B) => {
    const T = m(I), k = s++;
    n(M, k, I), h[M] = k, c[k] = I, f[k] = new RegExp(I, B ? "g" : void 0), u[k] = new RegExp(T, B ? "g" : void 0);
  };
  E("NUMERICIDENTIFIER", "0|[1-9]\\d*"), E("NUMERICIDENTIFIERLOOSE", "\\d+"), E("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${p}*`), E("MAINVERSION", `(${c[h.NUMERICIDENTIFIER]})\\.(${c[h.NUMERICIDENTIFIER]})\\.(${c[h.NUMERICIDENTIFIER]})`), E("MAINVERSIONLOOSE", `(${c[h.NUMERICIDENTIFIERLOOSE]})\\.(${c[h.NUMERICIDENTIFIERLOOSE]})\\.(${c[h.NUMERICIDENTIFIERLOOSE]})`), E("PRERELEASEIDENTIFIER", `(?:${c[h.NUMERICIDENTIFIER]}|${c[h.NONNUMERICIDENTIFIER]})`), E("PRERELEASEIDENTIFIERLOOSE", `(?:${c[h.NUMERICIDENTIFIERLOOSE]}|${c[h.NONNUMERICIDENTIFIER]})`), E("PRERELEASE", `(?:-(${c[h.PRERELEASEIDENTIFIER]}(?:\\.${c[h.PRERELEASEIDENTIFIER]})*))`), E("PRERELEASELOOSE", `(?:-?(${c[h.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[h.PRERELEASEIDENTIFIERLOOSE]})*))`), E("BUILDIDENTIFIER", `${p}+`), E("BUILD", `(?:\\+(${c[h.BUILDIDENTIFIER]}(?:\\.${c[h.BUILDIDENTIFIER]})*))`), E("FULLPLAIN", `v?${c[h.MAINVERSION]}${c[h.PRERELEASE]}?${c[h.BUILD]}?`), E("FULL", `^${c[h.FULLPLAIN]}$`), E("LOOSEPLAIN", `[v=\\s]*${c[h.MAINVERSIONLOOSE]}${c[h.PRERELEASELOOSE]}?${c[h.BUILD]}?`), E("LOOSE", `^${c[h.LOOSEPLAIN]}$`), E("GTLT", "((?:<|>)?=?)"), E("XRANGEIDENTIFIERLOOSE", `${c[h.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), E("XRANGEIDENTIFIER", `${c[h.NUMERICIDENTIFIER]}|x|X|\\*`), E("XRANGEPLAIN", `[v=\\s]*(${c[h.XRANGEIDENTIFIER]})(?:\\.(${c[h.XRANGEIDENTIFIER]})(?:\\.(${c[h.XRANGEIDENTIFIER]})(?:${c[h.PRERELEASE]})?${c[h.BUILD]}?)?)?`), E("XRANGEPLAINLOOSE", `[v=\\s]*(${c[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[h.XRANGEIDENTIFIERLOOSE]})(?:${c[h.PRERELEASELOOSE]})?${c[h.BUILD]}?)?)?`), E("XRANGE", `^${c[h.GTLT]}\\s*${c[h.XRANGEPLAIN]}$`), E("XRANGELOOSE", `^${c[h.GTLT]}\\s*${c[h.XRANGEPLAINLOOSE]}$`), E("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), E("COERCERTL", c[h.COERCE], !0), E("LONETILDE", "(?:~>?)"), E("TILDETRIM", `(\\s*)${c[h.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", E("TILDE", `^${c[h.LONETILDE]}${c[h.XRANGEPLAIN]}$`), E("TILDELOOSE", `^${c[h.LONETILDE]}${c[h.XRANGEPLAINLOOSE]}$`), E("LONECARET", "(?:\\^)"), E("CARETTRIM", `(\\s*)${c[h.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", E("CARET", `^${c[h.LONECARET]}${c[h.XRANGEPLAIN]}$`), E("CARETLOOSE", `^${c[h.LONECARET]}${c[h.XRANGEPLAINLOOSE]}$`), E("COMPARATORLOOSE", `^${c[h.GTLT]}\\s*(${c[h.LOOSEPLAIN]})$|^$`), E("COMPARATOR", `^${c[h.GTLT]}\\s*(${c[h.FULLPLAIN]})$|^$`), E("COMPARATORTRIM", `(\\s*)${c[h.GTLT]}\\s*(${c[h.LOOSEPLAIN]}|${c[h.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", E("HYPHENRANGE", `^\\s*(${c[h.XRANGEPLAIN]})\\s+-\\s+(${c[h.XRANGEPLAIN]})\\s*$`), E("HYPHENRANGELOOSE", `^\\s*(${c[h.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[h.XRANGEPLAINLOOSE]})\\s*$`), E("STAR", "(<|>)?=?\\s*\\*"), E("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), E("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Qc, Qc.exports);
var xa = Qc.exports;
const i6 = Object.freeze({ loose: !0 }), a6 = Object.freeze({}), o6 = (e) => e ? typeof e != "object" ? i6 : e : a6;
var Ph = o6;
const F0 = /^[0-9]+$/, Eb = (e, t) => {
  const r = F0.test(e), i = F0.test(t);
  return r && i && (e = +e, t = +t), e === t ? 0 : r && !i ? -1 : i && !r ? 1 : e < t ? -1 : 1;
}, f6 = (e, t) => Eb(t, e);
var Sb = {
  compareIdentifiers: Eb,
  rcompareIdentifiers: f6
};
const Na = qo, { MAX_LENGTH: H0, MAX_SAFE_INTEGER: La } = ko, { safeRe: z0, t: V0 } = xa, s6 = Ph, { compareIdentifiers: ui } = Sb;
let u6 = class en {
  constructor(t, r) {
    if (r = s6(r), t instanceof en) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > H0)
      throw new TypeError(
        `version is longer than ${H0} characters`
      );
    Na("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const i = t.trim().match(r.loose ? z0[V0.LOOSE] : z0[V0.FULL]);
    if (!i)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > La || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > La || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > La || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((o) => {
      if (/^[0-9]+$/.test(o)) {
        const n = +o;
        if (n >= 0 && n < La)
          return n;
      }
      return o;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Na("SemVer.compare", this.version, this.options, t), !(t instanceof en)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new en(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof en || (t = new en(t, this.options)), ui(this.major, t.major) || ui(this.minor, t.minor) || ui(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof en || (t = new en(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const i = this.prerelease[r], o = t.prerelease[r];
      if (Na("prerelease compare", r, i, o), i === void 0 && o === void 0)
        return 0;
      if (o === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === o)
        continue;
      return ui(i, o);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof en || (t = new en(t, this.options));
    let r = 0;
    do {
      const i = this.build[r], o = t.build[r];
      if (Na("prerelease compare", r, i, o), i === void 0 && o === void 0)
        return 0;
      if (o === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === o)
        continue;
      return ui(i, o);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r, i) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, i);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, i);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, i), this.inc("pre", r, i);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, i), this.inc("pre", r, i);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const o = Number(i) ? 1 : 0;
        if (!r && i === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [o];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          if (n === -1) {
            if (r === this.prerelease.join(".") && i === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(o);
          }
        }
        if (r) {
          let n = [r, o];
          i === !1 && (n = [r]), ui(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = n) : this.prerelease = n;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var mr = u6;
const W0 = mr, c6 = (e, t, r = !1) => {
  if (e instanceof W0)
    return e;
  try {
    return new W0(e, t);
  } catch (i) {
    if (!r)
      return null;
    throw i;
  }
};
var Hi = c6;
const h6 = Hi, l6 = (e, t) => {
  const r = h6(e, t);
  return r ? r.version : null;
};
var d6 = l6;
const p6 = Hi, v6 = (e, t) => {
  const r = p6(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var b6 = v6;
const K0 = mr, y6 = (e, t, r, i, o) => {
  typeof r == "string" && (o = i, i = r, r = void 0);
  try {
    return new K0(
      e instanceof K0 ? e.version : e,
      r
    ).inc(t, i, o).version;
  } catch {
    return null;
  }
};
var g6 = y6;
const Z0 = Hi, m6 = (e, t) => {
  const r = Z0(e, null, !0), i = Z0(t, null, !0), o = r.compare(i);
  if (o === 0)
    return null;
  const n = o > 0, f = n ? r : i, u = n ? i : r, c = !!f.prerelease.length;
  if (!!u.prerelease.length && !c)
    return !u.patch && !u.minor ? "major" : f.patch ? "patch" : f.minor ? "minor" : "major";
  const s = c ? "pre" : "";
  return r.major !== i.major ? s + "major" : r.minor !== i.minor ? s + "minor" : r.patch !== i.patch ? s + "patch" : "prerelease";
};
var w6 = m6;
const _6 = mr, x6 = (e, t) => new _6(e, t).major;
var E6 = x6;
const S6 = mr, A6 = (e, t) => new S6(e, t).minor;
var M6 = A6;
const R6 = mr, B6 = (e, t) => new R6(e, t).patch;
var I6 = B6;
const T6 = Hi, O6 = (e, t) => {
  const r = T6(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var P6 = O6;
const G0 = mr, C6 = (e, t, r) => new G0(e, r).compare(new G0(t, r));
var Jr = C6;
const N6 = Jr, L6 = (e, t, r) => N6(t, e, r);
var k6 = L6;
const q6 = Jr, $6 = (e, t) => q6(e, t, !0);
var D6 = $6;
const J0 = mr, j6 = (e, t, r) => {
  const i = new J0(e, r), o = new J0(t, r);
  return i.compare(o) || i.compareBuild(o);
};
var Ch = j6;
const U6 = Ch, F6 = (e, t) => e.sort((r, i) => U6(r, i, t));
var H6 = F6;
const z6 = Ch, V6 = (e, t) => e.sort((r, i) => z6(i, r, t));
var W6 = V6;
const K6 = Jr, Z6 = (e, t, r) => K6(e, t, r) > 0;
var $o = Z6;
const G6 = Jr, J6 = (e, t, r) => G6(e, t, r) < 0;
var Nh = J6;
const X6 = Jr, Y6 = (e, t, r) => X6(e, t, r) === 0;
var Ab = Y6;
const Q6 = Jr, e_ = (e, t, r) => Q6(e, t, r) !== 0;
var Mb = e_;
const t_ = Jr, r_ = (e, t, r) => t_(e, t, r) >= 0;
var Lh = r_;
const n_ = Jr, i_ = (e, t, r) => n_(e, t, r) <= 0;
var kh = i_;
const a_ = Ab, o_ = Mb, f_ = $o, s_ = Lh, u_ = Nh, c_ = kh, h_ = (e, t, r, i) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return a_(e, r, i);
    case "!=":
      return o_(e, r, i);
    case ">":
      return f_(e, r, i);
    case ">=":
      return s_(e, r, i);
    case "<":
      return u_(e, r, i);
    case "<=":
      return c_(e, r, i);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var Rb = h_;
const l_ = mr, d_ = Hi, { safeRe: ka, t: qa } = xa, p_ = (e, t) => {
  if (e instanceof l_)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
    r = e.match(ka[qa.COERCE]);
  else {
    let i;
    for (; (i = ka[qa.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || i.index + i[0].length !== r.index + r[0].length) && (r = i), ka[qa.COERCERTL].lastIndex = i.index + i[1].length + i[2].length;
    ka[qa.COERCERTL].lastIndex = -1;
  }
  return r === null ? null : d_(`${r[2]}.${r[3] || "0"}.${r[4] || "0"}`, t);
};
var v_ = p_, Ef, X0;
function b_() {
  return X0 || (X0 = 1, Ef = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), Ef;
}
var y_ = kt;
kt.Node = ti;
kt.create = kt;
function kt(e) {
  var t = this;
  if (t instanceof kt || (t = new kt()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(o) {
      t.push(o);
    });
  else if (arguments.length > 0)
    for (var r = 0, i = arguments.length; r < i; r++)
      t.push(arguments[r]);
  return t;
}
kt.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, r = e.prev;
  return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
kt.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
kt.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
kt.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    m_(this, arguments[e]);
  return this.length;
};
kt.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    w_(this, arguments[e]);
  return this.length;
};
kt.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
kt.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
kt.prototype.forEach = function(e, t) {
  t = t || this;
  for (var r = this.head, i = 0; r !== null; i++)
    e.call(t, r.value, i, this), r = r.next;
};
kt.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var r = this.tail, i = this.length - 1; r !== null; i--)
    e.call(t, r.value, i, this), r = r.prev;
};
kt.prototype.get = function(e) {
  for (var t = 0, r = this.head; r !== null && t < e; t++)
    r = r.next;
  if (t === e && r !== null)
    return r.value;
};
kt.prototype.getReverse = function(e) {
  for (var t = 0, r = this.tail; r !== null && t < e; t++)
    r = r.prev;
  if (t === e && r !== null)
    return r.value;
};
kt.prototype.map = function(e, t) {
  t = t || this;
  for (var r = new kt(), i = this.head; i !== null; )
    r.push(e.call(t, i.value, this)), i = i.next;
  return r;
};
kt.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var r = new kt(), i = this.tail; i !== null; )
    r.push(e.call(t, i.value, this)), i = i.prev;
  return r;
};
kt.prototype.reduce = function(e, t) {
  var r, i = this.head;
  if (arguments.length > 1)
    r = t;
  else if (this.head)
    i = this.head.next, r = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var o = 0; i !== null; o++)
    r = e(r, i.value, o), i = i.next;
  return r;
};
kt.prototype.reduceReverse = function(e, t) {
  var r, i = this.tail;
  if (arguments.length > 1)
    r = t;
  else if (this.tail)
    i = this.tail.prev, r = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var o = this.length - 1; i !== null; o--)
    r = e(r, i.value, o), i = i.prev;
  return r;
};
kt.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
    e[t] = r.value, r = r.next;
  return e;
};
kt.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
    e[t] = r.value, r = r.prev;
  return e;
};
kt.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new kt();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = 0, o = this.head; o !== null && i < e; i++)
    o = o.next;
  for (; o !== null && i < t; i++, o = o.next)
    r.push(o.value);
  return r;
};
kt.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new kt();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = this.length, o = this.tail; o !== null && i > t; i--)
    o = o.prev;
  for (; o !== null && i > e; i--, o = o.prev)
    r.push(o.value);
  return r;
};
kt.prototype.splice = function(e, t, ...r) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var i = 0, o = this.head; o !== null && i < e; i++)
    o = o.next;
  for (var n = [], i = 0; o && i < t; i++)
    n.push(o.value), o = this.removeNode(o);
  o === null && (o = this.tail), o !== this.head && o !== this.tail && (o = o.prev);
  for (var i = 0; i < r.length; i++)
    o = g_(this, o, r[i]);
  return n;
};
kt.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
    var i = r.prev;
    r.prev = r.next, r.next = i;
  }
  return this.head = t, this.tail = e, this;
};
function g_(e, t, r) {
  var i = t === e.head ? new ti(r, null, t, e) : new ti(r, t, t.next, e);
  return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
}
function m_(e, t) {
  e.tail = new ti(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function w_(e, t) {
  e.head = new ti(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function ti(e, t, r, i) {
  if (!(this instanceof ti))
    return new ti(e, t, r, i);
  this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
}
try {
  b_()(kt);
} catch {
}
const __ = y_, Fn = Symbol("max"), gn = Symbol("length"), ci = Symbol("lengthCalculator"), aa = Symbol("allowStale"), Kn = Symbol("maxAge"), vn = Symbol("dispose"), Y0 = Symbol("noDisposeOnSet"), or = Symbol("lruList"), Zr = Symbol("cache"), Bb = Symbol("updateAgeOnGet"), Sf = () => 1;
class x_ {
  constructor(t) {
    if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[Fn] = t.max || 1 / 0;
    const r = t.length || Sf;
    if (this[ci] = typeof r != "function" ? Sf : r, this[aa] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Kn] = t.maxAge || 0, this[vn] = t.dispose, this[Y0] = t.noDisposeOnSet || !1, this[Bb] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[Fn] = t || 1 / 0, Xi(this);
  }
  get max() {
    return this[Fn];
  }
  set allowStale(t) {
    this[aa] = !!t;
  }
  get allowStale() {
    return this[aa];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Kn] = t, Xi(this);
  }
  get maxAge() {
    return this[Kn];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = Sf), t !== this[ci] && (this[ci] = t, this[gn] = 0, this[or].forEach((r) => {
      r.length = this[ci](r.value, r.key), this[gn] += r.length;
    })), Xi(this);
  }
  get lengthCalculator() {
    return this[ci];
  }
  get length() {
    return this[gn];
  }
  get itemCount() {
    return this[or].length;
  }
  rforEach(t, r) {
    r = r || this;
    for (let i = this[or].tail; i !== null; ) {
      const o = i.prev;
      Q0(this, t, i, r), i = o;
    }
  }
  forEach(t, r) {
    r = r || this;
    for (let i = this[or].head; i !== null; ) {
      const o = i.next;
      Q0(this, t, i, r), i = o;
    }
  }
  keys() {
    return this[or].toArray().map((t) => t.key);
  }
  values() {
    return this[or].toArray().map((t) => t.value);
  }
  reset() {
    this[vn] && this[or] && this[or].length && this[or].forEach((t) => this[vn](t.key, t.value)), this[Zr] = /* @__PURE__ */ new Map(), this[or] = new __(), this[gn] = 0;
  }
  dump() {
    return this[or].map((t) => lo(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[or];
  }
  set(t, r, i) {
    if (i = i || this[Kn], i && typeof i != "number")
      throw new TypeError("maxAge must be a number");
    const o = i ? Date.now() : 0, n = this[ci](r, t);
    if (this[Zr].has(t)) {
      if (n > this[Fn])
        return Mi(this, this[Zr].get(t)), !1;
      const c = this[Zr].get(t).value;
      return this[vn] && (this[Y0] || this[vn](t, c.value)), c.now = o, c.maxAge = i, c.value = r, this[gn] += n - c.length, c.length = n, this.get(t), Xi(this), !0;
    }
    const f = new E_(t, r, n, o, i);
    return f.length > this[Fn] ? (this[vn] && this[vn](t, r), !1) : (this[gn] += f.length, this[or].unshift(f), this[Zr].set(t, this[or].head), Xi(this), !0);
  }
  has(t) {
    if (!this[Zr].has(t))
      return !1;
    const r = this[Zr].get(t).value;
    return !lo(this, r);
  }
  get(t) {
    return Af(this, t, !0);
  }
  peek(t) {
    return Af(this, t, !1);
  }
  pop() {
    const t = this[or].tail;
    return t ? (Mi(this, t), t.value) : null;
  }
  del(t) {
    Mi(this, this[Zr].get(t));
  }
  load(t) {
    this.reset();
    const r = Date.now();
    for (let i = t.length - 1; i >= 0; i--) {
      const o = t[i], n = o.e || 0;
      if (n === 0)
        this.set(o.k, o.v);
      else {
        const f = n - r;
        f > 0 && this.set(o.k, o.v, f);
      }
    }
  }
  prune() {
    this[Zr].forEach((t, r) => Af(this, r, !1));
  }
}
const Af = (e, t, r) => {
  const i = e[Zr].get(t);
  if (i) {
    const o = i.value;
    if (lo(e, o)) {
      if (Mi(e, i), !e[aa])
        return;
    } else
      r && (e[Bb] && (i.value.now = Date.now()), e[or].unshiftNode(i));
    return o.value;
  }
}, lo = (e, t) => {
  if (!t || !t.maxAge && !e[Kn])
    return !1;
  const r = Date.now() - t.now;
  return t.maxAge ? r > t.maxAge : e[Kn] && r > e[Kn];
}, Xi = (e) => {
  if (e[gn] > e[Fn])
    for (let t = e[or].tail; e[gn] > e[Fn] && t !== null; ) {
      const r = t.prev;
      Mi(e, t), t = r;
    }
}, Mi = (e, t) => {
  if (t) {
    const r = t.value;
    e[vn] && e[vn](r.key, r.value), e[gn] -= r.length, e[Zr].delete(r.key), e[or].removeNode(t);
  }
};
class E_ {
  constructor(t, r, i, o, n) {
    this.key = t, this.value = r, this.length = i, this.now = o, this.maxAge = n || 0;
  }
}
const Q0 = (e, t, r, i) => {
  let o = r.value;
  lo(e, o) && (Mi(e, r), e[aa] || (o = void 0)), o && t.call(i, o.value, o.key, e);
};
var S_ = x_, Mf, el;
function Xr() {
  if (el)
    return Mf;
  el = 1;
  class e {
    constructor(a, d) {
      if (d = i(d), a instanceof e)
        return a.loose === !!d.loose && a.includePrerelease === !!d.includePrerelease ? a : new e(a.raw, d);
      if (a instanceof o)
        return this.raw = a.value, this.set = [[a]], this.format(), this;
      if (this.options = d, this.loose = !!d.loose, this.includePrerelease = !!d.includePrerelease, this.raw = a.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((w) => this.parseRange(w.trim())).filter((w) => w.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const w = this.set[0];
        if (this.set = this.set.filter((x) => !E(x[0])), this.set.length === 0)
          this.set = [w];
        else if (this.set.length > 1) {
          for (const x of this.set)
            if (x.length === 1 && M(x[0])) {
              this.set = [x];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((a) => a.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(a) {
      const w = ((this.options.includePrerelease && v) | (this.options.loose && m)) + ":" + a, x = r.get(w);
      if (x)
        return x;
      const A = this.options.loose, S = A ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
      a = a.replace(S, j(this.options.includePrerelease)), n("hyphen replace", a), a = a.replace(u[c.COMPARATORTRIM], h), n("comparator trim", a), a = a.replace(u[c.TILDETRIM], s), n("tilde trim", a), a = a.replace(u[c.CARETTRIM], p), n("caret trim", a);
      let y = a.split(" ").map((ee) => B(ee, this.options)).join(" ").split(/\s+/).map((ee) => ue(ee, this.options));
      A && (y = y.filter((ee) => (n("loose invalid filter", ee, this.options), !!ee.match(u[c.COMPARATORLOOSE])))), n("range list", y);
      const _ = /* @__PURE__ */ new Map(), l = y.map((ee) => new o(ee, this.options));
      for (const ee of l) {
        if (E(ee))
          return [ee];
        _.set(ee.value, ee);
      }
      _.size > 1 && _.has("") && _.delete("");
      const R = [..._.values()];
      return r.set(w, R), R;
    }
    intersects(a, d) {
      if (!(a instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((w) => I(w, d) && a.set.some((x) => I(x, d) && w.every((A) => x.every((S) => A.intersects(S, d)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(a) {
      if (!a)
        return !1;
      if (typeof a == "string")
        try {
          a = new f(a, this.options);
        } catch {
          return !1;
        }
      for (let d = 0; d < this.set.length; d++)
        if (g(this.set[d], a, this.options))
          return !0;
      return !1;
    }
  }
  Mf = e;
  const t = S_, r = new t({ max: 1e3 }), i = Ph, o = Do(), n = qo, f = mr, {
    safeRe: u,
    t: c,
    comparatorTrimReplace: h,
    tildeTrimReplace: s,
    caretTrimReplace: p
  } = xa, { FLAG_INCLUDE_PRERELEASE: v, FLAG_LOOSE: m } = ko, E = (b) => b.value === "<0.0.0-0", M = (b) => b.value === "", I = (b, a) => {
    let d = !0;
    const w = b.slice();
    let x = w.pop();
    for (; d && w.length; )
      d = w.every((A) => x.intersects(A, a)), x = w.pop();
    return d;
  }, B = (b, a) => (n("comp", b, a), b = q(b, a), n("caret", b), b = k(b, a), n("tildes", b), b = U(b, a), n("xrange", b), b = Y(b, a), n("stars", b), b), T = (b) => !b || b.toLowerCase() === "x" || b === "*", k = (b, a) => b.trim().split(/\s+/).map((d) => N(d, a)).join(" "), N = (b, a) => {
    const d = a.loose ? u[c.TILDELOOSE] : u[c.TILDE];
    return b.replace(d, (w, x, A, S, y) => {
      n("tilde", b, w, x, A, S, y);
      let _;
      return T(x) ? _ = "" : T(A) ? _ = `>=${x}.0.0 <${+x + 1}.0.0-0` : T(S) ? _ = `>=${x}.${A}.0 <${x}.${+A + 1}.0-0` : y ? (n("replaceTilde pr", y), _ = `>=${x}.${A}.${S}-${y} <${x}.${+A + 1}.0-0`) : _ = `>=${x}.${A}.${S} <${x}.${+A + 1}.0-0`, n("tilde return", _), _;
    });
  }, q = (b, a) => b.trim().split(/\s+/).map((d) => D(d, a)).join(" "), D = (b, a) => {
    n("caret", b, a);
    const d = a.loose ? u[c.CARETLOOSE] : u[c.CARET], w = a.includePrerelease ? "-0" : "";
    return b.replace(d, (x, A, S, y, _) => {
      n("caret", b, x, A, S, y, _);
      let l;
      return T(A) ? l = "" : T(S) ? l = `>=${A}.0.0${w} <${+A + 1}.0.0-0` : T(y) ? A === "0" ? l = `>=${A}.${S}.0${w} <${A}.${+S + 1}.0-0` : l = `>=${A}.${S}.0${w} <${+A + 1}.0.0-0` : _ ? (n("replaceCaret pr", _), A === "0" ? S === "0" ? l = `>=${A}.${S}.${y}-${_} <${A}.${S}.${+y + 1}-0` : l = `>=${A}.${S}.${y}-${_} <${A}.${+S + 1}.0-0` : l = `>=${A}.${S}.${y}-${_} <${+A + 1}.0.0-0`) : (n("no pr"), A === "0" ? S === "0" ? l = `>=${A}.${S}.${y}${w} <${A}.${S}.${+y + 1}-0` : l = `>=${A}.${S}.${y}${w} <${A}.${+S + 1}.0-0` : l = `>=${A}.${S}.${y} <${+A + 1}.0.0-0`), n("caret return", l), l;
    });
  }, U = (b, a) => (n("replaceXRanges", b, a), b.split(/\s+/).map((d) => z(d, a)).join(" ")), z = (b, a) => {
    b = b.trim();
    const d = a.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
    return b.replace(d, (w, x, A, S, y, _) => {
      n("xRange", b, w, x, A, S, y, _);
      const l = T(A), R = l || T(S), ee = R || T(y), oe = ee;
      return x === "=" && oe && (x = ""), _ = a.includePrerelease ? "-0" : "", l ? x === ">" || x === "<" ? w = "<0.0.0-0" : w = "*" : x && oe ? (R && (S = 0), y = 0, x === ">" ? (x = ">=", R ? (A = +A + 1, S = 0, y = 0) : (S = +S + 1, y = 0)) : x === "<=" && (x = "<", R ? A = +A + 1 : S = +S + 1), x === "<" && (_ = "-0"), w = `${x + A}.${S}.${y}${_}`) : R ? w = `>=${A}.0.0${_} <${+A + 1}.0.0-0` : ee && (w = `>=${A}.${S}.0${_} <${A}.${+S + 1}.0-0`), n("xRange return", w), w;
    });
  }, Y = (b, a) => (n("replaceStars", b, a), b.trim().replace(u[c.STAR], "")), ue = (b, a) => (n("replaceGTE0", b, a), b.trim().replace(u[a.includePrerelease ? c.GTE0PRE : c.GTE0], "")), j = (b) => (a, d, w, x, A, S, y, _, l, R, ee, oe, V) => (T(w) ? d = "" : T(x) ? d = `>=${w}.0.0${b ? "-0" : ""}` : T(A) ? d = `>=${w}.${x}.0${b ? "-0" : ""}` : S ? d = `>=${d}` : d = `>=${d}${b ? "-0" : ""}`, T(l) ? _ = "" : T(R) ? _ = `<${+l + 1}.0.0-0` : T(ee) ? _ = `<${l}.${+R + 1}.0-0` : oe ? _ = `<=${l}.${R}.${ee}-${oe}` : b ? _ = `<${l}.${R}.${+ee + 1}-0` : _ = `<=${_}`, `${d} ${_}`.trim()), g = (b, a, d) => {
    for (let w = 0; w < b.length; w++)
      if (!b[w].test(a))
        return !1;
    if (a.prerelease.length && !d.includePrerelease) {
      for (let w = 0; w < b.length; w++)
        if (n(b[w].semver), b[w].semver !== o.ANY && b[w].semver.prerelease.length > 0) {
          const x = b[w].semver;
          if (x.major === a.major && x.minor === a.minor && x.patch === a.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Mf;
}
var Rf, tl;
function Do() {
  if (tl)
    return Rf;
  tl = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(s, p) {
      if (p = r(p), s instanceof t) {
        if (s.loose === !!p.loose)
          return s;
        s = s.value;
      }
      s = s.trim().split(/\s+/).join(" "), f("comparator", s, p), this.options = p, this.loose = !!p.loose, this.parse(s), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, f("comp", this);
    }
    parse(s) {
      const p = this.options.loose ? i[o.COMPARATORLOOSE] : i[o.COMPARATOR], v = s.match(p);
      if (!v)
        throw new TypeError(`Invalid comparator: ${s}`);
      this.operator = v[1] !== void 0 ? v[1] : "", this.operator === "=" && (this.operator = ""), v[2] ? this.semver = new u(v[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(s) {
      if (f("Comparator.test", s, this.options.loose), this.semver === e || s === e)
        return !0;
      if (typeof s == "string")
        try {
          s = new u(s, this.options);
        } catch {
          return !1;
        }
      return n(s, this.operator, this.semver, this.options);
    }
    intersects(s, p) {
      if (!(s instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(s.value, p).test(this.value) : s.operator === "" ? s.value === "" ? !0 : new c(this.value, p).test(s.semver) : (p = r(p), p.includePrerelease && (this.value === "<0.0.0-0" || s.value === "<0.0.0-0") || !p.includePrerelease && (this.value.startsWith("<0.0.0") || s.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && s.operator.startsWith(">") || this.operator.startsWith("<") && s.operator.startsWith("<") || this.semver.version === s.semver.version && this.operator.includes("=") && s.operator.includes("=") || n(this.semver, "<", s.semver, p) && this.operator.startsWith(">") && s.operator.startsWith("<") || n(this.semver, ">", s.semver, p) && this.operator.startsWith("<") && s.operator.startsWith(">")));
    }
  }
  Rf = t;
  const r = Ph, { safeRe: i, t: o } = xa, n = Rb, f = qo, u = mr, c = Xr();
  return Rf;
}
const A_ = Xr(), M_ = (e, t, r) => {
  try {
    t = new A_(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var jo = M_;
const R_ = Xr(), B_ = (e, t) => new R_(e, t).set.map((r) => r.map((i) => i.value).join(" ").trim().split(" "));
var I_ = B_;
const T_ = mr, O_ = Xr(), P_ = (e, t, r) => {
  let i = null, o = null, n = null;
  try {
    n = new O_(t, r);
  } catch {
    return null;
  }
  return e.forEach((f) => {
    n.test(f) && (!i || o.compare(f) === -1) && (i = f, o = new T_(i, r));
  }), i;
};
var C_ = P_;
const N_ = mr, L_ = Xr(), k_ = (e, t, r) => {
  let i = null, o = null, n = null;
  try {
    n = new L_(t, r);
  } catch {
    return null;
  }
  return e.forEach((f) => {
    n.test(f) && (!i || o.compare(f) === 1) && (i = f, o = new N_(i, r));
  }), i;
};
var q_ = k_;
const Bf = mr, $_ = Xr(), rl = $o, D_ = (e, t) => {
  e = new $_(e, t);
  let r = new Bf("0.0.0");
  if (e.test(r) || (r = new Bf("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let i = 0; i < e.set.length; ++i) {
    const o = e.set[i];
    let n = null;
    o.forEach((f) => {
      const u = new Bf(f.semver.version);
      switch (f.operator) {
        case ">":
          u.prerelease.length === 0 ? u.patch++ : u.prerelease.push(0), u.raw = u.format();
        case "":
        case ">=":
          (!n || rl(u, n)) && (n = u);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${f.operator}`);
      }
    }), n && (!r || rl(r, n)) && (r = n);
  }
  return r && e.test(r) ? r : null;
};
var j_ = D_;
const U_ = Xr(), F_ = (e, t) => {
  try {
    return new U_(e, t).range || "*";
  } catch {
    return null;
  }
};
var H_ = F_;
const z_ = mr, Ib = Do(), { ANY: V_ } = Ib, W_ = Xr(), K_ = jo, nl = $o, il = Nh, Z_ = kh, G_ = Lh, J_ = (e, t, r, i) => {
  e = new z_(e, i), t = new W_(t, i);
  let o, n, f, u, c;
  switch (r) {
    case ">":
      o = nl, n = Z_, f = il, u = ">", c = ">=";
      break;
    case "<":
      o = il, n = G_, f = nl, u = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (K_(e, t, i))
    return !1;
  for (let h = 0; h < t.set.length; ++h) {
    const s = t.set[h];
    let p = null, v = null;
    if (s.forEach((m) => {
      m.semver === V_ && (m = new Ib(">=0.0.0")), p = p || m, v = v || m, o(m.semver, p.semver, i) ? p = m : f(m.semver, v.semver, i) && (v = m);
    }), p.operator === u || p.operator === c || (!v.operator || v.operator === u) && n(e, v.semver))
      return !1;
    if (v.operator === c && f(e, v.semver))
      return !1;
  }
  return !0;
};
var qh = J_;
const X_ = qh, Y_ = (e, t, r) => X_(e, t, ">", r);
var Q_ = Y_;
const e3 = qh, t3 = (e, t, r) => e3(e, t, "<", r);
var r3 = t3;
const al = Xr(), n3 = (e, t, r) => (e = new al(e, r), t = new al(t, r), e.intersects(t, r));
var i3 = n3;
const a3 = jo, o3 = Jr;
var f3 = (e, t, r) => {
  const i = [];
  let o = null, n = null;
  const f = e.sort((s, p) => o3(s, p, r));
  for (const s of f)
    a3(s, t, r) ? (n = s, o || (o = s)) : (n && i.push([o, n]), n = null, o = null);
  o && i.push([o, null]);
  const u = [];
  for (const [s, p] of i)
    s === p ? u.push(s) : !p && s === f[0] ? u.push("*") : p ? s === f[0] ? u.push(`<=${p}`) : u.push(`${s} - ${p}`) : u.push(`>=${s}`);
  const c = u.join(" || "), h = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < h.length ? c : t;
};
const ol = Xr(), $h = Do(), { ANY: If } = $h, Yi = jo, Dh = Jr, s3 = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new ol(e, r), t = new ol(t, r);
  let i = !1;
  e:
    for (const o of e.set) {
      for (const n of t.set) {
        const f = c3(o, n, r);
        if (i = i || f !== null, f)
          continue e;
      }
      if (i)
        return !1;
    }
  return !0;
}, u3 = [new $h(">=0.0.0-0")], fl = [new $h(">=0.0.0")], c3 = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === If) {
    if (t.length === 1 && t[0].semver === If)
      return !0;
    r.includePrerelease ? e = u3 : e = fl;
  }
  if (t.length === 1 && t[0].semver === If) {
    if (r.includePrerelease)
      return !0;
    t = fl;
  }
  const i = /* @__PURE__ */ new Set();
  let o, n;
  for (const m of e)
    m.operator === ">" || m.operator === ">=" ? o = sl(o, m, r) : m.operator === "<" || m.operator === "<=" ? n = ul(n, m, r) : i.add(m.semver);
  if (i.size > 1)
    return null;
  let f;
  if (o && n) {
    if (f = Dh(o.semver, n.semver, r), f > 0)
      return null;
    if (f === 0 && (o.operator !== ">=" || n.operator !== "<="))
      return null;
  }
  for (const m of i) {
    if (o && !Yi(m, String(o), r) || n && !Yi(m, String(n), r))
      return null;
    for (const E of t)
      if (!Yi(m, String(E), r))
        return !1;
    return !0;
  }
  let u, c, h, s, p = n && !r.includePrerelease && n.semver.prerelease.length ? n.semver : !1, v = o && !r.includePrerelease && o.semver.prerelease.length ? o.semver : !1;
  p && p.prerelease.length === 1 && n.operator === "<" && p.prerelease[0] === 0 && (p = !1);
  for (const m of t) {
    if (s = s || m.operator === ">" || m.operator === ">=", h = h || m.operator === "<" || m.operator === "<=", o) {
      if (v && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === v.major && m.semver.minor === v.minor && m.semver.patch === v.patch && (v = !1), m.operator === ">" || m.operator === ">=") {
        if (u = sl(o, m, r), u === m && u !== o)
          return !1;
      } else if (o.operator === ">=" && !Yi(o.semver, String(m), r))
        return !1;
    }
    if (n) {
      if (p && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === p.major && m.semver.minor === p.minor && m.semver.patch === p.patch && (p = !1), m.operator === "<" || m.operator === "<=") {
        if (c = ul(n, m, r), c === m && c !== n)
          return !1;
      } else if (n.operator === "<=" && !Yi(n.semver, String(m), r))
        return !1;
    }
    if (!m.operator && (n || o) && f !== 0)
      return !1;
  }
  return !(o && h && !n && f !== 0 || n && s && !o && f !== 0 || v || p);
}, sl = (e, t, r) => {
  if (!e)
    return t;
  const i = Dh(e.semver, t.semver, r);
  return i > 0 ? e : i < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, ul = (e, t, r) => {
  if (!e)
    return t;
  const i = Dh(e.semver, t.semver, r);
  return i < 0 ? e : i > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var h3 = s3;
const Tf = xa, cl = ko, l3 = mr, hl = Sb, d3 = Hi, p3 = d6, v3 = b6, b3 = g6, y3 = w6, g3 = E6, m3 = M6, w3 = I6, _3 = P6, x3 = Jr, E3 = k6, S3 = D6, A3 = Ch, M3 = H6, R3 = W6, B3 = $o, I3 = Nh, T3 = Ab, O3 = Mb, P3 = Lh, C3 = kh, N3 = Rb, L3 = v_, k3 = Do(), q3 = Xr(), $3 = jo, D3 = I_, j3 = C_, U3 = q_, F3 = j_, H3 = H_, z3 = qh, V3 = Q_, W3 = r3, K3 = i3, Z3 = f3, G3 = h3;
var J3 = {
  parse: d3,
  valid: p3,
  clean: v3,
  inc: b3,
  diff: y3,
  major: g3,
  minor: m3,
  patch: w3,
  prerelease: _3,
  compare: x3,
  rcompare: E3,
  compareLoose: S3,
  compareBuild: A3,
  sort: M3,
  rsort: R3,
  gt: B3,
  lt: I3,
  eq: T3,
  neq: O3,
  gte: P3,
  lte: C3,
  cmp: N3,
  coerce: L3,
  Comparator: k3,
  Range: q3,
  satisfies: $3,
  toComparators: D3,
  maxSatisfying: j3,
  minSatisfying: U3,
  minVersion: F3,
  validRange: H3,
  outside: z3,
  gtr: V3,
  ltr: W3,
  intersects: K3,
  simplifyRange: Z3,
  subset: G3,
  SemVer: l3,
  re: Tf.re,
  src: Tf.src,
  tokens: Tf.t,
  SEMVER_SPEC_VERSION: cl.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: cl.RELEASE_TYPES,
  compareIdentifiers: hl.compareIdentifiers,
  rcompareIdentifiers: hl.rcompareIdentifiers
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
  const t = J3, r = ai, i = hr;
  e.VersionStruct = (0, r.refine)((0, r.string)(), "Version", (p) => (0, t.valid)(p) === null ? `Expected SemVer version, got "${p}"` : !0), e.VersionRangeStruct = (0, r.refine)((0, r.string)(), "Version range", (p) => (0, t.validRange)(p) === null ? `Expected SemVer range, got "${p}"` : !0);
  function o(p) {
    return (0, r.is)(p, e.VersionStruct);
  }
  e.isValidSemVerVersion = o;
  function n(p) {
    return (0, r.is)(p, e.VersionRangeStruct);
  }
  e.isValidSemVerRange = n;
  function f(p) {
    (0, i.assertStruct)(p, e.VersionStruct);
  }
  e.assertIsSemVerVersion = f;
  function u(p) {
    (0, i.assertStruct)(p, e.VersionRangeStruct);
  }
  e.assertIsSemVerRange = u;
  function c(p, v) {
    return (0, t.gt)(p, v);
  }
  e.gtVersion = c;
  function h(p, v) {
    return (0, t.gtr)(p, v);
  }
  e.gtRange = h;
  function s(p, v) {
    return (0, t.satisfies)(p, v, {
      includePrerelease: !0
    });
  }
  e.satisfiesVersionRange = s;
})(_b);
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, o, n, f) {
    f === void 0 && (f = n);
    var u = Object.getOwnPropertyDescriptor(o, n);
    (!u || ("get" in u ? !o.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return o[n];
    } }), Object.defineProperty(i, f, u);
  } : function(i, o, n, f) {
    f === void 0 && (f = n), i[f] = o[n];
  }), r = Ze && Ze.__exportStar || function(i, o) {
    for (var n in i)
      n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, i, n);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(hr, e), r(wa, e), r(Lt, e), r(No, e), r(on, e), r(Ti, e), r(_a, e), r(gb, e), r(Oi, e), r(Oh, e), r(fn, e), r(mb, e), r(wb, e), r(_b, e);
})(Zv);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
  const t = Zv;
  Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
    return t.createModuleLogger;
  } }), e.projectLogger = t.createProjectLogger("eth-json-rpc-middleware");
})(ji);
var sr = {}, $a = {}, Of, ll;
function X3() {
  if (ll)
    return Of;
  ll = 1;
  var e, t, r = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, i;
  function o(m) {
    throw {
      name: "SyntaxError",
      message: m,
      at: e,
      text: i
    };
  }
  function n(m) {
    return m && m !== t && o("Expected '" + m + "' instead of '" + t + "'"), t = i.charAt(e), e += 1, t;
  }
  function f() {
    var m, E = "";
    for (t === "-" && (E = "-", n("-")); t >= "0" && t <= "9"; )
      E += t, n();
    if (t === ".")
      for (E += "."; n() && t >= "0" && t <= "9"; )
        E += t;
    if (t === "e" || t === "E")
      for (E += t, n(), (t === "-" || t === "+") && (E += t, n()); t >= "0" && t <= "9"; )
        E += t, n();
    return m = Number(E), isFinite(m) || o("Bad number"), m;
  }
  function u() {
    var m, E, M = "", I;
    if (t === '"')
      for (; n(); ) {
        if (t === '"')
          return n(), M;
        if (t === "\\")
          if (n(), t === "u") {
            for (I = 0, E = 0; E < 4 && (m = parseInt(n(), 16), !!isFinite(m)); E += 1)
              I = I * 16 + m;
            M += String.fromCharCode(I);
          } else if (typeof r[t] == "string")
            M += r[t];
          else
            break;
        else
          M += t;
      }
    o("Bad string");
  }
  function c() {
    for (; t && t <= " "; )
      n();
  }
  function h() {
    switch (t) {
      case "t":
        return n("t"), n("r"), n("u"), n("e"), !0;
      case "f":
        return n("f"), n("a"), n("l"), n("s"), n("e"), !1;
      case "n":
        return n("n"), n("u"), n("l"), n("l"), null;
      default:
        o("Unexpected '" + t + "'");
    }
  }
  function s() {
    var m = [];
    if (t === "[") {
      if (n("["), c(), t === "]")
        return n("]"), m;
      for (; t; ) {
        if (m.push(v()), c(), t === "]")
          return n("]"), m;
        n(","), c();
      }
    }
    o("Bad array");
  }
  function p() {
    var m, E = {};
    if (t === "{") {
      if (n("{"), c(), t === "}")
        return n("}"), E;
      for (; t; ) {
        if (m = u(), c(), n(":"), Object.prototype.hasOwnProperty.call(E, m) && o('Duplicate key "' + m + '"'), E[m] = v(), c(), t === "}")
          return n("}"), E;
        n(","), c();
      }
    }
    o("Bad object");
  }
  function v() {
    switch (c(), t) {
      case "{":
        return p();
      case "[":
        return s();
      case '"':
        return u();
      case "-":
        return f();
      default:
        return t >= "0" && t <= "9" ? f() : h();
    }
  }
  return Of = function(m, E) {
    var M;
    return i = m, e = 0, t = " ", M = v(), c(), t && o("Syntax error"), typeof E == "function" ? function I(B, T) {
      var k, N, q = B[T];
      if (q && typeof q == "object")
        for (k in v)
          Object.prototype.hasOwnProperty.call(q, k) && (N = I(q, k), typeof N > "u" ? delete q[k] : q[k] = N);
      return E.call(B, T, q);
    }({ "": M }, "") : M;
  }, Of;
}
var Pf, dl;
function Y3() {
  if (dl)
    return Pf;
  dl = 1;
  var e = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, t, r, i = {
    // table of character substitutions
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  }, o;
  function n(u) {
    return e.lastIndex = 0, e.test(u) ? '"' + u.replace(e, function(c) {
      var h = i[c];
      return typeof h == "string" ? h : "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + u + '"';
  }
  function f(u, c) {
    var h, s, p, v, m = t, E, M = c[u];
    switch (M && typeof M == "object" && typeof M.toJSON == "function" && (M = M.toJSON(u)), typeof o == "function" && (M = o.call(c, u, M)), typeof M) {
      case "string":
        return n(M);
      case "number":
        return isFinite(M) ? String(M) : "null";
      case "boolean":
      case "null":
        return String(M);
      case "object":
        if (!M)
          return "null";
        if (t += r, E = [], Object.prototype.toString.apply(M) === "[object Array]") {
          for (v = M.length, h = 0; h < v; h += 1)
            E[h] = f(h, M) || "null";
          return p = E.length === 0 ? "[]" : t ? `[
` + t + E.join(`,
` + t) + `
` + m + "]" : "[" + E.join(",") + "]", t = m, p;
        }
        if (o && typeof o == "object")
          for (v = o.length, h = 0; h < v; h += 1)
            s = o[h], typeof s == "string" && (p = f(s, M), p && E.push(n(s) + (t ? ": " : ":") + p));
        else
          for (s in M)
            Object.prototype.hasOwnProperty.call(M, s) && (p = f(s, M), p && E.push(n(s) + (t ? ": " : ":") + p));
        return p = E.length === 0 ? "{}" : t ? `{
` + t + E.join(`,
` + t) + `
` + m + "}" : "{" + E.join(",") + "}", t = m, p;
    }
  }
  return Pf = function(u, c, h) {
    var s;
    if (t = "", r = "", typeof h == "number")
      for (s = 0; s < h; s += 1)
        r += " ";
    else
      typeof h == "string" && (r = h);
    if (o = c, c && typeof c != "function" && (typeof c != "object" || typeof c.length != "number"))
      throw new Error("JSON.stringify");
    return f("", { "": u });
  }, Pf;
}
var pl;
function Q3() {
  return pl || (pl = 1, $a.parse = X3(), $a.stringify = Y3()), $a;
}
var e4 = {}.toString, t4 = Array.isArray || function(e) {
  return e4.call(e) == "[object Array]";
}, vl = Object.prototype.toString, Tb = function(t) {
  var r = vl.call(t), i = r === "[object Arguments]";
  return i || (i = r !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && vl.call(t.callee) === "[object Function]"), i;
}, Cf, bl;
function r4() {
  if (bl)
    return Cf;
  bl = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, r = Object.prototype.toString, i = Tb, o = Object.prototype.propertyIsEnumerable, n = !o.call({ toString: null }, "toString"), f = o.call(function() {
    }, "prototype"), u = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], c = function(v) {
      var m = v.constructor;
      return m && m.prototype === v;
    }, h = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, s = function() {
      if (typeof window > "u")
        return !1;
      for (var v in window)
        try {
          if (!h["$" + v] && t.call(window, v) && window[v] !== null && typeof window[v] == "object")
            try {
              c(window[v]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), p = function(v) {
      if (typeof window > "u" || !s)
        return c(v);
      try {
        return c(v);
      } catch {
        return !1;
      }
    };
    e = function(m) {
      var E = m !== null && typeof m == "object", M = r.call(m) === "[object Function]", I = i(m), B = E && r.call(m) === "[object String]", T = [];
      if (!E && !M && !I)
        throw new TypeError("Object.keys called on a non-object");
      var k = f && M;
      if (B && m.length > 0 && !t.call(m, 0))
        for (var N = 0; N < m.length; ++N)
          T.push(String(N));
      if (I && m.length > 0)
        for (var q = 0; q < m.length; ++q)
          T.push(String(q));
      else
        for (var D in m)
          !(k && D === "prototype") && t.call(m, D) && T.push(String(D));
      if (n)
        for (var U = p(m), z = 0; z < u.length; ++z)
          !(U && u[z] === "constructor") && t.call(m, u[z]) && T.push(u[z]);
      return T;
    };
  }
  return Cf = e, Cf;
}
var n4 = Array.prototype.slice, i4 = Tb, yl = Object.keys, ao = yl ? function(t) {
  return yl(t);
} : r4(), gl = Object.keys;
ao.shim = function() {
  if (Object.keys) {
    var t = function() {
      var r = Object.keys(arguments);
      return r && r.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(i) {
      return i4(i) ? gl(n4.call(i)) : gl(i);
    });
  } else
    Object.keys = ao;
  return Object.keys || ao;
};
var jh = ao, Ob = { exports: {} }, a4 = "Function.prototype.bind called on incompatible ", o4 = Object.prototype.toString, f4 = Math.max, s4 = "[object Function]", ml = function(t, r) {
  for (var i = [], o = 0; o < t.length; o += 1)
    i[o] = t[o];
  for (var n = 0; n < r.length; n += 1)
    i[n + t.length] = r[n];
  return i;
}, u4 = function(t, r) {
  for (var i = [], o = r || 0, n = 0; o < t.length; o += 1, n += 1)
    i[n] = t[o];
  return i;
}, c4 = function(e, t) {
  for (var r = "", i = 0; i < e.length; i += 1)
    r += e[i], i + 1 < e.length && (r += t);
  return r;
}, h4 = function(t) {
  var r = this;
  if (typeof r != "function" || o4.apply(r) !== s4)
    throw new TypeError(a4 + r);
  for (var i = u4(arguments, 1), o, n = function() {
    if (this instanceof o) {
      var s = r.apply(
        this,
        ml(i, arguments)
      );
      return Object(s) === s ? s : this;
    }
    return r.apply(
      t,
      ml(i, arguments)
    );
  }, f = f4(0, r.length - i.length), u = [], c = 0; c < f; c++)
    u[c] = "$" + c;
  if (o = Function("binder", "return function (" + c4(u, ",") + "){ return binder.apply(this,arguments); }")(n), r.prototype) {
    var h = function() {
    };
    h.prototype = r.prototype, o.prototype = new h(), h.prototype = null;
  }
  return o;
}, l4 = h4, Uh = Function.prototype.bind || l4, Fh = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, r = Symbol("test"), i = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var o = 42;
  t[r] = o;
  for (r in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var n = Object.getOwnPropertySymbols(t);
  if (n.length !== 1 || n[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var f = Object.getOwnPropertyDescriptor(t, r);
    if (f.value !== o || f.enumerable !== !0)
      return !1;
  }
  return !0;
}, wl = typeof Symbol < "u" && Symbol, d4 = Fh, p4 = function() {
  return typeof wl != "function" || typeof Symbol != "function" || typeof wl("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : d4();
}, _l = {
  foo: {}
}, v4 = Object, b4 = function() {
  return { __proto__: _l }.foo === _l.foo && !({ __proto__: null } instanceof v4);
}, y4 = Function.prototype.call, g4 = Object.prototype.hasOwnProperty, m4 = Uh, w4 = m4.call(y4, g4), Tt, Pi = SyntaxError, Pb = Function, Ri = TypeError, Nf = function(e) {
  try {
    return Pb('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Yn = Object.getOwnPropertyDescriptor;
if (Yn)
  try {
    Yn({}, "");
  } catch {
    Yn = null;
  }
var Lf = function() {
  throw new Ri();
}, _4 = Yn ? function() {
  try {
    return arguments.callee, Lf;
  } catch {
    try {
      return Yn(arguments, "callee").get;
    } catch {
      return Lf;
    }
  }
}() : Lf, hi = p4(), x4 = b4(), fr = Object.getPrototypeOf || (x4 ? function(e) {
  return e.__proto__;
} : null), gi = {}, E4 = typeof Uint8Array > "u" || !fr ? Tt : fr(Uint8Array), Qn = {
  "%AggregateError%": typeof AggregateError > "u" ? Tt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Tt : ArrayBuffer,
  "%ArrayIteratorPrototype%": hi && fr ? fr([][Symbol.iterator]()) : Tt,
  "%AsyncFromSyncIteratorPrototype%": Tt,
  "%AsyncFunction%": gi,
  "%AsyncGenerator%": gi,
  "%AsyncGeneratorFunction%": gi,
  "%AsyncIteratorPrototype%": gi,
  "%Atomics%": typeof Atomics > "u" ? Tt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Tt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Tt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Tt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Tt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? Tt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Tt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Tt : FinalizationRegistry,
  "%Function%": Pb,
  "%GeneratorFunction%": gi,
  "%Int8Array%": typeof Int8Array > "u" ? Tt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Tt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Tt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hi && fr ? fr(fr([][Symbol.iterator]())) : Tt,
  "%JSON%": typeof JSON == "object" ? JSON : Tt,
  "%Map%": typeof Map > "u" ? Tt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hi || !fr ? Tt : fr((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Tt : Promise,
  "%Proxy%": typeof Proxy > "u" ? Tt : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? Tt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Tt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hi || !fr ? Tt : fr((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Tt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hi && fr ? fr(""[Symbol.iterator]()) : Tt,
  "%Symbol%": hi ? Symbol : Tt,
  "%SyntaxError%": Pi,
  "%ThrowTypeError%": _4,
  "%TypedArray%": E4,
  "%TypeError%": Ri,
  "%Uint8Array%": typeof Uint8Array > "u" ? Tt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Tt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Tt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Tt : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? Tt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Tt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Tt : WeakSet
};
if (fr)
  try {
    null.error;
  } catch (e) {
    var S4 = fr(fr(e));
    Qn["%Error.prototype%"] = S4;
  }
var A4 = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Nf("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Nf("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Nf("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (r = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var o = e("%AsyncGenerator%");
    o && fr && (r = fr(o.prototype));
  }
  return Qn[t] = r, r;
}, xl = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Ea = Uh, po = w4, M4 = Ea.call(Function.call, Array.prototype.concat), R4 = Ea.call(Function.apply, Array.prototype.splice), El = Ea.call(Function.call, String.prototype.replace), vo = Ea.call(Function.call, String.prototype.slice), B4 = Ea.call(Function.call, RegExp.prototype.exec), I4 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, T4 = /\\(\\)?/g, O4 = function(t) {
  var r = vo(t, 0, 1), i = vo(t, -1);
  if (r === "%" && i !== "%")
    throw new Pi("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && r !== "%")
    throw new Pi("invalid intrinsic syntax, expected opening `%`");
  var o = [];
  return El(t, I4, function(n, f, u, c) {
    o[o.length] = u ? El(c, T4, "$1") : f || n;
  }), o;
}, P4 = function(t, r) {
  var i = t, o;
  if (po(xl, i) && (o = xl[i], i = "%" + o[0] + "%"), po(Qn, i)) {
    var n = Qn[i];
    if (n === gi && (n = A4(i)), typeof n > "u" && !r)
      throw new Ri("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: o,
      name: i,
      value: n
    };
  }
  throw new Pi("intrinsic " + t + " does not exist!");
}, zi = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Ri("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Ri('"allowMissing" argument must be a boolean');
  if (B4(/^%?[^%]*%?$/, t) === null)
    throw new Pi("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = O4(t), o = i.length > 0 ? i[0] : "", n = P4("%" + o + "%", r), f = n.name, u = n.value, c = !1, h = n.alias;
  h && (o = h[0], R4(i, M4([0, 1], h)));
  for (var s = 1, p = !0; s < i.length; s += 1) {
    var v = i[s], m = vo(v, 0, 1), E = vo(v, -1);
    if ((m === '"' || m === "'" || m === "`" || E === '"' || E === "'" || E === "`") && m !== E)
      throw new Pi("property names with quotes must have matching quotes");
    if ((v === "constructor" || !p) && (c = !0), o += "." + v, f = "%" + o + "%", po(Qn, f))
      u = Qn[f];
    else if (u != null) {
      if (!(v in u)) {
        if (!r)
          throw new Ri("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Yn && s + 1 >= i.length) {
        var M = Yn(u, v);
        p = !!M, p && "get" in M && !("originalValue" in M.get) ? u = M.get : u = u[v];
      } else
        p = po(u, v), u = u[v];
      p && !c && (Qn[f] = u);
    }
  }
  return u;
}, C4 = zi, eh = C4("%Object.defineProperty%", !0), th = function() {
  if (eh)
    try {
      return eh({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
th.hasArrayLengthDefineBug = function() {
  if (!th())
    return null;
  try {
    return eh([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var Hh = th, N4 = zi, oo = N4("%Object.getOwnPropertyDescriptor%", !0);
if (oo)
  try {
    oo([], "length");
  } catch {
    oo = null;
  }
var zh = oo, L4 = Hh(), Vh = zi, oa = L4 && Vh("%Object.defineProperty%", !0);
if (oa)
  try {
    oa({}, "a", { value: 1 });
  } catch {
    oa = !1;
  }
var k4 = Vh("%SyntaxError%"), li = Vh("%TypeError%"), Sl = zh, Cb = function(t, r, i) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new li("`obj` must be an object or a function`");
  if (typeof r != "string" && typeof r != "symbol")
    throw new li("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new li("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new li("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new li("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new li("`loose`, if provided, must be a boolean");
  var o = arguments.length > 3 ? arguments[3] : null, n = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 ? arguments[6] : !1, c = !!Sl && Sl(t, r);
  if (oa)
    oa(t, r, {
      configurable: f === null && c ? c.configurable : !f,
      enumerable: o === null && c ? c.enumerable : !o,
      value: i,
      writable: n === null && c ? c.writable : !n
    });
  else if (u || !o && !n && !f)
    t[r] = i;
  else
    throw new k4("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, Nb = zi, Al = Cb, q4 = Hh(), Ml = zh, Rl = Nb("%TypeError%"), $4 = Nb("%Math.floor%"), D4 = function(t, r) {
  if (typeof t != "function")
    throw new Rl("`fn` is not a function");
  if (typeof r != "number" || r < 0 || r > 4294967295 || $4(r) !== r)
    throw new Rl("`length` must be a positive 32-bit integer");
  var i = arguments.length > 2 && !!arguments[2], o = !0, n = !0;
  if ("length" in t && Ml) {
    var f = Ml(t, "length");
    f && !f.configurable && (o = !1), f && !f.writable && (n = !1);
  }
  return (o || n || !i) && (q4 ? Al(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    r,
    !0,
    !0
  ) : Al(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    r
  )), t;
};
(function(e) {
  var t = Uh, r = zi, i = D4, o = r("%TypeError%"), n = r("%Function.prototype.apply%"), f = r("%Function.prototype.call%"), u = r("%Reflect.apply%", !0) || t.call(f, n), c = r("%Object.defineProperty%", !0), h = r("%Math.max%");
  if (c)
    try {
      c({}, "a", { value: 1 });
    } catch {
      c = null;
    }
  e.exports = function(v) {
    if (typeof v != "function")
      throw new o("a function is required");
    var m = u(t, f, arguments);
    return i(
      m,
      1 + h(0, v.length - (arguments.length - 1)),
      !0
    );
  };
  var s = function() {
    return u(t, n, arguments);
  };
  c ? c(e.exports, "apply", { value: s }) : e.exports.apply = s;
})(Ob);
var Sa = Ob.exports, Lb = zi, kb = Sa, j4 = kb(Lb("String.prototype.indexOf")), Aa = function(t, r) {
  var i = Lb(t, !!r);
  return typeof i == "function" && j4(t, ".prototype.") > -1 ? kb(i) : i;
}, Da = (typeof JSON < "u" ? JSON : Q3()).stringify, U4 = t4, F4 = jh, H4 = Sa, qb = Aa, Bl = qb("Array.prototype.join"), kf = qb("Array.prototype.push"), Il = function(t, r) {
  for (var i = "", o = 0; o < t; o += 1)
    i += r;
  return i;
}, z4 = function(e, t, r) {
  return r;
}, V4 = function(t) {
  var r = arguments.length > 1 ? arguments[1] : void 0, i = r && r.space || "";
  typeof i == "number" && (i = Il(i, " "));
  var o = !!r && typeof r.cycles == "boolean" && r.cycles, n = r && r.replacer ? H4(r.replacer) : z4, f = typeof r == "function" ? r : r && r.cmp, u = f && function(h) {
    var s = f.length > 2 && function(v) {
      return h[v];
    };
    return function(p, v) {
      return f(
        { key: p, value: h[p] },
        { key: v, value: h[v] },
        s ? { __proto__: null, get: s } : void 0
      );
    };
  }, c = [];
  return function h(s, p, v, m) {
    var E = i ? `
` + Il(m, i) : "", M = i ? ": " : ":";
    if (v && v.toJSON && typeof v.toJSON == "function" && (v = v.toJSON()), v = n(s, p, v), v !== void 0) {
      if (typeof v != "object" || v === null)
        return Da(v);
      if (U4(v)) {
        for (var k = [], I = 0; I < v.length; I++) {
          var B = h(v, I, v[I], m + 1) || Da(null);
          kf(k, E + i + B);
        }
        return "[" + Bl(k, ",") + E + "]";
      }
      if (c.indexOf(v) !== -1) {
        if (o)
          return Da("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      } else
        kf(c, v);
      for (var T = F4(v).sort(u && u(v)), k = [], I = 0; I < T.length; I++) {
        var p = T[I], N = h(v, p, v[p], m + 1);
        if (N) {
          var q = Da(p) + M + N;
          kf(k, E + i + q);
        }
      }
      return c.splice(c.indexOf(v), 1), "{" + Bl(k, ",") + E + "}";
    }
  }({ "": t }, "", t, 0);
}, W4 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.cacheTypeForPayload = sr.blockTagParamIndex = sr.paramsWithoutBlockTag = sr.blockTagForPayload = sr.canCache = sr.cacheIdentifierForPayload = void 0;
const K4 = W4(V4);
function Z4(e, t) {
  var r;
  const i = t ? Db(e) : (r = e.params) !== null && r !== void 0 ? r : [];
  return $b(e) ? `${e.method}:${K4.default(i)}` : null;
}
sr.cacheIdentifierForPayload = Z4;
function $b(e) {
  return jb(e) !== "never";
}
sr.canCache = $b;
function G4(e) {
  if (!e.params)
    return;
  const t = Wh(e);
  if (!(t === void 0 || t >= e.params.length))
    return e.params[t];
}
sr.blockTagForPayload = G4;
function Db(e) {
  if (!e.params)
    return [];
  const t = Wh(e);
  return t === void 0 || t >= e.params.length ? e.params : e.method === "eth_getBlockByNumber" ? e.params.slice(1) : e.params.slice(0, t);
}
sr.paramsWithoutBlockTag = Db;
function Wh(e) {
  switch (e.method) {
    case "eth_getStorageAt":
      return 2;
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    case "eth_getBlockByNumber":
      return 0;
    default:
      return;
  }
}
sr.blockTagParamIndex = Wh;
function jb(e) {
  switch (e.method) {
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return "perma";
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return "fork";
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return "block";
    default:
      return "never";
  }
}
sr.cacheTypeForPayload = jb;
Object.defineProperty(Oo, "__esModule", { value: !0 });
Oo.createBlockCacheMiddleware = void 0;
const J4 = Br, Tl = ji, wi = sr, di = Tl.createModuleLogger(Tl.projectLogger, "block-cache"), X4 = [void 0, null, "<nil>"];
class Y4 {
  constructor() {
    this.cache = {};
  }
  getBlockCacheForPayload(t, r) {
    const i = Number.parseInt(r, 16);
    let o = this.cache[i];
    if (!o) {
      const n = {};
      this.cache[i] = n, o = n;
    }
    return o;
  }
  async get(t, r) {
    const i = this.getBlockCacheForPayload(t, r), o = wi.cacheIdentifierForPayload(t, !0);
    return o ? i[o] : void 0;
  }
  async set(t, r, i) {
    if (!this.canCacheResult(t, i))
      return;
    const n = wi.cacheIdentifierForPayload(t, !0);
    if (!n)
      return;
    const f = this.getBlockCacheForPayload(t, r);
    f[n] = i;
  }
  canCacheRequest(t) {
    return !(!wi.canCache(t) || wi.blockTagForPayload(t) === "pending");
  }
  canCacheResult(t, r) {
    return !(X4.includes(r) || t.method && ["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(t.method) && (!r || !r.blockHash || r.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000"));
  }
  // removes all block caches with block number lower than `oldBlockHex`
  clearBefore(t) {
    const r = Number.parseInt(t, 16);
    Object.keys(this.cache).map(Number).filter((i) => i < r).forEach((i) => delete this.cache[i]);
  }
}
function Q4({ blockTracker: e } = {}) {
  if (!e)
    throw new Error("createBlockCacheMiddleware - No PollingBlockTracker specified");
  const t = new Y4(), r = {
    perma: t,
    block: t,
    fork: t
  };
  return J4.createAsyncMiddleware(async (i, o, n) => {
    if (i.skipCache)
      return n();
    const f = wi.cacheTypeForPayload(i), u = r[f];
    if (!u || !u.canCacheRequest(i))
      return n();
    let c = wi.blockTagForPayload(i);
    c || (c = "latest"), di("blockTag = %o, req = %o", c, i);
    let h;
    if (c === "earliest")
      h = "0x00";
    else if (c === "latest") {
      di("Fetching latest block number to determine cache key");
      const p = await e.getLatestBlock();
      di("Clearing values stored under block numbers before %o", p), t.clearBefore(p), h = p;
    } else
      h = c;
    const s = await u.get(i, h);
    s === void 0 ? (di("No cache stored under block number %o, carrying request forward", h), await n(), di("Populating cache with", o), await u.set(i, h, o.result)) : (di("Cache hit, reusing cache result stored under block number %o", h), o.result = s);
  });
}
Oo.createBlockCacheMiddleware = Q4;
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.createBlockRefRewriteMiddleware = void 0;
const e8 = Br, t8 = sr;
function r8({ blockTracker: e } = {}) {
  if (!e)
    throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
  return e8.createAsyncMiddleware(async (t, r, i) => {
    var o;
    const n = t8.blockTagParamIndex(t);
    if (n === void 0)
      return i();
    let f = (o = t.params) === null || o === void 0 ? void 0 : o[n];
    if (f === void 0 && (f = "latest"), f !== "latest")
      return i();
    const u = await e.getLatestBlock();
    return t.params && (t.params[n] = u), i();
  });
}
Uo.createBlockRefRewriteMiddleware = r8;
var Fo = {}, Ub = { exports: {} };
(function(e) {
  var t = function() {
    function r(v, m) {
      return m != null && v instanceof m;
    }
    var i;
    try {
      i = Map;
    } catch {
      i = function() {
      };
    }
    var o;
    try {
      o = Set;
    } catch {
      o = function() {
      };
    }
    var n;
    try {
      n = Promise;
    } catch {
      n = function() {
      };
    }
    function f(v, m, E, M, I) {
      typeof m == "object" && (E = m.depth, M = m.prototype, I = m.includeNonEnumerable, m = m.circular);
      var B = [], T = [], k = typeof Le.Buffer < "u";
      typeof m > "u" && (m = !0), typeof E > "u" && (E = 1 / 0);
      function N(q, D) {
        if (q === null)
          return null;
        if (D === 0)
          return q;
        var U, z;
        if (typeof q != "object")
          return q;
        if (r(q, i))
          U = new i();
        else if (r(q, o))
          U = new o();
        else if (r(q, n))
          U = new n(function(x, A) {
            q.then(function(S) {
              x(N(S, D - 1));
            }, function(S) {
              A(N(S, D - 1));
            });
          });
        else if (f.__isArray(q))
          U = [];
        else if (f.__isRegExp(q))
          U = new RegExp(q.source, p(q)), q.lastIndex && (U.lastIndex = q.lastIndex);
        else if (f.__isDate(q))
          U = new Date(q.getTime());
        else {
          if (k && Le.Buffer.isBuffer(q))
            return Le.Buffer.allocUnsafe ? U = Le.Buffer.allocUnsafe(q.length) : U = new Le.Buffer(q.length), q.copy(U), U;
          r(q, Error) ? U = Object.create(q) : typeof M > "u" ? (z = Object.getPrototypeOf(q), U = Object.create(z)) : (U = Object.create(M), z = M);
        }
        if (m) {
          var Y = B.indexOf(q);
          if (Y != -1)
            return T[Y];
          B.push(q), T.push(U);
        }
        r(q, i) && q.forEach(function(x, A) {
          var S = N(A, D - 1), y = N(x, D - 1);
          U.set(S, y);
        }), r(q, o) && q.forEach(function(x) {
          var A = N(x, D - 1);
          U.add(A);
        });
        for (var ue in q) {
          var j;
          z && (j = Object.getOwnPropertyDescriptor(z, ue)), !(j && j.set == null) && (U[ue] = N(q[ue], D - 1));
        }
        if (Object.getOwnPropertySymbols)
          for (var g = Object.getOwnPropertySymbols(q), ue = 0; ue < g.length; ue++) {
            var b = g[ue], a = Object.getOwnPropertyDescriptor(q, b);
            a && !a.enumerable && !I || (U[b] = N(q[b], D - 1), a.enumerable || Object.defineProperty(U, b, {
              enumerable: !1
            }));
          }
        if (I)
          for (var d = Object.getOwnPropertyNames(q), ue = 0; ue < d.length; ue++) {
            var w = d[ue], a = Object.getOwnPropertyDescriptor(q, w);
            a && a.enumerable || (U[w] = N(q[w], D - 1), Object.defineProperty(U, w, {
              enumerable: !1
            }));
          }
        return U;
      }
      return N(v, E);
    }
    f.clonePrototype = function(m) {
      if (m === null)
        return null;
      var E = function() {
      };
      return E.prototype = m, new E();
    };
    function u(v) {
      return Object.prototype.toString.call(v);
    }
    f.__objToStr = u;
    function c(v) {
      return typeof v == "object" && u(v) === "[object Date]";
    }
    f.__isDate = c;
    function h(v) {
      return typeof v == "object" && u(v) === "[object Array]";
    }
    f.__isArray = h;
    function s(v) {
      return typeof v == "object" && u(v) === "[object RegExp]";
    }
    f.__isRegExp = s;
    function p(v) {
      var m = "";
      return v.global && (m += "g"), v.ignoreCase && (m += "i"), v.multiline && (m += "m"), m;
    }
    return f.__getRegExpFlags = p, f;
  }();
  e.exports && (e.exports = t);
})(Ub);
var Kh = Ub.exports;
const Ol = (e, t) => function() {
  const r = t.promiseModule, i = new Array(arguments.length);
  for (let o = 0; o < arguments.length; o++)
    i[o] = arguments[o];
  return new r((o, n) => {
    t.errorFirst ? i.push(function(f, u) {
      if (t.multiArgs) {
        const c = new Array(arguments.length - 1);
        for (let h = 1; h < arguments.length; h++)
          c[h - 1] = arguments[h];
        f ? (c.unshift(f), n(c)) : o(c);
      } else
        f ? n(f) : o(u);
    }) : i.push(function(f) {
      if (t.multiArgs) {
        const u = new Array(arguments.length - 1);
        for (let c = 0; c < arguments.length; c++)
          u[c] = arguments[c];
        o(u);
      } else
        o(f);
    }), e.apply(this, i);
  });
};
var Fb = (e, t) => {
  t = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, t);
  const r = (o) => {
    const n = (f) => typeof f == "string" ? o === f : f.test(o);
    return t.include ? t.include.some(n) : !t.exclude.some(n);
  };
  let i;
  typeof e == "function" ? i = function() {
    return t.excludeMain ? e.apply(this, arguments) : Ol(e, t).apply(this, arguments);
  } : i = Object.create(Object.getPrototypeOf(e));
  for (const o in e) {
    const n = e[o];
    i[o] = typeof n == "function" && r(o) ? Ol(n, t) : n;
  }
  return i;
}, Hb = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.createBlockRefMiddleware = void 0;
const n8 = Br, i8 = Hb(Kh), a8 = Hb(Fb), Pl = ji, o8 = sr, qf = Pl.createModuleLogger(Pl.projectLogger, "block-ref");
function f8({ provider: e, blockTracker: t } = {}) {
  if (!e)
    throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
  if (!t)
    throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
  return n8.createAsyncMiddleware(async (r, i, o) => {
    var n, f;
    const u = o8.blockTagParamIndex(r);
    if (u === void 0)
      return o();
    if (((f = (n = r.params) === null || n === void 0 ? void 0 : n[u]) !== null && f !== void 0 ? f : "latest") !== "latest")
      return qf('blockRef is not "latest", carrying request forward'), o();
    const h = await t.getLatestBlock();
    qf(`blockRef is "latest", setting param ${u} to latest block ${h}`);
    const s = i8.default(r);
    s.params && (s.params[u] = h), qf("Performing another request %o", s);
    const p = await a8.default(e.sendAsync).call(e, s);
    i.result = p.result, i.error = p.error;
  });
}
Fo.createBlockRefMiddleware = f8;
var Ho = {};
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.createBlockTrackerInspectorMiddleware = void 0;
const s8 = Br, Cl = ji, Nl = Cl.createModuleLogger(Cl.projectLogger, "block-tracker-inspector"), u8 = [
  "eth_getTransactionByHash",
  "eth_getTransactionReceipt"
];
function c8({ blockTracker: e }) {
  return s8.createAsyncMiddleware(async (t, r, i) => {
    var o;
    if (!u8.includes(t.method))
      return i();
    if (await i(), !!(!((o = r.result) === null || o === void 0) && o.blockNumber) && (Nl("res.result.blockNumber exists, proceeding. res = %o", r), typeof r.result.blockNumber == "string")) {
      const n = Number.parseInt(r.result.blockNumber, 16), f = Number.parseInt(e.getCurrentBlock(), 16);
      n > f && (Nl("blockNumber from response is greater than current block number, refreshing current block number"), await e.checkForLatestBlock());
    }
  });
}
Ho.createBlockTrackerInspectorMiddleware = c8;
var Ci = {};
const h8 = {}, l8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: h8
}, Symbol.toStringTag, { value: "Module" })), zb = /* @__PURE__ */ Iv(l8);
Object.defineProperty(Ci, "__esModule", { value: !0 });
Ci.createFetchConfigFromReq = Ci.createFetchMiddleware = void 0;
const d8 = Br, la = Wt, p8 = Ze.fetch || zb, v8 = Ze.btoa || zb, b8 = [
  // ignore server overload errors
  "Gateway timeout",
  "ETIMEDOUT",
  // ignore server sent html error pages
  // or truncated json responses
  "failed to parse response body",
  // ignore errors where http req failed to establish
  "Failed to fetch"
];
function y8({ rpcUrl: e, originHttpHeaderKey: t }) {
  return d8.createAsyncMiddleware(async (r, i, o) => {
    const { fetchUrl: n, fetchParams: f } = Vb({
      req: r,
      rpcUrl: e,
      originHttpHeaderKey: t
    }), u = 5, c = 1e3;
    for (let h = 0; h < u; h++) {
      try {
        const s = await p8(n, f);
        g8(s);
        const p = await s.text();
        let v;
        try {
          v = JSON.parse(p);
        } catch {
          throw new Error(`FetchMiddleware - failed to parse response body: "${p}"`);
        }
        const m = m8(s, v);
        i.result = m;
        return;
      } catch (s) {
        const p = s.toString();
        if (!b8.some((m) => p.includes(m)))
          throw s;
      }
      await E8(c);
    }
  });
}
Ci.createFetchMiddleware = y8;
function g8(e) {
  switch (e.status) {
    case 405:
      throw la.ethErrors.rpc.methodNotFound();
    case 418:
      throw _8();
    case 503:
    case 504:
      throw x8();
  }
}
function m8(e, t) {
  if (e.status !== 200)
    throw la.ethErrors.rpc.internal({
      message: `Non-200 status code: '${e.status}'`,
      data: t
    });
  if (t.error)
    throw la.ethErrors.rpc.internal({
      data: t.error
    });
  return t.result;
}
function Vb({ req: e, rpcUrl: t, originHttpHeaderKey: r }) {
  const i = new URL(t), o = w8(i), n = {
    id: e.id,
    jsonrpc: e.jsonrpc,
    method: e.method,
    params: e.params
  }, f = e.origin, u = JSON.stringify(n), c = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: u
  };
  if (i.username && i.password) {
    const h = `${i.username}:${i.password}`, s = v8(h);
    c.headers.Authorization = `Basic ${s}`;
  }
  return r && f && (c.headers[r] = f), { fetchUrl: o, fetchParams: c };
}
Ci.createFetchConfigFromReq = Vb;
function w8(e) {
  let t = "";
  return t += e.protocol, t += `//${e.hostname}`, e.port && (t += `:${e.port}`), t += `${e.pathname}`, t += `${e.search}`, t;
}
function _8() {
  return la.ethErrors.rpc.internal({ message: "Request is being rate limited." });
}
function x8() {
  let e = "Gateway timeout. The request took too long to process. ";
  return e += "This can happen when querying logs over too wide a block range.", la.ethErrors.rpc.internal({ message: e });
}
function E8(e) {
  return new Promise((t) => setTimeout(t, e));
}
var zo = {}, S8 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zo, "__esModule", { value: !0 });
zo.createInflightCacheMiddleware = void 0;
const Ll = S8(Kh), A8 = Br, kl = ji, M8 = sr, ja = kl.createModuleLogger(kl.projectLogger, "inflight-cache");
function R8() {
  const e = {};
  return A8.createAsyncMiddleware(async (i, o, n) => {
    if (i.skipCache)
      return n();
    const f = M8.cacheIdentifierForPayload(i);
    if (!f)
      return ja("Request is not cacheable, proceeding. req = %o", i), n();
    let u = e[f];
    if (u) {
      ja("Running %i handler(s) for request %o", u.length, i), await t(o, u);
      return;
    }
    u = [], e[f] = u, ja("Carrying original request forward %o", i), await n(), delete e[f], ja("Running %i collected handler(s) for request %o", u.length, i), r(o, u);
  });
  function t(i, o) {
    const { resolve: n, promise: f } = B8();
    return o.push((u) => {
      i.result = Ll.default(u.result), i.error = Ll.default(u.error), n();
    }), f;
  }
  function r(i, o) {
    setTimeout(() => {
      o.forEach((n) => {
        try {
          n(i);
        } catch (f) {
          console.error(f);
        }
      });
    });
  }
}
zo.createInflightCacheMiddleware = R8;
function B8() {
  let e;
  const t = new Promise((r) => {
    e = r;
  });
  return { resolve: e, promise: t };
}
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.ethersProviderAsMiddleware = Ni.providerAsMiddleware = void 0;
function I8(e) {
  return (t, r, i, o) => {
    e.sendAsync(t, (n, f) => n instanceof Error ? o(n) : (Object.assign(r, f), o()));
  };
}
Ni.providerAsMiddleware = I8;
function T8(e) {
  return (t, r, i, o) => {
    e.send(t, (n, f) => n ? o(n) : (Object.assign(r, f), o()));
  };
}
Ni.ethersProviderAsMiddleware = T8;
var Ma = {}, O8 = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.providerFromEngine = void 0;
const P8 = O8(Io);
function C8(e) {
  const t = new P8.default();
  return t.sendAsync = (r, i) => {
    e.handle(r, i);
  }, t.send = (r, i) => {
    if (typeof i != "function")
      throw new Error('Must provide callback to "send" method.');
    e.handle(r, i);
  }, e.on && e.on("notification", (r) => {
    t.emit("data", null, r);
  }), t;
}
Ma.providerFromEngine = C8;
var Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.providerFromMiddleware = void 0;
const N8 = Br, L8 = Ma;
function k8(e) {
  const t = new N8.JsonRpcEngine();
  return t.push(e), L8.providerFromEngine(t);
}
Vo.providerFromMiddleware = k8;
var Wo = {}, Wb = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.createRetryOnEmptyMiddleware = void 0;
const q8 = Wb(Kh), $8 = Br, D8 = Wb(Fb), ql = ji, j8 = sr, Hn = ql.createModuleLogger(ql.projectLogger, "retry-on-empty"), U8 = [
  void 0,
  null,
  "<nil>"
];
function F8({ provider: e, blockTracker: t } = {}) {
  if (!e)
    throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
  if (!t)
    throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
  return $8.createAsyncMiddleware(async (r, i, o) => {
    var n;
    const f = j8.blockTagParamIndex(r);
    if (f === void 0)
      return o();
    let u = (n = r.params) === null || n === void 0 ? void 0 : n[f];
    if (u === void 0 && (u = "latest"), ["latest", "pending"].includes(u))
      return o();
    const c = Number.parseInt(u.slice(2), 16);
    if (Number.isNaN(c))
      return o();
    const h = await t.getLatestBlock(), s = Number.parseInt(h.slice(2), 16);
    if (c > s)
      return Hn("Requested block number %o is higher than latest block number %o, falling through to original request", c, s), o();
    Hn("Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received", c, s);
    const p = q8.default(r), v = await H8(10, async () => {
      Hn("Performing request %o", p);
      const m = await D8.default(e.sendAsync).call(e, p);
      if (Hn("Response is %o", m), U8.includes(m.result))
        throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(m)}" for request "${JSON.stringify(p)}"`);
      return m;
    });
    Hn("Copying result %o and error %o", v.result, v.error), i.result = v.result, i.error = v.error;
  });
}
Wo.createRetryOnEmptyMiddleware = F8;
async function H8(e, t) {
  for (let r = 0; r < e; r++)
    try {
      return await t();
    } catch {
      Hn("(call %i) Request failed, waiting 1s to retry again...", r + 1), await z8(1e3);
    }
  throw Hn("Retries exhausted"), new Error("RetryOnEmptyMiddleware - retries exhausted");
}
function z8(e) {
  return new Promise((t) => setTimeout(t, e));
}
var Ko = {}, Kb = {}, On = {}, Ra = {}, Zo = {}, Go = {}, Zb = {}, Li = {}, Jo = {}, ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.output = ur.exists = ur.hash = ur.bytes = ur.bool = ur.number = void 0;
function bo(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
ur.number = bo;
function Gb(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
ur.bool = Gb;
function V8(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Zh(e, ...t) {
  if (!V8(e))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
ur.bytes = Zh;
function Jb(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  bo(e.outputLen), bo(e.blockLen);
}
ur.hash = Jb;
function Xb(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
ur.exists = Xb;
function Yb(e, t) {
  Zh(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
ur.output = Yb;
const W8 = { number: bo, bool: Gb, bytes: Zh, hash: Jb, exists: Xb, output: Yb };
ur.default = W8;
var wn = {}, Xo = {};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.crypto = void 0;
Xo.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const t = Xo, r = (z) => new Uint8Array(z.buffer, z.byteOffset, z.byteLength);
  e.u8 = r;
  const i = (z) => new Uint32Array(z.buffer, z.byteOffset, Math.floor(z.byteLength / 4));
  e.u32 = i;
  function o(z) {
    return z instanceof Uint8Array || z != null && typeof z == "object" && z.constructor.name === "Uint8Array";
  }
  const n = (z) => new DataView(z.buffer, z.byteOffset, z.byteLength);
  e.createView = n;
  const f = (z, Y) => z << 32 - Y | z >>> Y;
  if (e.rotr = f, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const u = /* @__PURE__ */ Array.from({ length: 256 }, (z, Y) => Y.toString(16).padStart(2, "0"));
  function c(z) {
    if (!o(z))
      throw new Error("Uint8Array expected");
    let Y = "";
    for (let ue = 0; ue < z.length; ue++)
      Y += u[z[ue]];
    return Y;
  }
  e.bytesToHex = c;
  const h = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function s(z) {
    if (z >= h._0 && z <= h._9)
      return z - h._0;
    if (z >= h._A && z <= h._F)
      return z - (h._A - 10);
    if (z >= h._a && z <= h._f)
      return z - (h._a - 10);
  }
  function p(z) {
    if (typeof z != "string")
      throw new Error("hex string expected, got " + typeof z);
    const Y = z.length, ue = Y / 2;
    if (Y % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + Y);
    const j = new Uint8Array(ue);
    for (let g = 0, b = 0; g < ue; g++, b += 2) {
      const a = s(z.charCodeAt(b)), d = s(z.charCodeAt(b + 1));
      if (a === void 0 || d === void 0) {
        const w = z[b] + z[b + 1];
        throw new Error('hex string expected, got non-hex character "' + w + '" at index ' + b);
      }
      j[g] = a * 16 + d;
    }
    return j;
  }
  e.hexToBytes = p;
  const v = async () => {
  };
  e.nextTick = v;
  async function m(z, Y, ue) {
    let j = Date.now();
    for (let g = 0; g < z; g++) {
      ue(g);
      const b = Date.now() - j;
      b >= 0 && b < Y || (await (0, e.nextTick)(), j += b);
    }
  }
  e.asyncLoop = m;
  function E(z) {
    if (typeof z != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof z}`);
    return new Uint8Array(new TextEncoder().encode(z));
  }
  e.utf8ToBytes = E;
  function M(z) {
    if (typeof z == "string" && (z = E(z)), !o(z))
      throw new Error(`expected Uint8Array, got ${typeof z}`);
    return z;
  }
  e.toBytes = M;
  function I(...z) {
    let Y = 0;
    for (let j = 0; j < z.length; j++) {
      const g = z[j];
      if (!o(g))
        throw new Error("Uint8Array expected");
      Y += g.length;
    }
    const ue = new Uint8Array(Y);
    for (let j = 0, g = 0; j < z.length; j++) {
      const b = z[j];
      ue.set(b, g), g += b.length;
    }
    return ue;
  }
  e.concatBytes = I;
  class B {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = B;
  const T = {}.toString;
  function k(z, Y) {
    if (Y !== void 0 && T.call(Y) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(z, Y);
  }
  e.checkOpts = k;
  function N(z) {
    const Y = (j) => z().update(M(j)).digest(), ue = z();
    return Y.outputLen = ue.outputLen, Y.blockLen = ue.blockLen, Y.create = () => z(), Y;
  }
  e.wrapConstructor = N;
  function q(z) {
    const Y = (j, g) => z(g).update(M(j)).digest(), ue = z({});
    return Y.outputLen = ue.outputLen, Y.blockLen = ue.blockLen, Y.create = (j) => z(j), Y;
  }
  e.wrapConstructorWithOpts = q;
  function D(z) {
    const Y = (j, g) => z(g).update(M(j)).digest(), ue = z({});
    return Y.outputLen = ue.outputLen, Y.blockLen = ue.blockLen, Y.create = (j) => z(j), Y;
  }
  e.wrapXOFConstructorWithOpts = D;
  function U(z = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(z));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = U;
})(wn);
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.SHA2 = void 0;
const $f = ur, Qi = wn;
function K8(e, t, r, i) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, i);
  const o = BigInt(32), n = BigInt(4294967295), f = Number(r >> o & n), u = Number(r & n), c = i ? 4 : 0, h = i ? 0 : 4;
  e.setUint32(t + c, f, i), e.setUint32(t + h, u, i);
}
class Z8 extends Qi.Hash {
  constructor(t, r, i, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = i, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, Qi.createView)(this.buffer);
  }
  update(t) {
    (0, $f.exists)(this);
    const { view: r, buffer: i, blockLen: o } = this;
    t = (0, Qi.toBytes)(t);
    const n = t.length;
    for (let f = 0; f < n; ) {
      const u = Math.min(o - this.pos, n - f);
      if (u === o) {
        const c = (0, Qi.createView)(t);
        for (; o <= n - f; f += o)
          this.process(c, f);
        continue;
      }
      i.set(t.subarray(f, f + u), this.pos), this.pos += u, f += u, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, $f.exists)(this), (0, $f.output)(t, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: o, isLE: n } = this;
    let { pos: f } = this;
    r[f++] = 128, this.buffer.subarray(f).fill(0), this.padOffset > o - f && (this.process(i, 0), f = 0);
    for (let p = f; p < o; p++)
      r[p] = 0;
    K8(i, o - 8, BigInt(this.length * 8), n), this.process(i, 0);
    const u = (0, Qi.createView)(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const h = c / 4, s = this.get();
    if (h > s.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < h; p++)
      u.setUint32(4 * p, s[p], n);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: i, length: o, finished: n, destroyed: f, pos: u } = this;
    return t.length = o, t.pos = u, t.finished = n, t.destroyed = f, o % r && t.buffer.set(i), t;
  }
}
Jo.SHA2 = Z8;
Object.defineProperty(Li, "__esModule", { value: !0 });
Li.sha224 = Li.sha256 = void 0;
const G8 = Jo, Lr = wn, J8 = (e, t, r) => e & t ^ ~e & r, X8 = (e, t, r) => e & t ^ e & r ^ t & r, Y8 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), En = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Sn = /* @__PURE__ */ new Uint32Array(64);
class Qb extends G8.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = En[0] | 0, this.B = En[1] | 0, this.C = En[2] | 0, this.D = En[3] | 0, this.E = En[4] | 0, this.F = En[5] | 0, this.G = En[6] | 0, this.H = En[7] | 0;
  }
  get() {
    const { A: t, B: r, C: i, D: o, E: n, F: f, G: u, H: c } = this;
    return [t, r, i, o, n, f, u, c];
  }
  // prettier-ignore
  set(t, r, i, o, n, f, u, c) {
    this.A = t | 0, this.B = r | 0, this.C = i | 0, this.D = o | 0, this.E = n | 0, this.F = f | 0, this.G = u | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      Sn[p] = t.getUint32(r, !1);
    for (let p = 16; p < 64; p++) {
      const v = Sn[p - 15], m = Sn[p - 2], E = (0, Lr.rotr)(v, 7) ^ (0, Lr.rotr)(v, 18) ^ v >>> 3, M = (0, Lr.rotr)(m, 17) ^ (0, Lr.rotr)(m, 19) ^ m >>> 10;
      Sn[p] = M + Sn[p - 7] + E + Sn[p - 16] | 0;
    }
    let { A: i, B: o, C: n, D: f, E: u, F: c, G: h, H: s } = this;
    for (let p = 0; p < 64; p++) {
      const v = (0, Lr.rotr)(u, 6) ^ (0, Lr.rotr)(u, 11) ^ (0, Lr.rotr)(u, 25), m = s + v + J8(u, c, h) + Y8[p] + Sn[p] | 0, M = ((0, Lr.rotr)(i, 2) ^ (0, Lr.rotr)(i, 13) ^ (0, Lr.rotr)(i, 22)) + X8(i, o, n) | 0;
      s = h, h = c, c = u, u = f + m | 0, f = n, n = o, o = i, i = m + M | 0;
    }
    i = i + this.A | 0, o = o + this.B | 0, n = n + this.C | 0, f = f + this.D | 0, u = u + this.E | 0, c = c + this.F | 0, h = h + this.G | 0, s = s + this.H | 0, this.set(i, o, n, f, u, c, h, s);
  }
  roundClean() {
    Sn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class Q8 extends Qb {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
Li.sha256 = (0, Lr.wrapConstructor)(() => new Qb());
Li.sha224 = (0, Lr.wrapConstructor)(() => new Q8());
var wt = {}, gt = {};
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.validateObject = gt.createHmacDrbg = gt.bitMask = gt.bitSet = gt.bitGet = gt.bitLen = gt.utf8ToBytes = gt.equalBytes = gt.concatBytes = gt.ensureBytes = gt.numberToVarBytesBE = gt.numberToBytesLE = gt.numberToBytesBE = gt.bytesToNumberLE = gt.bytesToNumberBE = gt.hexToBytes = gt.hexToNumber = gt.numberToHexUnpadded = gt.bytesToHex = gt.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ey = BigInt(0), Yo = BigInt(1), e5 = BigInt(2);
function Vi(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
gt.isBytes = Vi;
const t5 = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Gh(e) {
  if (!Vi(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += t5[e[r]];
  return t;
}
gt.bytesToHex = Gh;
function ty(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
gt.numberToHexUnpadded = ty;
function Jh(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
gt.hexToNumber = Jh;
const dn = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function $l(e) {
  if (e >= dn._0 && e <= dn._9)
    return e - dn._0;
  if (e >= dn._A && e <= dn._F)
    return e - (dn._A - 10);
  if (e >= dn._a && e <= dn._f)
    return e - (dn._a - 10);
}
function Qo(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const i = new Uint8Array(r);
  for (let o = 0, n = 0; o < r; o++, n += 2) {
    const f = $l(e.charCodeAt(n)), u = $l(e.charCodeAt(n + 1));
    if (f === void 0 || u === void 0) {
      const c = e[n] + e[n + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + n);
    }
    i[o] = f * 16 + u;
  }
  return i;
}
gt.hexToBytes = Qo;
function r5(e) {
  return Jh(Gh(e));
}
gt.bytesToNumberBE = r5;
function n5(e) {
  if (!Vi(e))
    throw new Error("Uint8Array expected");
  return Jh(Gh(Uint8Array.from(e).reverse()));
}
gt.bytesToNumberLE = n5;
function ry(e, t) {
  return Qo(e.toString(16).padStart(t * 2, "0"));
}
gt.numberToBytesBE = ry;
function i5(e, t) {
  return ry(e, t).reverse();
}
gt.numberToBytesLE = i5;
function a5(e) {
  return Qo(ty(e));
}
gt.numberToVarBytesBE = a5;
function o5(e, t, r) {
  let i;
  if (typeof t == "string")
    try {
      i = Qo(t);
    } catch (n) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`);
    }
  else if (Vi(t))
    i = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = i.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return i;
}
gt.ensureBytes = o5;
function ny(...e) {
  let t = 0;
  for (let o = 0; o < e.length; o++) {
    const n = e[o];
    if (!Vi(n))
      throw new Error("Uint8Array expected");
    t += n.length;
  }
  let r = new Uint8Array(t), i = 0;
  for (let o = 0; o < e.length; o++) {
    const n = e[o];
    r.set(n, i), i += n.length;
  }
  return r;
}
gt.concatBytes = ny;
function f5(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let i = 0; i < e.length; i++)
    r |= e[i] ^ t[i];
  return r === 0;
}
gt.equalBytes = f5;
function s5(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
gt.utf8ToBytes = s5;
function u5(e) {
  let t;
  for (t = 0; e > ey; e >>= Yo, t += 1)
    ;
  return t;
}
gt.bitLen = u5;
function c5(e, t) {
  return e >> BigInt(t) & Yo;
}
gt.bitGet = c5;
const h5 = (e, t, r) => e | (r ? Yo : ey) << BigInt(t);
gt.bitSet = h5;
const l5 = (e) => (e5 << BigInt(e - 1)) - Yo;
gt.bitMask = l5;
const Df = (e) => new Uint8Array(e), Dl = (e) => Uint8Array.from(e);
function d5(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = Df(e), o = Df(e), n = 0;
  const f = () => {
    i.fill(1), o.fill(0), n = 0;
  }, u = (...p) => r(o, i, ...p), c = (p = Df()) => {
    o = u(Dl([0]), p), i = u(), p.length !== 0 && (o = u(Dl([1]), p), i = u());
  }, h = () => {
    if (n++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let p = 0;
    const v = [];
    for (; p < t; ) {
      i = u();
      const m = i.slice();
      v.push(m), p += i.length;
    }
    return ny(...v);
  };
  return (p, v) => {
    f(), c(p);
    let m;
    for (; !(m = v(h())); )
      c();
    return f(), m;
  };
}
gt.createHmacDrbg = d5;
const p5 = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || Vi(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function v5(e, t, r = {}) {
  const i = (o, n, f) => {
    const u = p5[n];
    if (typeof u != "function")
      throw new Error(`Invalid validator "${n}", expected function`);
    const c = e[o];
    if (!(f && c === void 0) && !u(c, e))
      throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${n}`);
  };
  for (const [o, n] of Object.entries(t))
    i(o, n, !1);
  for (const [o, n] of Object.entries(r))
    i(o, n, !0);
  return e;
}
gt.validateObject = v5;
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.mapHashToField = wt.getMinHashLength = wt.getFieldBytesLength = wt.hashToPrivateScalar = wt.FpSqrtEven = wt.FpSqrtOdd = wt.Field = wt.nLength = wt.FpIsSquare = wt.FpDiv = wt.FpInvertBatch = wt.FpPow = wt.validateField = wt.isNegativeLE = wt.FpSqrt = wt.tonelliShanks = wt.invert = wt.pow2 = wt.pow = wt.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Mr = gt, cr = BigInt(0), Vt = BigInt(1), Rn = BigInt(2), b5 = BigInt(3), rh = BigInt(4), jl = BigInt(5), Ul = BigInt(8);
BigInt(9);
BigInt(16);
function Sr(e, t) {
  const r = e % t;
  return r >= cr ? r : t + r;
}
wt.mod = Sr;
function iy(e, t, r) {
  if (r <= cr || t < cr)
    throw new Error("Expected power/modulo > 0");
  if (r === Vt)
    return cr;
  let i = Vt;
  for (; t > cr; )
    t & Vt && (i = i * e % r), e = e * e % r, t >>= Vt;
  return i;
}
wt.pow = iy;
function y5(e, t, r) {
  let i = e;
  for (; t-- > cr; )
    i *= i, i %= r;
  return i;
}
wt.pow2 = y5;
function yo(e, t) {
  if (e === cr || t <= cr)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Sr(e, t), i = t, o = cr, n = Vt;
  for (; r !== cr; ) {
    const u = i / r, c = i % r, h = o - n * u;
    i = r, r = c, o = n, n = h;
  }
  if (i !== Vt)
    throw new Error("invert: does not exist");
  return Sr(o, t);
}
wt.invert = yo;
function ay(e) {
  const t = (e - Vt) / Rn;
  let r, i, o;
  for (r = e - Vt, i = 0; r % Rn === cr; r /= Rn, i++)
    ;
  for (o = Rn; o < e && iy(o, t, e) !== e - Vt; o++)
    ;
  if (i === 1) {
    const f = (e + Vt) / rh;
    return function(c, h) {
      const s = c.pow(h, f);
      if (!c.eql(c.sqr(s), h))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  const n = (r + Vt) / Rn;
  return function(u, c) {
    if (u.pow(c, t) === u.neg(u.ONE))
      throw new Error("Cannot find square root");
    let h = i, s = u.pow(u.mul(u.ONE, o), r), p = u.pow(c, n), v = u.pow(c, r);
    for (; !u.eql(v, u.ONE); ) {
      if (u.eql(v, u.ZERO))
        return u.ZERO;
      let m = 1;
      for (let M = u.sqr(v); m < h && !u.eql(M, u.ONE); m++)
        M = u.sqr(M);
      const E = u.pow(s, Vt << BigInt(h - m - 1));
      s = u.sqr(E), p = u.mul(p, E), v = u.mul(v, s), h = m;
    }
    return p;
  };
}
wt.tonelliShanks = ay;
function oy(e) {
  if (e % rh === b5) {
    const t = (e + Vt) / rh;
    return function(i, o) {
      const n = i.pow(o, t);
      if (!i.eql(i.sqr(n), o))
        throw new Error("Cannot find square root");
      return n;
    };
  }
  if (e % Ul === jl) {
    const t = (e - jl) / Ul;
    return function(i, o) {
      const n = i.mul(o, Rn), f = i.pow(n, t), u = i.mul(o, f), c = i.mul(i.mul(u, Rn), f), h = i.mul(u, i.sub(c, i.ONE));
      if (!i.eql(i.sqr(h), o))
        throw new Error("Cannot find square root");
      return h;
    };
  }
  return ay(e);
}
wt.FpSqrt = oy;
const g5 = (e, t) => (Sr(e, t) & Vt) === Vt;
wt.isNegativeLE = g5;
const m5 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function w5(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = m5.reduce((i, o) => (i[o] = "function", i), t);
  return (0, Mr.validateObject)(e, r);
}
wt.validateField = w5;
function fy(e, t, r) {
  if (r < cr)
    throw new Error("Expected power > 0");
  if (r === cr)
    return e.ONE;
  if (r === Vt)
    return t;
  let i = e.ONE, o = t;
  for (; r > cr; )
    r & Vt && (i = e.mul(i, o)), o = e.sqr(o), r >>= Vt;
  return i;
}
wt.FpPow = fy;
function sy(e, t) {
  const r = new Array(t.length), i = t.reduce((n, f, u) => e.is0(f) ? n : (r[u] = n, e.mul(n, f)), e.ONE), o = e.inv(i);
  return t.reduceRight((n, f, u) => e.is0(f) ? n : (r[u] = e.mul(n, r[u]), e.mul(n, f)), o), r;
}
wt.FpInvertBatch = sy;
function _5(e, t, r) {
  return e.mul(t, typeof r == "bigint" ? yo(r, e.ORDER) : e.inv(r));
}
wt.FpDiv = _5;
function x5(e) {
  const t = (e.ORDER - Vt) / Rn;
  return (r) => {
    const i = e.pow(r, t);
    return e.eql(i, e.ZERO) || e.eql(i, e.ONE);
  };
}
wt.FpIsSquare = x5;
function Xh(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
wt.nLength = Xh;
function E5(e, t, r = !1, i = {}) {
  if (e <= cr)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: n } = Xh(e, t);
  if (n > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const f = oy(e), u = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: n,
    MASK: (0, Mr.bitMask)(o),
    ZERO: cr,
    ONE: Vt,
    create: (c) => Sr(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return cr <= c && c < e;
    },
    is0: (c) => c === cr,
    isOdd: (c) => (c & Vt) === Vt,
    neg: (c) => Sr(-c, e),
    eql: (c, h) => c === h,
    sqr: (c) => Sr(c * c, e),
    add: (c, h) => Sr(c + h, e),
    sub: (c, h) => Sr(c - h, e),
    mul: (c, h) => Sr(c * h, e),
    pow: (c, h) => fy(u, c, h),
    div: (c, h) => Sr(c * yo(h, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, h) => c + h,
    subN: (c, h) => c - h,
    mulN: (c, h) => c * h,
    inv: (c) => yo(c, e),
    sqrt: i.sqrt || ((c) => f(u, c)),
    invertBatch: (c) => sy(u, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, h, s) => s ? h : c,
    toBytes: (c) => r ? (0, Mr.numberToBytesLE)(c, n) : (0, Mr.numberToBytesBE)(c, n),
    fromBytes: (c) => {
      if (c.length !== n)
        throw new Error(`Fp.fromBytes: expected ${n}, got ${c.length}`);
      return r ? (0, Mr.bytesToNumberLE)(c) : (0, Mr.bytesToNumberBE)(c);
    }
  });
  return Object.freeze(u);
}
wt.Field = E5;
function S5(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? r : e.neg(r);
}
wt.FpSqrtOdd = S5;
function A5(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? e.neg(r) : r;
}
wt.FpSqrtEven = A5;
function M5(e, t, r = !1) {
  e = (0, Mr.ensureBytes)("privateHash", e);
  const i = e.length, o = Xh(t).nByteLength + 8;
  if (o < 24 || i < o || i > 1024)
    throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${i}`);
  const n = r ? (0, Mr.bytesToNumberLE)(e) : (0, Mr.bytesToNumberBE)(e);
  return Sr(n, t - Vt) + Vt;
}
wt.hashToPrivateScalar = M5;
function Yh(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
wt.getFieldBytesLength = Yh;
function uy(e) {
  const t = Yh(e);
  return t + Math.ceil(t / 2);
}
wt.getMinHashLength = uy;
function R5(e, t, r = !1) {
  const i = e.length, o = Yh(t), n = uy(t);
  if (i < 16 || i < n || i > 1024)
    throw new Error(`expected ${n}-1024 bytes of input, got ${i}`);
  const f = r ? (0, Mr.bytesToNumberBE)(e) : (0, Mr.bytesToNumberLE)(e), u = Sr(f, t - Vt) + Vt;
  return r ? (0, Mr.numberToBytesLE)(u, o) : (0, Mr.numberToBytesBE)(u, o);
}
wt.mapHashToField = R5;
var Qh = {}, ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.validateBasic = ki.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Fl = wt, B5 = gt, I5 = BigInt(0), jf = BigInt(1);
function T5(e, t) {
  const r = (o, n) => {
    const f = n.negate();
    return o ? f : n;
  }, i = (o) => {
    const n = Math.ceil(t / o) + 1, f = 2 ** (o - 1);
    return { windows: n, windowSize: f };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, n) {
      let f = e.ZERO, u = o;
      for (; n > I5; )
        n & jf && (f = f.add(u)), u = u.double(), n >>= jf;
      return f;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, n) {
      const { windows: f, windowSize: u } = i(n), c = [];
      let h = o, s = h;
      for (let p = 0; p < f; p++) {
        s = h, c.push(s);
        for (let v = 1; v < u; v++)
          s = s.add(h), c.push(s);
        h = s.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, n, f) {
      const { windows: u, windowSize: c } = i(o);
      let h = e.ZERO, s = e.BASE;
      const p = BigInt(2 ** o - 1), v = 2 ** o, m = BigInt(o);
      for (let E = 0; E < u; E++) {
        const M = E * c;
        let I = Number(f & p);
        f >>= m, I > c && (I -= v, f += jf);
        const B = M, T = M + Math.abs(I) - 1, k = E % 2 !== 0, N = I < 0;
        I === 0 ? s = s.add(r(k, n[B])) : h = h.add(r(N, n[T]));
      }
      return { p: h, f: s };
    },
    wNAFCached(o, n, f, u) {
      const c = o._WINDOW_SIZE || 1;
      let h = n.get(o);
      return h || (h = this.precomputeWindow(o, c), c !== 1 && n.set(o, u(h))), this.wNAF(c, h, f);
    }
  };
}
ki.wNAF = T5;
function O5(e) {
  return (0, Fl.validateField)(e.Fp), (0, B5.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, Fl.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
ki.validateBasic = O5;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = wt, r = gt, i = gt, o = ki;
  function n(T) {
    const k = (0, o.validateBasic)(T);
    r.validateObject(k, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: N, Fp: q, a: D } = k;
    if (N) {
      if (!q.eql(D, q.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof N != "object" || typeof N.beta != "bigint" || typeof N.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...k });
  }
  const { bytesToNumberBE: f, hexToBytes: u } = r;
  e.DER = {
    // asn.1 DER encoding utils
    Err: class extends Error {
      constructor(k = "") {
        super(k);
      }
    },
    _parseInt(T) {
      const { Err: k } = e.DER;
      if (T.length < 2 || T[0] !== 2)
        throw new k("Invalid signature integer tag");
      const N = T[1], q = T.subarray(2, N + 2);
      if (!N || q.length !== N)
        throw new k("Invalid signature integer: wrong length");
      if (q[0] & 128)
        throw new k("Invalid signature integer: negative");
      if (q[0] === 0 && !(q[1] & 128))
        throw new k("Invalid signature integer: unnecessary leading zero");
      return { d: f(q), l: T.subarray(N + 2) };
    },
    toSig(T) {
      const { Err: k } = e.DER, N = typeof T == "string" ? u(T) : T;
      if (!r.isBytes(N))
        throw new Error("ui8a expected");
      let q = N.length;
      if (q < 2 || N[0] != 48)
        throw new k("Invalid signature tag");
      if (N[1] !== q - 2)
        throw new k("Invalid signature: incorrect length");
      const { d: D, l: U } = e.DER._parseInt(N.subarray(2)), { d: z, l: Y } = e.DER._parseInt(U);
      if (Y.length)
        throw new k("Invalid signature: left bytes after parsing");
      return { r: D, s: z };
    },
    hexFromSig(T) {
      const k = (j) => Number.parseInt(j[0], 16) & 8 ? "00" + j : j, N = (j) => {
        const g = j.toString(16);
        return g.length & 1 ? `0${g}` : g;
      }, q = k(N(T.s)), D = k(N(T.r)), U = q.length / 2, z = D.length / 2, Y = N(U), ue = N(z);
      return `30${N(z + U + 4)}02${ue}${D}02${Y}${q}`;
    }
  };
  const c = BigInt(0), h = BigInt(1), s = BigInt(2), p = BigInt(3), v = BigInt(4);
  function m(T) {
    const k = n(T), { Fp: N } = k, q = k.toBytes || ((w, x, A) => {
      const S = x.toAffine();
      return r.concatBytes(Uint8Array.from([4]), N.toBytes(S.x), N.toBytes(S.y));
    }), D = k.fromBytes || ((w) => {
      const x = w.subarray(1), A = N.fromBytes(x.subarray(0, N.BYTES)), S = N.fromBytes(x.subarray(N.BYTES, 2 * N.BYTES));
      return { x: A, y: S };
    });
    function U(w) {
      const { a: x, b: A } = k, S = N.sqr(w), y = N.mul(S, w);
      return N.add(N.add(y, N.mul(w, x)), A);
    }
    if (!N.eql(N.sqr(k.Gy), U(k.Gx)))
      throw new Error("bad generator point: equation left != right");
    function z(w) {
      return typeof w == "bigint" && c < w && w < k.n;
    }
    function Y(w) {
      if (!z(w))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function ue(w) {
      const { allowedPrivateKeyLengths: x, nByteLength: A, wrapPrivateKey: S, n: y } = k;
      if (x && typeof w != "bigint") {
        if (r.isBytes(w) && (w = r.bytesToHex(w)), typeof w != "string" || !x.includes(w.length))
          throw new Error("Invalid key");
        w = w.padStart(A * 2, "0");
      }
      let _;
      try {
        _ = typeof w == "bigint" ? w : r.bytesToNumberBE((0, i.ensureBytes)("private key", w, A));
      } catch {
        throw new Error(`private key must be ${A} bytes, hex or bigint, not ${typeof w}`);
      }
      return S && (_ = t.mod(_, y)), Y(_), _;
    }
    const j = /* @__PURE__ */ new Map();
    function g(w) {
      if (!(w instanceof b))
        throw new Error("ProjectivePoint expected");
    }
    class b {
      constructor(x, A, S) {
        if (this.px = x, this.py = A, this.pz = S, x == null || !N.isValid(x))
          throw new Error("x required");
        if (A == null || !N.isValid(A))
          throw new Error("y required");
        if (S == null || !N.isValid(S))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(x) {
        const { x: A, y: S } = x || {};
        if (!x || !N.isValid(A) || !N.isValid(S))
          throw new Error("invalid affine point");
        if (x instanceof b)
          throw new Error("projective point not allowed");
        const y = (_) => N.eql(_, N.ZERO);
        return y(A) && y(S) ? b.ZERO : new b(A, S, N.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(x) {
        const A = N.invertBatch(x.map((S) => S.pz));
        return x.map((S, y) => S.toAffine(A[y])).map(b.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(x) {
        const A = b.fromAffine(D((0, i.ensureBytes)("pointHex", x)));
        return A.assertValidity(), A;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(x) {
        return b.BASE.multiply(ue(x));
      }
      // "Private method", don't use it directly
      _setWindowSize(x) {
        this._WINDOW_SIZE = x, j.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (k.allowInfinityPoint && !N.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y: A } = this.toAffine();
        if (!N.isValid(x) || !N.isValid(A))
          throw new Error("bad point: x or y not FE");
        const S = N.sqr(A), y = U(x);
        if (!N.eql(S, y))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: x } = this.toAffine();
        if (N.isOdd)
          return !N.isOdd(x);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(x) {
        g(x);
        const { px: A, py: S, pz: y } = this, { px: _, py: l, pz: R } = x, ee = N.eql(N.mul(A, R), N.mul(_, y)), oe = N.eql(N.mul(S, R), N.mul(l, y));
        return ee && oe;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new b(this.px, N.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: x, b: A } = k, S = N.mul(A, p), { px: y, py: _, pz: l } = this;
        let R = N.ZERO, ee = N.ZERO, oe = N.ZERO, V = N.mul(y, y), W = N.mul(_, _), F = N.mul(l, l), re = N.mul(y, _);
        return re = N.add(re, re), oe = N.mul(y, l), oe = N.add(oe, oe), R = N.mul(x, oe), ee = N.mul(S, F), ee = N.add(R, ee), R = N.sub(W, ee), ee = N.add(W, ee), ee = N.mul(R, ee), R = N.mul(re, R), oe = N.mul(S, oe), F = N.mul(x, F), re = N.sub(V, F), re = N.mul(x, re), re = N.add(re, oe), oe = N.add(V, V), V = N.add(oe, V), V = N.add(V, F), V = N.mul(V, re), ee = N.add(ee, V), F = N.mul(_, l), F = N.add(F, F), V = N.mul(F, re), R = N.sub(R, V), oe = N.mul(F, W), oe = N.add(oe, oe), oe = N.add(oe, oe), new b(R, ee, oe);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(x) {
        g(x);
        const { px: A, py: S, pz: y } = this, { px: _, py: l, pz: R } = x;
        let ee = N.ZERO, oe = N.ZERO, V = N.ZERO;
        const W = k.a, F = N.mul(k.b, p);
        let re = N.mul(A, _), he = N.mul(S, l), Z = N.mul(y, R), K = N.add(A, S), ce = N.add(_, l);
        K = N.mul(K, ce), ce = N.add(re, he), K = N.sub(K, ce), ce = N.add(A, y);
        let ve = N.add(_, R);
        return ce = N.mul(ce, ve), ve = N.add(re, Z), ce = N.sub(ce, ve), ve = N.add(S, y), ee = N.add(l, R), ve = N.mul(ve, ee), ee = N.add(he, Z), ve = N.sub(ve, ee), V = N.mul(W, ce), ee = N.mul(F, Z), V = N.add(ee, V), ee = N.sub(he, V), V = N.add(he, V), oe = N.mul(ee, V), he = N.add(re, re), he = N.add(he, re), Z = N.mul(W, Z), ce = N.mul(F, ce), he = N.add(he, Z), Z = N.sub(re, Z), Z = N.mul(W, Z), ce = N.add(ce, Z), re = N.mul(he, ce), oe = N.add(oe, re), re = N.mul(ve, ce), ee = N.mul(K, ee), ee = N.sub(ee, re), re = N.mul(K, he), V = N.mul(ve, V), V = N.add(V, re), new b(ee, oe, V);
      }
      subtract(x) {
        return this.add(x.negate());
      }
      is0() {
        return this.equals(b.ZERO);
      }
      wNAF(x) {
        return d.wNAFCached(this, j, x, (A) => {
          const S = N.invertBatch(A.map((y) => y.pz));
          return A.map((y, _) => y.toAffine(S[_])).map(b.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(x) {
        const A = b.ZERO;
        if (x === c)
          return A;
        if (Y(x), x === h)
          return this;
        const { endo: S } = k;
        if (!S)
          return d.unsafeLadder(this, x);
        let { k1neg: y, k1: _, k2neg: l, k2: R } = S.splitScalar(x), ee = A, oe = A, V = this;
        for (; _ > c || R > c; )
          _ & h && (ee = ee.add(V)), R & h && (oe = oe.add(V)), V = V.double(), _ >>= h, R >>= h;
        return y && (ee = ee.negate()), l && (oe = oe.negate()), oe = new b(N.mul(oe.px, S.beta), oe.py, oe.pz), ee.add(oe);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(x) {
        Y(x);
        let A = x, S, y;
        const { endo: _ } = k;
        if (_) {
          const { k1neg: l, k1: R, k2neg: ee, k2: oe } = _.splitScalar(A);
          let { p: V, f: W } = this.wNAF(R), { p: F, f: re } = this.wNAF(oe);
          V = d.constTimeNegate(l, V), F = d.constTimeNegate(ee, F), F = new b(N.mul(F.px, _.beta), F.py, F.pz), S = V.add(F), y = W.add(re);
        } else {
          const { p: l, f: R } = this.wNAF(A);
          S = l, y = R;
        }
        return b.normalizeZ([S, y])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(x, A, S) {
        const y = b.BASE, _ = (R, ee) => ee === c || ee === h || !R.equals(y) ? R.multiplyUnsafe(ee) : R.multiply(ee), l = _(this, A).add(_(x, S));
        return l.is0() ? void 0 : l;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(x) {
        const { px: A, py: S, pz: y } = this, _ = this.is0();
        x == null && (x = _ ? N.ONE : N.inv(y));
        const l = N.mul(A, x), R = N.mul(S, x), ee = N.mul(y, x);
        if (_)
          return { x: N.ZERO, y: N.ZERO };
        if (!N.eql(ee, N.ONE))
          throw new Error("invZ was invalid");
        return { x: l, y: R };
      }
      isTorsionFree() {
        const { h: x, isTorsionFree: A } = k;
        if (x === h)
          return !0;
        if (A)
          return A(b, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: x, clearCofactor: A } = k;
        return x === h ? this : A ? A(b, this) : this.multiplyUnsafe(k.h);
      }
      toRawBytes(x = !0) {
        return this.assertValidity(), q(b, this, x);
      }
      toHex(x = !0) {
        return r.bytesToHex(this.toRawBytes(x));
      }
    }
    b.BASE = new b(k.Gx, k.Gy, N.ONE), b.ZERO = new b(N.ZERO, N.ONE, N.ZERO);
    const a = k.nBitLength, d = (0, o.wNAF)(b, k.endo ? Math.ceil(a / 2) : a);
    return {
      CURVE: k,
      ProjectivePoint: b,
      normPrivateKeyToScalar: ue,
      weierstrassEquation: U,
      isWithinCurveOrder: z
    };
  }
  e.weierstrassPoints = m;
  function E(T) {
    const k = (0, o.validateBasic)(T);
    return r.validateObject(k, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...k });
  }
  function M(T) {
    const k = E(T), { Fp: N, n: q } = k, D = N.BYTES + 1, U = 2 * N.BYTES + 1;
    function z(ce) {
      return c < ce && ce < N.ORDER;
    }
    function Y(ce) {
      return t.mod(ce, q);
    }
    function ue(ce) {
      return t.invert(ce, q);
    }
    const { ProjectivePoint: j, normPrivateKeyToScalar: g, weierstrassEquation: b, isWithinCurveOrder: a } = m({
      ...k,
      toBytes(ce, ve, Be) {
        const te = ve.toAffine(), C = N.toBytes(te.x), L = r.concatBytes;
        return Be ? L(Uint8Array.from([ve.hasEvenY() ? 2 : 3]), C) : L(Uint8Array.from([4]), C, N.toBytes(te.y));
      },
      fromBytes(ce) {
        const ve = ce.length, Be = ce[0], te = ce.subarray(1);
        if (ve === D && (Be === 2 || Be === 3)) {
          const C = r.bytesToNumberBE(te);
          if (!z(C))
            throw new Error("Point is not on curve");
          const L = b(C);
          let G = N.sqrt(L);
          const de = (G & h) === h;
          return (Be & 1) === 1 !== de && (G = N.neg(G)), { x: C, y: G };
        } else if (ve === U && Be === 4) {
          const C = N.fromBytes(te.subarray(0, N.BYTES)), L = N.fromBytes(te.subarray(N.BYTES, 2 * N.BYTES));
          return { x: C, y: L };
        } else
          throw new Error(`Point of length ${ve} was invalid. Expected ${D} compressed bytes or ${U} uncompressed bytes`);
      }
    }), d = (ce) => r.bytesToHex(r.numberToBytesBE(ce, k.nByteLength));
    function w(ce) {
      const ve = q >> h;
      return ce > ve;
    }
    function x(ce) {
      return w(ce) ? Y(-ce) : ce;
    }
    const A = (ce, ve, Be) => r.bytesToNumberBE(ce.slice(ve, Be));
    class S {
      constructor(ve, Be, te) {
        this.r = ve, this.s = Be, this.recovery = te, this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(ve) {
        const Be = k.nByteLength;
        return ve = (0, i.ensureBytes)("compactSignature", ve, Be * 2), new S(A(ve, 0, Be), A(ve, Be, 2 * Be));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(ve) {
        const { r: Be, s: te } = e.DER.toSig((0, i.ensureBytes)("DER", ve));
        return new S(Be, te);
      }
      assertValidity() {
        if (!a(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!a(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(ve) {
        return new S(this.r, this.s, ve);
      }
      recoverPublicKey(ve) {
        const { r: Be, s: te, recovery: C } = this, L = oe((0, i.ensureBytes)("msgHash", ve));
        if (C == null || ![0, 1, 2, 3].includes(C))
          throw new Error("recovery id invalid");
        const G = C === 2 || C === 3 ? Be + k.n : Be;
        if (G >= N.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const de = C & 1 ? "03" : "02", me = j.fromHex(de + d(G)), Te = ue(G), He = Y(-L * Te), H = Y(te * Te), se = j.BASE.multiplyAndAddUnsafe(me, He, H);
        if (!se)
          throw new Error("point at infinify");
        return se.assertValidity(), se;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return w(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new S(this.r, Y(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return r.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return r.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return d(this.r) + d(this.s);
      }
    }
    const y = {
      isValidPrivateKey(ce) {
        try {
          return g(ce), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: g,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const ce = t.getMinHashLength(k.n);
        return t.mapHashToField(k.randomBytes(ce), k.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(ce = 8, ve = j.BASE) {
        return ve._setWindowSize(ce), ve.multiply(BigInt(3)), ve;
      }
    };
    function _(ce, ve = !0) {
      return j.fromPrivateKey(ce).toRawBytes(ve);
    }
    function l(ce) {
      const ve = r.isBytes(ce), Be = typeof ce == "string", te = (ve || Be) && ce.length;
      return ve ? te === D || te === U : Be ? te === 2 * D || te === 2 * U : ce instanceof j;
    }
    function R(ce, ve, Be = !0) {
      if (l(ce))
        throw new Error("first arg must be private key");
      if (!l(ve))
        throw new Error("second arg must be public key");
      return j.fromHex(ve).multiply(g(ce)).toRawBytes(Be);
    }
    const ee = k.bits2int || function(ce) {
      const ve = r.bytesToNumberBE(ce), Be = ce.length * 8 - k.nBitLength;
      return Be > 0 ? ve >> BigInt(Be) : ve;
    }, oe = k.bits2int_modN || function(ce) {
      return Y(ee(ce));
    }, V = r.bitMask(k.nBitLength);
    function W(ce) {
      if (typeof ce != "bigint")
        throw new Error("bigint expected");
      if (!(c <= ce && ce < V))
        throw new Error(`bigint expected < 2^${k.nBitLength}`);
      return r.numberToBytesBE(ce, k.nByteLength);
    }
    function F(ce, ve, Be = re) {
      if (["recovered", "canonical"].some((_e) => _e in Be))
        throw new Error("sign() legacy options not supported");
      const { hash: te, randomBytes: C } = k;
      let { lowS: L, prehash: G, extraEntropy: de } = Be;
      L == null && (L = !0), ce = (0, i.ensureBytes)("msgHash", ce), G && (ce = (0, i.ensureBytes)("prehashed msgHash", te(ce)));
      const me = oe(ce), Te = g(ve), He = [W(Te), W(me)];
      if (de != null) {
        const _e = de === !0 ? C(N.BYTES) : de;
        He.push((0, i.ensureBytes)("extraEntropy", _e));
      }
      const H = r.concatBytes(...He), se = me;
      function fe(_e) {
        const Ce = ee(_e);
        if (!a(Ce))
          return;
        const Ve = ue(Ce), ke = j.BASE.multiply(Ce).toAffine(), Q = Y(ke.x);
        if (Q === c)
          return;
        const Se = Y(Ve * Y(se + Q * Te));
        if (Se === c)
          return;
        let Ae = (ke.x === Q ? 0 : 2) | Number(ke.y & h), $e = Se;
        return L && w(Se) && ($e = x(Se), Ae ^= 1), new S(Q, $e, Ae);
      }
      return { seed: H, k2sig: fe };
    }
    const re = { lowS: k.lowS, prehash: !1 }, he = { lowS: k.lowS, prehash: !1 };
    function Z(ce, ve, Be = re) {
      const { seed: te, k2sig: C } = F(ce, ve, Be), L = k;
      return r.createHmacDrbg(L.hash.outputLen, L.nByteLength, L.hmac)(te, C);
    }
    j.BASE._setWindowSize(8);
    function K(ce, ve, Be, te = he) {
      var ke;
      const C = ce;
      if (ve = (0, i.ensureBytes)("msgHash", ve), Be = (0, i.ensureBytes)("publicKey", Be), "strict" in te)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: L, prehash: G } = te;
      let de, me;
      try {
        if (typeof C == "string" || r.isBytes(C))
          try {
            de = S.fromDER(C);
          } catch (Q) {
            if (!(Q instanceof e.DER.Err))
              throw Q;
            de = S.fromCompact(C);
          }
        else if (typeof C == "object" && typeof C.r == "bigint" && typeof C.s == "bigint") {
          const { r: Q, s: Se } = C;
          de = new S(Q, Se);
        } else
          throw new Error("PARSE");
        me = j.fromHex(Be);
      } catch (Q) {
        if (Q.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (L && de.hasHighS())
        return !1;
      G && (ve = k.hash(ve));
      const { r: Te, s: He } = de, H = oe(ve), se = ue(He), fe = Y(H * se), _e = Y(Te * se), Ce = (ke = j.BASE.multiplyAndAddUnsafe(me, fe, _e)) == null ? void 0 : ke.toAffine();
      return Ce ? Y(Ce.x) === Te : !1;
    }
    return {
      CURVE: k,
      getPublicKey: _,
      getSharedSecret: R,
      sign: Z,
      verify: K,
      ProjectivePoint: j,
      Signature: S,
      utils: y
    };
  }
  e.weierstrass = M;
  function I(T, k) {
    const N = T.ORDER;
    let q = c;
    for (let w = N - h; w % s === c; w /= s)
      q += h;
    const D = q, U = s << D - h - h, z = U * s, Y = (N - h) / z, ue = (Y - h) / s, j = z - h, g = U, b = T.pow(k, Y), a = T.pow(k, (Y + h) / s);
    let d = (w, x) => {
      let A = b, S = T.pow(x, j), y = T.sqr(S);
      y = T.mul(y, x);
      let _ = T.mul(w, y);
      _ = T.pow(_, ue), _ = T.mul(_, S), S = T.mul(_, x), y = T.mul(_, w);
      let l = T.mul(y, S);
      _ = T.pow(l, g);
      let R = T.eql(_, T.ONE);
      S = T.mul(y, a), _ = T.mul(l, A), y = T.cmov(S, y, R), l = T.cmov(_, l, R);
      for (let ee = D; ee > h; ee--) {
        let oe = ee - s;
        oe = s << oe - h;
        let V = T.pow(l, oe);
        const W = T.eql(V, T.ONE);
        S = T.mul(y, A), A = T.mul(A, A), V = T.mul(l, A), y = T.cmov(S, y, W), l = T.cmov(V, l, W);
      }
      return { isValid: R, value: y };
    };
    if (T.ORDER % v === p) {
      const w = (T.ORDER - p) / v, x = T.sqrt(T.neg(k));
      d = (A, S) => {
        let y = T.sqr(S);
        const _ = T.mul(A, S);
        y = T.mul(y, _);
        let l = T.pow(y, w);
        l = T.mul(l, _);
        const R = T.mul(l, x), ee = T.mul(T.sqr(l), S), oe = T.eql(ee, A);
        let V = T.cmov(R, l, oe);
        return { isValid: oe, value: V };
      };
    }
    return d;
  }
  e.SWUFpSqrtRatio = I;
  function B(T, k) {
    if (t.validateField(T), !T.isValid(k.A) || !T.isValid(k.B) || !T.isValid(k.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const N = I(T, k.Z);
    if (!T.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (q) => {
      let D, U, z, Y, ue, j, g, b;
      D = T.sqr(q), D = T.mul(D, k.Z), U = T.sqr(D), U = T.add(U, D), z = T.add(U, T.ONE), z = T.mul(z, k.B), Y = T.cmov(k.Z, T.neg(U), !T.eql(U, T.ZERO)), Y = T.mul(Y, k.A), U = T.sqr(z), j = T.sqr(Y), ue = T.mul(j, k.A), U = T.add(U, ue), U = T.mul(U, z), j = T.mul(j, Y), ue = T.mul(j, k.B), U = T.add(U, ue), g = T.mul(D, z);
      const { isValid: a, value: d } = N(U, j);
      b = T.mul(D, q), b = T.mul(b, d), g = T.cmov(g, z, a), b = T.cmov(b, d, a);
      const w = T.isOdd(q) === T.isOdd(b);
      return b = T.cmov(T.neg(b), b, w), g = T.div(g, Y), { x: g, y: b };
    };
  }
  e.mapToCurveSimpleSWU = B;
})(Qh);
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.createHasher = $r.isogenyMap = $r.hash_to_field = $r.expand_message_xof = $r.expand_message_xmd = void 0;
const P5 = wt, Ar = gt;
function C5(e) {
  if ((0, Ar.isBytes)(e))
    return e;
  if (typeof e == "string")
    return (0, Ar.utf8ToBytes)(e);
  throw new Error("DST must be Uint8Array or string");
}
const N5 = Ar.bytesToNumberBE;
function An(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let i = t - 1; i >= 0; i--)
    r[i] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function L5(e, t) {
  const r = new Uint8Array(e.length);
  for (let i = 0; i < e.length; i++)
    r[i] = e[i] ^ t[i];
  return r;
}
function da(e) {
  if (!(0, Ar.isBytes)(e))
    throw new Error("Uint8Array expected");
}
function e0(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function cy(e, t, r, i) {
  da(e), da(t), e0(r), t.length > 255 && (t = i((0, Ar.concatBytes)((0, Ar.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: o, blockLen: n } = i, f = Math.ceil(r / o);
  if (f > 255)
    throw new Error("Invalid xmd length");
  const u = (0, Ar.concatBytes)(t, An(t.length, 1)), c = An(0, n), h = An(r, 2), s = new Array(f), p = i((0, Ar.concatBytes)(c, e, h, An(0, 1), u));
  s[0] = i((0, Ar.concatBytes)(p, An(1, 1), u));
  for (let m = 1; m <= f; m++) {
    const E = [L5(p, s[m - 1]), An(m + 1, 1), u];
    s[m] = i((0, Ar.concatBytes)(...E));
  }
  return (0, Ar.concatBytes)(...s).slice(0, r);
}
$r.expand_message_xmd = cy;
function hy(e, t, r, i, o) {
  if (da(e), da(t), e0(r), t.length > 255) {
    const n = Math.ceil(2 * i / 8);
    t = o.create({ dkLen: n }).update((0, Ar.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return o.create({ dkLen: r }).update(e).update(An(r, 2)).update(t).update(An(t.length, 1)).digest();
}
$r.expand_message_xof = hy;
function nh(e, t, r) {
  (0, Ar.validateObject)(r, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: i, k: o, m: n, hash: f, expand: u, DST: c } = r;
  da(e), e0(t);
  const h = C5(c), s = i.toString(2).length, p = Math.ceil((s + o) / 8), v = t * n * p;
  let m;
  if (u === "xmd")
    m = cy(e, h, v, f);
  else if (u === "xof")
    m = hy(e, h, v, o, f);
  else if (u === "_internal_pass")
    m = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const E = new Array(t);
  for (let M = 0; M < t; M++) {
    const I = new Array(n);
    for (let B = 0; B < n; B++) {
      const T = p * (B + M * n), k = m.subarray(T, T + p);
      I[B] = (0, P5.mod)(N5(k), i);
    }
    E[M] = I;
  }
  return E;
}
$r.hash_to_field = nh;
function k5(e, t) {
  const r = t.map((i) => Array.from(i).reverse());
  return (i, o) => {
    const [n, f, u, c] = r.map((h) => h.reduce((s, p) => e.add(e.mul(s, i), p)));
    return i = e.div(n, f), o = e.mul(o, e.div(u, c)), { x: i, y: o };
  };
}
$r.isogenyMap = k5;
function q5(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(i, o) {
      const n = nh(i, 2, { ...r, DST: r.DST, ...o }), f = e.fromAffine(t(n[0])), u = e.fromAffine(t(n[1])), c = f.add(u).clearCofactor();
      return c.assertValidity(), c;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(i, o) {
      const n = nh(i, 1, { ...r, DST: r.encodeDST, ...o }), f = e.fromAffine(t(n[0])).clearCofactor();
      return f.assertValidity(), f;
    }
  };
}
$r.createHasher = q5;
var qi = {}, ly = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = ur, r = wn;
  class i extends r.Hash {
    constructor(f, u) {
      super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(f);
      const c = (0, r.toBytes)(u);
      if (this.iHash = f.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const h = this.blockLen, s = new Uint8Array(h);
      s.set(c.length > h ? f.create().update(c).digest() : c);
      for (let p = 0; p < s.length; p++)
        s[p] ^= 54;
      this.iHash.update(s), this.oHash = f.create();
      for (let p = 0; p < s.length; p++)
        s[p] ^= 106;
      this.oHash.update(s), s.fill(0);
    }
    update(f) {
      return (0, t.exists)(this), this.iHash.update(f), this;
    }
    digestInto(f) {
      (0, t.exists)(this), (0, t.bytes)(f, this.outputLen), this.finished = !0, this.iHash.digestInto(f), this.oHash.update(f), this.oHash.digestInto(f), this.destroy();
    }
    digest() {
      const f = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(f), f;
    }
    _cloneInto(f) {
      f || (f = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: u, iHash: c, finished: h, destroyed: s, blockLen: p, outputLen: v } = this;
      return f = f, f.finished = h, f.destroyed = s, f.blockLen = p, f.outputLen = v, f.oHash = u._cloneInto(f.oHash), f.iHash = c._cloneInto(f.iHash), f;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = i;
  const o = (n, f, u) => new i(n, f).update(u).digest();
  e.hmac = o, e.hmac.create = (n, f) => new i(n, f);
})(ly);
Object.defineProperty(qi, "__esModule", { value: !0 });
qi.createCurve = qi.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $5 = ly, Hl = wn, D5 = Qh;
function dy(e) {
  return {
    hash: e,
    hmac: (t, ...r) => (0, $5.hmac)(e, t, (0, Hl.concatBytes)(...r)),
    randomBytes: Hl.randomBytes
  };
}
qi.getHash = dy;
function j5(e, t) {
  const r = (i) => (0, D5.weierstrass)({ ...e, ...dy(i) });
  return Object.freeze({ ...r(t), create: r });
}
qi.createCurve = j5;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Li, r = wn, i = wt, o = Qh, n = gt, f = $r, u = qi, c = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), h = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), s = BigInt(1), p = BigInt(2), v = (S, y) => (S + y / p) / y;
  function m(S) {
    const y = c, _ = BigInt(3), l = BigInt(6), R = BigInt(11), ee = BigInt(22), oe = BigInt(23), V = BigInt(44), W = BigInt(88), F = S * S * S % y, re = F * F * S % y, he = (0, i.pow2)(re, _, y) * re % y, Z = (0, i.pow2)(he, _, y) * re % y, K = (0, i.pow2)(Z, p, y) * F % y, ce = (0, i.pow2)(K, R, y) * K % y, ve = (0, i.pow2)(ce, ee, y) * ce % y, Be = (0, i.pow2)(ve, V, y) * ve % y, te = (0, i.pow2)(Be, W, y) * Be % y, C = (0, i.pow2)(te, V, y) * ve % y, L = (0, i.pow2)(C, _, y) * re % y, G = (0, i.pow2)(L, oe, y) * ce % y, de = (0, i.pow2)(G, l, y) * F % y, me = (0, i.pow2)(de, p, y);
    if (!E.eql(E.sqr(me), S))
      throw new Error("Cannot find square root");
    return me;
  }
  const E = (0, i.Field)(c, void 0, void 0, { sqrt: m });
  e.secp256k1 = (0, u.createCurve)({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp: E,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: h,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (S) => {
        const y = h, _ = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), l = -s * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), R = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ee = _, oe = BigInt("0x100000000000000000000000000000000"), V = v(ee * S, y), W = v(-l * S, y);
        let F = (0, i.mod)(S - V * _ - W * R, y), re = (0, i.mod)(-V * l - W * ee, y);
        const he = F > oe, Z = re > oe;
        if (he && (F = y - F), Z && (re = y - re), F > oe || re > oe)
          throw new Error("splitScalar: Endomorphism failed, k=" + S);
        return { k1neg: he, k1: F, k2neg: Z, k2: re };
      }
    }
  }, t.sha256);
  const M = BigInt(0), I = (S) => typeof S == "bigint" && M < S && S < c, B = (S) => typeof S == "bigint" && M < S && S < h, T = {};
  function k(S, ...y) {
    let _ = T[S];
    if (_ === void 0) {
      const l = (0, t.sha256)(Uint8Array.from(S, (R) => R.charCodeAt(0)));
      _ = (0, n.concatBytes)(l, l), T[S] = _;
    }
    return (0, t.sha256)((0, n.concatBytes)(_, ...y));
  }
  const N = (S) => S.toRawBytes(!0).slice(1), q = (S) => (0, n.numberToBytesBE)(S, 32), D = (S) => (0, i.mod)(S, c), U = (S) => (0, i.mod)(S, h), z = e.secp256k1.ProjectivePoint, Y = (S, y, _) => z.BASE.multiplyAndAddUnsafe(S, y, _);
  function ue(S) {
    let y = e.secp256k1.utils.normPrivateKeyToScalar(S), _ = z.fromPrivateKey(y);
    return { scalar: _.hasEvenY() ? y : U(-y), bytes: N(_) };
  }
  function j(S) {
    if (!I(S))
      throw new Error("bad x: need 0 < x < p");
    const y = D(S * S), _ = D(y * S + BigInt(7));
    let l = m(_);
    l % p !== M && (l = D(-l));
    const R = new z(S, l, s);
    return R.assertValidity(), R;
  }
  function g(...S) {
    return U((0, n.bytesToNumberBE)(k("BIP0340/challenge", ...S)));
  }
  function b(S) {
    return ue(S).bytes;
  }
  function a(S, y, _ = (0, r.randomBytes)(32)) {
    const l = (0, n.ensureBytes)("message", S), { bytes: R, scalar: ee } = ue(y), oe = (0, n.ensureBytes)("auxRand", _, 32), V = q(ee ^ (0, n.bytesToNumberBE)(k("BIP0340/aux", oe))), W = k("BIP0340/nonce", V, R, l), F = U((0, n.bytesToNumberBE)(W));
    if (F === M)
      throw new Error("sign failed: k is zero");
    const { bytes: re, scalar: he } = ue(F), Z = g(re, R, l), K = new Uint8Array(64);
    if (K.set(re, 0), K.set(q(U(he + Z * ee)), 32), !d(K, l, R))
      throw new Error("sign: Invalid signature produced");
    return K;
  }
  function d(S, y, _) {
    const l = (0, n.ensureBytes)("signature", S, 64), R = (0, n.ensureBytes)("message", y), ee = (0, n.ensureBytes)("publicKey", _, 32);
    try {
      const oe = j((0, n.bytesToNumberBE)(ee)), V = (0, n.bytesToNumberBE)(l.subarray(0, 32));
      if (!I(V))
        return !1;
      const W = (0, n.bytesToNumberBE)(l.subarray(32, 64));
      if (!B(W))
        return !1;
      const F = g(q(V), N(oe), R), re = Y(oe, W, U(-F));
      return !(!re || !re.hasEvenY() || re.toAffine().x !== V);
    } catch {
      return !1;
    }
  }
  e.schnorr = {
    getPublicKey: b,
    sign: a,
    verify: d,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: j,
      pointToBytes: N,
      numberToBytesBE: n.numberToBytesBE,
      bytesToNumberBE: n.bytesToNumberBE,
      taggedHash: k,
      mod: i.mod
    }
  };
  const w = (0, f.isogenyMap)(E, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((S) => S.map((y) => BigInt(y)))), x = (0, o.mapToCurveSimpleSWU)(E, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: E.create(BigInt("-11"))
  }), A = (0, f.createHasher)(e.secp256k1.ProjectivePoint, (S) => {
    const { x: y, y: _ } = x(E.create(S[0]));
    return w(y, _);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: E.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: t.sha256
  });
  e.hashToCurve = A.hashToCurve, e.encodeToCurve = A.encodeToCurve;
})(Zb);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.secp256k1 = void 0;
  var t = Zb;
  Object.defineProperty(e, "secp256k1", { enumerable: !0, get: function() {
    return t.secp256k1;
  } });
})(Go);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MAX_WITHDRAWALS_PER_PAYLOAD = e.RLP_EMPTY_STRING = e.KECCAK256_RLP = e.KECCAK256_RLP_S = e.KECCAK256_RLP_ARRAY = e.KECCAK256_RLP_ARRAY_S = e.KECCAK256_NULL = e.KECCAK256_NULL_S = e.TWO_POW256 = e.SECP256K1_ORDER_DIV_2 = e.SECP256K1_ORDER = e.MAX_INTEGER_BIGINT = e.MAX_INTEGER = e.MAX_UINT64 = void 0;
  const t = Le, r = Go;
  e.MAX_UINT64 = BigInt("0xffffffffffffffff"), e.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), e.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), e.SECP256K1_ORDER = r.secp256k1.CURVE.n, e.SECP256K1_ORDER_DIV_2 = r.secp256k1.CURVE.n / BigInt(2), e.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), e.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", e.KECCAK256_NULL = t.Buffer.from(e.KECCAK256_NULL_S, "hex"), e.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", e.KECCAK256_RLP_ARRAY = t.Buffer.from(e.KECCAK256_RLP_ARRAY_S, "hex"), e.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", e.KECCAK256_RLP = t.Buffer.from(e.KECCAK256_RLP_S, "hex"), e.RLP_EMPTY_STRING = t.Buffer.from([128]), e.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
})(Zo);
var ef = {};
Object.defineProperty(ef, "__esModule", { value: !0 });
ef.GWEI_TO_WEI = void 0;
ef.GWEI_TO_WEI = BigInt(1e9);
var t0 = {}, sn = {};
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.RLP = sn.utils = sn.decode = sn.encode = void 0;
function r0(e) {
  if (Array.isArray(e)) {
    const r = [];
    let i = 0;
    for (let o = 0; o < e.length; o++) {
      const n = r0(e[o]);
      r.push(n), i += n.length;
    }
    return ah(Vl(i, 192), ...r);
  }
  const t = my(e);
  return t.length === 1 && t[0] < 128 ? t : ah(Vl(t.length, 128), t);
}
sn.encode = r0;
function pi(e, t, r) {
  if (r > e.length)
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  return e.slice(t, r);
}
function zl(e) {
  if (e[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return by(vy(e));
}
function Vl(e, t) {
  if (e < 56)
    return Uint8Array.from([e + t]);
  const r = oh(e), i = r.length / 2, o = oh(t + 55 + i);
  return Uint8Array.from(go(o + r));
}
function py(e, t = !1) {
  if (typeof e > "u" || e === null || e.length === 0)
    return Uint8Array.from([]);
  const r = my(e), i = ih(r);
  if (t)
    return i;
  if (i.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return i.data;
}
sn.decode = py;
function ih(e) {
  let t, r, i, o, n;
  const f = [], u = e[0];
  if (u <= 127)
    return {
      data: e.slice(0, 1),
      remainder: e.slice(1)
    };
  if (u <= 183) {
    if (t = u - 127, u === 128 ? i = Uint8Array.from([]) : i = pi(e, 1, t), t === 2 && i[0] < 128)
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    return {
      data: i,
      remainder: e.slice(t)
    };
  } else if (u <= 191) {
    if (r = u - 182, e.length - 1 < r)
      throw new Error("invalid RLP: not enough bytes for string length");
    if (t = zl(pi(e, 1, r)), t <= 55)
      throw new Error("invalid RLP: expected string length to be greater than 55");
    return i = pi(e, r, t + r), {
      data: i,
      remainder: e.slice(t + r)
    };
  } else if (u <= 247) {
    for (t = u - 191, o = pi(e, 1, t); o.length; )
      n = ih(o), f.push(n.data), o = n.remainder;
    return {
      data: f,
      remainder: e.slice(t)
    };
  } else {
    if (r = u - 246, t = zl(pi(e, 1, r)), t < 56)
      throw new Error("invalid RLP: encoded list too short");
    const c = r + t;
    if (c > e.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (o = pi(e, r, c); o.length; )
      n = ih(o), f.push(n.data), o = n.remainder;
    return {
      data: f,
      remainder: e.slice(c)
    };
  }
}
const U5 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function vy(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += U5[e[r]];
  return t;
}
function by(e) {
  const t = Number.parseInt(e, 16);
  if (Number.isNaN(t))
    throw new Error("Invalid byte sequence");
  return t;
}
function go(e) {
  if (typeof e != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof e);
  if (e.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const i = r * 2;
    t[r] = by(e.slice(i, i + 2));
  }
  return t;
}
function ah(...e) {
  if (e.length === 1)
    return e[0];
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  for (let i = 0, o = 0; i < e.length; i++) {
    const n = e[i];
    r.set(n, o), o += n.length;
  }
  return r;
}
function yy(e) {
  return new TextEncoder().encode(e);
}
function oh(e) {
  if (e < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const t = e.toString(16);
  return t.length % 2 ? `0${t}` : t;
}
function F5(e) {
  return e.length % 2 ? `0${e}` : e;
}
function gy(e) {
  return e.length >= 2 && e[0] === "0" && e[1] === "x";
}
function H5(e) {
  return typeof e != "string" ? e : gy(e) ? e.slice(2) : e;
}
function my(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return gy(e) ? go(F5(H5(e))) : yy(e);
  if (typeof e == "number" || typeof e == "bigint")
    return e ? go(oh(e)) : Uint8Array.from([]);
  if (e == null)
    return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof e);
}
sn.utils = {
  bytesToHex: vy,
  concatBytes: ah,
  hexToBytes: go,
  utf8ToBytes: yy
};
sn.RLP = { encode: r0, decode: py };
var jr = {}, Ht = {}, yt = {};
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.add5L = yt.add5H = yt.add4H = yt.add4L = yt.add3H = yt.add3L = yt.add = yt.rotlBL = yt.rotlBH = yt.rotlSL = yt.rotlSH = yt.rotr32L = yt.rotr32H = yt.rotrBL = yt.rotrBH = yt.rotrSL = yt.rotrSH = yt.shrSL = yt.shrSH = yt.toBig = yt.split = yt.fromBig = void 0;
const Ua = /* @__PURE__ */ BigInt(2 ** 32 - 1), fh = /* @__PURE__ */ BigInt(32);
function n0(e, t = !1) {
  return t ? { h: Number(e & Ua), l: Number(e >> fh & Ua) } : { h: Number(e >> fh & Ua) | 0, l: Number(e & Ua) | 0 };
}
yt.fromBig = n0;
function wy(e, t = !1) {
  let r = new Uint32Array(e.length), i = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: n, l: f } = n0(e[o], t);
    [r[o], i[o]] = [n, f];
  }
  return [r, i];
}
yt.split = wy;
const _y = (e, t) => BigInt(e >>> 0) << fh | BigInt(t >>> 0);
yt.toBig = _y;
const xy = (e, t, r) => e >>> r;
yt.shrSH = xy;
const Ey = (e, t, r) => e << 32 - r | t >>> r;
yt.shrSL = Ey;
const Sy = (e, t, r) => e >>> r | t << 32 - r;
yt.rotrSH = Sy;
const Ay = (e, t, r) => e << 32 - r | t >>> r;
yt.rotrSL = Ay;
const My = (e, t, r) => e << 64 - r | t >>> r - 32;
yt.rotrBH = My;
const Ry = (e, t, r) => e >>> r - 32 | t << 64 - r;
yt.rotrBL = Ry;
const By = (e, t) => t;
yt.rotr32H = By;
const Iy = (e, t) => e;
yt.rotr32L = Iy;
const Ty = (e, t, r) => e << r | t >>> 32 - r;
yt.rotlSH = Ty;
const Oy = (e, t, r) => t << r | e >>> 32 - r;
yt.rotlSL = Oy;
const Py = (e, t, r) => t << r - 32 | e >>> 64 - r;
yt.rotlBH = Py;
const Cy = (e, t, r) => e << r - 32 | t >>> 64 - r;
yt.rotlBL = Cy;
function Ny(e, t, r, i) {
  const o = (t >>> 0) + (i >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
yt.add = Ny;
const Ly = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
yt.add3L = Ly;
const ky = (e, t, r, i) => t + r + i + (e / 2 ** 32 | 0) | 0;
yt.add3H = ky;
const qy = (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0);
yt.add4L = qy;
const $y = (e, t, r, i, o) => t + r + i + o + (e / 2 ** 32 | 0) | 0;
yt.add4H = $y;
const Dy = (e, t, r, i, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (o >>> 0);
yt.add5L = Dy;
const jy = (e, t, r, i, o, n) => t + r + i + o + n + (e / 2 ** 32 | 0) | 0;
yt.add5H = jy;
const z5 = {
  fromBig: n0,
  split: wy,
  toBig: _y,
  shrSH: xy,
  shrSL: Ey,
  rotrSH: Sy,
  rotrSL: Ay,
  rotrBH: My,
  rotrBL: Ry,
  rotr32H: By,
  rotr32L: Iy,
  rotlSH: Ty,
  rotlSL: Oy,
  rotlBH: Py,
  rotlBL: Cy,
  add: Ny,
  add3L: Ly,
  add3H: ky,
  add4L: qy,
  add4H: $y,
  add5H: jy,
  add5L: Dy
};
yt.default = z5;
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.shake256 = Ht.shake128 = Ht.keccak_512 = Ht.keccak_384 = Ht.keccak_256 = Ht.keccak_224 = Ht.sha3_512 = Ht.sha3_384 = Ht.sha3_256 = Ht.sha3_224 = Ht.Keccak = Ht.keccakP = void 0;
const vi = ur, pa = yt, fa = wn, [Uy, Fy, Hy] = [[], [], []], V5 = /* @__PURE__ */ BigInt(0), ea = /* @__PURE__ */ BigInt(1), W5 = /* @__PURE__ */ BigInt(2), K5 = /* @__PURE__ */ BigInt(7), Z5 = /* @__PURE__ */ BigInt(256), G5 = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = ea, r = 1, i = 0; e < 24; e++) {
  [r, i] = [i, (2 * r + 3 * i) % 5], Uy.push(2 * (5 * i + r)), Fy.push((e + 1) * (e + 2) / 2 % 64);
  let o = V5;
  for (let n = 0; n < 7; n++)
    t = (t << ea ^ (t >> K5) * G5) % Z5, t & W5 && (o ^= ea << (ea << /* @__PURE__ */ BigInt(n)) - ea);
  Hy.push(o);
}
const [J5, X5] = /* @__PURE__ */ (0, pa.split)(Hy, !0), Wl = (e, t, r) => r > 32 ? (0, pa.rotlBH)(e, t, r) : (0, pa.rotlSH)(e, t, r), Kl = (e, t, r) => r > 32 ? (0, pa.rotlBL)(e, t, r) : (0, pa.rotlSL)(e, t, r);
function zy(e, t = 24) {
  const r = new Uint32Array(10);
  for (let i = 24 - t; i < 24; i++) {
    for (let f = 0; f < 10; f++)
      r[f] = e[f] ^ e[f + 10] ^ e[f + 20] ^ e[f + 30] ^ e[f + 40];
    for (let f = 0; f < 10; f += 2) {
      const u = (f + 8) % 10, c = (f + 2) % 10, h = r[c], s = r[c + 1], p = Wl(h, s, 1) ^ r[u], v = Kl(h, s, 1) ^ r[u + 1];
      for (let m = 0; m < 50; m += 10)
        e[f + m] ^= p, e[f + m + 1] ^= v;
    }
    let o = e[2], n = e[3];
    for (let f = 0; f < 24; f++) {
      const u = Fy[f], c = Wl(o, n, u), h = Kl(o, n, u), s = Uy[f];
      o = e[s], n = e[s + 1], e[s] = c, e[s + 1] = h;
    }
    for (let f = 0; f < 50; f += 10) {
      for (let u = 0; u < 10; u++)
        r[u] = e[f + u];
      for (let u = 0; u < 10; u++)
        e[f + u] ^= ~r[(u + 2) % 10] & r[(u + 4) % 10];
    }
    e[0] ^= J5[i], e[1] ^= X5[i];
  }
  r.fill(0);
}
Ht.keccakP = zy;
class Ba extends fa.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, r, i, o = !1, n = 24) {
    if (super(), this.blockLen = t, this.suffix = r, this.outputLen = i, this.enableXOF = o, this.rounds = n, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, vi.number)(i), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = (0, fa.u32)(this.state);
  }
  keccak() {
    zy(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    (0, vi.exists)(this);
    const { blockLen: r, state: i } = this;
    t = (0, fa.toBytes)(t);
    const o = t.length;
    for (let n = 0; n < o; ) {
      const f = Math.min(r - this.pos, o - n);
      for (let u = 0; u < f; u++)
        i[this.pos++] ^= t[n++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: r, pos: i, blockLen: o } = this;
    t[i] ^= r, r & 128 && i === o - 1 && this.keccak(), t[o - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    (0, vi.exists)(this, !1), (0, vi.bytes)(t), this.finish();
    const r = this.state, { blockLen: i } = this;
    for (let o = 0, n = t.length; o < n; ) {
      this.posOut >= i && this.keccak();
      const f = Math.min(i - this.posOut, n - o);
      t.set(r.subarray(this.posOut, this.posOut + f), o), this.posOut += f, o += f;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return (0, vi.number)(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((0, vi.output)(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: r, suffix: i, outputLen: o, rounds: n, enableXOF: f } = this;
    return t || (t = new Ba(r, i, o, f, n)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = n, t.suffix = i, t.outputLen = o, t.enableXOF = f, t.destroyed = this.destroyed, t;
  }
}
Ht.Keccak = Ba;
const kn = (e, t, r) => (0, fa.wrapConstructor)(() => new Ba(t, e, r));
Ht.sha3_224 = kn(6, 144, 224 / 8);
Ht.sha3_256 = kn(6, 136, 256 / 8);
Ht.sha3_384 = kn(6, 104, 384 / 8);
Ht.sha3_512 = kn(6, 72, 512 / 8);
Ht.keccak_224 = kn(1, 144, 224 / 8);
Ht.keccak_256 = kn(1, 136, 256 / 8);
Ht.keccak_384 = kn(1, 104, 384 / 8);
Ht.keccak_512 = kn(1, 72, 512 / 8);
const Vy = (e, t, r) => (0, fa.wrapXOFConstructorWithOpts)((i = {}) => new Ba(t, e, i.dkLen === void 0 ? r : i.dkLen, !0));
Ht.shake128 = Vy(31, 168, 128 / 8);
Ht.shake256 = Vy(31, 136, 256 / 8);
function sh(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var mo = { exports: {} };
mo.exports;
(function(e, t) {
  var r = Ze && Ze.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;
  const i = r(ur), o = wn, n = i.default.bool;
  t.assertBool = n;
  const f = i.default.bytes;
  t.assertBytes = f;
  var u = wn;
  Object.defineProperty(t, "bytesToHex", { enumerable: !0, get: function() {
    return u.bytesToHex;
  } }), Object.defineProperty(t, "toHex", { enumerable: !0, get: function() {
    return u.bytesToHex;
  } }), Object.defineProperty(t, "concatBytes", { enumerable: !0, get: function() {
    return u.concatBytes;
  } }), Object.defineProperty(t, "createView", { enumerable: !0, get: function() {
    return u.createView;
  } }), Object.defineProperty(t, "utf8ToBytes", { enumerable: !0, get: function() {
    return u.utf8ToBytes;
  } });
  function c(v) {
    if (!(v instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof v}`);
    return new TextDecoder().decode(v);
  }
  t.bytesToUtf8 = c;
  function h(v) {
    const m = v.startsWith("0x") ? v.substring(2) : v;
    return (0, o.hexToBytes)(m);
  }
  t.hexToBytes = h;
  function s(v, m) {
    if (v.length !== m.length)
      return !1;
    for (let E = 0; E < v.length; E++)
      if (v[E] !== m[E])
        return !1;
    return !0;
  }
  t.equalsBytes = s;
  function p(v) {
    return (m) => (i.default.bytes(m), v(m));
  }
  t.wrapHash = p, t.crypto = (() => {
    const v = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, m = typeof sh == "function" && sh.bind(e);
    return {
      node: m && !v ? m("crypto") : void 0,
      web: v
    };
  })();
})(mo, mo.exports);
var Wy = mo.exports;
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.keccak512 = jr.keccak384 = jr.keccak256 = jr.keccak224 = void 0;
const va = Ht, tf = Wy;
jr.keccak224 = (0, tf.wrapHash)(va.keccak_224);
jr.keccak256 = (() => {
  const e = (0, tf.wrapHash)(va.keccak_256);
  return e.create = va.keccak_256.create, e;
})();
jr.keccak384 = (0, tf.wrapHash)(va.keccak_384);
jr.keccak512 = (0, tf.wrapHash)(va.keccak_512);
var oi = {}, Ur = {}, zt = {};
Object.defineProperty(zt, "__esModule", { value: !0 });
zt.isHexString = zt.getKeys = zt.fromAscii = zt.fromUtf8 = zt.toAscii = zt.arrayContainsArray = zt.getBinarySize = zt.padToEven = zt.stripHexPrefix = zt.isHexPrefixed = void 0;
function Ky(e) {
  if (typeof e != "string")
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);
  return e[0] === "0" && e[1] === "x";
}
zt.isHexPrefixed = Ky;
const Y5 = (e) => {
  if (typeof e != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof e}`);
  return Ky(e) ? e.slice(2) : e;
};
zt.stripHexPrefix = Y5;
function Zy(e) {
  let t = e;
  if (typeof t != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof t}`);
  return t.length % 2 && (t = `0${t}`), t;
}
zt.padToEven = Zy;
function Q5(e) {
  if (typeof e != "string")
    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof e}`);
  return Le.Buffer.byteLength(e, "utf8");
}
zt.getBinarySize = Q5;
function ex(e, t, r) {
  if (Array.isArray(e) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e}'`);
  if (Array.isArray(t) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof t}'`);
  return t[r === !0 ? "some" : "every"]((i) => e.indexOf(i) >= 0);
}
zt.arrayContainsArray = ex;
function tx(e) {
  let t = "", r = 0;
  const i = e.length;
  for (e.substring(0, 2) === "0x" && (r = 2); r < i; r += 2) {
    const o = parseInt(e.substr(r, 2), 16);
    t += String.fromCharCode(o);
  }
  return t;
}
zt.toAscii = tx;
function rx(e) {
  const t = Le.Buffer.from(e, "utf8");
  return `0x${Zy(t.toString("hex")).replace(/^0+|0+$/g, "")}`;
}
zt.fromUtf8 = rx;
function nx(e) {
  let t = "";
  for (let r = 0; r < e.length; r++) {
    const o = e.charCodeAt(r).toString(16);
    t += o.length < 2 ? `0${o}` : o;
  }
  return `0x${t}`;
}
zt.fromAscii = nx;
function ix(e, t, r) {
  if (!Array.isArray(e))
    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof e}`);
  if (typeof t != "string")
    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof e}`);
  const i = [];
  for (let o = 0; o < e.length; o++) {
    let n = e[o][t];
    if (r === !0 && !n)
      n = "";
    else if (typeof n != "string")
      throw new Error(`invalid abi - expected type 'string', received ${typeof n}`);
    i.push(n);
  }
  return i;
}
zt.getKeys = ix;
function ax(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || typeof t < "u" && t > 0 && e.length !== 2 + 2 * t);
}
zt.isHexString = ax;
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.assertIsString = Ur.assertIsArray = Ur.assertIsBuffer = Ur.assertIsHexString = void 0;
const ox = zt, fx = function(e) {
  if (!(0, ox.isHexString)(e)) {
    const t = `This method only supports 0x-prefixed hex strings but input was: ${e}`;
    throw new Error(t);
  }
};
Ur.assertIsHexString = fx;
const sx = function(e) {
  if (!Le.Buffer.isBuffer(e)) {
    const t = `This method only supports Buffer but input was: ${e}`;
    throw new Error(t);
  }
};
Ur.assertIsBuffer = sx;
const ux = function(e) {
  if (!Array.isArray(e)) {
    const t = `This method only supports number arrays but input was: ${e}`;
    throw new Error(t);
  }
};
Ur.assertIsArray = ux;
const cx = function(e) {
  if (typeof e != "string") {
    const t = `This method only supports strings but input was: ${e}`;
    throw new Error(t);
  }
};
Ur.assertIsString = cx;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intToUnpaddedBuffer = e.bigIntToUnpaddedBuffer = e.bigIntToHex = e.bufArrToArr = e.arrToBufArr = e.validateNoLeadingZeroes = e.baToJSON = e.toUtf8 = e.short = e.addHexPrefix = e.toUnsigned = e.fromSigned = e.bufferToInt = e.bigIntToBuffer = e.bufferToBigInt = e.bufferToHex = e.toBuffer = e.unpadHexString = e.unpadArray = e.unpadBuffer = e.setLengthRight = e.setLengthLeft = e.zeros = e.intToBuffer = e.intToHex = void 0;
  const t = Ur, r = zt, i = function(a) {
    if (!Number.isSafeInteger(a) || a < 0)
      throw new Error(`Received an invalid integer type: ${a}`);
    return `0x${a.toString(16)}`;
  };
  e.intToHex = i;
  const o = function(a) {
    const d = (0, e.intToHex)(a);
    return Le.Buffer.from((0, r.padToEven)(d.slice(2)), "hex");
  };
  e.intToBuffer = o;
  const n = function(a) {
    return Le.Buffer.allocUnsafe(a).fill(0);
  };
  e.zeros = n;
  const f = function(a, d, w) {
    const x = (0, e.zeros)(d);
    return w ? a.length < d ? (a.copy(x), x) : a.slice(0, d) : a.length < d ? (a.copy(x, d - a.length), x) : a.slice(-d);
  }, u = function(a, d) {
    return (0, t.assertIsBuffer)(a), f(a, d, !1);
  };
  e.setLengthLeft = u;
  const c = function(a, d) {
    return (0, t.assertIsBuffer)(a), f(a, d, !0);
  };
  e.setLengthRight = c;
  const h = function(a) {
    let d = a[0];
    for (; a.length > 0 && d.toString() === "0"; )
      a = a.slice(1), d = a[0];
    return a;
  }, s = function(a) {
    return (0, t.assertIsBuffer)(a), h(a);
  };
  e.unpadBuffer = s;
  const p = function(a) {
    return (0, t.assertIsArray)(a), h(a);
  };
  e.unpadArray = p;
  const v = function(a) {
    return (0, t.assertIsHexString)(a), a = (0, r.stripHexPrefix)(a), "0x" + h(a);
  };
  e.unpadHexString = v;
  const m = function(a) {
    if (a == null)
      return Le.Buffer.allocUnsafe(0);
    if (Le.Buffer.isBuffer(a) || Array.isArray(a) || a instanceof Uint8Array)
      return Le.Buffer.from(a);
    if (typeof a == "string") {
      if (!(0, r.isHexString)(a))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${a}`);
      return Le.Buffer.from((0, r.padToEven)((0, r.stripHexPrefix)(a)), "hex");
    }
    if (typeof a == "number")
      return (0, e.intToBuffer)(a);
    if (typeof a == "bigint") {
      if (a < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${a}`);
      let d = a.toString(16);
      return d.length % 2 && (d = "0" + d), Le.Buffer.from(d, "hex");
    }
    if (a.toArray)
      return Le.Buffer.from(a.toArray());
    if (a.toBuffer)
      return Le.Buffer.from(a.toBuffer());
    throw new Error("invalid type");
  };
  e.toBuffer = m;
  const E = function(a) {
    return a = (0, e.toBuffer)(a), "0x" + a.toString("hex");
  };
  e.bufferToHex = E;
  function M(a) {
    const d = (0, e.bufferToHex)(a);
    return BigInt(d === "0x" ? 0 : d);
  }
  e.bufferToBigInt = M;
  function I(a) {
    return (0, e.toBuffer)("0x" + a.toString(16));
  }
  e.bigIntToBuffer = I;
  const B = function(a) {
    const d = Number(M(a));
    if (!Number.isSafeInteger(d))
      throw new Error("Number exceeds 53 bits");
    return d;
  };
  e.bufferToInt = B;
  const T = function(a) {
    return BigInt.asIntN(256, M(a));
  };
  e.fromSigned = T;
  const k = function(a) {
    return I(BigInt.asUintN(256, a));
  };
  e.toUnsigned = k;
  const N = function(a) {
    return typeof a != "string" || (0, r.isHexPrefixed)(a) ? a : "0x" + a;
  };
  e.addHexPrefix = N;
  function q(a, d = 50) {
    const w = Le.Buffer.isBuffer(a) ? a.toString("hex") : a;
    return w.length <= d ? w : w.slice(0, d) + "…";
  }
  e.short = q;
  const D = function(a) {
    const d = /^(00)+|(00)+$/g;
    if (a = (0, r.stripHexPrefix)(a), a.length % 2 !== 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return Le.Buffer.from(a.replace(d, ""), "hex").toString("utf8");
  };
  e.toUtf8 = D;
  const U = function(a) {
    if (Le.Buffer.isBuffer(a))
      return `0x${a.toString("hex")}`;
    if (a instanceof Array) {
      const d = [];
      for (let w = 0; w < a.length; w++)
        d.push((0, e.baToJSON)(a[w]));
      return d;
    }
  };
  e.baToJSON = U;
  const z = function(a) {
    for (const [d, w] of Object.entries(a))
      if (w !== void 0 && w.length > 0 && w[0] === 0)
        throw new Error(`${d} cannot have leading zeroes, received: ${w.toString("hex")}`);
  };
  e.validateNoLeadingZeroes = z;
  function Y(a) {
    return Array.isArray(a) ? a.map((d) => Y(d)) : Le.Buffer.from(a);
  }
  e.arrToBufArr = Y;
  function ue(a) {
    return Array.isArray(a) ? a.map((d) => ue(d)) : Uint8Array.from(a ?? []);
  }
  e.bufArrToArr = ue;
  const j = (a) => "0x" + a.toString(16);
  e.bigIntToHex = j;
  function g(a) {
    return (0, e.unpadBuffer)(I(a));
  }
  e.bigIntToUnpaddedBuffer = g;
  function b(a) {
    return (0, e.unpadBuffer)((0, e.intToBuffer)(a));
  }
  e.intToUnpaddedBuffer = b;
})(oi);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.accountBodyToRLP = e.accountBodyToSlim = e.accountBodyFromSlim = e.isZeroAddress = e.zeroAddress = e.importPublic = e.privateToAddress = e.privateToPublic = e.publicToAddress = e.pubToAddress = e.isValidPublic = e.isValidPrivate = e.generateAddress2 = e.generateAddress = e.isValidChecksumAddress = e.toChecksumAddress = e.isValidAddress = e.Account = void 0;
  const t = sn, r = jr, i = Go, o = Wy, n = oi, f = Zo, u = Ur, c = zt, h = BigInt(0);
  class s {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    constructor(b = h, a = h, d = f.KECCAK256_RLP, w = f.KECCAK256_NULL) {
      this.nonce = b, this.balance = a, this.storageRoot = d, this.codeHash = w, this._validate();
    }
    static fromAccountData(b) {
      const { nonce: a, balance: d, storageRoot: w, codeHash: x } = b;
      return new s(a !== void 0 ? (0, n.bufferToBigInt)((0, n.toBuffer)(a)) : void 0, d !== void 0 ? (0, n.bufferToBigInt)((0, n.toBuffer)(d)) : void 0, w !== void 0 ? (0, n.toBuffer)(w) : void 0, x !== void 0 ? (0, n.toBuffer)(x) : void 0);
    }
    static fromRlpSerializedAccount(b) {
      const a = (0, n.arrToBufArr)(t.RLP.decode(Uint8Array.from(b)));
      if (!Array.isArray(a))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray(a);
    }
    static fromValuesArray(b) {
      const [a, d, w, x] = b;
      return new s((0, n.bufferToBigInt)(a), (0, n.bufferToBigInt)(d), w, x);
    }
    _validate() {
      if (this.nonce < h)
        throw new Error("nonce must be greater than zero");
      if (this.balance < h)
        throw new Error("balance must be greater than zero");
      if (this.storageRoot.length !== 32)
        throw new Error("storageRoot must have a length of 32");
      if (this.codeHash.length !== 32)
        throw new Error("codeHash must have a length of 32");
    }
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    raw() {
      return [
        (0, n.bigIntToUnpaddedBuffer)(this.nonce),
        (0, n.bigIntToUnpaddedBuffer)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    serialize() {
      return Le.Buffer.from(t.RLP.encode((0, n.bufArrToArr)(this.raw())));
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      return !this.codeHash.equals(f.KECCAK256_NULL);
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      return this.balance === h && this.nonce === h && this.codeHash.equals(f.KECCAK256_NULL);
    }
  }
  e.Account = s;
  const p = function(g) {
    try {
      (0, u.assertIsString)(g);
    } catch {
      return !1;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(g);
  };
  e.isValidAddress = p;
  const v = function(g, b) {
    (0, u.assertIsHexString)(g);
    const a = (0, c.stripHexPrefix)(g).toLowerCase();
    let d = "";
    b !== void 0 && (d = (0, n.bufferToBigInt)((0, n.toBuffer)(b)).toString() + "0x");
    const w = Le.Buffer.from(d + a, "utf8"), x = (0, o.bytesToHex)((0, r.keccak256)(w));
    let A = "0x";
    for (let S = 0; S < a.length; S++)
      parseInt(x[S], 16) >= 8 ? A += a[S].toUpperCase() : A += a[S];
    return A;
  };
  e.toChecksumAddress = v;
  const m = function(g, b) {
    return (0, e.isValidAddress)(g) && (0, e.toChecksumAddress)(g, b) === g;
  };
  e.isValidChecksumAddress = m;
  const E = function(g, b) {
    return (0, u.assertIsBuffer)(g), (0, u.assertIsBuffer)(b), (0, n.bufferToBigInt)(b) === BigInt(0) ? Le.Buffer.from((0, r.keccak256)(t.RLP.encode((0, n.bufArrToArr)([g, null])))).slice(-20) : Le.Buffer.from((0, r.keccak256)(t.RLP.encode((0, n.bufArrToArr)([g, b])))).slice(-20);
  };
  e.generateAddress = E;
  const M = function(g, b, a) {
    if ((0, u.assertIsBuffer)(g), (0, u.assertIsBuffer)(b), (0, u.assertIsBuffer)(a), g.length !== 20)
      throw new Error("Expected from to be of length 20");
    if (b.length !== 32)
      throw new Error("Expected salt to be of length 32");
    const d = (0, r.keccak256)(Le.Buffer.concat([Le.Buffer.from("ff", "hex"), g, b, (0, r.keccak256)(a)]));
    return (0, n.toBuffer)(d).slice(-20);
  };
  e.generateAddress2 = M;
  const I = function(g) {
    return i.secp256k1.utils.isValidPrivateKey(g);
  };
  e.isValidPrivate = I;
  const B = function(g, b = !1) {
    if ((0, u.assertIsBuffer)(g), g.length === 64)
      try {
        return i.secp256k1.ProjectivePoint.fromHex(Le.Buffer.concat([Le.Buffer.from([4]), g])), !0;
      } catch {
        return !1;
      }
    if (!b)
      return !1;
    try {
      return i.secp256k1.ProjectivePoint.fromHex(g), !0;
    } catch {
      return !1;
    }
  };
  e.isValidPublic = B;
  const T = function(g, b = !1) {
    if ((0, u.assertIsBuffer)(g), b && g.length !== 64 && (g = Le.Buffer.from(i.secp256k1.ProjectivePoint.fromHex(g).toRawBytes(!1).slice(1))), g.length !== 64)
      throw new Error("Expected pubKey to be of length 64");
    return Le.Buffer.from((0, r.keccak256)(g)).slice(-20);
  };
  e.pubToAddress = T, e.publicToAddress = e.pubToAddress;
  const k = function(g) {
    return (0, u.assertIsBuffer)(g), Le.Buffer.from(i.secp256k1.ProjectivePoint.fromPrivateKey(g).toRawBytes(!1).slice(1));
  };
  e.privateToPublic = k;
  const N = function(g) {
    return (0, e.publicToAddress)((0, e.privateToPublic)(g));
  };
  e.privateToAddress = N;
  const q = function(g) {
    return (0, u.assertIsBuffer)(g), g.length !== 64 && (g = Le.Buffer.from(i.secp256k1.ProjectivePoint.fromHex(g).toRawBytes(!1).slice(1))), g;
  };
  e.importPublic = q;
  const D = function() {
    const b = (0, n.zeros)(20);
    return (0, n.bufferToHex)(b);
  };
  e.zeroAddress = D;
  const U = function(g) {
    try {
      (0, u.assertIsString)(g);
    } catch {
      return !1;
    }
    return (0, e.zeroAddress)() === g;
  };
  e.isZeroAddress = U;
  function z(g) {
    const [b, a, d, w] = g;
    return [
      b,
      a,
      (0, n.arrToBufArr)(d).length === 0 ? f.KECCAK256_RLP : d,
      (0, n.arrToBufArr)(w).length === 0 ? f.KECCAK256_NULL : w
    ];
  }
  e.accountBodyFromSlim = z;
  const Y = new Uint8Array(0);
  function ue(g) {
    const [b, a, d, w] = g;
    return [
      b,
      a,
      (0, n.arrToBufArr)(d).equals(f.KECCAK256_RLP) ? Y : d,
      (0, n.arrToBufArr)(w).equals(f.KECCAK256_NULL) ? Y : w
    ];
  }
  e.accountBodyToSlim = ue;
  function j(g, b = !0) {
    const a = b ? z(g) : g;
    return (0, n.arrToBufArr)(t.RLP.encode(a));
  }
  e.accountBodyToRLP = j;
})(t0);
var Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.Address = void 0;
const ta = t0, Fa = oi;
class bn {
  constructor(t) {
    if (t.length !== 20)
      throw new Error("Invalid address length");
    this.buf = t;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new bn((0, Fa.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(t) {
    if (!(0, ta.isValidAddress)(t))
      throw new Error("Invalid address");
    return new bn((0, Fa.toBuffer)(t));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(t) {
    if (!Le.Buffer.isBuffer(t))
      throw new Error("Public key should be Buffer");
    const r = (0, ta.pubToAddress)(t);
    return new bn(r);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(t) {
    if (!Le.Buffer.isBuffer(t))
      throw new Error("Private key should be Buffer");
    const r = (0, ta.privateToAddress)(t);
    return new bn(r);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(t, r) {
    if (typeof r != "bigint")
      throw new Error("Expected nonce to be a bigint");
    return new bn((0, ta.generateAddress)(t.buf, (0, Fa.bigIntToBuffer)(r)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(t, r, i) {
    if (!Le.Buffer.isBuffer(r))
      throw new Error("Expected salt to be a Buffer");
    if (!Le.Buffer.isBuffer(i))
      throw new Error("Expected initCode to be a Buffer");
    return new bn((0, ta.generateAddress2)(t.buf, r, i));
  }
  /**
   * Is address equal to another.
   */
  equals(t) {
    return this.buf.equals(t.buf);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(bn.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const t = (0, Fa.bufferToBigInt)(this.buf), r = BigInt(0), i = BigInt("0xffff");
    return t >= r && t <= i;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return "0x" + this.buf.toString("hex");
  }
  /**
   * Returns Buffer representation of address.
   */
  toBuffer() {
    return Le.Buffer.from(this.buf);
  }
}
Ia.Address = bn;
var rf = {}, i0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toType = e.TypeOutput = void 0;
  const t = oi, r = zt;
  var i;
  (function(n) {
    n[n.Number = 0] = "Number", n[n.BigInt = 1] = "BigInt", n[n.Buffer = 2] = "Buffer", n[n.PrefixedHexString = 3] = "PrefixedHexString";
  })(i = e.TypeOutput || (e.TypeOutput = {}));
  function o(n, f) {
    if (n === null)
      return null;
    if (n === void 0)
      return;
    if (typeof n == "string" && !(0, r.isHexString)(n))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${n}`);
    if (typeof n == "number" && !Number.isSafeInteger(n))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const u = (0, t.toBuffer)(n);
    switch (f) {
      case i.Buffer:
        return u;
      case i.BigInt:
        return (0, t.bufferToBigInt)(u);
      case i.Number: {
        const c = (0, t.bufferToBigInt)(u);
        if (c > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(c);
      }
      case i.PrefixedHexString:
        return (0, t.bufferToHex)(u);
      default:
        throw new Error("unknown outputType");
    }
  }
  e.toType = o;
})(i0);
Object.defineProperty(rf, "__esModule", { value: !0 });
rf.Withdrawal = void 0;
const Zl = Ia, Uf = oi, Xt = i0;
class sa {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(t, r, i, o) {
    this.index = t, this.validatorIndex = r, this.address = i, this.amount = o;
  }
  static fromWithdrawalData(t) {
    const { index: r, validatorIndex: i, address: o, amount: n } = t, f = (0, Xt.toType)(r, Xt.TypeOutput.BigInt), u = (0, Xt.toType)(i, Xt.TypeOutput.BigInt), c = new Zl.Address((0, Xt.toType)(o, Xt.TypeOutput.Buffer)), h = (0, Xt.toType)(n, Xt.TypeOutput.BigInt);
    return new sa(f, u, c, h);
  }
  static fromValuesArray(t) {
    if (t.length !== 4)
      throw Error(`Invalid withdrawalArray length expected=4 actual=${t.length}`);
    const [r, i, o, n] = t;
    return sa.fromWithdrawalData({ index: r, validatorIndex: i, address: o, amount: n });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBufferArray(t) {
    const { index: r, validatorIndex: i, address: o, amount: n } = t, f = (0, Xt.toType)(r, Xt.TypeOutput.BigInt) === BigInt(0) ? Le.Buffer.alloc(0) : (0, Xt.toType)(r, Xt.TypeOutput.Buffer), u = (0, Xt.toType)(i, Xt.TypeOutput.BigInt) === BigInt(0) ? Le.Buffer.alloc(0) : (0, Xt.toType)(i, Xt.TypeOutput.Buffer);
    let c;
    o instanceof Zl.Address ? c = o.buf : c = (0, Xt.toType)(o, Xt.TypeOutput.Buffer);
    const h = (0, Xt.toType)(n, Xt.TypeOutput.BigInt) === BigInt(0) ? Le.Buffer.alloc(0) : (0, Xt.toType)(n, Xt.TypeOutput.Buffer);
    return [f, u, c, h];
  }
  raw() {
    return sa.toBufferArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.buf,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, Uf.bigIntToHex)(this.index),
      validatorIndex: (0, Uf.bigIntToHex)(this.validatorIndex),
      address: "0x" + this.address.buf.toString("hex"),
      amount: (0, Uf.bigIntToHex)(this.amount)
    };
  }
}
rf.Withdrawal = sa;
var br = {};
Object.defineProperty(br, "__esModule", { value: !0 });
br.hashPersonalMessage = br.isValidSignature = br.fromRpcSig = br.toCompactSig = br.toRpcSig = br.ecrecover = br.ecsign = void 0;
const hx = jr, Gy = Go, wr = oi, Ff = Zo, lx = Ur;
function dx(e, t, r) {
  const i = Gy.secp256k1.sign(e, t), o = i.toCompactRawBytes(), n = Le.Buffer.from(o.slice(0, 32)), f = Le.Buffer.from(o.slice(32, 64)), u = r === void 0 ? BigInt(i.recovery + 27) : BigInt(i.recovery + 35) + BigInt(r) * BigInt(2);
  return { r: n, s: f, v: u };
}
br.ecsign = dx;
function nf(e, t) {
  return e === BigInt(0) || e === BigInt(1) ? e : t === void 0 ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35));
}
function af(e) {
  return e === BigInt(0) || e === BigInt(1);
}
const px = function(e, t, r, i, o) {
  const n = Le.Buffer.concat([(0, wr.setLengthLeft)(r, 32), (0, wr.setLengthLeft)(i, 32)], 64), f = nf(t, o);
  if (!af(f))
    throw new Error("Invalid signature v value");
  const c = Gy.secp256k1.Signature.fromCompact(n).addRecoveryBit(Number(f)).recoverPublicKey(e);
  return Le.Buffer.from(c.toRawBytes(!1).slice(1));
};
br.ecrecover = px;
const vx = function(e, t, r, i) {
  const o = nf(e, i);
  if (!af(o))
    throw new Error("Invalid signature v value");
  return (0, wr.bufferToHex)(Le.Buffer.concat([(0, wr.setLengthLeft)(t, 32), (0, wr.setLengthLeft)(r, 32), (0, wr.toBuffer)(e)]));
};
br.toRpcSig = vx;
const bx = function(e, t, r, i) {
  const o = nf(e, i);
  if (!af(o))
    throw new Error("Invalid signature v value");
  let n = r;
  return (e > BigInt(28) && e % BigInt(2) === BigInt(1) || e === BigInt(1) || e === BigInt(28)) && (n = Le.Buffer.from(r), n[0] |= 128), (0, wr.bufferToHex)(Le.Buffer.concat([(0, wr.setLengthLeft)(t, 32), (0, wr.setLengthLeft)(n, 32)]));
};
br.toCompactSig = bx;
const yx = function(e) {
  const t = (0, wr.toBuffer)(e);
  let r, i, o;
  if (t.length >= 65)
    r = t.slice(0, 32), i = t.slice(32, 64), o = (0, wr.bufferToBigInt)(t.slice(64));
  else if (t.length === 64)
    r = t.slice(0, 32), i = t.slice(32, 64), o = BigInt((0, wr.bufferToInt)(t.slice(32, 33)) >> 7), i[0] &= 127;
  else
    throw new Error("Invalid signature length");
  return o < 27 && (o = o + BigInt(27)), {
    v: o,
    r,
    s: i
  };
};
br.fromRpcSig = yx;
const gx = function(e, t, r, i = !0, o) {
  if (t.length !== 32 || r.length !== 32 || !af(nf(e, o)))
    return !1;
  const n = (0, wr.bufferToBigInt)(t), f = (0, wr.bufferToBigInt)(r);
  return !(n === BigInt(0) || n >= Ff.SECP256K1_ORDER || f === BigInt(0) || f >= Ff.SECP256K1_ORDER || i && f >= Ff.SECP256K1_ORDER_DIV_2);
};
br.isValidSignature = gx;
const mx = function(e) {
  (0, lx.assertIsBuffer)(e);
  const t = Le.Buffer.from(`Ethereum Signed Message:
${e.length}`, "utf-8");
  return Le.Buffer.from((0, hx.keccak256)(Le.Buffer.concat([t, e])));
};
br.hashPersonalMessage = mx;
var Jy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.compactBytesToNibbles = e.bytesToNibbles = e.nibblesToCompactBytes = e.nibblesToBytes = e.hasTerminator = void 0;
  const t = (f) => f.length > 0 && f[f.length - 1] === 16;
  e.hasTerminator = t;
  const r = (f, u) => {
    for (let c = 0, h = 0; h < f.length; c += 1, h += 2)
      u[c] = f[h] << 4 | f[h + 1];
  };
  e.nibblesToBytes = r;
  const i = (f) => {
    let u = 0;
    (0, e.hasTerminator)(f) && (u = 1, f = f.subarray(0, f.length - 1));
    const c = new Uint8Array(f.length / 2 + 1);
    return c[0] = u << 5, (f.length & 1) === 1 && (c[0] |= 16, c[0] |= f[0], f = f.subarray(1)), (0, e.nibblesToBytes)(f, c.subarray(1)), c;
  };
  e.nibblesToCompactBytes = i;
  const o = (f) => {
    const u = f.length * 2 + 1, c = new Uint8Array(u);
    for (let h = 0; h < f.length; h++) {
      const s = f[h];
      c[h * 2] = s / 16, c[h * 2 + 1] = s % 16;
    }
    return c[u - 1] = 16, c;
  };
  e.bytesToNibbles = o;
  const n = (f) => {
    if (f.length === 0)
      return f;
    let u = (0, e.bytesToNibbles)(f);
    u[0] < 2 && (u = u.subarray(0, u.length - 1));
    const c = 2 - (u[0] & 1);
    return u.subarray(c);
  };
  e.compactBytesToNibbles = n;
})(Jy);
var of = {};
Object.defineProperty(of, "__esModule", { value: !0 });
of.AsyncEventEmitter = void 0;
const wx = Di;
async function _x(e, t, r) {
  let i;
  for await (const o of t)
    try {
      o.length < 2 ? o.call(e, r) : await new Promise((n, f) => {
        o.call(e, r, (u) => {
          u ? f(u) : n();
        });
      });
    } catch (n) {
      i = n;
    }
  if (i)
    throw i;
}
class xx extends wx.EventEmitter {
  emit(t, ...r) {
    let [i, o] = r;
    const n = this;
    let f = n._events[t] ?? [];
    return o === void 0 && typeof i == "function" && (o = i, i = void 0), (t === "newListener" || t === "removeListener") && (i = {
      event: i,
      fn: o
    }, o = void 0), f = Array.isArray(f) ? f : [f], _x(n, f.slice(), i).then(o).catch(o), n.listenerCount(t) > 0;
  }
  once(t, r) {
    const i = this;
    let o;
    if (typeof r != "function")
      throw new TypeError("listener must be a function");
    return r.length >= 2 ? o = function(n, f) {
      i.removeListener(t, o), r(n, f);
    } : o = function(n) {
      i.removeListener(t, o), r(n, o);
    }, i.on(t, o), i;
  }
  first(t, r) {
    let i = this._events[t] ?? [];
    if (typeof r != "function")
      throw new TypeError("listener must be a function");
    return Array.isArray(i) || (this._events[t] = i = [i]), i.unshift(r), this;
  }
  before(t, r, i) {
    return this.beforeOrAfter(t, r, i);
  }
  after(t, r, i) {
    return this.beforeOrAfter(t, r, i, "after");
  }
  beforeOrAfter(t, r, i, o) {
    let n = this._events[t] ?? [], f, u;
    const c = o === "after" ? 1 : 0;
    if (typeof i != "function")
      throw new TypeError("listener must be a function");
    if (typeof r != "function")
      throw new TypeError("target must be a function");
    for (Array.isArray(n) || (this._events[t] = n = [n]), u = n.length, f = n.length; f--; )
      if (n[f] === r) {
        u = f + c;
        break;
      }
    return n.splice(u, 0, i), this;
  }
  on(t, r) {
    return super.on(t, r);
  }
  addListener(t, r) {
    return super.addListener(t, r);
  }
  prependListener(t, r) {
    return super.prependListener(t, r);
  }
  prependOnceListener(t, r) {
    return super.prependOnceListener(t, r);
  }
  removeAllListeners(t) {
    return super.removeAllListeners(t);
  }
  removeListener(t, r) {
    return super.removeListener(t, r);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(t) {
    return super.listeners(t);
  }
  listenerCount(t) {
    return super.listenerCount(t);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(t) {
    return super.setMaxListeners(t);
  }
}
of.AsyncEventEmitter = xx;
var ff = {};
Object.defineProperty(ff, "__esModule", { value: !0 });
ff.Lock = void 0;
class Ex {
  constructor() {
    this.permits = 1, this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise((t) => this.promiseResolverQueue.push(t));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const t = this.promiseResolverQueue.shift();
      t && t(!0);
    }
  }
}
ff.Lock = Ex;
var $i = {}, ri = {}, Hf = {}, zf = { exports: {} }, Vf = {}, Gl;
function Xy() {
  return Gl || (Gl = 1, function(e) {
    e.fetch = o(Ze.fetch) && o(Ze.ReadableStream), e.writableStream = o(Ze.WritableStream), e.abortController = o(Ze.AbortController);
    var t;
    function r() {
      if (t !== void 0)
        return t;
      if (Ze.XMLHttpRequest) {
        t = new Ze.XMLHttpRequest();
        try {
          t.open("GET", Ze.XDomainRequest ? "/" : "https://example.com");
        } catch {
          t = null;
        }
      } else
        t = null;
      return t;
    }
    function i(n) {
      var f = r();
      if (!f)
        return !1;
      try {
        return f.responseType = n, f.responseType === n;
      } catch {
      }
      return !1;
    }
    e.arraybuffer = e.fetch || i("arraybuffer"), e.msstream = !e.fetch && i("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && i("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (r() ? o(r().overrideMimeType) : !1);
    function o(n) {
      return typeof n == "function";
    }
    t = null;
  }(Vf)), Vf;
}
var Ha = { exports: {} }, Jl;
function Et() {
  return Jl || (Jl = 1, typeof Object.create == "function" ? Ha.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Ha.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var i = function() {
      };
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  }), Ha.exports;
}
var za = {}, Va = { exports: {} }, Wf, Xl;
function Yy() {
  return Xl || (Xl = 1, Wf = Di.EventEmitter), Wf;
}
var Kf = {}, Zf = {}, Gf, Yl;
function a0() {
  if (Yl)
    return Gf;
  Yl = 1;
  var e = Fh;
  return Gf = function() {
    return e() && !!Symbol.toStringTag;
  }, Gf;
}
var Jf, Ql;
function Sx() {
  if (Ql)
    return Jf;
  Ql = 1;
  var e = a0()(), t = Aa, r = t("Object.prototype.toString"), i = function(u) {
    return e && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : r(u) === "[object Arguments]";
  }, o = function(u) {
    return i(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && r(u) !== "[object Array]" && r(u.callee) === "[object Function]";
  }, n = function() {
    return i(arguments);
  }();
  return i.isLegacyArguments = o, Jf = n ? i : o, Jf;
}
var Xf, ed;
function Ax() {
  if (ed)
    return Xf;
  ed = 1;
  var e = Object.prototype.toString, t = Function.prototype.toString, r = /^\s*(?:function)?\*/, i = a0()(), o = Object.getPrototypeOf, n = function() {
    if (!i)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, f;
  return Xf = function(c) {
    if (typeof c != "function")
      return !1;
    if (r.test(t.call(c)))
      return !0;
    if (!i) {
      var h = e.call(c);
      return h === "[object GeneratorFunction]";
    }
    if (!o)
      return !1;
    if (typeof f > "u") {
      var s = n();
      f = s ? o(s) : !1;
    }
    return o(c) === f;
  }, Xf;
}
var Yf, td;
function Mx() {
  if (td)
    return Yf;
  td = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, i;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw i;
        }
      }), i = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (T) {
      T !== i && (t = null);
    }
  else
    t = null;
  var o = /^\s*class\b/, n = function(k) {
    try {
      var N = e.call(k);
      return o.test(N);
    } catch {
      return !1;
    }
  }, f = function(k) {
    try {
      return n(k) ? !1 : (e.call(k), !0);
    } catch {
      return !1;
    }
  }, u = Object.prototype.toString, c = "[object Object]", h = "[object Function]", s = "[object GeneratorFunction]", p = "[object HTMLAllCollection]", v = "[object HTML document.all class]", m = "[object HTMLCollection]", E = typeof Symbol == "function" && !!Symbol.toStringTag, M = !(0 in [,]), I = function() {
    return !1;
  };
  if (typeof document == "object") {
    var B = document.all;
    u.call(B) === u.call(document.all) && (I = function(k) {
      if ((M || !k) && (typeof k > "u" || typeof k == "object"))
        try {
          var N = u.call(k);
          return (N === p || N === v || N === m || N === c) && k("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Yf = t ? function(k) {
    if (I(k))
      return !0;
    if (!k || typeof k != "function" && typeof k != "object")
      return !1;
    try {
      t(k, null, r);
    } catch (N) {
      if (N !== i)
        return !1;
    }
    return !n(k) && f(k);
  } : function(k) {
    if (I(k))
      return !0;
    if (!k || typeof k != "function" && typeof k != "object")
      return !1;
    if (E)
      return f(k);
    if (n(k))
      return !1;
    var N = u.call(k);
    return N !== h && N !== s && !/^\[object HTML/.test(N) ? !1 : f(k);
  }, Yf;
}
var Qf, rd;
function Rx() {
  if (rd)
    return Qf;
  rd = 1;
  var e = Mx(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, i = function(c, h, s) {
    for (var p = 0, v = c.length; p < v; p++)
      r.call(c, p) && (s == null ? h(c[p], p, c) : h.call(s, c[p], p, c));
  }, o = function(c, h, s) {
    for (var p = 0, v = c.length; p < v; p++)
      s == null ? h(c.charAt(p), p, c) : h.call(s, c.charAt(p), p, c);
  }, n = function(c, h, s) {
    for (var p in c)
      r.call(c, p) && (s == null ? h(c[p], p, c) : h.call(s, c[p], p, c));
  }, f = function(c, h, s) {
    if (!e(h))
      throw new TypeError("iterator must be a function");
    var p;
    arguments.length >= 3 && (p = s), t.call(c) === "[object Array]" ? i(c, h, p) : typeof c == "string" ? o(c, h, p) : n(c, h, p);
  };
  return Qf = f, Qf;
}
var es, nd;
function Bx() {
  if (nd)
    return es;
  nd = 1;
  var e = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ], t = typeof globalThis > "u" ? Ze : globalThis;
  return es = function() {
    for (var i = [], o = 0; o < e.length; o++)
      typeof t[e[o]] == "function" && (i[i.length] = e[o]);
    return i;
  }, es;
}
var ts, id;
function Qy() {
  if (id)
    return ts;
  id = 1;
  var e = Rx(), t = Bx(), r = Sa, i = Aa, o = zh, n = i("Object.prototype.toString"), f = a0()(), u = typeof globalThis > "u" ? Ze : globalThis, c = t(), h = i("String.prototype.slice"), s = Object.getPrototypeOf, p = i("Array.prototype.indexOf", !0) || function(I, B) {
    for (var T = 0; T < I.length; T += 1)
      if (I[T] === B)
        return T;
    return -1;
  }, v = { __proto__: null };
  f && o && s ? e(c, function(M) {
    var I = new u[M]();
    if (Symbol.toStringTag in I) {
      var B = s(I), T = o(B, Symbol.toStringTag);
      if (!T) {
        var k = s(B);
        T = o(k, Symbol.toStringTag);
      }
      v["$" + M] = r(T.get);
    }
  }) : e(c, function(M) {
    var I = new u[M](), B = I.slice || I.set;
    B && (v["$" + M] = r(B));
  });
  var m = function(I) {
    var B = !1;
    return e(v, function(T, k) {
      if (!B)
        try {
          "$" + T(I) === k && (B = h(k, 1));
        } catch {
        }
    }), B;
  }, E = function(I) {
    var B = !1;
    return e(v, function(T, k) {
      if (!B)
        try {
          T(I), B = h(k, 1);
        } catch {
        }
    }), B;
  };
  return ts = function(I) {
    if (!I || typeof I != "object")
      return !1;
    if (!f) {
      var B = h(n(I), 8, -1);
      return p(c, B) > -1 ? B : B !== "Object" ? !1 : E(I);
    }
    return o ? m(I) : null;
  }, ts;
}
var rs, ad;
function Ix() {
  if (ad)
    return rs;
  ad = 1;
  var e = Qy();
  return rs = function(r) {
    return !!e(r);
  }, rs;
}
var od;
function Tx() {
  return od || (od = 1, function(e) {
    var t = Sx(), r = Ax(), i = Qy(), o = Ix();
    function n(G) {
      return G.call.bind(G);
    }
    var f = typeof BigInt < "u", u = typeof Symbol < "u", c = n(Object.prototype.toString), h = n(Number.prototype.valueOf), s = n(String.prototype.valueOf), p = n(Boolean.prototype.valueOf);
    if (f)
      var v = n(BigInt.prototype.valueOf);
    if (u)
      var m = n(Symbol.prototype.valueOf);
    function E(G, de) {
      if (typeof G != "object")
        return !1;
      try {
        return de(G), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = o;
    function M(G) {
      return typeof Promise < "u" && G instanceof Promise || G !== null && typeof G == "object" && typeof G.then == "function" && typeof G.catch == "function";
    }
    e.isPromise = M;
    function I(G) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(G) : o(G) || R(G);
    }
    e.isArrayBufferView = I;
    function B(G) {
      return i(G) === "Uint8Array";
    }
    e.isUint8Array = B;
    function T(G) {
      return i(G) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = T;
    function k(G) {
      return i(G) === "Uint16Array";
    }
    e.isUint16Array = k;
    function N(G) {
      return i(G) === "Uint32Array";
    }
    e.isUint32Array = N;
    function q(G) {
      return i(G) === "Int8Array";
    }
    e.isInt8Array = q;
    function D(G) {
      return i(G) === "Int16Array";
    }
    e.isInt16Array = D;
    function U(G) {
      return i(G) === "Int32Array";
    }
    e.isInt32Array = U;
    function z(G) {
      return i(G) === "Float32Array";
    }
    e.isFloat32Array = z;
    function Y(G) {
      return i(G) === "Float64Array";
    }
    e.isFloat64Array = Y;
    function ue(G) {
      return i(G) === "BigInt64Array";
    }
    e.isBigInt64Array = ue;
    function j(G) {
      return i(G) === "BigUint64Array";
    }
    e.isBigUint64Array = j;
    function g(G) {
      return c(G) === "[object Map]";
    }
    g.working = typeof Map < "u" && g(/* @__PURE__ */ new Map());
    function b(G) {
      return typeof Map > "u" ? !1 : g.working ? g(G) : G instanceof Map;
    }
    e.isMap = b;
    function a(G) {
      return c(G) === "[object Set]";
    }
    a.working = typeof Set < "u" && a(/* @__PURE__ */ new Set());
    function d(G) {
      return typeof Set > "u" ? !1 : a.working ? a(G) : G instanceof Set;
    }
    e.isSet = d;
    function w(G) {
      return c(G) === "[object WeakMap]";
    }
    w.working = typeof WeakMap < "u" && w(/* @__PURE__ */ new WeakMap());
    function x(G) {
      return typeof WeakMap > "u" ? !1 : w.working ? w(G) : G instanceof WeakMap;
    }
    e.isWeakMap = x;
    function A(G) {
      return c(G) === "[object WeakSet]";
    }
    A.working = typeof WeakSet < "u" && A(/* @__PURE__ */ new WeakSet());
    function S(G) {
      return A(G);
    }
    e.isWeakSet = S;
    function y(G) {
      return c(G) === "[object ArrayBuffer]";
    }
    y.working = typeof ArrayBuffer < "u" && y(new ArrayBuffer());
    function _(G) {
      return typeof ArrayBuffer > "u" ? !1 : y.working ? y(G) : G instanceof ArrayBuffer;
    }
    e.isArrayBuffer = _;
    function l(G) {
      return c(G) === "[object DataView]";
    }
    l.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && l(new DataView(new ArrayBuffer(1), 0, 1));
    function R(G) {
      return typeof DataView > "u" ? !1 : l.working ? l(G) : G instanceof DataView;
    }
    e.isDataView = R;
    var ee = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function oe(G) {
      return c(G) === "[object SharedArrayBuffer]";
    }
    function V(G) {
      return typeof ee > "u" ? !1 : (typeof oe.working > "u" && (oe.working = oe(new ee())), oe.working ? oe(G) : G instanceof ee);
    }
    e.isSharedArrayBuffer = V;
    function W(G) {
      return c(G) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = W;
    function F(G) {
      return c(G) === "[object Map Iterator]";
    }
    e.isMapIterator = F;
    function re(G) {
      return c(G) === "[object Set Iterator]";
    }
    e.isSetIterator = re;
    function he(G) {
      return c(G) === "[object Generator]";
    }
    e.isGeneratorObject = he;
    function Z(G) {
      return c(G) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = Z;
    function K(G) {
      return E(G, h);
    }
    e.isNumberObject = K;
    function ce(G) {
      return E(G, s);
    }
    e.isStringObject = ce;
    function ve(G) {
      return E(G, p);
    }
    e.isBooleanObject = ve;
    function Be(G) {
      return f && E(G, v);
    }
    e.isBigIntObject = Be;
    function te(G) {
      return u && E(G, m);
    }
    e.isSymbolObject = te;
    function C(G) {
      return K(G) || ce(G) || ve(G) || Be(G) || te(G);
    }
    e.isBoxedPrimitive = C;
    function L(G) {
      return typeof Uint8Array < "u" && (_(G) || V(G));
    }
    e.isAnyArrayBuffer = L, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(G) {
      Object.defineProperty(e, G, {
        enumerable: !1,
        value: function() {
          throw new Error(G + " is not supported in userland");
        }
      });
    });
  }(Zf)), Zf;
}
var ns, fd;
function Ox() {
  return fd || (fd = 1, ns = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), ns;
}
var sd;
function _n() {
  return sd || (sd = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(R) {
      for (var ee = Object.keys(R), oe = {}, V = 0; V < ee.length; V++)
        oe[ee[V]] = Object.getOwnPropertyDescriptor(R, ee[V]);
      return oe;
    }, r = /%[sdj%]/g;
    e.format = function(l) {
      if (!q(l)) {
        for (var R = [], ee = 0; ee < arguments.length; ee++)
          R.push(f(arguments[ee]));
        return R.join(" ");
      }
      for (var ee = 1, oe = arguments, V = oe.length, W = String(l).replace(r, function(re) {
        if (re === "%%")
          return "%";
        if (ee >= V)
          return re;
        switch (re) {
          case "%s":
            return String(oe[ee++]);
          case "%d":
            return Number(oe[ee++]);
          case "%j":
            try {
              return JSON.stringify(oe[ee++]);
            } catch {
              return "[Circular]";
            }
          default:
            return re;
        }
      }), F = oe[ee]; ee < V; F = oe[++ee])
        T(F) || !Y(F) ? W += " " + F : W += " " + f(F);
      return W;
    }, e.deprecate = function(l, R) {
      if (typeof at < "u" && at.noDeprecation === !0)
        return l;
      if (typeof at > "u")
        return function() {
          return e.deprecate(l, R).apply(this, arguments);
        };
      var ee = !1;
      function oe() {
        if (!ee) {
          if (at.throwDeprecation)
            throw new Error(R);
          at.traceDeprecation ? console.trace(R) : console.error(R), ee = !0;
        }
        return l.apply(this, arguments);
      }
      return oe;
    };
    var i = {}, o = /^$/;
    if (at.env.NODE_DEBUG) {
      var n = at.env.NODE_DEBUG;
      n = n.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o = new RegExp("^" + n + "$", "i");
    }
    e.debuglog = function(l) {
      if (l = l.toUpperCase(), !i[l])
        if (o.test(l)) {
          var R = at.pid;
          i[l] = function() {
            var ee = e.format.apply(e, arguments);
            console.error("%s %d: %s", l, R, ee);
          };
        } else
          i[l] = function() {
          };
      return i[l];
    };
    function f(l, R) {
      var ee = {
        seen: [],
        stylize: c
      };
      return arguments.length >= 3 && (ee.depth = arguments[2]), arguments.length >= 4 && (ee.colors = arguments[3]), B(R) ? ee.showHidden = R : R && e._extend(ee, R), U(ee.showHidden) && (ee.showHidden = !1), U(ee.depth) && (ee.depth = 2), U(ee.colors) && (ee.colors = !1), U(ee.customInspect) && (ee.customInspect = !0), ee.colors && (ee.stylize = u), s(ee, l, ee.depth);
    }
    e.inspect = f, f.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, f.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function u(l, R) {
      var ee = f.styles[R];
      return ee ? "\x1B[" + f.colors[ee][0] + "m" + l + "\x1B[" + f.colors[ee][1] + "m" : l;
    }
    function c(l, R) {
      return l;
    }
    function h(l) {
      var R = {};
      return l.forEach(function(ee, oe) {
        R[ee] = !0;
      }), R;
    }
    function s(l, R, ee) {
      if (l.customInspect && R && g(R.inspect) && // Filter out the util module, it's inspect function is special
      R.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(R.constructor && R.constructor.prototype === R)) {
        var oe = R.inspect(ee, l);
        return q(oe) || (oe = s(l, oe, ee)), oe;
      }
      var V = p(l, R);
      if (V)
        return V;
      var W = Object.keys(R), F = h(W);
      if (l.showHidden && (W = Object.getOwnPropertyNames(R)), j(R) && (W.indexOf("message") >= 0 || W.indexOf("description") >= 0))
        return v(R);
      if (W.length === 0) {
        if (g(R)) {
          var re = R.name ? ": " + R.name : "";
          return l.stylize("[Function" + re + "]", "special");
        }
        if (z(R))
          return l.stylize(RegExp.prototype.toString.call(R), "regexp");
        if (ue(R))
          return l.stylize(Date.prototype.toString.call(R), "date");
        if (j(R))
          return v(R);
      }
      var he = "", Z = !1, K = ["{", "}"];
      if (I(R) && (Z = !0, K = ["[", "]"]), g(R)) {
        var ce = R.name ? ": " + R.name : "";
        he = " [Function" + ce + "]";
      }
      if (z(R) && (he = " " + RegExp.prototype.toString.call(R)), ue(R) && (he = " " + Date.prototype.toUTCString.call(R)), j(R) && (he = " " + v(R)), W.length === 0 && (!Z || R.length == 0))
        return K[0] + he + K[1];
      if (ee < 0)
        return z(R) ? l.stylize(RegExp.prototype.toString.call(R), "regexp") : l.stylize("[Object]", "special");
      l.seen.push(R);
      var ve;
      return Z ? ve = m(l, R, ee, F, W) : ve = W.map(function(Be) {
        return E(l, R, ee, F, Be, Z);
      }), l.seen.pop(), M(ve, he, K);
    }
    function p(l, R) {
      if (U(R))
        return l.stylize("undefined", "undefined");
      if (q(R)) {
        var ee = "'" + JSON.stringify(R).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return l.stylize(ee, "string");
      }
      if (N(R))
        return l.stylize("" + R, "number");
      if (B(R))
        return l.stylize("" + R, "boolean");
      if (T(R))
        return l.stylize("null", "null");
    }
    function v(l) {
      return "[" + Error.prototype.toString.call(l) + "]";
    }
    function m(l, R, ee, oe, V) {
      for (var W = [], F = 0, re = R.length; F < re; ++F)
        A(R, String(F)) ? W.push(E(
          l,
          R,
          ee,
          oe,
          String(F),
          !0
        )) : W.push("");
      return V.forEach(function(he) {
        he.match(/^\d+$/) || W.push(E(
          l,
          R,
          ee,
          oe,
          he,
          !0
        ));
      }), W;
    }
    function E(l, R, ee, oe, V, W) {
      var F, re, he;
      if (he = Object.getOwnPropertyDescriptor(R, V) || { value: R[V] }, he.get ? he.set ? re = l.stylize("[Getter/Setter]", "special") : re = l.stylize("[Getter]", "special") : he.set && (re = l.stylize("[Setter]", "special")), A(oe, V) || (F = "[" + V + "]"), re || (l.seen.indexOf(he.value) < 0 ? (T(ee) ? re = s(l, he.value, null) : re = s(l, he.value, ee - 1), re.indexOf(`
`) > -1 && (W ? re = re.split(`
`).map(function(Z) {
        return "  " + Z;
      }).join(`
`).slice(2) : re = `
` + re.split(`
`).map(function(Z) {
        return "   " + Z;
      }).join(`
`))) : re = l.stylize("[Circular]", "special")), U(F)) {
        if (W && V.match(/^\d+$/))
          return re;
        F = JSON.stringify("" + V), F.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (F = F.slice(1, -1), F = l.stylize(F, "name")) : (F = F.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), F = l.stylize(F, "string"));
      }
      return F + ": " + re;
    }
    function M(l, R, ee) {
      var oe = l.reduce(function(V, W) {
        return W.indexOf(`
`) >= 0, V + W.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return oe > 60 ? ee[0] + (R === "" ? "" : R + `
 `) + " " + l.join(`,
  `) + " " + ee[1] : ee[0] + R + " " + l.join(", ") + " " + ee[1];
    }
    e.types = Tx();
    function I(l) {
      return Array.isArray(l);
    }
    e.isArray = I;
    function B(l) {
      return typeof l == "boolean";
    }
    e.isBoolean = B;
    function T(l) {
      return l === null;
    }
    e.isNull = T;
    function k(l) {
      return l == null;
    }
    e.isNullOrUndefined = k;
    function N(l) {
      return typeof l == "number";
    }
    e.isNumber = N;
    function q(l) {
      return typeof l == "string";
    }
    e.isString = q;
    function D(l) {
      return typeof l == "symbol";
    }
    e.isSymbol = D;
    function U(l) {
      return l === void 0;
    }
    e.isUndefined = U;
    function z(l) {
      return Y(l) && a(l) === "[object RegExp]";
    }
    e.isRegExp = z, e.types.isRegExp = z;
    function Y(l) {
      return typeof l == "object" && l !== null;
    }
    e.isObject = Y;
    function ue(l) {
      return Y(l) && a(l) === "[object Date]";
    }
    e.isDate = ue, e.types.isDate = ue;
    function j(l) {
      return Y(l) && (a(l) === "[object Error]" || l instanceof Error);
    }
    e.isError = j, e.types.isNativeError = j;
    function g(l) {
      return typeof l == "function";
    }
    e.isFunction = g;
    function b(l) {
      return l === null || typeof l == "boolean" || typeof l == "number" || typeof l == "string" || typeof l == "symbol" || // ES6 symbol
      typeof l > "u";
    }
    e.isPrimitive = b, e.isBuffer = Ox();
    function a(l) {
      return Object.prototype.toString.call(l);
    }
    function d(l) {
      return l < 10 ? "0" + l.toString(10) : l.toString(10);
    }
    var w = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function x() {
      var l = /* @__PURE__ */ new Date(), R = [
        d(l.getHours()),
        d(l.getMinutes()),
        d(l.getSeconds())
      ].join(":");
      return [l.getDate(), w[l.getMonth()], R].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", x(), e.format.apply(e, arguments));
    }, e.inherits = Et(), e._extend = function(l, R) {
      if (!R || !Y(R))
        return l;
      for (var ee = Object.keys(R), oe = ee.length; oe--; )
        l[ee[oe]] = R[ee[oe]];
      return l;
    };
    function A(l, R) {
      return Object.prototype.hasOwnProperty.call(l, R);
    }
    var S = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(R) {
      if (typeof R != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (S && R[S]) {
        var ee = R[S];
        if (typeof ee != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ee, S, {
          value: ee,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ee;
      }
      function ee() {
        for (var oe, V, W = new Promise(function(he, Z) {
          oe = he, V = Z;
        }), F = [], re = 0; re < arguments.length; re++)
          F.push(arguments[re]);
        F.push(function(he, Z) {
          he ? V(he) : oe(Z);
        });
        try {
          R.apply(this, F);
        } catch (he) {
          V(he);
        }
        return W;
      }
      return Object.setPrototypeOf(ee, Object.getPrototypeOf(R)), S && Object.defineProperty(ee, S, {
        value: ee,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ee,
        t(R)
      );
    }, e.promisify.custom = S;
    function y(l, R) {
      if (!l) {
        var ee = new Error("Promise was rejected with a falsy value");
        ee.reason = l, l = ee;
      }
      return R(l);
    }
    function _(l) {
      if (typeof l != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function R() {
        for (var ee = [], oe = 0; oe < arguments.length; oe++)
          ee.push(arguments[oe]);
        var V = ee.pop();
        if (typeof V != "function")
          throw new TypeError("The last argument must be of type Function");
        var W = this, F = function() {
          return V.apply(W, arguments);
        };
        l.apply(this, ee).then(
          function(re) {
            at.nextTick(F.bind(null, null, re));
          },
          function(re) {
            at.nextTick(y.bind(null, re, F));
          }
        );
      }
      return Object.setPrototypeOf(R, Object.getPrototypeOf(l)), Object.defineProperties(
        R,
        t(l)
      ), R;
    }
    e.callbackify = _;
  }(Kf)), Kf;
}
var is, ud;
function Px() {
  if (ud)
    return is;
  ud = 1;
  function e(E, M) {
    var I = Object.keys(E);
    if (Object.getOwnPropertySymbols) {
      var B = Object.getOwnPropertySymbols(E);
      M && (B = B.filter(function(T) {
        return Object.getOwnPropertyDescriptor(E, T).enumerable;
      })), I.push.apply(I, B);
    }
    return I;
  }
  function t(E) {
    for (var M = 1; M < arguments.length; M++) {
      var I = arguments[M] != null ? arguments[M] : {};
      M % 2 ? e(Object(I), !0).forEach(function(B) {
        r(E, B, I[B]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors(I)) : e(Object(I)).forEach(function(B) {
        Object.defineProperty(E, B, Object.getOwnPropertyDescriptor(I, B));
      });
    }
    return E;
  }
  function r(E, M, I) {
    return M = f(M), M in E ? Object.defineProperty(E, M, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : E[M] = I, E;
  }
  function i(E, M) {
    if (!(E instanceof M))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(E, M) {
    for (var I = 0; I < M.length; I++) {
      var B = M[I];
      B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(E, f(B.key), B);
    }
  }
  function n(E, M, I) {
    return M && o(E.prototype, M), I && o(E, I), Object.defineProperty(E, "prototype", { writable: !1 }), E;
  }
  function f(E) {
    var M = u(E, "string");
    return typeof M == "symbol" ? M : String(M);
  }
  function u(E, M) {
    if (typeof E != "object" || E === null)
      return E;
    var I = E[Symbol.toPrimitive];
    if (I !== void 0) {
      var B = I.call(E, M || "default");
      if (typeof B != "object")
        return B;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (M === "string" ? String : Number)(E);
  }
  var c = Le, h = c.Buffer, s = _n(), p = s.inspect, v = p && p.custom || "inspect";
  function m(E, M, I) {
    h.prototype.copy.call(E, M, I);
  }
  return is = /* @__PURE__ */ function() {
    function E() {
      i(this, E), this.head = null, this.tail = null, this.length = 0;
    }
    return n(E, [{
      key: "push",
      value: function(I) {
        var B = {
          data: I,
          next: null
        };
        this.length > 0 ? this.tail.next = B : this.head = B, this.tail = B, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(I) {
        var B = {
          data: I,
          next: this.head
        };
        this.length === 0 && (this.tail = B), this.head = B, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var I = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, I;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(I) {
        if (this.length === 0)
          return "";
        for (var B = this.head, T = "" + B.data; B = B.next; )
          T += I + B.data;
        return T;
      }
    }, {
      key: "concat",
      value: function(I) {
        if (this.length === 0)
          return h.alloc(0);
        for (var B = h.allocUnsafe(I >>> 0), T = this.head, k = 0; T; )
          m(T.data, B, k), k += T.data.length, T = T.next;
        return B;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(I, B) {
        var T;
        return I < this.head.data.length ? (T = this.head.data.slice(0, I), this.head.data = this.head.data.slice(I)) : I === this.head.data.length ? T = this.shift() : T = B ? this._getString(I) : this._getBuffer(I), T;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(I) {
        var B = this.head, T = 1, k = B.data;
        for (I -= k.length; B = B.next; ) {
          var N = B.data, q = I > N.length ? N.length : I;
          if (q === N.length ? k += N : k += N.slice(0, I), I -= q, I === 0) {
            q === N.length ? (++T, B.next ? this.head = B.next : this.head = this.tail = null) : (this.head = B, B.data = N.slice(q));
            break;
          }
          ++T;
        }
        return this.length -= T, k;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(I) {
        var B = h.allocUnsafe(I), T = this.head, k = 1;
        for (T.data.copy(B), I -= T.data.length; T = T.next; ) {
          var N = T.data, q = I > N.length ? N.length : I;
          if (N.copy(B, B.length - I, 0, q), I -= q, I === 0) {
            q === N.length ? (++k, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = N.slice(q));
            break;
          }
          ++k;
        }
        return this.length -= k, B;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: v,
      value: function(I, B) {
        return p(this, t(t({}, B), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), E;
  }(), is;
}
var as, cd;
function eg() {
  if (cd)
    return as;
  cd = 1;
  function e(f, u) {
    var c = this, h = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return h || s ? (u ? u(f) : f && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, at.nextTick(o, this, f)) : at.nextTick(o, this, f)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(f || null, function(p) {
      !u && p ? c._writableState ? c._writableState.errorEmitted ? at.nextTick(r, c) : (c._writableState.errorEmitted = !0, at.nextTick(t, c, p)) : at.nextTick(t, c, p) : u ? (at.nextTick(r, c), u(p)) : at.nextTick(r, c);
    }), this);
  }
  function t(f, u) {
    o(f, u), r(f);
  }
  function r(f) {
    f._writableState && !f._writableState.emitClose || f._readableState && !f._readableState.emitClose || f.emit("close");
  }
  function i() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function o(f, u) {
    f.emit("error", u);
  }
  function n(f, u) {
    var c = f._readableState, h = f._writableState;
    c && c.autoDestroy || h && h.autoDestroy ? f.destroy(u) : f.emit("error", u);
  }
  return as = {
    destroy: e,
    undestroy: i,
    errorOrDestroy: n
  }, as;
}
var os = {}, hd;
function Wi() {
  if (hd)
    return os;
  hd = 1;
  function e(u, c) {
    u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.__proto__ = c;
  }
  var t = {};
  function r(u, c, h) {
    h || (h = Error);
    function s(v, m, E) {
      return typeof c == "string" ? c : c(v, m, E);
    }
    var p = /* @__PURE__ */ function(v) {
      e(m, v);
      function m(E, M, I) {
        return v.call(this, s(E, M, I)) || this;
      }
      return m;
    }(h);
    p.prototype.name = h.name, p.prototype.code = u, t[u] = p;
  }
  function i(u, c) {
    if (Array.isArray(u)) {
      var h = u.length;
      return u = u.map(function(s) {
        return String(s);
      }), h > 2 ? "one of ".concat(c, " ").concat(u.slice(0, h - 1).join(", "), ", or ") + u[h - 1] : h === 2 ? "one of ".concat(c, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(c, " ").concat(u[0]);
    } else
      return "of ".concat(c, " ").concat(String(u));
  }
  function o(u, c, h) {
    return u.substr(!h || h < 0 ? 0 : +h, c.length) === c;
  }
  function n(u, c, h) {
    return (h === void 0 || h > u.length) && (h = u.length), u.substring(h - c.length, h) === c;
  }
  function f(u, c, h) {
    return typeof h != "number" && (h = 0), h + c.length > u.length ? !1 : u.indexOf(c, h) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(u, c) {
    return 'The value "' + c + '" is invalid for option "' + u + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(u, c, h) {
    var s;
    typeof c == "string" && o(c, "not ") ? (s = "must not be", c = c.replace(/^not /, "")) : s = "must be";
    var p;
    if (n(u, " argument"))
      p = "The ".concat(u, " ").concat(s, " ").concat(i(c, "type"));
    else {
      var v = f(u, ".") ? "property" : "argument";
      p = 'The "'.concat(u, '" ').concat(v, " ").concat(s, " ").concat(i(c, "type"));
    }
    return p += ". Received type ".concat(typeof h), p;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
    return "The " + u + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(u) {
    return "Cannot call " + u + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(u) {
    return "Unknown encoding: " + u;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), os.codes = t, os;
}
var fs, ld;
function tg() {
  if (ld)
    return fs;
  ld = 1;
  var e = Wi().codes.ERR_INVALID_OPT_VALUE;
  function t(i, o, n) {
    return i.highWaterMark != null ? i.highWaterMark : o ? i[n] : null;
  }
  function r(i, o, n, f) {
    var u = t(o, f, n);
    if (u != null) {
      if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
        var c = f ? n : "highWaterMark";
        throw new e(c, u);
      }
      return Math.floor(u);
    }
    return i.objectMode ? 16 : 16 * 1024;
  }
  return fs = {
    getHighWaterMark: r
  }, fs;
}
var ss, dd;
function Cx() {
  if (dd)
    return ss;
  dd = 1, ss = e;
  function e(r, i) {
    if (t("noDeprecation"))
      return r;
    var o = !1;
    function n() {
      if (!o) {
        if (t("throwDeprecation"))
          throw new Error(i);
        t("traceDeprecation") ? console.trace(i) : console.warn(i), o = !0;
      }
      return r.apply(this, arguments);
    }
    return n;
  }
  function t(r) {
    try {
      if (!Ze.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var i = Ze.localStorage[r];
    return i == null ? !1 : String(i).toLowerCase() === "true";
  }
  return ss;
}
var us, pd;
function o0() {
  if (pd)
    return us;
  pd = 1, us = z;
  function e(V) {
    var W = this;
    this.next = null, this.entry = null, this.finish = function() {
      oe(W, V);
    };
  }
  var t;
  z.WritableState = D;
  var r = {
    deprecate: Cx()
  }, i = Yy(), o = Le.Buffer, n = (typeof Ze < "u" ? Ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(V) {
    return o.from(V);
  }
  function u(V) {
    return o.isBuffer(V) || V instanceof n;
  }
  var c = eg(), h = tg(), s = h.getHighWaterMark, p = Wi().codes, v = p.ERR_INVALID_ARG_TYPE, m = p.ERR_METHOD_NOT_IMPLEMENTED, E = p.ERR_MULTIPLE_CALLBACK, M = p.ERR_STREAM_CANNOT_PIPE, I = p.ERR_STREAM_DESTROYED, B = p.ERR_STREAM_NULL_VALUES, T = p.ERR_STREAM_WRITE_AFTER_END, k = p.ERR_UNKNOWN_ENCODING, N = c.errorOrDestroy;
  Et()(z, i);
  function q() {
  }
  function D(V, W, F) {
    t = t || ni(), V = V || {}, typeof F != "boolean" && (F = W instanceof t), this.objectMode = !!V.objectMode, F && (this.objectMode = this.objectMode || !!V.writableObjectMode), this.highWaterMark = s(this, V, "writableHighWaterMark", F), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var re = V.decodeStrings === !1;
    this.decodeStrings = !re, this.defaultEncoding = V.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(he) {
      w(W, he);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = V.emitClose !== !1, this.autoDestroy = !!V.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  D.prototype.getBuffer = function() {
    for (var W = this.bufferedRequest, F = []; W; )
      F.push(W), W = W.next;
    return F;
  }, function() {
    try {
      Object.defineProperty(D.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var U;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (U = Function.prototype[Symbol.hasInstance], Object.defineProperty(z, Symbol.hasInstance, {
    value: function(W) {
      return U.call(this, W) ? !0 : this !== z ? !1 : W && W._writableState instanceof D;
    }
  })) : U = function(W) {
    return W instanceof this;
  };
  function z(V) {
    t = t || ni();
    var W = this instanceof t;
    if (!W && !U.call(z, this))
      return new z(V);
    this._writableState = new D(V, this, W), this.writable = !0, V && (typeof V.write == "function" && (this._write = V.write), typeof V.writev == "function" && (this._writev = V.writev), typeof V.destroy == "function" && (this._destroy = V.destroy), typeof V.final == "function" && (this._final = V.final)), i.call(this);
  }
  z.prototype.pipe = function() {
    N(this, new M());
  };
  function Y(V, W) {
    var F = new T();
    N(V, F), at.nextTick(W, F);
  }
  function ue(V, W, F, re) {
    var he;
    return F === null ? he = new B() : typeof F != "string" && !W.objectMode && (he = new v("chunk", ["string", "Buffer"], F)), he ? (N(V, he), at.nextTick(re, he), !1) : !0;
  }
  z.prototype.write = function(V, W, F) {
    var re = this._writableState, he = !1, Z = !re.objectMode && u(V);
    return Z && !o.isBuffer(V) && (V = f(V)), typeof W == "function" && (F = W, W = null), Z ? W = "buffer" : W || (W = re.defaultEncoding), typeof F != "function" && (F = q), re.ending ? Y(this, F) : (Z || ue(this, re, V, F)) && (re.pendingcb++, he = g(this, re, Z, V, W, F)), he;
  }, z.prototype.cork = function() {
    this._writableState.corked++;
  }, z.prototype.uncork = function() {
    var V = this._writableState;
    V.corked && (V.corked--, !V.writing && !V.corked && !V.bufferProcessing && V.bufferedRequest && S(this, V));
  }, z.prototype.setDefaultEncoding = function(W) {
    if (typeof W == "string" && (W = W.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((W + "").toLowerCase()) > -1))
      throw new k(W);
    return this._writableState.defaultEncoding = W, this;
  }, Object.defineProperty(z.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function j(V, W, F) {
    return !V.objectMode && V.decodeStrings !== !1 && typeof W == "string" && (W = o.from(W, F)), W;
  }
  Object.defineProperty(z.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function g(V, W, F, re, he, Z) {
    if (!F) {
      var K = j(W, re, he);
      re !== K && (F = !0, he = "buffer", re = K);
    }
    var ce = W.objectMode ? 1 : re.length;
    W.length += ce;
    var ve = W.length < W.highWaterMark;
    if (ve || (W.needDrain = !0), W.writing || W.corked) {
      var Be = W.lastBufferedRequest;
      W.lastBufferedRequest = {
        chunk: re,
        encoding: he,
        isBuf: F,
        callback: Z,
        next: null
      }, Be ? Be.next = W.lastBufferedRequest : W.bufferedRequest = W.lastBufferedRequest, W.bufferedRequestCount += 1;
    } else
      b(V, W, !1, ce, re, he, Z);
    return ve;
  }
  function b(V, W, F, re, he, Z, K) {
    W.writelen = re, W.writecb = K, W.writing = !0, W.sync = !0, W.destroyed ? W.onwrite(new I("write")) : F ? V._writev(he, W.onwrite) : V._write(he, Z, W.onwrite), W.sync = !1;
  }
  function a(V, W, F, re, he) {
    --W.pendingcb, F ? (at.nextTick(he, re), at.nextTick(R, V, W), V._writableState.errorEmitted = !0, N(V, re)) : (he(re), V._writableState.errorEmitted = !0, N(V, re), R(V, W));
  }
  function d(V) {
    V.writing = !1, V.writecb = null, V.length -= V.writelen, V.writelen = 0;
  }
  function w(V, W) {
    var F = V._writableState, re = F.sync, he = F.writecb;
    if (typeof he != "function")
      throw new E();
    if (d(F), W)
      a(V, F, re, W, he);
    else {
      var Z = y(F) || V.destroyed;
      !Z && !F.corked && !F.bufferProcessing && F.bufferedRequest && S(V, F), re ? at.nextTick(x, V, F, Z, he) : x(V, F, Z, he);
    }
  }
  function x(V, W, F, re) {
    F || A(V, W), W.pendingcb--, re(), R(V, W);
  }
  function A(V, W) {
    W.length === 0 && W.needDrain && (W.needDrain = !1, V.emit("drain"));
  }
  function S(V, W) {
    W.bufferProcessing = !0;
    var F = W.bufferedRequest;
    if (V._writev && F && F.next) {
      var re = W.bufferedRequestCount, he = new Array(re), Z = W.corkedRequestsFree;
      Z.entry = F;
      for (var K = 0, ce = !0; F; )
        he[K] = F, F.isBuf || (ce = !1), F = F.next, K += 1;
      he.allBuffers = ce, b(V, W, !0, W.length, he, "", Z.finish), W.pendingcb++, W.lastBufferedRequest = null, Z.next ? (W.corkedRequestsFree = Z.next, Z.next = null) : W.corkedRequestsFree = new e(W), W.bufferedRequestCount = 0;
    } else {
      for (; F; ) {
        var ve = F.chunk, Be = F.encoding, te = F.callback, C = W.objectMode ? 1 : ve.length;
        if (b(V, W, !1, C, ve, Be, te), F = F.next, W.bufferedRequestCount--, W.writing)
          break;
      }
      F === null && (W.lastBufferedRequest = null);
    }
    W.bufferedRequest = F, W.bufferProcessing = !1;
  }
  z.prototype._write = function(V, W, F) {
    F(new m("_write()"));
  }, z.prototype._writev = null, z.prototype.end = function(V, W, F) {
    var re = this._writableState;
    return typeof V == "function" ? (F = V, V = null, W = null) : typeof W == "function" && (F = W, W = null), V != null && this.write(V, W), re.corked && (re.corked = 1, this.uncork()), re.ending || ee(this, re, F), this;
  }, Object.defineProperty(z.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function y(V) {
    return V.ending && V.length === 0 && V.bufferedRequest === null && !V.finished && !V.writing;
  }
  function _(V, W) {
    V._final(function(F) {
      W.pendingcb--, F && N(V, F), W.prefinished = !0, V.emit("prefinish"), R(V, W);
    });
  }
  function l(V, W) {
    !W.prefinished && !W.finalCalled && (typeof V._final == "function" && !W.destroyed ? (W.pendingcb++, W.finalCalled = !0, at.nextTick(_, V, W)) : (W.prefinished = !0, V.emit("prefinish")));
  }
  function R(V, W) {
    var F = y(W);
    if (F && (l(V, W), W.pendingcb === 0 && (W.finished = !0, V.emit("finish"), W.autoDestroy))) {
      var re = V._readableState;
      (!re || re.autoDestroy && re.endEmitted) && V.destroy();
    }
    return F;
  }
  function ee(V, W, F) {
    W.ending = !0, R(V, W), F && (W.finished ? at.nextTick(F) : V.once("finish", F)), W.ended = !0, V.writable = !1;
  }
  function oe(V, W, F) {
    var re = V.entry;
    for (V.entry = null; re; ) {
      var he = re.callback;
      W.pendingcb--, he(F), re = re.next;
    }
    W.corkedRequestsFree.next = V;
  }
  return Object.defineProperty(z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(W) {
      this._writableState && (this._writableState.destroyed = W);
    }
  }), z.prototype.destroy = c.destroy, z.prototype._undestroy = c.undestroy, z.prototype._destroy = function(V, W) {
    W(V);
  }, us;
}
var cs, vd;
function ni() {
  if (vd)
    return cs;
  vd = 1;
  var e = Object.keys || function(h) {
    var s = [];
    for (var p in h)
      s.push(p);
    return s;
  };
  cs = f;
  var t = f0(), r = o0();
  Et()(f, t);
  for (var i = e(r.prototype), o = 0; o < i.length; o++) {
    var n = i[o];
    f.prototype[n] || (f.prototype[n] = r.prototype[n]);
  }
  function f(h) {
    if (!(this instanceof f))
      return new f(h);
    t.call(this, h), r.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(f.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(f.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || at.nextTick(c, this);
  }
  function c(h) {
    h.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(s) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = s, this._writableState.destroyed = s);
    }
  }), cs;
}
var hs = {}, Wa = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var bd;
function Bt() {
  return bd || (bd = 1, function(e, t) {
    var r = Le, i = r.Buffer;
    function o(f, u) {
      for (var c in f)
        u[c] = f[c];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = n);
    function n(f, u, c) {
      return i(f, u, c);
    }
    n.prototype = Object.create(i.prototype), o(i, n), n.from = function(f, u, c) {
      if (typeof f == "number")
        throw new TypeError("Argument must not be a number");
      return i(f, u, c);
    }, n.alloc = function(f, u, c) {
      if (typeof f != "number")
        throw new TypeError("Argument must be a number");
      var h = i(f);
      return u !== void 0 ? typeof c == "string" ? h.fill(u, c) : h.fill(u) : h.fill(0), h;
    }, n.allocUnsafe = function(f) {
      if (typeof f != "number")
        throw new TypeError("Argument must be a number");
      return i(f);
    }, n.allocUnsafeSlow = function(f) {
      if (typeof f != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(f);
    };
  }(Wa, Wa.exports)), Wa.exports;
}
var yd;
function uh() {
  if (yd)
    return hs;
  yd = 1;
  var e = Bt().Buffer, t = e.isEncoding || function(B) {
    switch (B = "" + B, B && B.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(B) {
    if (!B)
      return "utf8";
    for (var T; ; )
      switch (B) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return B;
        default:
          if (T)
            return;
          B = ("" + B).toLowerCase(), T = !0;
      }
  }
  function i(B) {
    var T = r(B);
    if (typeof T != "string" && (e.isEncoding === t || !t(B)))
      throw new Error("Unknown encoding: " + B);
    return T || B;
  }
  hs.StringDecoder = o;
  function o(B) {
    this.encoding = i(B);
    var T;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = v, T = 4;
        break;
      case "utf8":
        this.fillLast = c, T = 4;
        break;
      case "base64":
        this.text = m, this.end = E, T = 3;
        break;
      default:
        this.write = M, this.end = I;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(T);
  }
  o.prototype.write = function(B) {
    if (B.length === 0)
      return "";
    var T, k;
    if (this.lastNeed) {
      if (T = this.fillLast(B), T === void 0)
        return "";
      k = this.lastNeed, this.lastNeed = 0;
    } else
      k = 0;
    return k < B.length ? T ? T + this.text(B, k) : this.text(B, k) : T || "";
  }, o.prototype.end = s, o.prototype.text = h, o.prototype.fillLast = function(B) {
    if (this.lastNeed <= B.length)
      return B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, B.length), this.lastNeed -= B.length;
  };
  function n(B) {
    return B <= 127 ? 0 : B >> 5 === 6 ? 2 : B >> 4 === 14 ? 3 : B >> 3 === 30 ? 4 : B >> 6 === 2 ? -1 : -2;
  }
  function f(B, T, k) {
    var N = T.length - 1;
    if (N < k)
      return 0;
    var q = n(T[N]);
    return q >= 0 ? (q > 0 && (B.lastNeed = q - 1), q) : --N < k || q === -2 ? 0 : (q = n(T[N]), q >= 0 ? (q > 0 && (B.lastNeed = q - 2), q) : --N < k || q === -2 ? 0 : (q = n(T[N]), q >= 0 ? (q > 0 && (q === 2 ? q = 0 : B.lastNeed = q - 3), q) : 0));
  }
  function u(B, T, k) {
    if ((T[0] & 192) !== 128)
      return B.lastNeed = 0, "�";
    if (B.lastNeed > 1 && T.length > 1) {
      if ((T[1] & 192) !== 128)
        return B.lastNeed = 1, "�";
      if (B.lastNeed > 2 && T.length > 2 && (T[2] & 192) !== 128)
        return B.lastNeed = 2, "�";
    }
  }
  function c(B) {
    var T = this.lastTotal - this.lastNeed, k = u(this, B);
    if (k !== void 0)
      return k;
    if (this.lastNeed <= B.length)
      return B.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    B.copy(this.lastChar, T, 0, B.length), this.lastNeed -= B.length;
  }
  function h(B, T) {
    var k = f(this, B, T);
    if (!this.lastNeed)
      return B.toString("utf8", T);
    this.lastTotal = k;
    var N = B.length - (k - this.lastNeed);
    return B.copy(this.lastChar, 0, N), B.toString("utf8", T, N);
  }
  function s(B) {
    var T = B && B.length ? this.write(B) : "";
    return this.lastNeed ? T + "�" : T;
  }
  function p(B, T) {
    if ((B.length - T) % 2 === 0) {
      var k = B.toString("utf16le", T);
      if (k) {
        var N = k.charCodeAt(k.length - 1);
        if (N >= 55296 && N <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1], k.slice(0, -1);
      }
      return k;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = B[B.length - 1], B.toString("utf16le", T, B.length - 1);
  }
  function v(B) {
    var T = B && B.length ? this.write(B) : "";
    if (this.lastNeed) {
      var k = this.lastTotal - this.lastNeed;
      return T + this.lastChar.toString("utf16le", 0, k);
    }
    return T;
  }
  function m(B, T) {
    var k = (B.length - T) % 3;
    return k === 0 ? B.toString("base64", T) : (this.lastNeed = 3 - k, this.lastTotal = 3, k === 1 ? this.lastChar[0] = B[B.length - 1] : (this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1]), B.toString("base64", T, B.length - k));
  }
  function E(B) {
    var T = B && B.length ? this.write(B) : "";
    return this.lastNeed ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : T;
  }
  function M(B) {
    return B.toString(this.encoding);
  }
  function I(B) {
    return B && B.length ? this.write(B) : "";
  }
  return hs;
}
var ls, gd;
function sf() {
  if (gd)
    return ls;
  gd = 1;
  var e = Wi().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(n) {
    var f = !1;
    return function() {
      if (!f) {
        f = !0;
        for (var u = arguments.length, c = new Array(u), h = 0; h < u; h++)
          c[h] = arguments[h];
        n.apply(this, c);
      }
    };
  }
  function r() {
  }
  function i(n) {
    return n.setHeader && typeof n.abort == "function";
  }
  function o(n, f, u) {
    if (typeof f == "function")
      return o(n, null, f);
    f || (f = {}), u = t(u || r);
    var c = f.readable || f.readable !== !1 && n.readable, h = f.writable || f.writable !== !1 && n.writable, s = function() {
      n.writable || v();
    }, p = n._writableState && n._writableState.finished, v = function() {
      h = !1, p = !0, c || u.call(n);
    }, m = n._readableState && n._readableState.endEmitted, E = function() {
      c = !1, m = !0, h || u.call(n);
    }, M = function(k) {
      u.call(n, k);
    }, I = function() {
      var k;
      if (c && !m)
        return (!n._readableState || !n._readableState.ended) && (k = new e()), u.call(n, k);
      if (h && !p)
        return (!n._writableState || !n._writableState.ended) && (k = new e()), u.call(n, k);
    }, B = function() {
      n.req.on("finish", v);
    };
    return i(n) ? (n.on("complete", v), n.on("abort", I), n.req ? B() : n.on("request", B)) : h && !n._writableState && (n.on("end", s), n.on("close", s)), n.on("end", E), n.on("finish", v), f.error !== !1 && n.on("error", M), n.on("close", I), function() {
      n.removeListener("complete", v), n.removeListener("abort", I), n.removeListener("request", B), n.req && n.req.removeListener("finish", v), n.removeListener("end", s), n.removeListener("close", s), n.removeListener("finish", v), n.removeListener("end", E), n.removeListener("error", M), n.removeListener("close", I);
    };
  }
  return ls = o, ls;
}
var ds, md;
function Nx() {
  if (md)
    return ds;
  md = 1;
  var e;
  function t(k, N, q) {
    return N = r(N), N in k ? Object.defineProperty(k, N, { value: q, enumerable: !0, configurable: !0, writable: !0 }) : k[N] = q, k;
  }
  function r(k) {
    var N = i(k, "string");
    return typeof N == "symbol" ? N : String(N);
  }
  function i(k, N) {
    if (typeof k != "object" || k === null)
      return k;
    var q = k[Symbol.toPrimitive];
    if (q !== void 0) {
      var D = q.call(k, N || "default");
      if (typeof D != "object")
        return D;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (N === "string" ? String : Number)(k);
  }
  var o = sf(), n = Symbol("lastResolve"), f = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), h = Symbol("lastPromise"), s = Symbol("handlePromise"), p = Symbol("stream");
  function v(k, N) {
    return {
      value: k,
      done: N
    };
  }
  function m(k) {
    var N = k[n];
    if (N !== null) {
      var q = k[p].read();
      q !== null && (k[h] = null, k[n] = null, k[f] = null, N(v(q, !1)));
    }
  }
  function E(k) {
    at.nextTick(m, k);
  }
  function M(k, N) {
    return function(q, D) {
      k.then(function() {
        if (N[c]) {
          q(v(void 0, !0));
          return;
        }
        N[s](q, D);
      }, D);
    };
  }
  var I = Object.getPrototypeOf(function() {
  }), B = Object.setPrototypeOf((e = {
    get stream() {
      return this[p];
    },
    next: function() {
      var N = this, q = this[u];
      if (q !== null)
        return Promise.reject(q);
      if (this[c])
        return Promise.resolve(v(void 0, !0));
      if (this[p].destroyed)
        return new Promise(function(Y, ue) {
          at.nextTick(function() {
            N[u] ? ue(N[u]) : Y(v(void 0, !0));
          });
        });
      var D = this[h], U;
      if (D)
        U = new Promise(M(D, this));
      else {
        var z = this[p].read();
        if (z !== null)
          return Promise.resolve(v(z, !1));
        U = new Promise(this[s]);
      }
      return this[h] = U, U;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var N = this;
    return new Promise(function(q, D) {
      N[p].destroy(null, function(U) {
        if (U) {
          D(U);
          return;
        }
        q(v(void 0, !0));
      });
    });
  }), e), I), T = function(N) {
    var q, D = Object.create(B, (q = {}, t(q, p, {
      value: N,
      writable: !0
    }), t(q, n, {
      value: null,
      writable: !0
    }), t(q, f, {
      value: null,
      writable: !0
    }), t(q, u, {
      value: null,
      writable: !0
    }), t(q, c, {
      value: N._readableState.endEmitted,
      writable: !0
    }), t(q, s, {
      value: function(z, Y) {
        var ue = D[p].read();
        ue ? (D[h] = null, D[n] = null, D[f] = null, z(v(ue, !1))) : (D[n] = z, D[f] = Y);
      },
      writable: !0
    }), q));
    return D[h] = null, o(N, function(U) {
      if (U && U.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var z = D[f];
        z !== null && (D[h] = null, D[n] = null, D[f] = null, z(U)), D[u] = U;
        return;
      }
      var Y = D[n];
      Y !== null && (D[h] = null, D[n] = null, D[f] = null, Y(v(void 0, !0))), D[c] = !0;
    }), N.on("readable", E.bind(null, D)), D;
  };
  return ds = T, ds;
}
var ps, wd;
function Lx() {
  return wd || (wd = 1, ps = function() {
    throw new Error("Readable.from is not available in the browser");
  }), ps;
}
var vs, _d;
function f0() {
  if (_d)
    return vs;
  _d = 1, vs = Y;
  var e;
  Y.ReadableState = z, Di.EventEmitter;
  var t = function(K, ce) {
    return K.listeners(ce).length;
  }, r = Yy(), i = Le.Buffer, o = (typeof Ze < "u" ? Ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function n(Z) {
    return i.from(Z);
  }
  function f(Z) {
    return i.isBuffer(Z) || Z instanceof o;
  }
  var u = _n(), c;
  u && u.debuglog ? c = u.debuglog("stream") : c = function() {
  };
  var h = Px(), s = eg(), p = tg(), v = p.getHighWaterMark, m = Wi().codes, E = m.ERR_INVALID_ARG_TYPE, M = m.ERR_STREAM_PUSH_AFTER_EOF, I = m.ERR_METHOD_NOT_IMPLEMENTED, B = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, T, k, N;
  Et()(Y, r);
  var q = s.errorOrDestroy, D = ["error", "close", "destroy", "pause", "resume"];
  function U(Z, K, ce) {
    if (typeof Z.prependListener == "function")
      return Z.prependListener(K, ce);
    !Z._events || !Z._events[K] ? Z.on(K, ce) : Array.isArray(Z._events[K]) ? Z._events[K].unshift(ce) : Z._events[K] = [ce, Z._events[K]];
  }
  function z(Z, K, ce) {
    e = e || ni(), Z = Z || {}, typeof ce != "boolean" && (ce = K instanceof e), this.objectMode = !!Z.objectMode, ce && (this.objectMode = this.objectMode || !!Z.readableObjectMode), this.highWaterMark = v(this, Z, "readableHighWaterMark", ce), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Z.emitClose !== !1, this.autoDestroy = !!Z.autoDestroy, this.destroyed = !1, this.defaultEncoding = Z.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Z.encoding && (T || (T = uh().StringDecoder), this.decoder = new T(Z.encoding), this.encoding = Z.encoding);
  }
  function Y(Z) {
    if (e = e || ni(), !(this instanceof Y))
      return new Y(Z);
    var K = this instanceof e;
    this._readableState = new z(Z, this, K), this.readable = !0, Z && (typeof Z.read == "function" && (this._read = Z.read), typeof Z.destroy == "function" && (this._destroy = Z.destroy)), r.call(this);
  }
  Object.defineProperty(Y.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(K) {
      this._readableState && (this._readableState.destroyed = K);
    }
  }), Y.prototype.destroy = s.destroy, Y.prototype._undestroy = s.undestroy, Y.prototype._destroy = function(Z, K) {
    K(Z);
  }, Y.prototype.push = function(Z, K) {
    var ce = this._readableState, ve;
    return ce.objectMode ? ve = !0 : typeof Z == "string" && (K = K || ce.defaultEncoding, K !== ce.encoding && (Z = i.from(Z, K), K = ""), ve = !0), ue(this, Z, K, !1, ve);
  }, Y.prototype.unshift = function(Z) {
    return ue(this, Z, null, !0, !1);
  };
  function ue(Z, K, ce, ve, Be) {
    c("readableAddChunk", K);
    var te = Z._readableState;
    if (K === null)
      te.reading = !1, w(Z, te);
    else {
      var C;
      if (Be || (C = g(te, K)), C)
        q(Z, C);
      else if (te.objectMode || K && K.length > 0)
        if (typeof K != "string" && !te.objectMode && Object.getPrototypeOf(K) !== i.prototype && (K = n(K)), ve)
          te.endEmitted ? q(Z, new B()) : j(Z, te, K, !0);
        else if (te.ended)
          q(Z, new M());
        else {
          if (te.destroyed)
            return !1;
          te.reading = !1, te.decoder && !ce ? (K = te.decoder.write(K), te.objectMode || K.length !== 0 ? j(Z, te, K, !1) : S(Z, te)) : j(Z, te, K, !1);
        }
      else
        ve || (te.reading = !1, S(Z, te));
    }
    return !te.ended && (te.length < te.highWaterMark || te.length === 0);
  }
  function j(Z, K, ce, ve) {
    K.flowing && K.length === 0 && !K.sync ? (K.awaitDrain = 0, Z.emit("data", ce)) : (K.length += K.objectMode ? 1 : ce.length, ve ? K.buffer.unshift(ce) : K.buffer.push(ce), K.needReadable && x(Z)), S(Z, K);
  }
  function g(Z, K) {
    var ce;
    return !f(K) && typeof K != "string" && K !== void 0 && !Z.objectMode && (ce = new E("chunk", ["string", "Buffer", "Uint8Array"], K)), ce;
  }
  Y.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Y.prototype.setEncoding = function(Z) {
    T || (T = uh().StringDecoder);
    var K = new T(Z);
    this._readableState.decoder = K, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ce = this._readableState.buffer.head, ve = ""; ce !== null; )
      ve += K.write(ce.data), ce = ce.next;
    return this._readableState.buffer.clear(), ve !== "" && this._readableState.buffer.push(ve), this._readableState.length = ve.length, this;
  };
  var b = 1073741824;
  function a(Z) {
    return Z >= b ? Z = b : (Z--, Z |= Z >>> 1, Z |= Z >>> 2, Z |= Z >>> 4, Z |= Z >>> 8, Z |= Z >>> 16, Z++), Z;
  }
  function d(Z, K) {
    return Z <= 0 || K.length === 0 && K.ended ? 0 : K.objectMode ? 1 : Z !== Z ? K.flowing && K.length ? K.buffer.head.data.length : K.length : (Z > K.highWaterMark && (K.highWaterMark = a(Z)), Z <= K.length ? Z : K.ended ? K.length : (K.needReadable = !0, 0));
  }
  Y.prototype.read = function(Z) {
    c("read", Z), Z = parseInt(Z, 10);
    var K = this._readableState, ce = Z;
    if (Z !== 0 && (K.emittedReadable = !1), Z === 0 && K.needReadable && ((K.highWaterMark !== 0 ? K.length >= K.highWaterMark : K.length > 0) || K.ended))
      return c("read: emitReadable", K.length, K.ended), K.length === 0 && K.ended ? F(this) : x(this), null;
    if (Z = d(Z, K), Z === 0 && K.ended)
      return K.length === 0 && F(this), null;
    var ve = K.needReadable;
    c("need readable", ve), (K.length === 0 || K.length - Z < K.highWaterMark) && (ve = !0, c("length less than watermark", ve)), K.ended || K.reading ? (ve = !1, c("reading or ended", ve)) : ve && (c("do read"), K.reading = !0, K.sync = !0, K.length === 0 && (K.needReadable = !0), this._read(K.highWaterMark), K.sync = !1, K.reading || (Z = d(ce, K)));
    var Be;
    return Z > 0 ? Be = W(Z, K) : Be = null, Be === null ? (K.needReadable = K.length <= K.highWaterMark, Z = 0) : (K.length -= Z, K.awaitDrain = 0), K.length === 0 && (K.ended || (K.needReadable = !0), ce !== Z && K.ended && F(this)), Be !== null && this.emit("data", Be), Be;
  };
  function w(Z, K) {
    if (c("onEofChunk"), !K.ended) {
      if (K.decoder) {
        var ce = K.decoder.end();
        ce && ce.length && (K.buffer.push(ce), K.length += K.objectMode ? 1 : ce.length);
      }
      K.ended = !0, K.sync ? x(Z) : (K.needReadable = !1, K.emittedReadable || (K.emittedReadable = !0, A(Z)));
    }
  }
  function x(Z) {
    var K = Z._readableState;
    c("emitReadable", K.needReadable, K.emittedReadable), K.needReadable = !1, K.emittedReadable || (c("emitReadable", K.flowing), K.emittedReadable = !0, at.nextTick(A, Z));
  }
  function A(Z) {
    var K = Z._readableState;
    c("emitReadable_", K.destroyed, K.length, K.ended), !K.destroyed && (K.length || K.ended) && (Z.emit("readable"), K.emittedReadable = !1), K.needReadable = !K.flowing && !K.ended && K.length <= K.highWaterMark, V(Z);
  }
  function S(Z, K) {
    K.readingMore || (K.readingMore = !0, at.nextTick(y, Z, K));
  }
  function y(Z, K) {
    for (; !K.reading && !K.ended && (K.length < K.highWaterMark || K.flowing && K.length === 0); ) {
      var ce = K.length;
      if (c("maybeReadMore read 0"), Z.read(0), ce === K.length)
        break;
    }
    K.readingMore = !1;
  }
  Y.prototype._read = function(Z) {
    q(this, new I("_read()"));
  }, Y.prototype.pipe = function(Z, K) {
    var ce = this, ve = this._readableState;
    switch (ve.pipesCount) {
      case 0:
        ve.pipes = Z;
        break;
      case 1:
        ve.pipes = [ve.pipes, Z];
        break;
      default:
        ve.pipes.push(Z);
        break;
    }
    ve.pipesCount += 1, c("pipe count=%d opts=%j", ve.pipesCount, K);
    var Be = (!K || K.end !== !1) && Z !== at.stdout && Z !== at.stderr, te = Be ? L : fe;
    ve.endEmitted ? at.nextTick(te) : ce.once("end", te), Z.on("unpipe", C);
    function C(_e, Ce) {
      c("onunpipe"), _e === ce && Ce && Ce.hasUnpiped === !1 && (Ce.hasUnpiped = !0, me());
    }
    function L() {
      c("onend"), Z.end();
    }
    var G = _(ce);
    Z.on("drain", G);
    var de = !1;
    function me() {
      c("cleanup"), Z.removeListener("close", H), Z.removeListener("finish", se), Z.removeListener("drain", G), Z.removeListener("error", He), Z.removeListener("unpipe", C), ce.removeListener("end", L), ce.removeListener("end", fe), ce.removeListener("data", Te), de = !0, ve.awaitDrain && (!Z._writableState || Z._writableState.needDrain) && G();
    }
    ce.on("data", Te);
    function Te(_e) {
      c("ondata");
      var Ce = Z.write(_e);
      c("dest.write", Ce), Ce === !1 && ((ve.pipesCount === 1 && ve.pipes === Z || ve.pipesCount > 1 && he(ve.pipes, Z) !== -1) && !de && (c("false write response, pause", ve.awaitDrain), ve.awaitDrain++), ce.pause());
    }
    function He(_e) {
      c("onerror", _e), fe(), Z.removeListener("error", He), t(Z, "error") === 0 && q(Z, _e);
    }
    U(Z, "error", He);
    function H() {
      Z.removeListener("finish", se), fe();
    }
    Z.once("close", H);
    function se() {
      c("onfinish"), Z.removeListener("close", H), fe();
    }
    Z.once("finish", se);
    function fe() {
      c("unpipe"), ce.unpipe(Z);
    }
    return Z.emit("pipe", ce), ve.flowing || (c("pipe resume"), ce.resume()), Z;
  };
  function _(Z) {
    return function() {
      var ce = Z._readableState;
      c("pipeOnDrain", ce.awaitDrain), ce.awaitDrain && ce.awaitDrain--, ce.awaitDrain === 0 && t(Z, "data") && (ce.flowing = !0, V(Z));
    };
  }
  Y.prototype.unpipe = function(Z) {
    var K = this._readableState, ce = {
      hasUnpiped: !1
    };
    if (K.pipesCount === 0)
      return this;
    if (K.pipesCount === 1)
      return Z && Z !== K.pipes ? this : (Z || (Z = K.pipes), K.pipes = null, K.pipesCount = 0, K.flowing = !1, Z && Z.emit("unpipe", this, ce), this);
    if (!Z) {
      var ve = K.pipes, Be = K.pipesCount;
      K.pipes = null, K.pipesCount = 0, K.flowing = !1;
      for (var te = 0; te < Be; te++)
        ve[te].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var C = he(K.pipes, Z);
    return C === -1 ? this : (K.pipes.splice(C, 1), K.pipesCount -= 1, K.pipesCount === 1 && (K.pipes = K.pipes[0]), Z.emit("unpipe", this, ce), this);
  }, Y.prototype.on = function(Z, K) {
    var ce = r.prototype.on.call(this, Z, K), ve = this._readableState;
    return Z === "data" ? (ve.readableListening = this.listenerCount("readable") > 0, ve.flowing !== !1 && this.resume()) : Z === "readable" && !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.flowing = !1, ve.emittedReadable = !1, c("on readable", ve.length, ve.reading), ve.length ? x(this) : ve.reading || at.nextTick(R, this)), ce;
  }, Y.prototype.addListener = Y.prototype.on, Y.prototype.removeListener = function(Z, K) {
    var ce = r.prototype.removeListener.call(this, Z, K);
    return Z === "readable" && at.nextTick(l, this), ce;
  }, Y.prototype.removeAllListeners = function(Z) {
    var K = r.prototype.removeAllListeners.apply(this, arguments);
    return (Z === "readable" || Z === void 0) && at.nextTick(l, this), K;
  };
  function l(Z) {
    var K = Z._readableState;
    K.readableListening = Z.listenerCount("readable") > 0, K.resumeScheduled && !K.paused ? K.flowing = !0 : Z.listenerCount("data") > 0 && Z.resume();
  }
  function R(Z) {
    c("readable nexttick read 0"), Z.read(0);
  }
  Y.prototype.resume = function() {
    var Z = this._readableState;
    return Z.flowing || (c("resume"), Z.flowing = !Z.readableListening, ee(this, Z)), Z.paused = !1, this;
  };
  function ee(Z, K) {
    K.resumeScheduled || (K.resumeScheduled = !0, at.nextTick(oe, Z, K));
  }
  function oe(Z, K) {
    c("resume", K.reading), K.reading || Z.read(0), K.resumeScheduled = !1, Z.emit("resume"), V(Z), K.flowing && !K.reading && Z.read(0);
  }
  Y.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function V(Z) {
    var K = Z._readableState;
    for (c("flow", K.flowing); K.flowing && Z.read() !== null; )
      ;
  }
  Y.prototype.wrap = function(Z) {
    var K = this, ce = this._readableState, ve = !1;
    Z.on("end", function() {
      if (c("wrapped end"), ce.decoder && !ce.ended) {
        var C = ce.decoder.end();
        C && C.length && K.push(C);
      }
      K.push(null);
    }), Z.on("data", function(C) {
      if (c("wrapped data"), ce.decoder && (C = ce.decoder.write(C)), !(ce.objectMode && C == null) && !(!ce.objectMode && (!C || !C.length))) {
        var L = K.push(C);
        L || (ve = !0, Z.pause());
      }
    });
    for (var Be in Z)
      this[Be] === void 0 && typeof Z[Be] == "function" && (this[Be] = /* @__PURE__ */ function(L) {
        return function() {
          return Z[L].apply(Z, arguments);
        };
      }(Be));
    for (var te = 0; te < D.length; te++)
      Z.on(D[te], this.emit.bind(this, D[te]));
    return this._read = function(C) {
      c("wrapped _read", C), ve && (ve = !1, Z.resume());
    }, this;
  }, typeof Symbol == "function" && (Y.prototype[Symbol.asyncIterator] = function() {
    return k === void 0 && (k = Nx()), k(this);
  }), Object.defineProperty(Y.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Y.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Y.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(K) {
      this._readableState && (this._readableState.flowing = K);
    }
  }), Y._fromList = W, Object.defineProperty(Y.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function W(Z, K) {
    if (K.length === 0)
      return null;
    var ce;
    return K.objectMode ? ce = K.buffer.shift() : !Z || Z >= K.length ? (K.decoder ? ce = K.buffer.join("") : K.buffer.length === 1 ? ce = K.buffer.first() : ce = K.buffer.concat(K.length), K.buffer.clear()) : ce = K.buffer.consume(Z, K.decoder), ce;
  }
  function F(Z) {
    var K = Z._readableState;
    c("endReadable", K.endEmitted), K.endEmitted || (K.ended = !0, at.nextTick(re, K, Z));
  }
  function re(Z, K) {
    if (c("endReadableNT", Z.endEmitted, Z.length), !Z.endEmitted && Z.length === 0 && (Z.endEmitted = !0, K.readable = !1, K.emit("end"), Z.autoDestroy)) {
      var ce = K._writableState;
      (!ce || ce.autoDestroy && ce.finished) && K.destroy();
    }
  }
  typeof Symbol == "function" && (Y.from = function(Z, K) {
    return N === void 0 && (N = Lx()), N(Y, Z, K);
  });
  function he(Z, K) {
    for (var ce = 0, ve = Z.length; ce < ve; ce++)
      if (Z[ce] === K)
        return ce;
    return -1;
  }
  return vs;
}
var bs, xd;
function s0() {
  if (xd)
    return bs;
  xd = 1, bs = u;
  var e = Wi().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, r = e.ERR_MULTIPLE_CALLBACK, i = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, o = e.ERR_TRANSFORM_WITH_LENGTH_0, n = ni();
  Et()(u, n);
  function f(s, p) {
    var v = this._transformState;
    v.transforming = !1;
    var m = v.writecb;
    if (m === null)
      return this.emit("error", new r());
    v.writechunk = null, v.writecb = null, p != null && this.push(p), m(s);
    var E = this._readableState;
    E.reading = !1, (E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
  }
  function u(s) {
    if (!(this instanceof u))
      return new u(s);
    n.call(this, s), this._transformState = {
      afterTransform: f.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", c);
  }
  function c() {
    var s = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(p, v) {
      h(s, p, v);
    }) : h(this, null, null);
  }
  u.prototype.push = function(s, p) {
    return this._transformState.needTransform = !1, n.prototype.push.call(this, s, p);
  }, u.prototype._transform = function(s, p, v) {
    v(new t("_transform()"));
  }, u.prototype._write = function(s, p, v) {
    var m = this._transformState;
    if (m.writecb = v, m.writechunk = s, m.writeencoding = p, !m.transforming) {
      var E = this._readableState;
      (m.needTransform || E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
    }
  }, u.prototype._read = function(s) {
    var p = this._transformState;
    p.writechunk !== null && !p.transforming ? (p.transforming = !0, this._transform(p.writechunk, p.writeencoding, p.afterTransform)) : p.needTransform = !0;
  }, u.prototype._destroy = function(s, p) {
    n.prototype._destroy.call(this, s, function(v) {
      p(v);
    });
  };
  function h(s, p, v) {
    if (p)
      return s.emit("error", p);
    if (v != null && s.push(v), s._writableState.length)
      throw new o();
    if (s._transformState.transforming)
      throw new i();
    return s.push(null);
  }
  return bs;
}
var ys, Ed;
function rg() {
  if (Ed)
    return ys;
  Ed = 1, ys = t;
  var e = s0();
  Et()(t, e);
  function t(r) {
    if (!(this instanceof t))
      return new t(r);
    e.call(this, r);
  }
  return t.prototype._transform = function(r, i, o) {
    o(null, r);
  }, ys;
}
var gs, Sd;
function ng() {
  if (Sd)
    return gs;
  Sd = 1;
  var e;
  function t(v) {
    var m = !1;
    return function() {
      m || (m = !0, v.apply(void 0, arguments));
    };
  }
  var r = Wi().codes, i = r.ERR_MISSING_ARGS, o = r.ERR_STREAM_DESTROYED;
  function n(v) {
    if (v)
      throw v;
  }
  function f(v) {
    return v.setHeader && typeof v.abort == "function";
  }
  function u(v, m, E, M) {
    M = t(M);
    var I = !1;
    v.on("close", function() {
      I = !0;
    }), e === void 0 && (e = sf()), e(v, {
      readable: m,
      writable: E
    }, function(T) {
      if (T)
        return M(T);
      I = !0, M();
    });
    var B = !1;
    return function(T) {
      if (!I && !B) {
        if (B = !0, f(v))
          return v.abort();
        if (typeof v.destroy == "function")
          return v.destroy();
        M(T || new o("pipe"));
      }
    };
  }
  function c(v) {
    v();
  }
  function h(v, m) {
    return v.pipe(m);
  }
  function s(v) {
    return !v.length || typeof v[v.length - 1] != "function" ? n : v.pop();
  }
  function p() {
    for (var v = arguments.length, m = new Array(v), E = 0; E < v; E++)
      m[E] = arguments[E];
    var M = s(m);
    if (Array.isArray(m[0]) && (m = m[0]), m.length < 2)
      throw new i("streams");
    var I, B = m.map(function(T, k) {
      var N = k < m.length - 1, q = k > 0;
      return u(T, N, q, function(D) {
        I || (I = D), D && B.forEach(c), !N && (B.forEach(c), M(I));
      });
    });
    return m.reduce(h);
  }
  return gs = p, gs;
}
var Ad;
function uf() {
  return Ad || (Ad = 1, function(e, t) {
    t = e.exports = f0(), t.Stream = t, t.Readable = t, t.Writable = o0(), t.Duplex = ni(), t.Transform = s0(), t.PassThrough = rg(), t.finished = sf(), t.pipeline = ng();
  }(Va, Va.exports)), Va.exports;
}
var Md;
function ig() {
  if (Md)
    return za;
  Md = 1;
  var e = Xy(), t = Et(), r = uf(), i = za.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  }, o = za.IncomingMessage = function(n, f, u, c) {
    var h = this;
    if (r.Readable.call(h), h._mode = u, h.headers = {}, h.rawHeaders = [], h.trailers = {}, h.rawTrailers = [], h.on("end", function() {
      at.nextTick(function() {
        h.emit("close");
      });
    }), u === "fetch") {
      let M = function() {
        p.read().then(function(I) {
          if (!h._destroyed) {
            if (c(I.done), I.done) {
              h.push(null);
              return;
            }
            h.push(Le.Buffer.from(I.value)), M();
          }
        }).catch(function(I) {
          c(!0), h._destroyed || h.emit("error", I);
        });
      };
      if (h._fetchResponse = f, h.url = f.url, h.statusCode = f.status, h.statusMessage = f.statusText, f.headers.forEach(function(I, B) {
        h.headers[B.toLowerCase()] = I, h.rawHeaders.push(B, I);
      }), e.writableStream) {
        var s = new WritableStream({
          write: function(I) {
            return c(!1), new Promise(function(B, T) {
              h._destroyed ? T() : h.push(Le.Buffer.from(I)) ? B() : h._resumeFetch = B;
            });
          },
          close: function() {
            c(!0), h._destroyed || h.push(null);
          },
          abort: function(I) {
            c(!0), h._destroyed || h.emit("error", I);
          }
        });
        try {
          f.body.pipeTo(s).catch(function(I) {
            c(!0), h._destroyed || h.emit("error", I);
          });
          return;
        } catch {
        }
      }
      var p = f.body.getReader();
      M();
    } else {
      h._xhr = n, h._pos = 0, h.url = n.responseURL, h.statusCode = n.status, h.statusMessage = n.statusText;
      var v = n.getAllResponseHeaders().split(/\r?\n/);
      if (v.forEach(function(M) {
        var I = M.match(/^([^:]+):\s*(.*)/);
        if (I) {
          var B = I[1].toLowerCase();
          B === "set-cookie" ? (h.headers[B] === void 0 && (h.headers[B] = []), h.headers[B].push(I[2])) : h.headers[B] !== void 0 ? h.headers[B] += ", " + I[2] : h.headers[B] = I[2], h.rawHeaders.push(I[1], I[2]);
        }
      }), h._charset = "x-user-defined", !e.overrideMimeType) {
        var m = h.rawHeaders["mime-type"];
        if (m) {
          var E = m.match(/;\s*charset=([^;])(;|$)/);
          E && (h._charset = E[1].toLowerCase());
        }
        h._charset || (h._charset = "utf-8");
      }
    }
  };
  return t(o, r.Readable), o.prototype._read = function() {
    var n = this, f = n._resumeFetch;
    f && (n._resumeFetch = null, f());
  }, o.prototype._onXHRProgress = function(n) {
    var f = this, u = f._xhr, c = null;
    switch (f._mode) {
      case "text":
        if (c = u.responseText, c.length > f._pos) {
          var h = c.substr(f._pos);
          if (f._charset === "x-user-defined") {
            for (var s = Le.Buffer.alloc(h.length), p = 0; p < h.length; p++)
              s[p] = h.charCodeAt(p) & 255;
            f.push(s);
          } else
            f.push(h, f._charset);
          f._pos = c.length;
        }
        break;
      case "arraybuffer":
        if (u.readyState !== i.DONE || !u.response)
          break;
        c = u.response, f.push(Le.Buffer.from(new Uint8Array(c)));
        break;
      case "moz-chunked-arraybuffer":
        if (c = u.response, u.readyState !== i.LOADING || !c)
          break;
        f.push(Le.Buffer.from(new Uint8Array(c)));
        break;
      case "ms-stream":
        if (c = u.response, u.readyState !== i.LOADING)
          break;
        var v = new Ze.MSStreamReader();
        v.onprogress = function() {
          v.result.byteLength > f._pos && (f.push(Le.Buffer.from(new Uint8Array(v.result.slice(f._pos)))), f._pos = v.result.byteLength);
        }, v.onload = function() {
          n(!0), f.push(null);
        }, v.readAsArrayBuffer(c);
        break;
    }
    f._xhr.readyState === i.DONE && f._mode !== "ms-stream" && (n(!0), f.push(null));
  }, za;
}
var Rd;
function kx() {
  if (Rd)
    return zf.exports;
  Rd = 1;
  var e = Xy(), t = Et(), r = ig(), i = uf(), o = r.IncomingMessage, n = r.readyStates;
  function f(s, p) {
    return e.fetch && p ? "fetch" : e.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : e.msstream ? "ms-stream" : e.arraybuffer && s ? "arraybuffer" : "text";
  }
  var u = zf.exports = function(s) {
    var p = this;
    i.Writable.call(p), p._opts = s, p._body = [], p._headers = {}, s.auth && p.setHeader("Authorization", "Basic " + Le.Buffer.from(s.auth).toString("base64")), Object.keys(s.headers).forEach(function(E) {
      p.setHeader(E, s.headers[E]);
    });
    var v, m = !0;
    if (s.mode === "disable-fetch" || "requestTimeout" in s && !e.abortController)
      m = !1, v = !0;
    else if (s.mode === "prefer-streaming")
      v = !1;
    else if (s.mode === "allow-wrong-content-type")
      v = !e.overrideMimeType;
    else if (!s.mode || s.mode === "default" || s.mode === "prefer-fast")
      v = !0;
    else
      throw new Error("Invalid value for opts.mode");
    p._mode = f(v, m), p._fetchTimer = null, p._socketTimeout = null, p._socketTimer = null, p.on("finish", function() {
      p._onFinish();
    });
  };
  t(u, i.Writable), u.prototype.setHeader = function(s, p) {
    var v = this, m = s.toLowerCase();
    h.indexOf(m) === -1 && (v._headers[m] = {
      name: s,
      value: p
    });
  }, u.prototype.getHeader = function(s) {
    var p = this._headers[s.toLowerCase()];
    return p ? p.value : null;
  }, u.prototype.removeHeader = function(s) {
    var p = this;
    delete p._headers[s.toLowerCase()];
  }, u.prototype._onFinish = function() {
    var s = this;
    if (!s._destroyed) {
      var p = s._opts;
      "timeout" in p && p.timeout !== 0 && s.setTimeout(p.timeout);
      var v = s._headers, m = null;
      p.method !== "GET" && p.method !== "HEAD" && (m = new Blob(s._body, {
        type: (v["content-type"] || {}).value || ""
      }));
      var E = [];
      if (Object.keys(v).forEach(function(T) {
        var k = v[T].name, N = v[T].value;
        Array.isArray(N) ? N.forEach(function(q) {
          E.push([k, q]);
        }) : E.push([k, N]);
      }), s._mode === "fetch") {
        var M = null;
        if (e.abortController) {
          var I = new AbortController();
          M = I.signal, s._fetchAbortController = I, "requestTimeout" in p && p.requestTimeout !== 0 && (s._fetchTimer = Ze.setTimeout(function() {
            s.emit("requestTimeout"), s._fetchAbortController && s._fetchAbortController.abort();
          }, p.requestTimeout));
        }
        Ze.fetch(s._opts.url, {
          method: s._opts.method,
          headers: E,
          body: m || void 0,
          mode: "cors",
          credentials: p.withCredentials ? "include" : "same-origin",
          signal: M
        }).then(function(T) {
          s._fetchResponse = T, s._resetTimers(!1), s._connect();
        }, function(T) {
          s._resetTimers(!0), s._destroyed || s.emit("error", T);
        });
      } else {
        var B = s._xhr = new Ze.XMLHttpRequest();
        try {
          B.open(s._opts.method, s._opts.url, !0);
        } catch (T) {
          at.nextTick(function() {
            s.emit("error", T);
          });
          return;
        }
        "responseType" in B && (B.responseType = s._mode), "withCredentials" in B && (B.withCredentials = !!p.withCredentials), s._mode === "text" && "overrideMimeType" in B && B.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in p && (B.timeout = p.requestTimeout, B.ontimeout = function() {
          s.emit("requestTimeout");
        }), E.forEach(function(T) {
          B.setRequestHeader(T[0], T[1]);
        }), s._response = null, B.onreadystatechange = function() {
          switch (B.readyState) {
            case n.LOADING:
            case n.DONE:
              s._onXHRProgress();
              break;
          }
        }, s._mode === "moz-chunked-arraybuffer" && (B.onprogress = function() {
          s._onXHRProgress();
        }), B.onerror = function() {
          s._destroyed || (s._resetTimers(!0), s.emit("error", new Error("XHR error")));
        };
        try {
          B.send(m);
        } catch (T) {
          at.nextTick(function() {
            s.emit("error", T);
          });
          return;
        }
      }
    }
  };
  function c(s) {
    try {
      var p = s.status;
      return p !== null && p !== 0;
    } catch {
      return !1;
    }
  }
  u.prototype._onXHRProgress = function() {
    var s = this;
    s._resetTimers(!1), !(!c(s._xhr) || s._destroyed) && (s._response || s._connect(), s._response._onXHRProgress(s._resetTimers.bind(s)));
  }, u.prototype._connect = function() {
    var s = this;
    s._destroyed || (s._response = new o(s._xhr, s._fetchResponse, s._mode, s._resetTimers.bind(s)), s._response.on("error", function(p) {
      s.emit("error", p);
    }), s.emit("response", s._response));
  }, u.prototype._write = function(s, p, v) {
    var m = this;
    m._body.push(s), v();
  }, u.prototype._resetTimers = function(s) {
    var p = this;
    Ze.clearTimeout(p._socketTimer), p._socketTimer = null, s ? (Ze.clearTimeout(p._fetchTimer), p._fetchTimer = null) : p._socketTimeout && (p._socketTimer = Ze.setTimeout(function() {
      p.emit("timeout");
    }, p._socketTimeout));
  }, u.prototype.abort = u.prototype.destroy = function(s) {
    var p = this;
    p._destroyed = !0, p._resetTimers(!0), p._response && (p._response._destroyed = !0), p._xhr ? p._xhr.abort() : p._fetchAbortController && p._fetchAbortController.abort(), s && p.emit("error", s);
  }, u.prototype.end = function(s, p, v) {
    var m = this;
    typeof s == "function" && (v = s, s = void 0), i.Writable.prototype.end.call(m, s, p, v);
  }, u.prototype.setTimeout = function(s, p) {
    var v = this;
    p && v.once("timeout", p), v._socketTimeout = s, v._resetTimers(!1);
  }, u.prototype.flushHeaders = function() {
  }, u.prototype.setNoDelay = function() {
  }, u.prototype.setSocketKeepAlive = function() {
  };
  var h = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];
  return zf.exports;
}
var ms, Bd;
function qx() {
  if (Bd)
    return ms;
  Bd = 1, ms = t;
  var e = Object.prototype.hasOwnProperty;
  function t() {
    for (var r = {}, i = 0; i < arguments.length; i++) {
      var o = arguments[i];
      for (var n in o)
        e.call(o, n) && (r[n] = o[n]);
    }
    return r;
  }
  return ms;
}
var ws, Id;
function $x() {
  return Id || (Id = 1, ws = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Unordered Collection",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    511: "Network Authentication Required"
  }), ws;
}
var Ka = { exports: {} }, na = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
na.exports;
var Td;
function Dx() {
  return Td || (Td = 1, function(e, t) {
    (function(r) {
      var i = t && !t.nodeType && t, o = e && !e.nodeType && e, n = typeof Ze == "object" && Ze;
      (n.global === n || n.window === n || n.self === n) && (r = n);
      var f, u = 2147483647, c = 36, h = 1, s = 26, p = 38, v = 700, m = 72, E = 128, M = "-", I = /^xn--/, B = /[^\x20-\x7E]/, T = /[\x2E\u3002\uFF0E\uFF61]/g, k = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, N = c - h, q = Math.floor, D = String.fromCharCode, U;
      function z(y) {
        throw new RangeError(k[y]);
      }
      function Y(y, _) {
        for (var l = y.length, R = []; l--; )
          R[l] = _(y[l]);
        return R;
      }
      function ue(y, _) {
        var l = y.split("@"), R = "";
        l.length > 1 && (R = l[0] + "@", y = l[1]), y = y.replace(T, ".");
        var ee = y.split("."), oe = Y(ee, _).join(".");
        return R + oe;
      }
      function j(y) {
        for (var _ = [], l = 0, R = y.length, ee, oe; l < R; )
          ee = y.charCodeAt(l++), ee >= 55296 && ee <= 56319 && l < R ? (oe = y.charCodeAt(l++), (oe & 64512) == 56320 ? _.push(((ee & 1023) << 10) + (oe & 1023) + 65536) : (_.push(ee), l--)) : _.push(ee);
        return _;
      }
      function g(y) {
        return Y(y, function(_) {
          var l = "";
          return _ > 65535 && (_ -= 65536, l += D(_ >>> 10 & 1023 | 55296), _ = 56320 | _ & 1023), l += D(_), l;
        }).join("");
      }
      function b(y) {
        return y - 48 < 10 ? y - 22 : y - 65 < 26 ? y - 65 : y - 97 < 26 ? y - 97 : c;
      }
      function a(y, _) {
        return y + 22 + 75 * (y < 26) - ((_ != 0) << 5);
      }
      function d(y, _, l) {
        var R = 0;
        for (y = l ? q(y / v) : y >> 1, y += q(y / _); y > N * s >> 1; R += c)
          y = q(y / N);
        return q(R + (N + 1) * y / (y + p));
      }
      function w(y) {
        var _ = [], l = y.length, R, ee = 0, oe = E, V = m, W, F, re, he, Z, K, ce, ve, Be;
        for (W = y.lastIndexOf(M), W < 0 && (W = 0), F = 0; F < W; ++F)
          y.charCodeAt(F) >= 128 && z("not-basic"), _.push(y.charCodeAt(F));
        for (re = W > 0 ? W + 1 : 0; re < l; ) {
          for (he = ee, Z = 1, K = c; re >= l && z("invalid-input"), ce = b(y.charCodeAt(re++)), (ce >= c || ce > q((u - ee) / Z)) && z("overflow"), ee += ce * Z, ve = K <= V ? h : K >= V + s ? s : K - V, !(ce < ve); K += c)
            Be = c - ve, Z > q(u / Be) && z("overflow"), Z *= Be;
          R = _.length + 1, V = d(ee - he, R, he == 0), q(ee / R) > u - oe && z("overflow"), oe += q(ee / R), ee %= R, _.splice(ee++, 0, oe);
        }
        return g(_);
      }
      function x(y) {
        var _, l, R, ee, oe, V, W, F, re, he, Z, K = [], ce, ve, Be, te;
        for (y = j(y), ce = y.length, _ = E, l = 0, oe = m, V = 0; V < ce; ++V)
          Z = y[V], Z < 128 && K.push(D(Z));
        for (R = ee = K.length, ee && K.push(M); R < ce; ) {
          for (W = u, V = 0; V < ce; ++V)
            Z = y[V], Z >= _ && Z < W && (W = Z);
          for (ve = R + 1, W - _ > q((u - l) / ve) && z("overflow"), l += (W - _) * ve, _ = W, V = 0; V < ce; ++V)
            if (Z = y[V], Z < _ && ++l > u && z("overflow"), Z == _) {
              for (F = l, re = c; he = re <= oe ? h : re >= oe + s ? s : re - oe, !(F < he); re += c)
                te = F - he, Be = c - he, K.push(
                  D(a(he + te % Be, 0))
                ), F = q(te / Be);
              K.push(D(a(F, 0))), oe = d(l, ve, R == ee), l = 0, ++R;
            }
          ++l, ++_;
        }
        return K.join("");
      }
      function A(y) {
        return ue(y, function(_) {
          return I.test(_) ? w(_.slice(4).toLowerCase()) : _;
        });
      }
      function S(y) {
        return ue(y, function(_) {
          return B.test(_) ? "xn--" + x(_) : _;
        });
      }
      if (f = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: j,
          encode: g
        },
        decode: w,
        encode: x,
        toASCII: S,
        toUnicode: A
      }, i && o)
        if (e.exports == i)
          o.exports = f;
        else
          for (U in f)
            f.hasOwnProperty(U) && (i[U] = f[U]);
      else
        r.punycode = f;
    })(Ze);
  }(na, na.exports)), na.exports;
}
var Za = { exports: {} }, bi = {}, _s, Od;
function jx() {
  if (Od)
    return _s;
  Od = 1;
  function e(r, i) {
    return Object.prototype.hasOwnProperty.call(r, i);
  }
  _s = function(r, i, o, n) {
    i = i || "&", o = o || "=";
    var f = {};
    if (typeof r != "string" || r.length === 0)
      return f;
    var u = /\+/g;
    r = r.split(i);
    var c = 1e3;
    n && typeof n.maxKeys == "number" && (c = n.maxKeys);
    var h = r.length;
    c > 0 && h > c && (h = c);
    for (var s = 0; s < h; ++s) {
      var p = r[s].replace(u, "%20"), v = p.indexOf(o), m, E, M, I;
      v >= 0 ? (m = p.substr(0, v), E = p.substr(v + 1)) : (m = p, E = ""), M = decodeURIComponent(m), I = decodeURIComponent(E), e(f, M) ? t(f[M]) ? f[M].push(I) : f[M] = [f[M], I] : f[M] = I;
    }
    return f;
  };
  var t = Array.isArray || function(r) {
    return Object.prototype.toString.call(r) === "[object Array]";
  };
  return _s;
}
var xs, Pd;
function Ux() {
  if (Pd)
    return xs;
  Pd = 1;
  var e = function(o) {
    switch (typeof o) {
      case "string":
        return o;
      case "boolean":
        return o ? "true" : "false";
      case "number":
        return isFinite(o) ? o : "";
      default:
        return "";
    }
  };
  xs = function(o, n, f, u) {
    return n = n || "&", f = f || "=", o === null && (o = void 0), typeof o == "object" ? r(i(o), function(c) {
      var h = encodeURIComponent(e(c)) + f;
      return t(o[c]) ? r(o[c], function(s) {
        return h + encodeURIComponent(e(s));
      }).join(n) : h + encodeURIComponent(e(o[c]));
    }).join(n) : u ? encodeURIComponent(e(u)) + f + encodeURIComponent(e(o)) : "";
  };
  var t = Array.isArray || function(o) {
    return Object.prototype.toString.call(o) === "[object Array]";
  };
  function r(o, n) {
    if (o.map)
      return o.map(n);
    for (var f = [], u = 0; u < o.length; u++)
      f.push(n(o[u], u));
    return f;
  }
  var i = Object.keys || function(o) {
    var n = [];
    for (var f in o)
      Object.prototype.hasOwnProperty.call(o, f) && n.push(f);
    return n;
  };
  return xs;
}
var Cd;
function Fx() {
  return Cd || (Cd = 1, bi.decode = bi.parse = jx(), bi.encode = bi.stringify = Ux()), bi;
}
var Nd;
function Hx() {
  return Nd || (Nd = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var r = Fx();
    function i(f) {
      return encodeURIComponent(f);
    }
    function o(f) {
      return decodeURIComponent(f);
    }
    var n = {
      decode: r.decode,
      encode: r.encode,
      parse: r.parse,
      stringify: r.stringify,
      escape: i,
      unescape: o
    };
    Object.defineProperty(t, "decode", {
      enumerable: !0,
      get: function() {
        return r.decode;
      }
    }), Object.defineProperty(t, "encode", {
      enumerable: !0,
      get: function() {
        return r.encode;
      }
    }), Object.defineProperty(t, "parse", {
      enumerable: !0,
      get: function() {
        return r.parse;
      }
    }), Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function() {
        return r.stringify;
      }
    }), t.default = n, t.escape = i, t.unescape = o, t = e.exports = n;
  }(Za, Za.exports)), Za.exports;
}
var Ld;
function u0() {
  return Ld || (Ld = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var r = Dx(), i = Hx();
    function o(H) {
      return H && typeof H == "object" && "default" in H ? H : { default: H };
    }
    var n = /* @__PURE__ */ o(r), f = /* @__PURE__ */ o(i), u = {
      isString: function(H) {
        return typeof H == "string";
      },
      isObject: function(H) {
        return typeof H == "object" && H !== null;
      },
      isNull: function(H) {
        return H === null;
      },
      isNullOrUndefined: function(H) {
        return H == null;
      }
    }, c = n.default, h = u, s = d, p = x, v = A, m = w, E = M;
    function M() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var I = /^([a-z0-9.+-]+:)/i, B = /:[0-9]*$/, T = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, k = ["<", ">", '"', "`", " ", "\r", `
`, "	"], N = ["{", "}", "|", "\\", "^", "`"].concat(k), q = ["'"].concat(N), D = ["%", "/", "?", ";", "#"].concat(q), U = ["/", "?", "#"], z = 255, Y = /^[+a-z0-9A-Z_-]{0,63}$/, ue = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, j = {
      javascript: !0,
      "javascript:": !0
    }, g = {
      javascript: !0,
      "javascript:": !0
    }, b = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0
    }, a = f.default;
    function d(H, se, fe) {
      if (H && h.isObject(H) && H instanceof M)
        return H;
      var _e = new M();
      return _e.parse(H, se, fe), _e;
    }
    M.prototype.parse = function(H, se, fe) {
      if (!h.isString(H))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof H);
      var _e = H.indexOf("?"), Ce = _e !== -1 && _e < H.indexOf("#") ? "?" : "#", Ve = H.split(Ce), ke = /\\/g;
      Ve[0] = Ve[0].replace(ke, "/"), H = Ve.join(Ce);
      var Q = H;
      if (Q = Q.trim(), !fe && H.split("#").length === 1) {
        var Se = T.exec(Q);
        if (Se)
          return this.path = Q, this.href = Q, this.pathname = Se[1], Se[2] ? (this.search = Se[2], se ? this.query = a.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : se && (this.search = "", this.query = {}), this;
      }
      var Ae = I.exec(Q);
      if (Ae) {
        Ae = Ae[0];
        var $e = Ae.toLowerCase();
        this.protocol = $e, Q = Q.substr(Ae.length);
      }
      if (fe || Ae || Q.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var pe = Q.substr(0, 2) === "//";
        pe && !(Ae && g[Ae]) && (Q = Q.substr(2), this.slashes = !0);
      }
      if (!g[Ae] && (pe || Ae && !b[Ae])) {
        for (var Ee = -1, J = 0; J < U.length; J++) {
          var Ie = Q.indexOf(U[J]);
          Ie !== -1 && (Ee === -1 || Ie < Ee) && (Ee = Ie);
        }
        var qe, P;
        Ee === -1 ? P = Q.lastIndexOf("@") : P = Q.lastIndexOf("@", Ee), P !== -1 && (qe = Q.slice(0, P), Q = Q.slice(P + 1), this.auth = decodeURIComponent(qe)), Ee = -1;
        for (var J = 0; J < D.length; J++) {
          var Ie = Q.indexOf(D[J]);
          Ie !== -1 && (Ee === -1 || Ie < Ee) && (Ee = Ie);
        }
        Ee === -1 && (Ee = Q.length), this.host = Q.slice(0, Ee), Q = Q.slice(Ee), this.parseHost(), this.hostname = this.hostname || "";
        var Me = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!Me)
          for (var be = this.hostname.split(/\./), J = 0, ie = be.length; J < ie; J++) {
            var le = be[J];
            if (le && !le.match(Y)) {
              for (var ge = "", Ge = 0, je = le.length; Ge < je; Ge++)
                le.charCodeAt(Ge) > 127 ? ge += "x" : ge += le[Ge];
              if (!ge.match(Y)) {
                var Ne = be.slice(0, J), nt = be.slice(J + 1), st = le.match(ue);
                st && (Ne.push(st[1]), nt.unshift(st[2])), nt.length && (Q = "/" + nt.join(".") + Q), this.hostname = Ne.join(".");
                break;
              }
            }
          }
        this.hostname.length > z ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Me || (this.hostname = c.toASCII(this.hostname));
        var Je = this.port ? ":" + this.port : "", ft = this.hostname || "";
        this.host = ft + Je, this.href += this.host, Me && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), Q[0] !== "/" && (Q = "/" + Q));
      }
      if (!j[$e])
        for (var J = 0, ie = q.length; J < ie; J++) {
          var $ = q[J];
          if (Q.indexOf($) !== -1) {
            var X = encodeURIComponent($);
            X === $ && (X = escape($)), Q = Q.split($).join(X);
          }
        }
      var ne = Q.indexOf("#");
      ne !== -1 && (this.hash = Q.substr(ne), Q = Q.slice(0, ne));
      var O = Q.indexOf("?");
      if (O !== -1 ? (this.search = Q.substr(O), this.query = Q.substr(O + 1), se && (this.query = a.parse(this.query)), Q = Q.slice(0, O)) : se && (this.search = "", this.query = {}), Q && (this.pathname = Q), b[$e] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Je = this.pathname || "", ae = this.search || "";
        this.path = Je + ae;
      }
      return this.href = this.format(), this;
    };
    function w(H) {
      return h.isString(H) && (H = d(H)), H instanceof M ? H.format() : M.prototype.format.call(H);
    }
    M.prototype.format = function() {
      var H = this.auth || "";
      H && (H = encodeURIComponent(H), H = H.replace(/%3A/i, ":"), H += "@");
      var se = this.protocol || "", fe = this.pathname || "", _e = this.hash || "", Ce = !1, Ve = "";
      this.host ? Ce = H + this.host : this.hostname && (Ce = H + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Ce += ":" + this.port)), this.query && h.isObject(this.query) && Object.keys(this.query).length && (Ve = a.stringify(this.query));
      var ke = this.search || Ve && "?" + Ve || "";
      return se && se.substr(-1) !== ":" && (se += ":"), this.slashes || (!se || b[se]) && Ce !== !1 ? (Ce = "//" + (Ce || ""), fe && fe.charAt(0) !== "/" && (fe = "/" + fe)) : Ce || (Ce = ""), _e && _e.charAt(0) !== "#" && (_e = "#" + _e), ke && ke.charAt(0) !== "?" && (ke = "?" + ke), fe = fe.replace(/[?#]/g, function(Q) {
        return encodeURIComponent(Q);
      }), ke = ke.replace("#", "%23"), se + Ce + fe + ke + _e;
    };
    function x(H, se) {
      return d(H, !1, !0).resolve(se);
    }
    M.prototype.resolve = function(H) {
      return this.resolveObject(d(H, !1, !0)).format();
    };
    function A(H, se) {
      return H ? d(H, !1, !0).resolveObject(se) : se;
    }
    M.prototype.resolveObject = function(H) {
      if (h.isString(H)) {
        var se = new M();
        se.parse(H, !1, !0), H = se;
      }
      for (var fe = new M(), _e = Object.keys(this), Ce = 0; Ce < _e.length; Ce++) {
        var Ve = _e[Ce];
        fe[Ve] = this[Ve];
      }
      if (fe.hash = H.hash, H.href === "")
        return fe.href = fe.format(), fe;
      if (H.slashes && !H.protocol) {
        for (var ke = Object.keys(H), Q = 0; Q < ke.length; Q++) {
          var Se = ke[Q];
          Se !== "protocol" && (fe[Se] = H[Se]);
        }
        return b[fe.protocol] && fe.hostname && !fe.pathname && (fe.path = fe.pathname = "/"), fe.href = fe.format(), fe;
      }
      if (H.protocol && H.protocol !== fe.protocol) {
        if (!b[H.protocol]) {
          for (var Ae = Object.keys(H), $e = 0; $e < Ae.length; $e++) {
            var pe = Ae[$e];
            fe[pe] = H[pe];
          }
          return fe.href = fe.format(), fe;
        }
        if (fe.protocol = H.protocol, !H.host && !g[H.protocol]) {
          for (var ie = (H.pathname || "").split("/"); ie.length && !(H.host = ie.shift()); )
            ;
          H.host || (H.host = ""), H.hostname || (H.hostname = ""), ie[0] !== "" && ie.unshift(""), ie.length < 2 && ie.unshift(""), fe.pathname = ie.join("/");
        } else
          fe.pathname = H.pathname;
        if (fe.search = H.search, fe.query = H.query, fe.host = H.host || "", fe.auth = H.auth, fe.hostname = H.hostname || H.host, fe.port = H.port, fe.pathname || fe.search) {
          var Ee = fe.pathname || "", J = fe.search || "";
          fe.path = Ee + J;
        }
        return fe.slashes = fe.slashes || H.slashes, fe.href = fe.format(), fe;
      }
      var Ie = fe.pathname && fe.pathname.charAt(0) === "/", qe = H.host || H.pathname && H.pathname.charAt(0) === "/", P = qe || Ie || fe.host && H.pathname, Me = P, be = fe.pathname && fe.pathname.split("/") || [], ie = H.pathname && H.pathname.split("/") || [], le = fe.protocol && !b[fe.protocol];
      if (le && (fe.hostname = "", fe.port = null, fe.host && (be[0] === "" ? be[0] = fe.host : be.unshift(fe.host)), fe.host = "", H.protocol && (H.hostname = null, H.port = null, H.host && (ie[0] === "" ? ie[0] = H.host : ie.unshift(H.host)), H.host = null), P = P && (ie[0] === "" || be[0] === "")), qe)
        fe.host = H.host || H.host === "" ? H.host : fe.host, fe.hostname = H.hostname || H.hostname === "" ? H.hostname : fe.hostname, fe.search = H.search, fe.query = H.query, be = ie;
      else if (ie.length)
        be || (be = []), be.pop(), be = be.concat(ie), fe.search = H.search, fe.query = H.query;
      else if (!h.isNullOrUndefined(H.search)) {
        if (le) {
          fe.hostname = fe.host = be.shift();
          var ge = fe.host && fe.host.indexOf("@") > 0 ? fe.host.split("@") : !1;
          ge && (fe.auth = ge.shift(), fe.host = fe.hostname = ge.shift());
        }
        return fe.search = H.search, fe.query = H.query, (!h.isNull(fe.pathname) || !h.isNull(fe.search)) && (fe.path = (fe.pathname ? fe.pathname : "") + (fe.search ? fe.search : "")), fe.href = fe.format(), fe;
      }
      if (!be.length)
        return fe.pathname = null, fe.search ? fe.path = "/" + fe.search : fe.path = null, fe.href = fe.format(), fe;
      for (var Ge = be.slice(-1)[0], je = (fe.host || H.host || be.length > 1) && (Ge === "." || Ge === "..") || Ge === "", Ne = 0, nt = be.length; nt >= 0; nt--)
        Ge = be[nt], Ge === "." ? be.splice(nt, 1) : Ge === ".." ? (be.splice(nt, 1), Ne++) : Ne && (be.splice(nt, 1), Ne--);
      if (!P && !Me)
        for (; Ne--; Ne)
          be.unshift("..");
      P && be[0] !== "" && (!be[0] || be[0].charAt(0) !== "/") && be.unshift(""), je && be.join("/").substr(-1) !== "/" && be.push("");
      var st = be[0] === "" || be[0] && be[0].charAt(0) === "/";
      if (le) {
        fe.hostname = fe.host = st ? "" : be.length ? be.shift() : "";
        var ge = fe.host && fe.host.indexOf("@") > 0 ? fe.host.split("@") : !1;
        ge && (fe.auth = ge.shift(), fe.host = fe.hostname = ge.shift());
      }
      return P = P || fe.host && be.length, P && !st && be.unshift(""), be.length ? fe.pathname = be.join("/") : (fe.pathname = null, fe.path = null), (!h.isNull(fe.pathname) || !h.isNull(fe.search)) && (fe.path = (fe.pathname ? fe.pathname : "") + (fe.search ? fe.search : "")), fe.auth = H.auth || fe.auth, fe.slashes = fe.slashes || H.slashes, fe.href = fe.format(), fe;
    }, M.prototype.parseHost = function() {
      var H = this.host, se = B.exec(H);
      se && (se = se[0], se !== ":" && (this.port = se.substr(1)), H = H.substr(0, H.length - se.length)), H && (this.hostname = H);
    };
    function S(H, se) {
      for (var fe = 0, _e = H.length - 1; _e >= 0; _e--) {
        var Ce = H[_e];
        Ce === "." ? H.splice(_e, 1) : Ce === ".." ? (H.splice(_e, 1), fe++) : fe && (H.splice(_e, 1), fe--);
      }
      if (se)
        for (; fe--; fe)
          H.unshift("..");
      return H;
    }
    function y() {
      for (var H = "", se = !1, fe = arguments.length - 1; fe >= -1 && !se; fe--) {
        var _e = fe >= 0 ? arguments[fe] : "/";
        if (typeof _e != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!_e)
          continue;
        H = _e + "/" + H, se = _e.charAt(0) === "/";
      }
      return H = S(_(H.split("/"), function(Ce) {
        return !!Ce;
      }), !se).join("/"), (se ? "/" : "") + H || ".";
    }
    function _(H, se) {
      if (H.filter)
        return H.filter(se);
      for (var fe = [], _e = 0; _e < H.length; _e++)
        se(H[_e], _e, H) && fe.push(H[_e]);
      return fe;
    }
    var l = function(H) {
      function se() {
        var _e = this || self;
        return delete H.prototype.__magic__, _e;
      }
      if (typeof globalThis == "object")
        return globalThis;
      if (this)
        return se();
      H.defineProperty(H.prototype, "__magic__", {
        configurable: !0,
        get: se
      });
      var fe = __magic__;
      return fe;
    }(Object), R = (
      /** @type {formatImport}*/
      m
    ), ee = (
      /** @type {parseImport}*/
      s
    ), oe = (
      /** @type {resolveImport}*/
      p
    ), V = (
      /** @type {UrlImport}*/
      E
    ), W = l.URL, F = l.URLSearchParams, re = /%/g, he = /\\/g, Z = /\n/g, K = /\r/g, ce = /\t/g, ve = 47;
    function Be(H) {
      var se = (
        /** @type {URL|null} */
        H ?? null
      );
      return !!(se !== null && (se != null && se.href) && (se != null && se.origin));
    }
    function te(H) {
      if (H.hostname !== "")
        throw new TypeError('File URL host must be "localhost" or empty on browser');
      for (var se = H.pathname, fe = 0; fe < se.length; fe++)
        if (se[fe] === "%") {
          var _e = se.codePointAt(fe + 2) | 32;
          if (se[fe + 1] === "2" && _e === 102)
            throw new TypeError("File URL path must not include encoded / characters");
        }
      return decodeURIComponent(se);
    }
    function C(H) {
      return H.includes("%") && (H = H.replace(re, "%25")), H.includes("\\") && (H = H.replace(he, "%5C")), H.includes(`
`) && (H = H.replace(Z, "%0A")), H.includes("\r") && (H = H.replace(K, "%0D")), H.includes("	") && (H = H.replace(ce, "%09")), H;
    }
    var L = (
      /**
       * @type {domainToASCII}
       */
      function(se) {
        if (typeof se > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new W("http://" + se).hostname;
      }
    ), G = (
      /**
       * @type {domainToUnicode}
       */
      function(se) {
        if (typeof se > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new W("http://" + se).hostname;
      }
    ), de = (
      /**
       * @type {(url: string) => URL}
       */
      function(se) {
        var fe = new W("file://"), _e = y(se), Ce = se.charCodeAt(se.length - 1);
        return Ce === ve && _e[_e.length - 1] !== "/" && (_e += "/"), fe.pathname = C(_e), fe;
      }
    ), me = (
      /**
       * @type {fileURLToPath & ((path: string | URL) => string)}
       */
      function(se) {
        if (!Be(se) && typeof se != "string")
          throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof se + " (" + se + ")");
        var fe = new W(se);
        if (fe.protocol !== "file:")
          throw new TypeError("The URL must be of scheme file");
        return te(fe);
      }
    ), Te = (
      /**
       * @type {(
       *   ((urlObject: URL, options?: URLFormatOptions) => string) &
       *   ((urlObject: UrlObject | string, options?: never) => string)
       * )}
       */
      function(se, fe) {
        var _e, Ce, Ve;
        if (fe === void 0 && (fe = {}), !(se instanceof W))
          return R(se);
        if (typeof fe != "object" || fe === null)
          throw new TypeError('The "options" argument must be of type object.');
        var ke = (_e = fe.auth) != null ? _e : !0, Q = (Ce = fe.fragment) != null ? Ce : !0, Se = (Ve = fe.search) != null ? Ve : !0, Ae = new W(se.toString());
        return ke || (Ae.username = "", Ae.password = ""), Q || (Ae.hash = ""), Se || (Ae.search = ""), Ae.toString();
      }
    ), He = {
      format: Te,
      parse: ee,
      resolve: oe,
      resolveObject: v,
      Url: V,
      URL: W,
      URLSearchParams: F,
      domainToASCII: L,
      domainToUnicode: G,
      pathToFileURL: de,
      fileURLToPath: me
    };
    t.URL = W, t.URLSearchParams = F, t.Url = V, t.default = He, t.domainToASCII = L, t.domainToUnicode = G, t.fileURLToPath = me, t.format = Te, t.parse = ee, t.pathToFileURL = de, t.resolve = oe, t.resolveObject = v, t = e.exports = He;
  }(Ka, Ka.exports)), Ka.exports;
}
var kd;
function ag() {
  return kd || (kd = 1, function(e) {
    var t = kx(), r = ig(), i = qx(), o = $x(), n = u0(), f = e;
    f.request = function(u, c) {
      typeof u == "string" ? u = n.parse(u) : u = i(u);
      var h = Ze.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", s = u.protocol || h, p = u.hostname || u.host, v = u.port, m = u.path || "/";
      p && p.indexOf(":") !== -1 && (p = "[" + p + "]"), u.url = (p ? s + "//" + p : "") + (v ? ":" + v : "") + m, u.method = (u.method || "GET").toUpperCase(), u.headers = u.headers || {};
      var E = new t(u);
      return c && E.on("response", c), E;
    }, f.get = function(c, h) {
      var s = f.request(c, h);
      return s.end(), s;
    }, f.ClientRequest = t, f.IncomingMessage = r.IncomingMessage, f.Agent = function() {
    }, f.Agent.defaultMaxSockets = 4, f.globalAgent = new f.Agent(), f.STATUS_CODES = o, f.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }(Hf)), Hf;
}
var Es = { exports: {} }, qd;
function zx() {
  return qd || (qd = 1, function(e) {
    var t = ag(), r = u0(), i = e.exports;
    for (var o in t)
      t.hasOwnProperty(o) && (i[o] = t[o]);
    i.request = function(f, u) {
      return f = n(f), t.request.call(this, f, u);
    }, i.get = function(f, u) {
      return f = n(f), t.get.call(this, f, u);
    };
    function n(f) {
      if (typeof f == "string" && (f = r.parse(f)), f.protocol || (f.protocol = "https:"), f.protocol !== "https:")
        throw new Error('Protocol "' + f.protocol + '" not supported. Expected "https:"');
      return f;
    }
  }(Es)), Es.exports;
}
var Ss = {}, As, $d;
function og() {
  if ($d)
    return As;
  $d = 1, As = r;
  var e = Di.EventEmitter, t = Et();
  t(r, e), r.Readable = f0(), r.Writable = o0(), r.Duplex = ni(), r.Transform = s0(), r.PassThrough = rg(), r.finished = sf(), r.pipeline = ng(), r.Stream = r;
  function r() {
    e.call(this);
  }
  return r.prototype.pipe = function(i, o) {
    var n = this;
    function f(m) {
      i.writable && i.write(m) === !1 && n.pause && n.pause();
    }
    n.on("data", f);
    function u() {
      n.readable && n.resume && n.resume();
    }
    i.on("drain", u), !i._isStdio && (!o || o.end !== !1) && (n.on("end", h), n.on("close", s));
    var c = !1;
    function h() {
      c || (c = !0, i.end());
    }
    function s() {
      c || (c = !0, typeof i.destroy == "function" && i.destroy());
    }
    function p(m) {
      if (v(), e.listenerCount(this, "error") === 0)
        throw m;
    }
    n.on("error", p), i.on("error", p);
    function v() {
      n.removeListener("data", f), i.removeListener("drain", u), n.removeListener("end", h), n.removeListener("close", s), n.removeListener("error", p), i.removeListener("error", p), n.removeListener("end", v), n.removeListener("close", v), i.removeListener("close", v);
    }
    return n.on("end", v), n.on("close", v), i.on("close", v), i.emit("pipe", n), i;
  }, As;
}
var Ms = {}, Rs = { exports: {} }, Bs = {}, Dd;
function fg() {
  if (Dd)
    return Bs;
  Dd = 1;
  function e(q) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
      return typeof D;
    } : function(D) {
      return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
    }, e(q);
  }
  function t(q, D) {
    for (var U = 0; U < D.length; U++) {
      var z = D[U];
      z.enumerable = z.enumerable || !1, z.configurable = !0, "value" in z && (z.writable = !0), Object.defineProperty(q, i(z.key), z);
    }
  }
  function r(q, D, U) {
    return D && t(q.prototype, D), U && t(q, U), Object.defineProperty(q, "prototype", { writable: !1 }), q;
  }
  function i(q) {
    var D = o(q, "string");
    return e(D) === "symbol" ? D : String(D);
  }
  function o(q, D) {
    if (e(q) !== "object" || q === null)
      return q;
    var U = q[Symbol.toPrimitive];
    if (U !== void 0) {
      var z = U.call(q, D || "default");
      if (e(z) !== "object")
        return z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (D === "string" ? String : Number)(q);
  }
  function n(q, D) {
    if (!(q instanceof D))
      throw new TypeError("Cannot call a class as a function");
  }
  function f(q, D) {
    if (typeof D != "function" && D !== null)
      throw new TypeError("Super expression must either be null or a function");
    q.prototype = Object.create(D && D.prototype, { constructor: { value: q, writable: !0, configurable: !0 } }), Object.defineProperty(q, "prototype", { writable: !1 }), D && u(q, D);
  }
  function u(q, D) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(z, Y) {
      return z.__proto__ = Y, z;
    }, u(q, D);
  }
  function c(q) {
    var D = p();
    return function() {
      var z = v(q), Y;
      if (D) {
        var ue = v(this).constructor;
        Y = Reflect.construct(z, arguments, ue);
      } else
        Y = z.apply(this, arguments);
      return h(this, Y);
    };
  }
  function h(q, D) {
    if (D && (e(D) === "object" || typeof D == "function"))
      return D;
    if (D !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return s(q);
  }
  function s(q) {
    if (q === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return q;
  }
  function p() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function v(q) {
    return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(U) {
      return U.__proto__ || Object.getPrototypeOf(U);
    }, v(q);
  }
  var m = {}, E, M;
  function I(q, D, U) {
    U || (U = Error);
    function z(ue, j, g) {
      return typeof D == "string" ? D : D(ue, j, g);
    }
    var Y = /* @__PURE__ */ function(ue) {
      f(g, ue);
      var j = c(g);
      function g(b, a, d) {
        var w;
        return n(this, g), w = j.call(this, z(b, a, d)), w.code = q, w;
      }
      return r(g);
    }(U);
    m[q] = Y;
  }
  function B(q, D) {
    if (Array.isArray(q)) {
      var U = q.length;
      return q = q.map(function(z) {
        return String(z);
      }), U > 2 ? "one of ".concat(D, " ").concat(q.slice(0, U - 1).join(", "), ", or ") + q[U - 1] : U === 2 ? "one of ".concat(D, " ").concat(q[0], " or ").concat(q[1]) : "of ".concat(D, " ").concat(q[0]);
    } else
      return "of ".concat(D, " ").concat(String(q));
  }
  function T(q, D, U) {
    return q.substr(!U || U < 0 ? 0 : +U, D.length) === D;
  }
  function k(q, D, U) {
    return (U === void 0 || U > q.length) && (U = q.length), q.substring(U - D.length, U) === D;
  }
  function N(q, D, U) {
    return typeof U != "number" && (U = 0), U + D.length > q.length ? !1 : q.indexOf(D, U) !== -1;
  }
  return I("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), I("ERR_INVALID_ARG_TYPE", function(q, D, U) {
    E === void 0 && (E = wo()), E(typeof q == "string", "'name' must be a string");
    var z;
    typeof D == "string" && T(D, "not ") ? (z = "must not be", D = D.replace(/^not /, "")) : z = "must be";
    var Y;
    if (k(q, " argument"))
      Y = "The ".concat(q, " ").concat(z, " ").concat(B(D, "type"));
    else {
      var ue = N(q, ".") ? "property" : "argument";
      Y = 'The "'.concat(q, '" ').concat(ue, " ").concat(z, " ").concat(B(D, "type"));
    }
    return Y += ". Received type ".concat(e(U)), Y;
  }, TypeError), I("ERR_INVALID_ARG_VALUE", function(q, D) {
    var U = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    M === void 0 && (M = _n());
    var z = M.inspect(D);
    return z.length > 128 && (z = "".concat(z.slice(0, 128), "...")), "The argument '".concat(q, "' ").concat(U, ". Received ").concat(z);
  }, TypeError), I("ERR_INVALID_RETURN_VALUE", function(q, D, U) {
    var z;
    return U && U.constructor && U.constructor.name ? z = "instance of ".concat(U.constructor.name) : z = "type ".concat(e(U)), "Expected ".concat(q, ' to be returned from the "').concat(D, '"') + " function but got ".concat(z, ".");
  }, TypeError), I("ERR_MISSING_ARGS", function() {
    for (var q = arguments.length, D = new Array(q), U = 0; U < q; U++)
      D[U] = arguments[U];
    E === void 0 && (E = wo()), E(D.length > 0, "At least one arg needs to be specified");
    var z = "The ", Y = D.length;
    switch (D = D.map(function(ue) {
      return '"'.concat(ue, '"');
    }), Y) {
      case 1:
        z += "".concat(D[0], " argument");
        break;
      case 2:
        z += "".concat(D[0], " and ").concat(D[1], " arguments");
        break;
      default:
        z += D.slice(0, Y - 1).join(", "), z += ", and ".concat(D[Y - 1], " arguments");
        break;
    }
    return "".concat(z, " must be specified");
  }, TypeError), Bs.codes = m, Bs;
}
var Is, jd;
function Vx() {
  if (jd)
    return Is;
  jd = 1;
  function e(S, y) {
    var _ = Object.keys(S);
    if (Object.getOwnPropertySymbols) {
      var l = Object.getOwnPropertySymbols(S);
      y && (l = l.filter(function(R) {
        return Object.getOwnPropertyDescriptor(S, R).enumerable;
      })), _.push.apply(_, l);
    }
    return _;
  }
  function t(S) {
    for (var y = 1; y < arguments.length; y++) {
      var _ = arguments[y] != null ? arguments[y] : {};
      y % 2 ? e(Object(_), !0).forEach(function(l) {
        r(S, l, _[l]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(_)) : e(Object(_)).forEach(function(l) {
        Object.defineProperty(S, l, Object.getOwnPropertyDescriptor(_, l));
      });
    }
    return S;
  }
  function r(S, y, _) {
    return y = f(y), y in S ? Object.defineProperty(S, y, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : S[y] = _, S;
  }
  function i(S, y) {
    if (!(S instanceof y))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(S, y) {
    for (var _ = 0; _ < y.length; _++) {
      var l = y[_];
      l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(S, f(l.key), l);
    }
  }
  function n(S, y, _) {
    return y && o(S.prototype, y), _ && o(S, _), Object.defineProperty(S, "prototype", { writable: !1 }), S;
  }
  function f(S) {
    var y = u(S, "string");
    return T(y) === "symbol" ? y : String(y);
  }
  function u(S, y) {
    if (T(S) !== "object" || S === null)
      return S;
    var _ = S[Symbol.toPrimitive];
    if (_ !== void 0) {
      var l = _.call(S, y || "default");
      if (T(l) !== "object")
        return l;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (y === "string" ? String : Number)(S);
  }
  function c(S, y) {
    if (typeof y != "function" && y !== null)
      throw new TypeError("Super expression must either be null or a function");
    S.prototype = Object.create(y && y.prototype, { constructor: { value: S, writable: !0, configurable: !0 } }), Object.defineProperty(S, "prototype", { writable: !1 }), y && I(S, y);
  }
  function h(S) {
    var y = E();
    return function() {
      var l = B(S), R;
      if (y) {
        var ee = B(this).constructor;
        R = Reflect.construct(l, arguments, ee);
      } else
        R = l.apply(this, arguments);
      return s(this, R);
    };
  }
  function s(S, y) {
    if (y && (T(y) === "object" || typeof y == "function"))
      return y;
    if (y !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return p(S);
  }
  function p(S) {
    if (S === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return S;
  }
  function v(S) {
    var y = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return v = function(l) {
      if (l === null || !M(l))
        return l;
      if (typeof l != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof y < "u") {
        if (y.has(l))
          return y.get(l);
        y.set(l, R);
      }
      function R() {
        return m(l, arguments, B(this).constructor);
      }
      return R.prototype = Object.create(l.prototype, { constructor: { value: R, enumerable: !1, writable: !0, configurable: !0 } }), I(R, l);
    }, v(S);
  }
  function m(S, y, _) {
    return E() ? m = Reflect.construct.bind() : m = function(R, ee, oe) {
      var V = [null];
      V.push.apply(V, ee);
      var W = Function.bind.apply(R, V), F = new W();
      return oe && I(F, oe.prototype), F;
    }, m.apply(null, arguments);
  }
  function E() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function M(S) {
    return Function.toString.call(S).indexOf("[native code]") !== -1;
  }
  function I(S, y) {
    return I = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, R) {
      return l.__proto__ = R, l;
    }, I(S, y);
  }
  function B(S) {
    return B = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(_) {
      return _.__proto__ || Object.getPrototypeOf(_);
    }, B(S);
  }
  function T(S) {
    "@babel/helpers - typeof";
    return T = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y) {
      return typeof y;
    } : function(y) {
      return y && typeof Symbol == "function" && y.constructor === Symbol && y !== Symbol.prototype ? "symbol" : typeof y;
    }, T(S);
  }
  var k = _n(), N = k.inspect, q = fg(), D = q.codes.ERR_INVALID_ARG_TYPE;
  function U(S, y, _) {
    return (_ === void 0 || _ > S.length) && (_ = S.length), S.substring(_ - y.length, _) === y;
  }
  function z(S, y) {
    if (y = Math.floor(y), S.length == 0 || y == 0)
      return "";
    var _ = S.length * y;
    for (y = Math.floor(Math.log(y) / Math.log(2)); y; )
      S += S, y--;
    return S += S.substring(0, _ - S.length), S;
  }
  var Y = "", ue = "", j = "", g = "", b = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, a = 10;
  function d(S) {
    var y = Object.keys(S), _ = Object.create(Object.getPrototypeOf(S));
    return y.forEach(function(l) {
      _[l] = S[l];
    }), Object.defineProperty(_, "message", {
      value: S.message
    }), _;
  }
  function w(S) {
    return N(S, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function x(S, y, _) {
    var l = "", R = "", ee = 0, oe = "", V = !1, W = w(S), F = W.split(`
`), re = w(y).split(`
`), he = 0, Z = "";
    if (_ === "strictEqual" && T(S) === "object" && T(y) === "object" && S !== null && y !== null && (_ = "strictEqualObject"), F.length === 1 && re.length === 1 && F[0] !== re[0]) {
      var K = F[0].length + re[0].length;
      if (K <= a) {
        if ((T(S) !== "object" || S === null) && (T(y) !== "object" || y === null) && (S !== 0 || y !== 0))
          return "".concat(b[_], `

`) + "".concat(F[0], " !== ").concat(re[0], `
`);
      } else if (_ !== "strictEqualObject") {
        var ce = at.stderr && at.stderr.isTTY ? at.stderr.columns : 80;
        if (K < ce) {
          for (; F[0][he] === re[0][he]; )
            he++;
          he > 2 && (Z = `
  `.concat(z(" ", he), "^"), he = 0);
        }
      }
    }
    for (var ve = F[F.length - 1], Be = re[re.length - 1]; ve === Be && (he++ < 2 ? oe = `
  `.concat(ve).concat(oe) : l = ve, F.pop(), re.pop(), !(F.length === 0 || re.length === 0)); )
      ve = F[F.length - 1], Be = re[re.length - 1];
    var te = Math.max(F.length, re.length);
    if (te === 0) {
      var C = W.split(`
`);
      if (C.length > 30)
        for (C[26] = "".concat(Y, "...").concat(g); C.length > 27; )
          C.pop();
      return "".concat(b.notIdentical, `

`).concat(C.join(`
`), `
`);
    }
    he > 3 && (oe = `
`.concat(Y, "...").concat(g).concat(oe), V = !0), l !== "" && (oe = `
  `.concat(l).concat(oe), l = "");
    var L = 0, G = b[_] + `
`.concat(ue, "+ actual").concat(g, " ").concat(j, "- expected").concat(g), de = " ".concat(Y, "...").concat(g, " Lines skipped");
    for (he = 0; he < te; he++) {
      var me = he - ee;
      if (F.length < he + 1)
        me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(Y, "...").concat(g), V = !0) : me > 3 && (R += `
  `.concat(re[he - 2]), L++), R += `
  `.concat(re[he - 1]), L++), ee = he, l += `
`.concat(j, "-").concat(g, " ").concat(re[he]), L++;
      else if (re.length < he + 1)
        me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(Y, "...").concat(g), V = !0) : me > 3 && (R += `
  `.concat(F[he - 2]), L++), R += `
  `.concat(F[he - 1]), L++), ee = he, R += `
`.concat(ue, "+").concat(g, " ").concat(F[he]), L++;
      else {
        var Te = re[he], He = F[he], H = He !== Te && (!U(He, ",") || He.slice(0, -1) !== Te);
        H && U(Te, ",") && Te.slice(0, -1) === He && (H = !1, He += ","), H ? (me > 1 && he > 2 && (me > 4 ? (R += `
`.concat(Y, "...").concat(g), V = !0) : me > 3 && (R += `
  `.concat(F[he - 2]), L++), R += `
  `.concat(F[he - 1]), L++), ee = he, R += `
`.concat(ue, "+").concat(g, " ").concat(He), l += `
`.concat(j, "-").concat(g, " ").concat(Te), L += 2) : (R += l, l = "", (me === 1 || he === 0) && (R += `
  `.concat(He), L++));
      }
      if (L > 20 && he < te - 2)
        return "".concat(G).concat(de, `
`).concat(R, `
`).concat(Y, "...").concat(g).concat(l, `
`) + "".concat(Y, "...").concat(g);
    }
    return "".concat(G).concat(V ? de : "", `
`).concat(R).concat(l).concat(oe).concat(Z);
  }
  var A = /* @__PURE__ */ function(S, y) {
    c(l, S);
    var _ = h(l);
    function l(R) {
      var ee;
      if (i(this, l), T(R) !== "object" || R === null)
        throw new D("options", "Object", R);
      var oe = R.message, V = R.operator, W = R.stackStartFn, F = R.actual, re = R.expected, he = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, oe != null)
        ee = _.call(this, String(oe));
      else if (at.stderr && at.stderr.isTTY && (at.stderr && at.stderr.getColorDepth && at.stderr.getColorDepth() !== 1 ? (Y = "\x1B[34m", ue = "\x1B[32m", g = "\x1B[39m", j = "\x1B[31m") : (Y = "", ue = "", g = "", j = "")), T(F) === "object" && F !== null && T(re) === "object" && re !== null && "stack" in F && F instanceof Error && "stack" in re && re instanceof Error && (F = d(F), re = d(re)), V === "deepStrictEqual" || V === "strictEqual")
        ee = _.call(this, x(F, re, V));
      else if (V === "notDeepStrictEqual" || V === "notStrictEqual") {
        var Z = b[V], K = w(F).split(`
`);
        if (V === "notStrictEqual" && T(F) === "object" && F !== null && (Z = b.notStrictEqualObject), K.length > 30)
          for (K[26] = "".concat(Y, "...").concat(g); K.length > 27; )
            K.pop();
        K.length === 1 ? ee = _.call(this, "".concat(Z, " ").concat(K[0])) : ee = _.call(this, "".concat(Z, `

`).concat(K.join(`
`), `
`));
      } else {
        var ce = w(F), ve = "", Be = b[V];
        V === "notDeepEqual" || V === "notEqual" ? (ce = "".concat(b[V], `

`).concat(ce), ce.length > 1024 && (ce = "".concat(ce.slice(0, 1021), "..."))) : (ve = "".concat(w(re)), ce.length > 512 && (ce = "".concat(ce.slice(0, 509), "...")), ve.length > 512 && (ve = "".concat(ve.slice(0, 509), "...")), V === "deepEqual" || V === "equal" ? ce = "".concat(Be, `

`).concat(ce, `

should equal

`) : ve = " ".concat(V, " ").concat(ve)), ee = _.call(this, "".concat(ce).concat(ve));
      }
      return Error.stackTraceLimit = he, ee.generatedMessage = !oe, Object.defineProperty(p(ee), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), ee.code = "ERR_ASSERTION", ee.actual = F, ee.expected = re, ee.operator = V, Error.captureStackTrace && Error.captureStackTrace(p(ee), W), ee.stack, ee.name = "AssertionError", s(ee);
    }
    return n(l, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: y,
      value: function(ee, oe) {
        return N(this, t(t({}, oe), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), l;
  }(/* @__PURE__ */ v(Error), N.custom);
  return Is = A, Is;
}
var Ts, Ud;
function Wx() {
  if (Ud)
    return Ts;
  Ud = 1;
  var e = jh, t = Fh(), r = Aa, i = Object, o = r("Array.prototype.push"), n = r("Object.prototype.propertyIsEnumerable"), f = t ? Object.getOwnPropertySymbols : null;
  return Ts = function(c, h) {
    if (c == null)
      throw new TypeError("target must be an object");
    var s = i(c);
    if (arguments.length === 1)
      return s;
    for (var p = 1; p < arguments.length; ++p) {
      var v = i(arguments[p]), m = e(v), E = t && (Object.getOwnPropertySymbols || f);
      if (E)
        for (var M = E(v), I = 0; I < M.length; ++I) {
          var B = M[I];
          n(v, B) && o(m, B);
        }
      for (var T = 0; T < m.length; ++T) {
        var k = m[T];
        if (n(v, k)) {
          var N = v[k];
          s[k] = N;
        }
      }
    }
    return s;
  }, Ts;
}
var Os, Fd;
function Kx() {
  if (Fd)
    return Os;
  Fd = 1;
  var e = Wx(), t = function() {
    if (!Object.assign)
      return !1;
    for (var i = "abcdefghijklmnopqrst", o = i.split(""), n = {}, f = 0; f < o.length; ++f)
      n[o[f]] = o[f];
    var u = Object.assign({}, n), c = "";
    for (var h in u)
      c += h;
    return i !== c;
  }, r = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var i = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(i, "xy");
    } catch {
      return i[1] === "y";
    }
    return !1;
  };
  return Os = function() {
    return !Object.assign || t() || r() ? e : Object.assign;
  }, Os;
}
var Ps, Hd;
function sg() {
  if (Hd)
    return Ps;
  Hd = 1;
  var e = function(t) {
    return t !== t;
  };
  return Ps = function(r, i) {
    return r === 0 && i === 0 ? 1 / r === 1 / i : !!(r === i || e(r) && e(i));
  }, Ps;
}
var Cs, zd;
function c0() {
  if (zd)
    return Cs;
  zd = 1;
  var e = sg();
  return Cs = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, Cs;
}
var Ns, Vd;
function cf() {
  if (Vd)
    return Ns;
  Vd = 1;
  var e = jh, t = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", r = Object.prototype.toString, i = Array.prototype.concat, o = Cb, n = function(h) {
    return typeof h == "function" && r.call(h) === "[object Function]";
  }, f = Hh(), u = function(h, s, p, v) {
    if (s in h) {
      if (v === !0) {
        if (h[s] === p)
          return;
      } else if (!n(v) || !v())
        return;
    }
    f ? o(h, s, p, !0) : o(h, s, p);
  }, c = function(h, s) {
    var p = arguments.length > 2 ? arguments[2] : {}, v = e(s);
    t && (v = i.call(v, Object.getOwnPropertySymbols(s)));
    for (var m = 0; m < v.length; m += 1)
      u(h, v[m], s[v[m]], p[v[m]]);
  };
  return c.supportsDescriptors = !!f, Ns = c, Ns;
}
var Ls, Wd;
function Zx() {
  if (Wd)
    return Ls;
  Wd = 1;
  var e = c0(), t = cf();
  return Ls = function() {
    var i = e();
    return t(Object, { is: i }, {
      is: function() {
        return Object.is !== i;
      }
    }), i;
  }, Ls;
}
var ks, Kd;
function Gx() {
  if (Kd)
    return ks;
  Kd = 1;
  var e = cf(), t = Sa, r = sg(), i = c0(), o = Zx(), n = t(i(), Object);
  return e(n, {
    getPolyfill: i,
    implementation: r,
    shim: o
  }), ks = n, ks;
}
var qs, Zd;
function ug() {
  return Zd || (Zd = 1, qs = function(t) {
    return t !== t;
  }), qs;
}
var $s, Gd;
function cg() {
  if (Gd)
    return $s;
  Gd = 1;
  var e = ug();
  return $s = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, $s;
}
var Ds, Jd;
function Jx() {
  if (Jd)
    return Ds;
  Jd = 1;
  var e = cf(), t = cg();
  return Ds = function() {
    var i = t();
    return e(Number, { isNaN: i }, {
      isNaN: function() {
        return Number.isNaN !== i;
      }
    }), i;
  }, Ds;
}
var js, Xd;
function Xx() {
  if (Xd)
    return js;
  Xd = 1;
  var e = Sa, t = cf(), r = ug(), i = cg(), o = Jx(), n = e(i(), Number);
  return t(n, {
    getPolyfill: i,
    implementation: r,
    shim: o
  }), js = n, js;
}
var Us, Yd;
function Yx() {
  if (Yd)
    return Us;
  Yd = 1;
  function e(H, se) {
    return n(H) || o(H, se) || r(H, se) || t();
  }
  function t() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function r(H, se) {
    if (H) {
      if (typeof H == "string")
        return i(H, se);
      var fe = Object.prototype.toString.call(H).slice(8, -1);
      if (fe === "Object" && H.constructor && (fe = H.constructor.name), fe === "Map" || fe === "Set")
        return Array.from(H);
      if (fe === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(fe))
        return i(H, se);
    }
  }
  function i(H, se) {
    (se == null || se > H.length) && (se = H.length);
    for (var fe = 0, _e = new Array(se); fe < se; fe++)
      _e[fe] = H[fe];
    return _e;
  }
  function o(H, se) {
    var fe = H == null ? null : typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
    if (fe != null) {
      var _e, Ce, Ve, ke, Q = [], Se = !0, Ae = !1;
      try {
        if (Ve = (fe = fe.call(H)).next, se === 0) {
          if (Object(fe) !== fe)
            return;
          Se = !1;
        } else
          for (; !(Se = (_e = Ve.call(fe)).done) && (Q.push(_e.value), Q.length !== se); Se = !0)
            ;
      } catch ($e) {
        Ae = !0, Ce = $e;
      } finally {
        try {
          if (!Se && fe.return != null && (ke = fe.return(), Object(ke) !== ke))
            return;
        } finally {
          if (Ae)
            throw Ce;
        }
      }
      return Q;
    }
  }
  function n(H) {
    if (Array.isArray(H))
      return H;
  }
  function f(H) {
    "@babel/helpers - typeof";
    return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(se) {
      return typeof se;
    } : function(se) {
      return se && typeof Symbol == "function" && se.constructor === Symbol && se !== Symbol.prototype ? "symbol" : typeof se;
    }, f(H);
  }
  var u = /a/g.flags !== void 0, c = function(se) {
    var fe = [];
    return se.forEach(function(_e) {
      return fe.push(_e);
    }), fe;
  }, h = function(se) {
    var fe = [];
    return se.forEach(function(_e, Ce) {
      return fe.push([Ce, _e]);
    }), fe;
  }, s = Object.is ? Object.is : Gx(), p = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, v = Number.isNaN ? Number.isNaN : Xx();
  function m(H) {
    return H.call.bind(H);
  }
  var E = m(Object.prototype.hasOwnProperty), M = m(Object.prototype.propertyIsEnumerable), I = m(Object.prototype.toString), B = _n().types, T = B.isAnyArrayBuffer, k = B.isArrayBufferView, N = B.isDate, q = B.isMap, D = B.isRegExp, U = B.isSet, z = B.isNativeError, Y = B.isBoxedPrimitive, ue = B.isNumberObject, j = B.isStringObject, g = B.isBooleanObject, b = B.isBigIntObject, a = B.isSymbolObject, d = B.isFloat32Array, w = B.isFloat64Array;
  function x(H) {
    if (H.length === 0 || H.length > 10)
      return !0;
    for (var se = 0; se < H.length; se++) {
      var fe = H.charCodeAt(se);
      if (fe < 48 || fe > 57)
        return !0;
    }
    return H.length === 10 && H >= Math.pow(2, 32);
  }
  function A(H) {
    return Object.keys(H).filter(x).concat(p(H).filter(Object.prototype.propertyIsEnumerable.bind(H)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function S(H, se) {
    if (H === se)
      return 0;
    for (var fe = H.length, _e = se.length, Ce = 0, Ve = Math.min(fe, _e); Ce < Ve; ++Ce)
      if (H[Ce] !== se[Ce]) {
        fe = H[Ce], _e = se[Ce];
        break;
      }
    return fe < _e ? -1 : _e < fe ? 1 : 0;
  }
  var y = !0, _ = !1, l = 0, R = 1, ee = 2, oe = 3;
  function V(H, se) {
    return u ? H.source === se.source && H.flags === se.flags : RegExp.prototype.toString.call(H) === RegExp.prototype.toString.call(se);
  }
  function W(H, se) {
    if (H.byteLength !== se.byteLength)
      return !1;
    for (var fe = 0; fe < H.byteLength; fe++)
      if (H[fe] !== se[fe])
        return !1;
    return !0;
  }
  function F(H, se) {
    return H.byteLength !== se.byteLength ? !1 : S(new Uint8Array(H.buffer, H.byteOffset, H.byteLength), new Uint8Array(se.buffer, se.byteOffset, se.byteLength)) === 0;
  }
  function re(H, se) {
    return H.byteLength === se.byteLength && S(new Uint8Array(H), new Uint8Array(se)) === 0;
  }
  function he(H, se) {
    return ue(H) ? ue(se) && s(Number.prototype.valueOf.call(H), Number.prototype.valueOf.call(se)) : j(H) ? j(se) && String.prototype.valueOf.call(H) === String.prototype.valueOf.call(se) : g(H) ? g(se) && Boolean.prototype.valueOf.call(H) === Boolean.prototype.valueOf.call(se) : b(H) ? b(se) && BigInt.prototype.valueOf.call(H) === BigInt.prototype.valueOf.call(se) : a(se) && Symbol.prototype.valueOf.call(H) === Symbol.prototype.valueOf.call(se);
  }
  function Z(H, se, fe, _e) {
    if (H === se)
      return H !== 0 ? !0 : fe ? s(H, se) : !0;
    if (fe) {
      if (f(H) !== "object")
        return typeof H == "number" && v(H) && v(se);
      if (f(se) !== "object" || H === null || se === null || Object.getPrototypeOf(H) !== Object.getPrototypeOf(se))
        return !1;
    } else {
      if (H === null || f(H) !== "object")
        return se === null || f(se) !== "object" ? H == se : !1;
      if (se === null || f(se) !== "object")
        return !1;
    }
    var Ce = I(H), Ve = I(se);
    if (Ce !== Ve)
      return !1;
    if (Array.isArray(H)) {
      if (H.length !== se.length)
        return !1;
      var ke = A(H), Q = A(se);
      return ke.length !== Q.length ? !1 : ce(H, se, fe, _e, R, ke);
    }
    if (Ce === "[object Object]" && (!q(H) && q(se) || !U(H) && U(se)))
      return !1;
    if (N(H)) {
      if (!N(se) || Date.prototype.getTime.call(H) !== Date.prototype.getTime.call(se))
        return !1;
    } else if (D(H)) {
      if (!D(se) || !V(H, se))
        return !1;
    } else if (z(H) || H instanceof Error) {
      if (H.message !== se.message || H.name !== se.name)
        return !1;
    } else if (k(H)) {
      if (!fe && (d(H) || w(H))) {
        if (!W(H, se))
          return !1;
      } else if (!F(H, se))
        return !1;
      var Se = A(H), Ae = A(se);
      return Se.length !== Ae.length ? !1 : ce(H, se, fe, _e, l, Se);
    } else {
      if (U(H))
        return !U(se) || H.size !== se.size ? !1 : ce(H, se, fe, _e, ee);
      if (q(H))
        return !q(se) || H.size !== se.size ? !1 : ce(H, se, fe, _e, oe);
      if (T(H)) {
        if (!re(H, se))
          return !1;
      } else if (Y(H) && !he(H, se))
        return !1;
    }
    return ce(H, se, fe, _e, l);
  }
  function K(H, se) {
    return se.filter(function(fe) {
      return M(H, fe);
    });
  }
  function ce(H, se, fe, _e, Ce, Ve) {
    if (arguments.length === 5) {
      Ve = Object.keys(H);
      var ke = Object.keys(se);
      if (Ve.length !== ke.length)
        return !1;
    }
    for (var Q = 0; Q < Ve.length; Q++)
      if (!E(se, Ve[Q]))
        return !1;
    if (fe && arguments.length === 5) {
      var Se = p(H);
      if (Se.length !== 0) {
        var Ae = 0;
        for (Q = 0; Q < Se.length; Q++) {
          var $e = Se[Q];
          if (M(H, $e)) {
            if (!M(se, $e))
              return !1;
            Ve.push($e), Ae++;
          } else if (M(se, $e))
            return !1;
        }
        var pe = p(se);
        if (Se.length !== pe.length && K(se, pe).length !== Ae)
          return !1;
      } else {
        var Ee = p(se);
        if (Ee.length !== 0 && K(se, Ee).length !== 0)
          return !1;
      }
    }
    if (Ve.length === 0 && (Ce === l || Ce === R && H.length === 0 || H.size === 0))
      return !0;
    if (_e === void 0)
      _e = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var J = _e.val1.get(H);
      if (J !== void 0) {
        var Ie = _e.val2.get(se);
        if (Ie !== void 0)
          return J === Ie;
      }
      _e.position++;
    }
    _e.val1.set(H, _e.position), _e.val2.set(se, _e.position);
    var qe = me(H, se, fe, Ve, _e, Ce);
    return _e.val1.delete(H), _e.val2.delete(se), qe;
  }
  function ve(H, se, fe, _e) {
    for (var Ce = c(H), Ve = 0; Ve < Ce.length; Ve++) {
      var ke = Ce[Ve];
      if (Z(se, ke, fe, _e))
        return H.delete(ke), !0;
    }
    return !1;
  }
  function Be(H) {
    switch (f(H)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        H = +H;
      case "number":
        if (v(H))
          return !1;
    }
    return !0;
  }
  function te(H, se, fe) {
    var _e = Be(fe);
    return _e ?? (se.has(_e) && !H.has(_e));
  }
  function C(H, se, fe, _e, Ce) {
    var Ve = Be(fe);
    if (Ve != null)
      return Ve;
    var ke = se.get(Ve);
    return ke === void 0 && !se.has(Ve) || !Z(_e, ke, !1, Ce) ? !1 : !H.has(Ve) && Z(_e, ke, !1, Ce);
  }
  function L(H, se, fe, _e) {
    for (var Ce = null, Ve = c(H), ke = 0; ke < Ve.length; ke++) {
      var Q = Ve[ke];
      if (f(Q) === "object" && Q !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Q);
      else if (!se.has(Q)) {
        if (fe || !te(H, se, Q))
          return !1;
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Q);
      }
    }
    if (Ce !== null) {
      for (var Se = c(se), Ae = 0; Ae < Se.length; Ae++) {
        var $e = Se[Ae];
        if (f($e) === "object" && $e !== null) {
          if (!ve(Ce, $e, fe, _e))
            return !1;
        } else if (!fe && !H.has($e) && !ve(Ce, $e, fe, _e))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function G(H, se, fe, _e, Ce, Ve) {
    for (var ke = c(H), Q = 0; Q < ke.length; Q++) {
      var Se = ke[Q];
      if (Z(fe, Se, Ce, Ve) && Z(_e, se.get(Se), Ce, Ve))
        return H.delete(Se), !0;
    }
    return !1;
  }
  function de(H, se, fe, _e) {
    for (var Ce = null, Ve = h(H), ke = 0; ke < Ve.length; ke++) {
      var Q = e(Ve[ke], 2), Se = Q[0], Ae = Q[1];
      if (f(Se) === "object" && Se !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Se);
      else {
        var $e = se.get(Se);
        if ($e === void 0 && !se.has(Se) || !Z(Ae, $e, fe, _e)) {
          if (fe || !C(H, se, Se, Ae, _e))
            return !1;
          Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Se);
        }
      }
    }
    if (Ce !== null) {
      for (var pe = h(se), Ee = 0; Ee < pe.length; Ee++) {
        var J = e(pe[Ee], 2), Ie = J[0], qe = J[1];
        if (f(Ie) === "object" && Ie !== null) {
          if (!G(Ce, H, Ie, qe, fe, _e))
            return !1;
        } else if (!fe && (!H.has(Ie) || !Z(H.get(Ie), qe, !1, _e)) && !G(Ce, H, Ie, qe, !1, _e))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function me(H, se, fe, _e, Ce, Ve) {
    var ke = 0;
    if (Ve === ee) {
      if (!L(H, se, fe, Ce))
        return !1;
    } else if (Ve === oe) {
      if (!de(H, se, fe, Ce))
        return !1;
    } else if (Ve === R)
      for (; ke < H.length; ke++)
        if (E(H, ke)) {
          if (!E(se, ke) || !Z(H[ke], se[ke], fe, Ce))
            return !1;
        } else {
          if (E(se, ke))
            return !1;
          for (var Q = Object.keys(H); ke < Q.length; ke++) {
            var Se = Q[ke];
            if (!E(se, Se) || !Z(H[Se], se[Se], fe, Ce))
              return !1;
          }
          return Q.length === Object.keys(se).length;
        }
    for (ke = 0; ke < _e.length; ke++) {
      var Ae = _e[ke];
      if (!Z(H[Ae], se[Ae], fe, Ce))
        return !1;
    }
    return !0;
  }
  function Te(H, se) {
    return Z(H, se, _);
  }
  function He(H, se) {
    return Z(H, se, y);
  }
  return Us = {
    isDeepEqual: Te,
    isDeepStrictEqual: He
  }, Us;
}
var Qd;
function wo() {
  if (Qd)
    return Rs.exports;
  Qd = 1;
  function e(W) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
      return typeof F;
    } : function(F) {
      return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
    }, e(W);
  }
  function t(W, F) {
    for (var re = 0; re < F.length; re++) {
      var he = F[re];
      he.enumerable = he.enumerable || !1, he.configurable = !0, "value" in he && (he.writable = !0), Object.defineProperty(W, i(he.key), he);
    }
  }
  function r(W, F, re) {
    return F && t(W.prototype, F), re && t(W, re), Object.defineProperty(W, "prototype", { writable: !1 }), W;
  }
  function i(W) {
    var F = o(W, "string");
    return e(F) === "symbol" ? F : String(F);
  }
  function o(W, F) {
    if (e(W) !== "object" || W === null)
      return W;
    var re = W[Symbol.toPrimitive];
    if (re !== void 0) {
      var he = re.call(W, F || "default");
      if (e(he) !== "object")
        return he;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (F === "string" ? String : Number)(W);
  }
  function n(W, F) {
    if (!(W instanceof F))
      throw new TypeError("Cannot call a class as a function");
  }
  var f = fg(), u = f.codes, c = u.ERR_AMBIGUOUS_ARGUMENT, h = u.ERR_INVALID_ARG_TYPE, s = u.ERR_INVALID_ARG_VALUE, p = u.ERR_INVALID_RETURN_VALUE, v = u.ERR_MISSING_ARGS, m = Vx(), E = _n(), M = E.inspect, I = _n().types, B = I.isPromise, T = I.isRegExp, k = Kx()(), N = c0()(), q = Aa("RegExp.prototype.test"), D, U;
  function z() {
    var W = Yx();
    D = W.isDeepEqual, U = W.isDeepStrictEqual;
  }
  var Y = !1, ue = Rs.exports = d, j = {};
  function g(W) {
    throw W.message instanceof Error ? W.message : new m(W);
  }
  function b(W, F, re, he, Z) {
    var K = arguments.length, ce;
    if (K === 0)
      ce = "Failed";
    else if (K === 1)
      re = W, W = void 0;
    else {
      if (Y === !1) {
        Y = !0;
        var ve = at.emitWarning ? at.emitWarning : console.warn.bind(console);
        ve("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      K === 2 && (he = "!=");
    }
    if (re instanceof Error)
      throw re;
    var Be = {
      actual: W,
      expected: F,
      operator: he === void 0 ? "fail" : he,
      stackStartFn: Z || b
    };
    re !== void 0 && (Be.message = re);
    var te = new m(Be);
    throw ce && (te.message = ce, te.generatedMessage = !0), te;
  }
  ue.fail = b, ue.AssertionError = m;
  function a(W, F, re, he) {
    if (!re) {
      var Z = !1;
      if (F === 0)
        Z = !0, he = "No value argument passed to `assert.ok()`";
      else if (he instanceof Error)
        throw he;
      var K = new m({
        actual: re,
        expected: !0,
        message: he,
        operator: "==",
        stackStartFn: W
      });
      throw K.generatedMessage = Z, K;
    }
  }
  function d() {
    for (var W = arguments.length, F = new Array(W), re = 0; re < W; re++)
      F[re] = arguments[re];
    a.apply(void 0, [d, F.length].concat(F));
  }
  ue.ok = d, ue.equal = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    F != re && g({
      actual: F,
      expected: re,
      message: he,
      operator: "==",
      stackStartFn: W
    });
  }, ue.notEqual = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    F == re && g({
      actual: F,
      expected: re,
      message: he,
      operator: "!=",
      stackStartFn: W
    });
  }, ue.deepEqual = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    D === void 0 && z(), D(F, re) || g({
      actual: F,
      expected: re,
      message: he,
      operator: "deepEqual",
      stackStartFn: W
    });
  }, ue.notDeepEqual = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    D === void 0 && z(), D(F, re) && g({
      actual: F,
      expected: re,
      message: he,
      operator: "notDeepEqual",
      stackStartFn: W
    });
  }, ue.deepStrictEqual = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    D === void 0 && z(), U(F, re) || g({
      actual: F,
      expected: re,
      message: he,
      operator: "deepStrictEqual",
      stackStartFn: W
    });
  }, ue.notDeepStrictEqual = w;
  function w(W, F, re) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    D === void 0 && z(), U(W, F) && g({
      actual: W,
      expected: F,
      message: re,
      operator: "notDeepStrictEqual",
      stackStartFn: w
    });
  }
  ue.strictEqual = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    N(F, re) || g({
      actual: F,
      expected: re,
      message: he,
      operator: "strictEqual",
      stackStartFn: W
    });
  }, ue.notStrictEqual = function W(F, re, he) {
    if (arguments.length < 2)
      throw new v("actual", "expected");
    N(F, re) && g({
      actual: F,
      expected: re,
      message: he,
      operator: "notStrictEqual",
      stackStartFn: W
    });
  };
  var x = /* @__PURE__ */ r(function W(F, re, he) {
    var Z = this;
    n(this, W), re.forEach(function(K) {
      K in F && (he !== void 0 && typeof he[K] == "string" && T(F[K]) && q(F[K], he[K]) ? Z[K] = he[K] : Z[K] = F[K]);
    });
  });
  function A(W, F, re, he, Z, K) {
    if (!(re in W) || !U(W[re], F[re])) {
      if (!he) {
        var ce = new x(W, Z), ve = new x(F, Z, W), Be = new m({
          actual: ce,
          expected: ve,
          operator: "deepStrictEqual",
          stackStartFn: K
        });
        throw Be.actual = W, Be.expected = F, Be.operator = K.name, Be;
      }
      g({
        actual: W,
        expected: F,
        message: he,
        operator: K.name,
        stackStartFn: K
      });
    }
  }
  function S(W, F, re, he) {
    if (typeof F != "function") {
      if (T(F))
        return q(F, W);
      if (arguments.length === 2)
        throw new h("expected", ["Function", "RegExp"], F);
      if (e(W) !== "object" || W === null) {
        var Z = new m({
          actual: W,
          expected: F,
          message: re,
          operator: "deepStrictEqual",
          stackStartFn: he
        });
        throw Z.operator = he.name, Z;
      }
      var K = Object.keys(F);
      if (F instanceof Error)
        K.push("name", "message");
      else if (K.length === 0)
        throw new s("error", F, "may not be an empty object");
      return D === void 0 && z(), K.forEach(function(ce) {
        typeof W[ce] == "string" && T(F[ce]) && q(F[ce], W[ce]) || A(W, F, ce, re, K, he);
      }), !0;
    }
    return F.prototype !== void 0 && W instanceof F ? !0 : Error.isPrototypeOf(F) ? !1 : F.call({}, W) === !0;
  }
  function y(W) {
    if (typeof W != "function")
      throw new h("fn", "Function", W);
    try {
      W();
    } catch (F) {
      return F;
    }
    return j;
  }
  function _(W) {
    return B(W) || W !== null && e(W) === "object" && typeof W.then == "function" && typeof W.catch == "function";
  }
  function l(W) {
    return Promise.resolve().then(function() {
      var F;
      if (typeof W == "function") {
        if (F = W(), !_(F))
          throw new p("instance of Promise", "promiseFn", F);
      } else if (_(W))
        F = W;
      else
        throw new h("promiseFn", ["Function", "Promise"], W);
      return Promise.resolve().then(function() {
        return F;
      }).then(function() {
        return j;
      }).catch(function(re) {
        return re;
      });
    });
  }
  function R(W, F, re, he) {
    if (typeof re == "string") {
      if (arguments.length === 4)
        throw new h("error", ["Object", "Error", "Function", "RegExp"], re);
      if (e(F) === "object" && F !== null) {
        if (F.message === re)
          throw new c("error/message", 'The error message "'.concat(F.message, '" is identical to the message.'));
      } else if (F === re)
        throw new c("error/message", 'The error "'.concat(F, '" is identical to the message.'));
      he = re, re = void 0;
    } else if (re != null && e(re) !== "object" && typeof re != "function")
      throw new h("error", ["Object", "Error", "Function", "RegExp"], re);
    if (F === j) {
      var Z = "";
      re && re.name && (Z += " (".concat(re.name, ")")), Z += he ? ": ".concat(he) : ".";
      var K = W.name === "rejects" ? "rejection" : "exception";
      g({
        actual: void 0,
        expected: re,
        operator: W.name,
        message: "Missing expected ".concat(K).concat(Z),
        stackStartFn: W
      });
    }
    if (re && !S(F, re, he, W))
      throw F;
  }
  function ee(W, F, re, he) {
    if (F !== j) {
      if (typeof re == "string" && (he = re, re = void 0), !re || S(F, re)) {
        var Z = he ? ": ".concat(he) : ".", K = W.name === "doesNotReject" ? "rejection" : "exception";
        g({
          actual: F,
          expected: re,
          operator: W.name,
          message: "Got unwanted ".concat(K).concat(Z, `
`) + 'Actual message: "'.concat(F && F.message, '"'),
          stackStartFn: W
        });
      }
      throw F;
    }
  }
  ue.throws = function W(F) {
    for (var re = arguments.length, he = new Array(re > 1 ? re - 1 : 0), Z = 1; Z < re; Z++)
      he[Z - 1] = arguments[Z];
    R.apply(void 0, [W, y(F)].concat(he));
  }, ue.rejects = function W(F) {
    for (var re = arguments.length, he = new Array(re > 1 ? re - 1 : 0), Z = 1; Z < re; Z++)
      he[Z - 1] = arguments[Z];
    return l(F).then(function(K) {
      return R.apply(void 0, [W, K].concat(he));
    });
  }, ue.doesNotThrow = function W(F) {
    for (var re = arguments.length, he = new Array(re > 1 ? re - 1 : 0), Z = 1; Z < re; Z++)
      he[Z - 1] = arguments[Z];
    ee.apply(void 0, [W, y(F)].concat(he));
  }, ue.doesNotReject = function W(F) {
    for (var re = arguments.length, he = new Array(re > 1 ? re - 1 : 0), Z = 1; Z < re; Z++)
      he[Z - 1] = arguments[Z];
    return l(F).then(function(K) {
      return ee.apply(void 0, [W, K].concat(he));
    });
  }, ue.ifError = function W(F) {
    if (F != null) {
      var re = "ifError got unwanted exception: ";
      e(F) === "object" && typeof F.message == "string" ? F.message.length === 0 && F.constructor ? re += F.constructor.name : re += F.message : re += M(F);
      var he = new m({
        actual: F,
        expected: null,
        operator: "ifError",
        message: re,
        stackStartFn: W
      }), Z = F.stack;
      if (typeof Z == "string") {
        var K = Z.split(`
`);
        K.shift();
        for (var ce = he.stack.split(`
`), ve = 0; ve < K.length; ve++) {
          var Be = ce.indexOf(K[ve]);
          if (Be !== -1) {
            ce = ce.slice(0, Be);
            break;
          }
        }
        he.stack = "".concat(ce.join(`
`), `
`).concat(K.join(`
`));
      }
      throw he;
    }
  };
  function oe(W, F, re, he, Z) {
    if (!T(F))
      throw new h("regexp", "RegExp", F);
    var K = Z === "match";
    if (typeof W != "string" || q(F, W) !== K) {
      if (re instanceof Error)
        throw re;
      var ce = !re;
      re = re || (typeof W != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(W), " (").concat(M(W), ")") : (K ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(M(F), `. Input:

`).concat(M(W), `
`));
      var ve = new m({
        actual: W,
        expected: F,
        message: re,
        operator: Z,
        stackStartFn: he
      });
      throw ve.generatedMessage = ce, ve;
    }
  }
  ue.match = function W(F, re, he) {
    oe(F, re, he, W, "match");
  }, ue.doesNotMatch = function W(F, re, he) {
    oe(F, re, he, W, "doesNotMatch");
  };
  function V() {
    for (var W = arguments.length, F = new Array(W), re = 0; re < W; re++)
      F[re] = arguments[re];
    a.apply(void 0, [V, F.length].concat(F));
  }
  return ue.strict = k(V, ue, {
    equal: ue.strictEqual,
    deepEqual: ue.deepStrictEqual,
    notEqual: ue.notStrictEqual,
    notDeepEqual: ue.notDeepStrictEqual
  }), ue.strict.strict = ue.strict, Rs.exports;
}
var Fs, e1;
function Qx() {
  if (e1)
    return Fs;
  e1 = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return Fs = e, Fs;
}
var Wr = {}, Hs = {}, t1;
function hf() {
  return t1 || (t1 = 1, function(e) {
    var t = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function r(n, f) {
      return Object.prototype.hasOwnProperty.call(n, f);
    }
    e.assign = function(n) {
      for (var f = Array.prototype.slice.call(arguments, 1); f.length; ) {
        var u = f.shift();
        if (u) {
          if (typeof u != "object")
            throw new TypeError(u + "must be non-object");
          for (var c in u)
            r(u, c) && (n[c] = u[c]);
        }
      }
      return n;
    }, e.shrinkBuf = function(n, f) {
      return n.length === f ? n : n.subarray ? n.subarray(0, f) : (n.length = f, n);
    };
    var i = {
      arraySet: function(n, f, u, c, h) {
        if (f.subarray && n.subarray) {
          n.set(f.subarray(u, u + c), h);
          return;
        }
        for (var s = 0; s < c; s++)
          n[h + s] = f[u + s];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        var f, u, c, h, s, p;
        for (c = 0, f = 0, u = n.length; f < u; f++)
          c += n[f].length;
        for (p = new Uint8Array(c), h = 0, f = 0, u = n.length; f < u; f++)
          s = n[f], p.set(s, h), h += s.length;
        return p;
      }
    }, o = {
      arraySet: function(n, f, u, c, h) {
        for (var s = 0; s < c; s++)
          n[h + s] = f[u + s];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        return [].concat.apply([], n);
      }
    };
    e.setTyped = function(n) {
      n ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, o));
    }, e.setTyped(t);
  }(Hs)), Hs;
}
var $n = {}, r1;
function eE() {
  if (r1)
    return $n;
  r1 = 1;
  var e = hf(), t = 4, r = 0, i = 1, o = 2;
  function n(Q) {
    for (var Se = Q.length; --Se >= 0; )
      Q[Se] = 0;
  }
  var f = 0, u = 1, c = 2, h = 3, s = 258, p = 29, v = 256, m = v + 1 + p, E = 30, M = 19, I = 2 * m + 1, B = 15, T = 16, k = 7, N = 256, q = 16, D = 17, U = 18, z = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), Y = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), ue = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], g = 512, b = new Array((m + 2) * 2);
  n(b);
  var a = new Array(E * 2);
  n(a);
  var d = new Array(g);
  n(d);
  var w = new Array(s - h + 1);
  n(w);
  var x = new Array(p);
  n(x);
  var A = new Array(E);
  n(A);
  function S(Q, Se, Ae, $e, pe) {
    this.static_tree = Q, this.extra_bits = Se, this.extra_base = Ae, this.elems = $e, this.max_length = pe, this.has_stree = Q && Q.length;
  }
  var y, _, l;
  function R(Q, Se) {
    this.dyn_tree = Q, this.max_code = 0, this.stat_desc = Se;
  }
  function ee(Q) {
    return Q < 256 ? d[Q] : d[256 + (Q >>> 7)];
  }
  function oe(Q, Se) {
    Q.pending_buf[Q.pending++] = Se & 255, Q.pending_buf[Q.pending++] = Se >>> 8 & 255;
  }
  function V(Q, Se, Ae) {
    Q.bi_valid > T - Ae ? (Q.bi_buf |= Se << Q.bi_valid & 65535, oe(Q, Q.bi_buf), Q.bi_buf = Se >> T - Q.bi_valid, Q.bi_valid += Ae - T) : (Q.bi_buf |= Se << Q.bi_valid & 65535, Q.bi_valid += Ae);
  }
  function W(Q, Se, Ae) {
    V(
      Q,
      Ae[Se * 2],
      Ae[Se * 2 + 1]
      /*.Len*/
    );
  }
  function F(Q, Se) {
    var Ae = 0;
    do
      Ae |= Q & 1, Q >>>= 1, Ae <<= 1;
    while (--Se > 0);
    return Ae >>> 1;
  }
  function re(Q) {
    Q.bi_valid === 16 ? (oe(Q, Q.bi_buf), Q.bi_buf = 0, Q.bi_valid = 0) : Q.bi_valid >= 8 && (Q.pending_buf[Q.pending++] = Q.bi_buf & 255, Q.bi_buf >>= 8, Q.bi_valid -= 8);
  }
  function he(Q, Se) {
    var Ae = Se.dyn_tree, $e = Se.max_code, pe = Se.stat_desc.static_tree, Ee = Se.stat_desc.has_stree, J = Se.stat_desc.extra_bits, Ie = Se.stat_desc.extra_base, qe = Se.stat_desc.max_length, P, Me, be, ie, le, ge, Ge = 0;
    for (ie = 0; ie <= B; ie++)
      Q.bl_count[ie] = 0;
    for (Ae[Q.heap[Q.heap_max] * 2 + 1] = 0, P = Q.heap_max + 1; P < I; P++)
      Me = Q.heap[P], ie = Ae[Ae[Me * 2 + 1] * 2 + 1] + 1, ie > qe && (ie = qe, Ge++), Ae[Me * 2 + 1] = ie, !(Me > $e) && (Q.bl_count[ie]++, le = 0, Me >= Ie && (le = J[Me - Ie]), ge = Ae[Me * 2], Q.opt_len += ge * (ie + le), Ee && (Q.static_len += ge * (pe[Me * 2 + 1] + le)));
    if (Ge !== 0) {
      do {
        for (ie = qe - 1; Q.bl_count[ie] === 0; )
          ie--;
        Q.bl_count[ie]--, Q.bl_count[ie + 1] += 2, Q.bl_count[qe]--, Ge -= 2;
      } while (Ge > 0);
      for (ie = qe; ie !== 0; ie--)
        for (Me = Q.bl_count[ie]; Me !== 0; )
          be = Q.heap[--P], !(be > $e) && (Ae[be * 2 + 1] !== ie && (Q.opt_len += (ie - Ae[be * 2 + 1]) * Ae[be * 2], Ae[be * 2 + 1] = ie), Me--);
    }
  }
  function Z(Q, Se, Ae) {
    var $e = new Array(B + 1), pe = 0, Ee, J;
    for (Ee = 1; Ee <= B; Ee++)
      $e[Ee] = pe = pe + Ae[Ee - 1] << 1;
    for (J = 0; J <= Se; J++) {
      var Ie = Q[J * 2 + 1];
      Ie !== 0 && (Q[J * 2] = F($e[Ie]++, Ie));
    }
  }
  function K() {
    var Q, Se, Ae, $e, pe, Ee = new Array(B + 1);
    for (Ae = 0, $e = 0; $e < p - 1; $e++)
      for (x[$e] = Ae, Q = 0; Q < 1 << z[$e]; Q++)
        w[Ae++] = $e;
    for (w[Ae - 1] = $e, pe = 0, $e = 0; $e < 16; $e++)
      for (A[$e] = pe, Q = 0; Q < 1 << Y[$e]; Q++)
        d[pe++] = $e;
    for (pe >>= 7; $e < E; $e++)
      for (A[$e] = pe << 7, Q = 0; Q < 1 << Y[$e] - 7; Q++)
        d[256 + pe++] = $e;
    for (Se = 0; Se <= B; Se++)
      Ee[Se] = 0;
    for (Q = 0; Q <= 143; )
      b[Q * 2 + 1] = 8, Q++, Ee[8]++;
    for (; Q <= 255; )
      b[Q * 2 + 1] = 9, Q++, Ee[9]++;
    for (; Q <= 279; )
      b[Q * 2 + 1] = 7, Q++, Ee[7]++;
    for (; Q <= 287; )
      b[Q * 2 + 1] = 8, Q++, Ee[8]++;
    for (Z(b, m + 1, Ee), Q = 0; Q < E; Q++)
      a[Q * 2 + 1] = 5, a[Q * 2] = F(Q, 5);
    y = new S(b, z, v + 1, m, B), _ = new S(a, Y, 0, E, B), l = new S(new Array(0), ue, 0, M, k);
  }
  function ce(Q) {
    var Se;
    for (Se = 0; Se < m; Se++)
      Q.dyn_ltree[Se * 2] = 0;
    for (Se = 0; Se < E; Se++)
      Q.dyn_dtree[Se * 2] = 0;
    for (Se = 0; Se < M; Se++)
      Q.bl_tree[Se * 2] = 0;
    Q.dyn_ltree[N * 2] = 1, Q.opt_len = Q.static_len = 0, Q.last_lit = Q.matches = 0;
  }
  function ve(Q) {
    Q.bi_valid > 8 ? oe(Q, Q.bi_buf) : Q.bi_valid > 0 && (Q.pending_buf[Q.pending++] = Q.bi_buf), Q.bi_buf = 0, Q.bi_valid = 0;
  }
  function Be(Q, Se, Ae, $e) {
    ve(Q), $e && (oe(Q, Ae), oe(Q, ~Ae)), e.arraySet(Q.pending_buf, Q.window, Se, Ae, Q.pending), Q.pending += Ae;
  }
  function te(Q, Se, Ae, $e) {
    var pe = Se * 2, Ee = Ae * 2;
    return Q[pe] < Q[Ee] || Q[pe] === Q[Ee] && $e[Se] <= $e[Ae];
  }
  function C(Q, Se, Ae) {
    for (var $e = Q.heap[Ae], pe = Ae << 1; pe <= Q.heap_len && (pe < Q.heap_len && te(Se, Q.heap[pe + 1], Q.heap[pe], Q.depth) && pe++, !te(Se, $e, Q.heap[pe], Q.depth)); )
      Q.heap[Ae] = Q.heap[pe], Ae = pe, pe <<= 1;
    Q.heap[Ae] = $e;
  }
  function L(Q, Se, Ae) {
    var $e, pe, Ee = 0, J, Ie;
    if (Q.last_lit !== 0)
      do
        $e = Q.pending_buf[Q.d_buf + Ee * 2] << 8 | Q.pending_buf[Q.d_buf + Ee * 2 + 1], pe = Q.pending_buf[Q.l_buf + Ee], Ee++, $e === 0 ? W(Q, pe, Se) : (J = w[pe], W(Q, J + v + 1, Se), Ie = z[J], Ie !== 0 && (pe -= x[J], V(Q, pe, Ie)), $e--, J = ee($e), W(Q, J, Ae), Ie = Y[J], Ie !== 0 && ($e -= A[J], V(Q, $e, Ie)));
      while (Ee < Q.last_lit);
    W(Q, N, Se);
  }
  function G(Q, Se) {
    var Ae = Se.dyn_tree, $e = Se.stat_desc.static_tree, pe = Se.stat_desc.has_stree, Ee = Se.stat_desc.elems, J, Ie, qe = -1, P;
    for (Q.heap_len = 0, Q.heap_max = I, J = 0; J < Ee; J++)
      Ae[J * 2] !== 0 ? (Q.heap[++Q.heap_len] = qe = J, Q.depth[J] = 0) : Ae[J * 2 + 1] = 0;
    for (; Q.heap_len < 2; )
      P = Q.heap[++Q.heap_len] = qe < 2 ? ++qe : 0, Ae[P * 2] = 1, Q.depth[P] = 0, Q.opt_len--, pe && (Q.static_len -= $e[P * 2 + 1]);
    for (Se.max_code = qe, J = Q.heap_len >> 1; J >= 1; J--)
      C(Q, Ae, J);
    P = Ee;
    do
      J = Q.heap[
        1
        /*SMALLEST*/
      ], Q.heap[
        1
        /*SMALLEST*/
      ] = Q.heap[Q.heap_len--], C(
        Q,
        Ae,
        1
        /*SMALLEST*/
      ), Ie = Q.heap[
        1
        /*SMALLEST*/
      ], Q.heap[--Q.heap_max] = J, Q.heap[--Q.heap_max] = Ie, Ae[P * 2] = Ae[J * 2] + Ae[Ie * 2], Q.depth[P] = (Q.depth[J] >= Q.depth[Ie] ? Q.depth[J] : Q.depth[Ie]) + 1, Ae[J * 2 + 1] = Ae[Ie * 2 + 1] = P, Q.heap[
        1
        /*SMALLEST*/
      ] = P++, C(
        Q,
        Ae,
        1
        /*SMALLEST*/
      );
    while (Q.heap_len >= 2);
    Q.heap[--Q.heap_max] = Q.heap[
      1
      /*SMALLEST*/
    ], he(Q, Se), Z(Ae, qe, Q.bl_count);
  }
  function de(Q, Se, Ae) {
    var $e, pe = -1, Ee, J = Se[0 * 2 + 1], Ie = 0, qe = 7, P = 4;
    for (J === 0 && (qe = 138, P = 3), Se[(Ae + 1) * 2 + 1] = 65535, $e = 0; $e <= Ae; $e++)
      Ee = J, J = Se[($e + 1) * 2 + 1], !(++Ie < qe && Ee === J) && (Ie < P ? Q.bl_tree[Ee * 2] += Ie : Ee !== 0 ? (Ee !== pe && Q.bl_tree[Ee * 2]++, Q.bl_tree[q * 2]++) : Ie <= 10 ? Q.bl_tree[D * 2]++ : Q.bl_tree[U * 2]++, Ie = 0, pe = Ee, J === 0 ? (qe = 138, P = 3) : Ee === J ? (qe = 6, P = 3) : (qe = 7, P = 4));
  }
  function me(Q, Se, Ae) {
    var $e, pe = -1, Ee, J = Se[0 * 2 + 1], Ie = 0, qe = 7, P = 4;
    for (J === 0 && (qe = 138, P = 3), $e = 0; $e <= Ae; $e++)
      if (Ee = J, J = Se[($e + 1) * 2 + 1], !(++Ie < qe && Ee === J)) {
        if (Ie < P)
          do
            W(Q, Ee, Q.bl_tree);
          while (--Ie !== 0);
        else
          Ee !== 0 ? (Ee !== pe && (W(Q, Ee, Q.bl_tree), Ie--), W(Q, q, Q.bl_tree), V(Q, Ie - 3, 2)) : Ie <= 10 ? (W(Q, D, Q.bl_tree), V(Q, Ie - 3, 3)) : (W(Q, U, Q.bl_tree), V(Q, Ie - 11, 7));
        Ie = 0, pe = Ee, J === 0 ? (qe = 138, P = 3) : Ee === J ? (qe = 6, P = 3) : (qe = 7, P = 4);
      }
  }
  function Te(Q) {
    var Se;
    for (de(Q, Q.dyn_ltree, Q.l_desc.max_code), de(Q, Q.dyn_dtree, Q.d_desc.max_code), G(Q, Q.bl_desc), Se = M - 1; Se >= 3 && Q.bl_tree[j[Se] * 2 + 1] === 0; Se--)
      ;
    return Q.opt_len += 3 * (Se + 1) + 5 + 5 + 4, Se;
  }
  function He(Q, Se, Ae, $e) {
    var pe;
    for (V(Q, Se - 257, 5), V(Q, Ae - 1, 5), V(Q, $e - 4, 4), pe = 0; pe < $e; pe++)
      V(Q, Q.bl_tree[j[pe] * 2 + 1], 3);
    me(Q, Q.dyn_ltree, Se - 1), me(Q, Q.dyn_dtree, Ae - 1);
  }
  function H(Q) {
    var Se = 4093624447, Ae;
    for (Ae = 0; Ae <= 31; Ae++, Se >>>= 1)
      if (Se & 1 && Q.dyn_ltree[Ae * 2] !== 0)
        return r;
    if (Q.dyn_ltree[9 * 2] !== 0 || Q.dyn_ltree[10 * 2] !== 0 || Q.dyn_ltree[13 * 2] !== 0)
      return i;
    for (Ae = 32; Ae < v; Ae++)
      if (Q.dyn_ltree[Ae * 2] !== 0)
        return i;
    return r;
  }
  var se = !1;
  function fe(Q) {
    se || (K(), se = !0), Q.l_desc = new R(Q.dyn_ltree, y), Q.d_desc = new R(Q.dyn_dtree, _), Q.bl_desc = new R(Q.bl_tree, l), Q.bi_buf = 0, Q.bi_valid = 0, ce(Q);
  }
  function _e(Q, Se, Ae, $e) {
    V(Q, (f << 1) + ($e ? 1 : 0), 3), Be(Q, Se, Ae, !0);
  }
  function Ce(Q) {
    V(Q, u << 1, 3), W(Q, N, b), re(Q);
  }
  function Ve(Q, Se, Ae, $e) {
    var pe, Ee, J = 0;
    Q.level > 0 ? (Q.strm.data_type === o && (Q.strm.data_type = H(Q)), G(Q, Q.l_desc), G(Q, Q.d_desc), J = Te(Q), pe = Q.opt_len + 3 + 7 >>> 3, Ee = Q.static_len + 3 + 7 >>> 3, Ee <= pe && (pe = Ee)) : pe = Ee = Ae + 5, Ae + 4 <= pe && Se !== -1 ? _e(Q, Se, Ae, $e) : Q.strategy === t || Ee === pe ? (V(Q, (u << 1) + ($e ? 1 : 0), 3), L(Q, b, a)) : (V(Q, (c << 1) + ($e ? 1 : 0), 3), He(Q, Q.l_desc.max_code + 1, Q.d_desc.max_code + 1, J + 1), L(Q, Q.dyn_ltree, Q.dyn_dtree)), ce(Q), $e && ve(Q);
  }
  function ke(Q, Se, Ae) {
    return Q.pending_buf[Q.d_buf + Q.last_lit * 2] = Se >>> 8 & 255, Q.pending_buf[Q.d_buf + Q.last_lit * 2 + 1] = Se & 255, Q.pending_buf[Q.l_buf + Q.last_lit] = Ae & 255, Q.last_lit++, Se === 0 ? Q.dyn_ltree[Ae * 2]++ : (Q.matches++, Se--, Q.dyn_ltree[(w[Ae] + v + 1) * 2]++, Q.dyn_dtree[ee(Se) * 2]++), Q.last_lit === Q.lit_bufsize - 1;
  }
  return $n._tr_init = fe, $n._tr_stored_block = _e, $n._tr_flush_block = Ve, $n._tr_tally = ke, $n._tr_align = Ce, $n;
}
var zs, n1;
function hg() {
  if (n1)
    return zs;
  n1 = 1;
  function e(t, r, i, o) {
    for (var n = t & 65535 | 0, f = t >>> 16 & 65535 | 0, u = 0; i !== 0; ) {
      u = i > 2e3 ? 2e3 : i, i -= u;
      do
        n = n + r[o++] | 0, f = f + n | 0;
      while (--u);
      n %= 65521, f %= 65521;
    }
    return n | f << 16 | 0;
  }
  return zs = e, zs;
}
var Vs, i1;
function lg() {
  if (i1)
    return Vs;
  i1 = 1;
  function e() {
    for (var i, o = [], n = 0; n < 256; n++) {
      i = n;
      for (var f = 0; f < 8; f++)
        i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
      o[n] = i;
    }
    return o;
  }
  var t = e();
  function r(i, o, n, f) {
    var u = t, c = f + n;
    i ^= -1;
    for (var h = f; h < c; h++)
      i = i >>> 8 ^ u[(i ^ o[h]) & 255];
    return i ^ -1;
  }
  return Vs = r, Vs;
}
var Ws, a1;
function tE() {
  return a1 || (a1 = 1, Ws = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), Ws;
}
var o1;
function rE() {
  if (o1)
    return Wr;
  o1 = 1;
  var e = hf(), t = eE(), r = hg(), i = lg(), o = tE(), n = 0, f = 1, u = 3, c = 4, h = 5, s = 0, p = 1, v = -2, m = -3, E = -5, M = -1, I = 1, B = 2, T = 3, k = 4, N = 0, q = 2, D = 8, U = 9, z = 15, Y = 8, ue = 29, j = 256, g = j + 1 + ue, b = 30, a = 19, d = 2 * g + 1, w = 15, x = 3, A = 258, S = A + x + 1, y = 32, _ = 42, l = 69, R = 73, ee = 91, oe = 103, V = 113, W = 666, F = 1, re = 2, he = 3, Z = 4, K = 3;
  function ce(P, Me) {
    return P.msg = o[Me], Me;
  }
  function ve(P) {
    return (P << 1) - (P > 4 ? 9 : 0);
  }
  function Be(P) {
    for (var Me = P.length; --Me >= 0; )
      P[Me] = 0;
  }
  function te(P) {
    var Me = P.state, be = Me.pending;
    be > P.avail_out && (be = P.avail_out), be !== 0 && (e.arraySet(P.output, Me.pending_buf, Me.pending_out, be, P.next_out), P.next_out += be, Me.pending_out += be, P.total_out += be, P.avail_out -= be, Me.pending -= be, Me.pending === 0 && (Me.pending_out = 0));
  }
  function C(P, Me) {
    t._tr_flush_block(P, P.block_start >= 0 ? P.block_start : -1, P.strstart - P.block_start, Me), P.block_start = P.strstart, te(P.strm);
  }
  function L(P, Me) {
    P.pending_buf[P.pending++] = Me;
  }
  function G(P, Me) {
    P.pending_buf[P.pending++] = Me >>> 8 & 255, P.pending_buf[P.pending++] = Me & 255;
  }
  function de(P, Me, be, ie) {
    var le = P.avail_in;
    return le > ie && (le = ie), le === 0 ? 0 : (P.avail_in -= le, e.arraySet(Me, P.input, P.next_in, le, be), P.state.wrap === 1 ? P.adler = r(P.adler, Me, le, be) : P.state.wrap === 2 && (P.adler = i(P.adler, Me, le, be)), P.next_in += le, P.total_in += le, le);
  }
  function me(P, Me) {
    var be = P.max_chain_length, ie = P.strstart, le, ge, Ge = P.prev_length, je = P.nice_match, Ne = P.strstart > P.w_size - S ? P.strstart - (P.w_size - S) : 0, nt = P.window, st = P.w_mask, Je = P.prev, ft = P.strstart + A, $ = nt[ie + Ge - 1], X = nt[ie + Ge];
    P.prev_length >= P.good_match && (be >>= 2), je > P.lookahead && (je = P.lookahead);
    do
      if (le = Me, !(nt[le + Ge] !== X || nt[le + Ge - 1] !== $ || nt[le] !== nt[ie] || nt[++le] !== nt[ie + 1])) {
        ie += 2, le++;
        do
          ;
        while (nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && nt[++ie] === nt[++le] && ie < ft);
        if (ge = A - (ft - ie), ie = ft - A, ge > Ge) {
          if (P.match_start = Me, Ge = ge, ge >= je)
            break;
          $ = nt[ie + Ge - 1], X = nt[ie + Ge];
        }
      }
    while ((Me = Je[Me & st]) > Ne && --be !== 0);
    return Ge <= P.lookahead ? Ge : P.lookahead;
  }
  function Te(P) {
    var Me = P.w_size, be, ie, le, ge, Ge;
    do {
      if (ge = P.window_size - P.lookahead - P.strstart, P.strstart >= Me + (Me - S)) {
        e.arraySet(P.window, P.window, Me, Me, 0), P.match_start -= Me, P.strstart -= Me, P.block_start -= Me, ie = P.hash_size, be = ie;
        do
          le = P.head[--be], P.head[be] = le >= Me ? le - Me : 0;
        while (--ie);
        ie = Me, be = ie;
        do
          le = P.prev[--be], P.prev[be] = le >= Me ? le - Me : 0;
        while (--ie);
        ge += Me;
      }
      if (P.strm.avail_in === 0)
        break;
      if (ie = de(P.strm, P.window, P.strstart + P.lookahead, ge), P.lookahead += ie, P.lookahead + P.insert >= x)
        for (Ge = P.strstart - P.insert, P.ins_h = P.window[Ge], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Ge + 1]) & P.hash_mask; P.insert && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Ge + x - 1]) & P.hash_mask, P.prev[Ge & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = Ge, Ge++, P.insert--, !(P.lookahead + P.insert < x)); )
          ;
    } while (P.lookahead < S && P.strm.avail_in !== 0);
  }
  function He(P, Me) {
    var be = 65535;
    for (be > P.pending_buf_size - 5 && (be = P.pending_buf_size - 5); ; ) {
      if (P.lookahead <= 1) {
        if (Te(P), P.lookahead === 0 && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      P.strstart += P.lookahead, P.lookahead = 0;
      var ie = P.block_start + be;
      if ((P.strstart === 0 || P.strstart >= ie) && (P.lookahead = P.strstart - ie, P.strstart = ie, C(P, !1), P.strm.avail_out === 0) || P.strstart - P.block_start >= P.w_size - S && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : (P.strstart > P.block_start && (C(P, !1), P.strm.avail_out === 0), F);
  }
  function H(P, Me) {
    for (var be, ie; ; ) {
      if (P.lookahead < S) {
        if (Te(P), P.lookahead < S && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (be = 0, P.lookahead >= x && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), be !== 0 && P.strstart - be <= P.w_size - S && (P.match_length = me(P, be)), P.match_length >= x)
        if (ie = t._tr_tally(P, P.strstart - P.match_start, P.match_length - x), P.lookahead -= P.match_length, P.match_length <= P.max_lazy_match && P.lookahead >= x) {
          P.match_length--;
          do
            P.strstart++, P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart;
          while (--P.match_length !== 0);
          P.strstart++;
        } else
          P.strstart += P.match_length, P.match_length = 0, P.ins_h = P.window[P.strstart], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + 1]) & P.hash_mask;
      else
        ie = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++;
      if (ie && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = P.strstart < x - 1 ? P.strstart : x - 1, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : re;
  }
  function se(P, Me) {
    for (var be, ie, le; ; ) {
      if (P.lookahead < S) {
        if (Te(P), P.lookahead < S && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (be = 0, P.lookahead >= x && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), P.prev_length = P.match_length, P.prev_match = P.match_start, P.match_length = x - 1, be !== 0 && P.prev_length < P.max_lazy_match && P.strstart - be <= P.w_size - S && (P.match_length = me(P, be), P.match_length <= 5 && (P.strategy === I || P.match_length === x && P.strstart - P.match_start > 4096) && (P.match_length = x - 1)), P.prev_length >= x && P.match_length <= P.prev_length) {
        le = P.strstart + P.lookahead - x, ie = t._tr_tally(P, P.strstart - 1 - P.prev_match, P.prev_length - x), P.lookahead -= P.prev_length - 1, P.prev_length -= 2;
        do
          ++P.strstart <= le && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + x - 1]) & P.hash_mask, be = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart);
        while (--P.prev_length !== 0);
        if (P.match_available = 0, P.match_length = x - 1, P.strstart++, ie && (C(P, !1), P.strm.avail_out === 0))
          return F;
      } else if (P.match_available) {
        if (ie = t._tr_tally(P, 0, P.window[P.strstart - 1]), ie && C(P, !1), P.strstart++, P.lookahead--, P.strm.avail_out === 0)
          return F;
      } else
        P.match_available = 1, P.strstart++, P.lookahead--;
    }
    return P.match_available && (ie = t._tr_tally(P, 0, P.window[P.strstart - 1]), P.match_available = 0), P.insert = P.strstart < x - 1 ? P.strstart : x - 1, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : re;
  }
  function fe(P, Me) {
    for (var be, ie, le, ge, Ge = P.window; ; ) {
      if (P.lookahead <= A) {
        if (Te(P), P.lookahead <= A && Me === n)
          return F;
        if (P.lookahead === 0)
          break;
      }
      if (P.match_length = 0, P.lookahead >= x && P.strstart > 0 && (le = P.strstart - 1, ie = Ge[le], ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le])) {
        ge = P.strstart + A;
        do
          ;
        while (ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && ie === Ge[++le] && le < ge);
        P.match_length = A - (ge - le), P.match_length > P.lookahead && (P.match_length = P.lookahead);
      }
      if (P.match_length >= x ? (be = t._tr_tally(P, 1, P.match_length - x), P.lookahead -= P.match_length, P.strstart += P.match_length, P.match_length = 0) : (be = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++), be && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : re;
  }
  function _e(P, Me) {
    for (var be; ; ) {
      if (P.lookahead === 0 && (Te(P), P.lookahead === 0)) {
        if (Me === n)
          return F;
        break;
      }
      if (P.match_length = 0, be = t._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++, be && (C(P, !1), P.strm.avail_out === 0))
        return F;
    }
    return P.insert = 0, Me === c ? (C(P, !0), P.strm.avail_out === 0 ? he : Z) : P.last_lit && (C(P, !1), P.strm.avail_out === 0) ? F : re;
  }
  function Ce(P, Me, be, ie, le) {
    this.good_length = P, this.max_lazy = Me, this.nice_length = be, this.max_chain = ie, this.func = le;
  }
  var Ve;
  Ve = [
    /*      good lazy nice chain */
    new Ce(0, 0, 0, 0, He),
    /* 0 store only */
    new Ce(4, 4, 8, 4, H),
    /* 1 max speed, no lazy matches */
    new Ce(4, 5, 16, 8, H),
    /* 2 */
    new Ce(4, 6, 32, 32, H),
    /* 3 */
    new Ce(4, 4, 16, 16, se),
    /* 4 lazy matches */
    new Ce(8, 16, 32, 32, se),
    /* 5 */
    new Ce(8, 16, 128, 128, se),
    /* 6 */
    new Ce(8, 32, 128, 256, se),
    /* 7 */
    new Ce(32, 128, 258, 1024, se),
    /* 8 */
    new Ce(32, 258, 258, 4096, se)
    /* 9 max compression */
  ];
  function ke(P) {
    P.window_size = 2 * P.w_size, Be(P.head), P.max_lazy_match = Ve[P.level].max_lazy, P.good_match = Ve[P.level].good_length, P.nice_match = Ve[P.level].nice_length, P.max_chain_length = Ve[P.level].max_chain, P.strstart = 0, P.block_start = 0, P.lookahead = 0, P.insert = 0, P.match_length = P.prev_length = x - 1, P.match_available = 0, P.ins_h = 0;
  }
  function Q() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = D, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(d * 2), this.dyn_dtree = new e.Buf16((2 * b + 1) * 2), this.bl_tree = new e.Buf16((2 * a + 1) * 2), Be(this.dyn_ltree), Be(this.dyn_dtree), Be(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(w + 1), this.heap = new e.Buf16(2 * g + 1), Be(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * g + 1), Be(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function Se(P) {
    var Me;
    return !P || !P.state ? ce(P, v) : (P.total_in = P.total_out = 0, P.data_type = q, Me = P.state, Me.pending = 0, Me.pending_out = 0, Me.wrap < 0 && (Me.wrap = -Me.wrap), Me.status = Me.wrap ? _ : V, P.adler = Me.wrap === 2 ? 0 : 1, Me.last_flush = n, t._tr_init(Me), s);
  }
  function Ae(P) {
    var Me = Se(P);
    return Me === s && ke(P.state), Me;
  }
  function $e(P, Me) {
    return !P || !P.state || P.state.wrap !== 2 ? v : (P.state.gzhead = Me, s);
  }
  function pe(P, Me, be, ie, le, ge) {
    if (!P)
      return v;
    var Ge = 1;
    if (Me === M && (Me = 6), ie < 0 ? (Ge = 0, ie = -ie) : ie > 15 && (Ge = 2, ie -= 16), le < 1 || le > U || be !== D || ie < 8 || ie > 15 || Me < 0 || Me > 9 || ge < 0 || ge > k)
      return ce(P, v);
    ie === 8 && (ie = 9);
    var je = new Q();
    return P.state = je, je.strm = P, je.wrap = Ge, je.gzhead = null, je.w_bits = ie, je.w_size = 1 << je.w_bits, je.w_mask = je.w_size - 1, je.hash_bits = le + 7, je.hash_size = 1 << je.hash_bits, je.hash_mask = je.hash_size - 1, je.hash_shift = ~~((je.hash_bits + x - 1) / x), je.window = new e.Buf8(je.w_size * 2), je.head = new e.Buf16(je.hash_size), je.prev = new e.Buf16(je.w_size), je.lit_bufsize = 1 << le + 6, je.pending_buf_size = je.lit_bufsize * 4, je.pending_buf = new e.Buf8(je.pending_buf_size), je.d_buf = 1 * je.lit_bufsize, je.l_buf = 3 * je.lit_bufsize, je.level = Me, je.strategy = ge, je.method = be, Ae(P);
  }
  function Ee(P, Me) {
    return pe(P, Me, D, z, Y, N);
  }
  function J(P, Me) {
    var be, ie, le, ge;
    if (!P || !P.state || Me > h || Me < 0)
      return P ? ce(P, v) : v;
    if (ie = P.state, !P.output || !P.input && P.avail_in !== 0 || ie.status === W && Me !== c)
      return ce(P, P.avail_out === 0 ? E : v);
    if (ie.strm = P, be = ie.last_flush, ie.last_flush = Me, ie.status === _)
      if (ie.wrap === 2)
        P.adler = 0, L(ie, 31), L(ie, 139), L(ie, 8), ie.gzhead ? (L(
          ie,
          (ie.gzhead.text ? 1 : 0) + (ie.gzhead.hcrc ? 2 : 0) + (ie.gzhead.extra ? 4 : 0) + (ie.gzhead.name ? 8 : 0) + (ie.gzhead.comment ? 16 : 0)
        ), L(ie, ie.gzhead.time & 255), L(ie, ie.gzhead.time >> 8 & 255), L(ie, ie.gzhead.time >> 16 & 255), L(ie, ie.gzhead.time >> 24 & 255), L(ie, ie.level === 9 ? 2 : ie.strategy >= B || ie.level < 2 ? 4 : 0), L(ie, ie.gzhead.os & 255), ie.gzhead.extra && ie.gzhead.extra.length && (L(ie, ie.gzhead.extra.length & 255), L(ie, ie.gzhead.extra.length >> 8 & 255)), ie.gzhead.hcrc && (P.adler = i(P.adler, ie.pending_buf, ie.pending, 0)), ie.gzindex = 0, ie.status = l) : (L(ie, 0), L(ie, 0), L(ie, 0), L(ie, 0), L(ie, 0), L(ie, ie.level === 9 ? 2 : ie.strategy >= B || ie.level < 2 ? 4 : 0), L(ie, K), ie.status = V);
      else {
        var Ge = D + (ie.w_bits - 8 << 4) << 8, je = -1;
        ie.strategy >= B || ie.level < 2 ? je = 0 : ie.level < 6 ? je = 1 : ie.level === 6 ? je = 2 : je = 3, Ge |= je << 6, ie.strstart !== 0 && (Ge |= y), Ge += 31 - Ge % 31, ie.status = V, G(ie, Ge), ie.strstart !== 0 && (G(ie, P.adler >>> 16), G(ie, P.adler & 65535)), P.adler = 1;
      }
    if (ie.status === l)
      if (ie.gzhead.extra) {
        for (le = ie.pending; ie.gzindex < (ie.gzhead.extra.length & 65535) && !(ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), te(P), le = ie.pending, ie.pending === ie.pending_buf_size)); )
          L(ie, ie.gzhead.extra[ie.gzindex] & 255), ie.gzindex++;
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ie.gzindex === ie.gzhead.extra.length && (ie.gzindex = 0, ie.status = R);
      } else
        ie.status = R;
    if (ie.status === R)
      if (ie.gzhead.name) {
        le = ie.pending;
        do {
          if (ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), te(P), le = ie.pending, ie.pending === ie.pending_buf_size)) {
            ge = 1;
            break;
          }
          ie.gzindex < ie.gzhead.name.length ? ge = ie.gzhead.name.charCodeAt(ie.gzindex++) & 255 : ge = 0, L(ie, ge);
        } while (ge !== 0);
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ge === 0 && (ie.gzindex = 0, ie.status = ee);
      } else
        ie.status = ee;
    if (ie.status === ee)
      if (ie.gzhead.comment) {
        le = ie.pending;
        do {
          if (ie.pending === ie.pending_buf_size && (ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), te(P), le = ie.pending, ie.pending === ie.pending_buf_size)) {
            ge = 1;
            break;
          }
          ie.gzindex < ie.gzhead.comment.length ? ge = ie.gzhead.comment.charCodeAt(ie.gzindex++) & 255 : ge = 0, L(ie, ge);
        } while (ge !== 0);
        ie.gzhead.hcrc && ie.pending > le && (P.adler = i(P.adler, ie.pending_buf, ie.pending - le, le)), ge === 0 && (ie.status = oe);
      } else
        ie.status = oe;
    if (ie.status === oe && (ie.gzhead.hcrc ? (ie.pending + 2 > ie.pending_buf_size && te(P), ie.pending + 2 <= ie.pending_buf_size && (L(ie, P.adler & 255), L(ie, P.adler >> 8 & 255), P.adler = 0, ie.status = V)) : ie.status = V), ie.pending !== 0) {
      if (te(P), P.avail_out === 0)
        return ie.last_flush = -1, s;
    } else if (P.avail_in === 0 && ve(Me) <= ve(be) && Me !== c)
      return ce(P, E);
    if (ie.status === W && P.avail_in !== 0)
      return ce(P, E);
    if (P.avail_in !== 0 || ie.lookahead !== 0 || Me !== n && ie.status !== W) {
      var Ne = ie.strategy === B ? _e(ie, Me) : ie.strategy === T ? fe(ie, Me) : Ve[ie.level].func(ie, Me);
      if ((Ne === he || Ne === Z) && (ie.status = W), Ne === F || Ne === he)
        return P.avail_out === 0 && (ie.last_flush = -1), s;
      if (Ne === re && (Me === f ? t._tr_align(ie) : Me !== h && (t._tr_stored_block(ie, 0, 0, !1), Me === u && (Be(ie.head), ie.lookahead === 0 && (ie.strstart = 0, ie.block_start = 0, ie.insert = 0))), te(P), P.avail_out === 0))
        return ie.last_flush = -1, s;
    }
    return Me !== c ? s : ie.wrap <= 0 ? p : (ie.wrap === 2 ? (L(ie, P.adler & 255), L(ie, P.adler >> 8 & 255), L(ie, P.adler >> 16 & 255), L(ie, P.adler >> 24 & 255), L(ie, P.total_in & 255), L(ie, P.total_in >> 8 & 255), L(ie, P.total_in >> 16 & 255), L(ie, P.total_in >> 24 & 255)) : (G(ie, P.adler >>> 16), G(ie, P.adler & 65535)), te(P), ie.wrap > 0 && (ie.wrap = -ie.wrap), ie.pending !== 0 ? s : p);
  }
  function Ie(P) {
    var Me;
    return !P || !P.state ? v : (Me = P.state.status, Me !== _ && Me !== l && Me !== R && Me !== ee && Me !== oe && Me !== V && Me !== W ? ce(P, v) : (P.state = null, Me === V ? ce(P, m) : s));
  }
  function qe(P, Me) {
    var be = Me.length, ie, le, ge, Ge, je, Ne, nt, st;
    if (!P || !P.state || (ie = P.state, Ge = ie.wrap, Ge === 2 || Ge === 1 && ie.status !== _ || ie.lookahead))
      return v;
    for (Ge === 1 && (P.adler = r(P.adler, Me, be, 0)), ie.wrap = 0, be >= ie.w_size && (Ge === 0 && (Be(ie.head), ie.strstart = 0, ie.block_start = 0, ie.insert = 0), st = new e.Buf8(ie.w_size), e.arraySet(st, Me, be - ie.w_size, ie.w_size, 0), Me = st, be = ie.w_size), je = P.avail_in, Ne = P.next_in, nt = P.input, P.avail_in = be, P.next_in = 0, P.input = Me, Te(ie); ie.lookahead >= x; ) {
      le = ie.strstart, ge = ie.lookahead - (x - 1);
      do
        ie.ins_h = (ie.ins_h << ie.hash_shift ^ ie.window[le + x - 1]) & ie.hash_mask, ie.prev[le & ie.w_mask] = ie.head[ie.ins_h], ie.head[ie.ins_h] = le, le++;
      while (--ge);
      ie.strstart = le, ie.lookahead = x - 1, Te(ie);
    }
    return ie.strstart += ie.lookahead, ie.block_start = ie.strstart, ie.insert = ie.lookahead, ie.lookahead = 0, ie.match_length = ie.prev_length = x - 1, ie.match_available = 0, P.next_in = Ne, P.input = nt, P.avail_in = je, ie.wrap = Ge, s;
  }
  return Wr.deflateInit = Ee, Wr.deflateInit2 = pe, Wr.deflateReset = Ae, Wr.deflateResetKeep = Se, Wr.deflateSetHeader = $e, Wr.deflate = J, Wr.deflateEnd = Ie, Wr.deflateSetDictionary = qe, Wr.deflateInfo = "pako deflate (from Nodeca project)", Wr;
}
var Or = {}, Ks, f1;
function nE() {
  if (f1)
    return Ks;
  f1 = 1;
  var e = 30, t = 12;
  return Ks = function(i, o) {
    var n, f, u, c, h, s, p, v, m, E, M, I, B, T, k, N, q, D, U, z, Y, ue, j, g, b;
    n = i.state, f = i.next_in, g = i.input, u = f + (i.avail_in - 5), c = i.next_out, b = i.output, h = c - (o - i.avail_out), s = c + (i.avail_out - 257), p = n.dmax, v = n.wsize, m = n.whave, E = n.wnext, M = n.window, I = n.hold, B = n.bits, T = n.lencode, k = n.distcode, N = (1 << n.lenbits) - 1, q = (1 << n.distbits) - 1;
    e:
      do {
        B < 15 && (I += g[f++] << B, B += 8, I += g[f++] << B, B += 8), D = T[I & N];
        t:
          for (; ; ) {
            if (U = D >>> 24, I >>>= U, B -= U, U = D >>> 16 & 255, U === 0)
              b[c++] = D & 65535;
            else if (U & 16) {
              z = D & 65535, U &= 15, U && (B < U && (I += g[f++] << B, B += 8), z += I & (1 << U) - 1, I >>>= U, B -= U), B < 15 && (I += g[f++] << B, B += 8, I += g[f++] << B, B += 8), D = k[I & q];
              r:
                for (; ; ) {
                  if (U = D >>> 24, I >>>= U, B -= U, U = D >>> 16 & 255, U & 16) {
                    if (Y = D & 65535, U &= 15, B < U && (I += g[f++] << B, B += 8, B < U && (I += g[f++] << B, B += 8)), Y += I & (1 << U) - 1, Y > p) {
                      i.msg = "invalid distance too far back", n.mode = e;
                      break e;
                    }
                    if (I >>>= U, B -= U, U = c - h, Y > U) {
                      if (U = Y - U, U > m && n.sane) {
                        i.msg = "invalid distance too far back", n.mode = e;
                        break e;
                      }
                      if (ue = 0, j = M, E === 0) {
                        if (ue += v - U, U < z) {
                          z -= U;
                          do
                            b[c++] = M[ue++];
                          while (--U);
                          ue = c - Y, j = b;
                        }
                      } else if (E < U) {
                        if (ue += v + E - U, U -= E, U < z) {
                          z -= U;
                          do
                            b[c++] = M[ue++];
                          while (--U);
                          if (ue = 0, E < z) {
                            U = E, z -= U;
                            do
                              b[c++] = M[ue++];
                            while (--U);
                            ue = c - Y, j = b;
                          }
                        }
                      } else if (ue += E - U, U < z) {
                        z -= U;
                        do
                          b[c++] = M[ue++];
                        while (--U);
                        ue = c - Y, j = b;
                      }
                      for (; z > 2; )
                        b[c++] = j[ue++], b[c++] = j[ue++], b[c++] = j[ue++], z -= 3;
                      z && (b[c++] = j[ue++], z > 1 && (b[c++] = j[ue++]));
                    } else {
                      ue = c - Y;
                      do
                        b[c++] = b[ue++], b[c++] = b[ue++], b[c++] = b[ue++], z -= 3;
                      while (z > 2);
                      z && (b[c++] = b[ue++], z > 1 && (b[c++] = b[ue++]));
                    }
                  } else if (U & 64) {
                    i.msg = "invalid distance code", n.mode = e;
                    break e;
                  } else {
                    D = k[(D & 65535) + (I & (1 << U) - 1)];
                    continue r;
                  }
                  break;
                }
            } else if (U & 64)
              if (U & 32) {
                n.mode = t;
                break e;
              } else {
                i.msg = "invalid literal/length code", n.mode = e;
                break e;
              }
            else {
              D = T[(D & 65535) + (I & (1 << U) - 1)];
              continue t;
            }
            break;
          }
      } while (f < u && c < s);
    z = B >> 3, f -= z, B -= z << 3, I &= (1 << B) - 1, i.next_in = f, i.next_out = c, i.avail_in = f < u ? 5 + (u - f) : 5 - (f - u), i.avail_out = c < s ? 257 + (s - c) : 257 - (c - s), n.hold = I, n.bits = B;
  }, Ks;
}
var Zs, s1;
function iE() {
  if (s1)
    return Zs;
  s1 = 1;
  var e = hf(), t = 15, r = 852, i = 592, o = 0, n = 1, f = 2, u = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], c = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], h = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], s = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return Zs = function(v, m, E, M, I, B, T, k) {
    var N = k.bits, q = 0, D = 0, U = 0, z = 0, Y = 0, ue = 0, j = 0, g = 0, b = 0, a = 0, d, w, x, A, S, y = null, _ = 0, l, R = new e.Buf16(t + 1), ee = new e.Buf16(t + 1), oe = null, V = 0, W, F, re;
    for (q = 0; q <= t; q++)
      R[q] = 0;
    for (D = 0; D < M; D++)
      R[m[E + D]]++;
    for (Y = N, z = t; z >= 1 && R[z] === 0; z--)
      ;
    if (Y > z && (Y = z), z === 0)
      return I[B++] = 1 << 24 | 64 << 16 | 0, I[B++] = 1 << 24 | 64 << 16 | 0, k.bits = 1, 0;
    for (U = 1; U < z && R[U] === 0; U++)
      ;
    for (Y < U && (Y = U), g = 1, q = 1; q <= t; q++)
      if (g <<= 1, g -= R[q], g < 0)
        return -1;
    if (g > 0 && (v === o || z !== 1))
      return -1;
    for (ee[1] = 0, q = 1; q < t; q++)
      ee[q + 1] = ee[q] + R[q];
    for (D = 0; D < M; D++)
      m[E + D] !== 0 && (T[ee[m[E + D]]++] = D);
    if (v === o ? (y = oe = T, l = 19) : v === n ? (y = u, _ -= 257, oe = c, V -= 257, l = 256) : (y = h, oe = s, l = -1), a = 0, D = 0, q = U, S = B, ue = Y, j = 0, x = -1, b = 1 << Y, A = b - 1, v === n && b > r || v === f && b > i)
      return 1;
    for (; ; ) {
      W = q - j, T[D] < l ? (F = 0, re = T[D]) : T[D] > l ? (F = oe[V + T[D]], re = y[_ + T[D]]) : (F = 96, re = 0), d = 1 << q - j, w = 1 << ue, U = w;
      do
        w -= d, I[S + (a >> j) + w] = W << 24 | F << 16 | re | 0;
      while (w !== 0);
      for (d = 1 << q - 1; a & d; )
        d >>= 1;
      if (d !== 0 ? (a &= d - 1, a += d) : a = 0, D++, --R[q] === 0) {
        if (q === z)
          break;
        q = m[E + T[D]];
      }
      if (q > Y && (a & A) !== x) {
        for (j === 0 && (j = Y), S += U, ue = q - j, g = 1 << ue; ue + j < z && (g -= R[ue + j], !(g <= 0)); )
          ue++, g <<= 1;
        if (b += 1 << ue, v === n && b > r || v === f && b > i)
          return 1;
        x = a & A, I[x] = Y << 24 | ue << 16 | S - B | 0;
      }
    }
    return a !== 0 && (I[S + a] = q - j << 24 | 64 << 16 | 0), k.bits = Y, 0;
  }, Zs;
}
var u1;
function aE() {
  if (u1)
    return Or;
  u1 = 1;
  var e = hf(), t = hg(), r = lg(), i = nE(), o = iE(), n = 0, f = 1, u = 2, c = 4, h = 5, s = 6, p = 0, v = 1, m = 2, E = -2, M = -3, I = -4, B = -5, T = 8, k = 1, N = 2, q = 3, D = 4, U = 5, z = 6, Y = 7, ue = 8, j = 9, g = 10, b = 11, a = 12, d = 13, w = 14, x = 15, A = 16, S = 17, y = 18, _ = 19, l = 20, R = 21, ee = 22, oe = 23, V = 24, W = 25, F = 26, re = 27, he = 28, Z = 29, K = 30, ce = 31, ve = 32, Be = 852, te = 592, C = 15, L = C;
  function G(pe) {
    return (pe >>> 24 & 255) + (pe >>> 8 & 65280) + ((pe & 65280) << 8) + ((pe & 255) << 24);
  }
  function de() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function me(pe) {
    var Ee;
    return !pe || !pe.state ? E : (Ee = pe.state, pe.total_in = pe.total_out = Ee.total = 0, pe.msg = "", Ee.wrap && (pe.adler = Ee.wrap & 1), Ee.mode = k, Ee.last = 0, Ee.havedict = 0, Ee.dmax = 32768, Ee.head = null, Ee.hold = 0, Ee.bits = 0, Ee.lencode = Ee.lendyn = new e.Buf32(Be), Ee.distcode = Ee.distdyn = new e.Buf32(te), Ee.sane = 1, Ee.back = -1, p);
  }
  function Te(pe) {
    var Ee;
    return !pe || !pe.state ? E : (Ee = pe.state, Ee.wsize = 0, Ee.whave = 0, Ee.wnext = 0, me(pe));
  }
  function He(pe, Ee) {
    var J, Ie;
    return !pe || !pe.state || (Ie = pe.state, Ee < 0 ? (J = 0, Ee = -Ee) : (J = (Ee >> 4) + 1, Ee < 48 && (Ee &= 15)), Ee && (Ee < 8 || Ee > 15)) ? E : (Ie.window !== null && Ie.wbits !== Ee && (Ie.window = null), Ie.wrap = J, Ie.wbits = Ee, Te(pe));
  }
  function H(pe, Ee) {
    var J, Ie;
    return pe ? (Ie = new de(), pe.state = Ie, Ie.window = null, J = He(pe, Ee), J !== p && (pe.state = null), J) : E;
  }
  function se(pe) {
    return H(pe, L);
  }
  var fe = !0, _e, Ce;
  function Ve(pe) {
    if (fe) {
      var Ee;
      for (_e = new e.Buf32(512), Ce = new e.Buf32(32), Ee = 0; Ee < 144; )
        pe.lens[Ee++] = 8;
      for (; Ee < 256; )
        pe.lens[Ee++] = 9;
      for (; Ee < 280; )
        pe.lens[Ee++] = 7;
      for (; Ee < 288; )
        pe.lens[Ee++] = 8;
      for (o(f, pe.lens, 0, 288, _e, 0, pe.work, { bits: 9 }), Ee = 0; Ee < 32; )
        pe.lens[Ee++] = 5;
      o(u, pe.lens, 0, 32, Ce, 0, pe.work, { bits: 5 }), fe = !1;
    }
    pe.lencode = _e, pe.lenbits = 9, pe.distcode = Ce, pe.distbits = 5;
  }
  function ke(pe, Ee, J, Ie) {
    var qe, P = pe.state;
    return P.window === null && (P.wsize = 1 << P.wbits, P.wnext = 0, P.whave = 0, P.window = new e.Buf8(P.wsize)), Ie >= P.wsize ? (e.arraySet(P.window, Ee, J - P.wsize, P.wsize, 0), P.wnext = 0, P.whave = P.wsize) : (qe = P.wsize - P.wnext, qe > Ie && (qe = Ie), e.arraySet(P.window, Ee, J - Ie, qe, P.wnext), Ie -= qe, Ie ? (e.arraySet(P.window, Ee, J - Ie, Ie, 0), P.wnext = Ie, P.whave = P.wsize) : (P.wnext += qe, P.wnext === P.wsize && (P.wnext = 0), P.whave < P.wsize && (P.whave += qe))), 0;
  }
  function Q(pe, Ee) {
    var J, Ie, qe, P, Me, be, ie, le, ge, Ge, je, Ne, nt, st, Je = 0, ft, $, X, ne, O, ae, we, xe, Re = new e.Buf8(4), De, ze, Ue = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!pe || !pe.state || !pe.output || !pe.input && pe.avail_in !== 0)
      return E;
    J = pe.state, J.mode === a && (J.mode = d), Me = pe.next_out, qe = pe.output, ie = pe.avail_out, P = pe.next_in, Ie = pe.input, be = pe.avail_in, le = J.hold, ge = J.bits, Ge = be, je = ie, xe = p;
    e:
      for (; ; )
        switch (J.mode) {
          case k:
            if (J.wrap === 0) {
              J.mode = d;
              break;
            }
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (J.wrap & 2 && le === 35615) {
              J.check = 0, Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = r(J.check, Re, 2, 0), le = 0, ge = 0, J.mode = N;
              break;
            }
            if (J.flags = 0, J.head && (J.head.done = !1), !(J.wrap & 1) || /* check if zlib header allowed */
            (((le & 255) << 8) + (le >> 8)) % 31) {
              pe.msg = "incorrect header check", J.mode = K;
              break;
            }
            if ((le & 15) !== T) {
              pe.msg = "unknown compression method", J.mode = K;
              break;
            }
            if (le >>>= 4, ge -= 4, we = (le & 15) + 8, J.wbits === 0)
              J.wbits = we;
            else if (we > J.wbits) {
              pe.msg = "invalid window size", J.mode = K;
              break;
            }
            J.dmax = 1 << we, pe.adler = J.check = 1, J.mode = le & 512 ? g : a, le = 0, ge = 0;
            break;
          case N:
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (J.flags = le, (J.flags & 255) !== T) {
              pe.msg = "unknown compression method", J.mode = K;
              break;
            }
            if (J.flags & 57344) {
              pe.msg = "unknown header flags set", J.mode = K;
              break;
            }
            J.head && (J.head.text = le >> 8 & 1), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = r(J.check, Re, 2, 0)), le = 0, ge = 0, J.mode = q;
          case q:
            for (; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            J.head && (J.head.time = le), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, Re[2] = le >>> 16 & 255, Re[3] = le >>> 24 & 255, J.check = r(J.check, Re, 4, 0)), le = 0, ge = 0, J.mode = D;
          case D:
            for (; ge < 16; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            J.head && (J.head.xflags = le & 255, J.head.os = le >> 8), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = r(J.check, Re, 2, 0)), le = 0, ge = 0, J.mode = U;
          case U:
            if (J.flags & 1024) {
              for (; ge < 16; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.length = le, J.head && (J.head.extra_len = le), J.flags & 512 && (Re[0] = le & 255, Re[1] = le >>> 8 & 255, J.check = r(J.check, Re, 2, 0)), le = 0, ge = 0;
            } else
              J.head && (J.head.extra = null);
            J.mode = z;
          case z:
            if (J.flags & 1024 && (Ne = J.length, Ne > be && (Ne = be), Ne && (J.head && (we = J.head.extra_len - J.length, J.head.extra || (J.head.extra = new Array(J.head.extra_len)), e.arraySet(
              J.head.extra,
              Ie,
              P,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              Ne,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              we
            )), J.flags & 512 && (J.check = r(J.check, Ie, Ne, P)), be -= Ne, P += Ne, J.length -= Ne), J.length))
              break e;
            J.length = 0, J.mode = Y;
          case Y:
            if (J.flags & 2048) {
              if (be === 0)
                break e;
              Ne = 0;
              do
                we = Ie[P + Ne++], J.head && we && J.length < 65536 && (J.head.name += String.fromCharCode(we));
              while (we && Ne < be);
              if (J.flags & 512 && (J.check = r(J.check, Ie, Ne, P)), be -= Ne, P += Ne, we)
                break e;
            } else
              J.head && (J.head.name = null);
            J.length = 0, J.mode = ue;
          case ue:
            if (J.flags & 4096) {
              if (be === 0)
                break e;
              Ne = 0;
              do
                we = Ie[P + Ne++], J.head && we && J.length < 65536 && (J.head.comment += String.fromCharCode(we));
              while (we && Ne < be);
              if (J.flags & 512 && (J.check = r(J.check, Ie, Ne, P)), be -= Ne, P += Ne, we)
                break e;
            } else
              J.head && (J.head.comment = null);
            J.mode = j;
          case j:
            if (J.flags & 512) {
              for (; ge < 16; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (le !== (J.check & 65535)) {
                pe.msg = "header crc mismatch", J.mode = K;
                break;
              }
              le = 0, ge = 0;
            }
            J.head && (J.head.hcrc = J.flags >> 9 & 1, J.head.done = !0), pe.adler = J.check = 0, J.mode = a;
            break;
          case g:
            for (; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            pe.adler = J.check = G(le), le = 0, ge = 0, J.mode = b;
          case b:
            if (J.havedict === 0)
              return pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, J.hold = le, J.bits = ge, m;
            pe.adler = J.check = 1, J.mode = a;
          case a:
            if (Ee === h || Ee === s)
              break e;
          case d:
            if (J.last) {
              le >>>= ge & 7, ge -= ge & 7, J.mode = re;
              break;
            }
            for (; ge < 3; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            switch (J.last = le & 1, le >>>= 1, ge -= 1, le & 3) {
              case 0:
                J.mode = w;
                break;
              case 1:
                if (Ve(J), J.mode = l, Ee === s) {
                  le >>>= 2, ge -= 2;
                  break e;
                }
                break;
              case 2:
                J.mode = S;
                break;
              case 3:
                pe.msg = "invalid block type", J.mode = K;
            }
            le >>>= 2, ge -= 2;
            break;
          case w:
            for (le >>>= ge & 7, ge -= ge & 7; ge < 32; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if ((le & 65535) !== (le >>> 16 ^ 65535)) {
              pe.msg = "invalid stored block lengths", J.mode = K;
              break;
            }
            if (J.length = le & 65535, le = 0, ge = 0, J.mode = x, Ee === s)
              break e;
          case x:
            J.mode = A;
          case A:
            if (Ne = J.length, Ne) {
              if (Ne > be && (Ne = be), Ne > ie && (Ne = ie), Ne === 0)
                break e;
              e.arraySet(qe, Ie, P, Ne, Me), be -= Ne, P += Ne, ie -= Ne, Me += Ne, J.length -= Ne;
              break;
            }
            J.mode = a;
            break;
          case S:
            for (; ge < 14; ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (J.nlen = (le & 31) + 257, le >>>= 5, ge -= 5, J.ndist = (le & 31) + 1, le >>>= 5, ge -= 5, J.ncode = (le & 15) + 4, le >>>= 4, ge -= 4, J.nlen > 286 || J.ndist > 30) {
              pe.msg = "too many length or distance symbols", J.mode = K;
              break;
            }
            J.have = 0, J.mode = y;
          case y:
            for (; J.have < J.ncode; ) {
              for (; ge < 3; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.lens[Ue[J.have++]] = le & 7, le >>>= 3, ge -= 3;
            }
            for (; J.have < 19; )
              J.lens[Ue[J.have++]] = 0;
            if (J.lencode = J.lendyn, J.lenbits = 7, De = { bits: J.lenbits }, xe = o(n, J.lens, 0, 19, J.lencode, 0, J.work, De), J.lenbits = De.bits, xe) {
              pe.msg = "invalid code lengths set", J.mode = K;
              break;
            }
            J.have = 0, J.mode = _;
          case _:
            for (; J.have < J.nlen + J.ndist; ) {
              for (; Je = J.lencode[le & (1 << J.lenbits) - 1], ft = Je >>> 24, $ = Je >>> 16 & 255, X = Je & 65535, !(ft <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (X < 16)
                le >>>= ft, ge -= ft, J.lens[J.have++] = X;
              else {
                if (X === 16) {
                  for (ze = ft + 2; ge < ze; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  if (le >>>= ft, ge -= ft, J.have === 0) {
                    pe.msg = "invalid bit length repeat", J.mode = K;
                    break;
                  }
                  we = J.lens[J.have - 1], Ne = 3 + (le & 3), le >>>= 2, ge -= 2;
                } else if (X === 17) {
                  for (ze = ft + 3; ge < ze; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  le >>>= ft, ge -= ft, we = 0, Ne = 3 + (le & 7), le >>>= 3, ge -= 3;
                } else {
                  for (ze = ft + 7; ge < ze; ) {
                    if (be === 0)
                      break e;
                    be--, le += Ie[P++] << ge, ge += 8;
                  }
                  le >>>= ft, ge -= ft, we = 0, Ne = 11 + (le & 127), le >>>= 7, ge -= 7;
                }
                if (J.have + Ne > J.nlen + J.ndist) {
                  pe.msg = "invalid bit length repeat", J.mode = K;
                  break;
                }
                for (; Ne--; )
                  J.lens[J.have++] = we;
              }
            }
            if (J.mode === K)
              break;
            if (J.lens[256] === 0) {
              pe.msg = "invalid code -- missing end-of-block", J.mode = K;
              break;
            }
            if (J.lenbits = 9, De = { bits: J.lenbits }, xe = o(f, J.lens, 0, J.nlen, J.lencode, 0, J.work, De), J.lenbits = De.bits, xe) {
              pe.msg = "invalid literal/lengths set", J.mode = K;
              break;
            }
            if (J.distbits = 6, J.distcode = J.distdyn, De = { bits: J.distbits }, xe = o(u, J.lens, J.nlen, J.ndist, J.distcode, 0, J.work, De), J.distbits = De.bits, xe) {
              pe.msg = "invalid distances set", J.mode = K;
              break;
            }
            if (J.mode = l, Ee === s)
              break e;
          case l:
            J.mode = R;
          case R:
            if (be >= 6 && ie >= 258) {
              pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, J.hold = le, J.bits = ge, i(pe, je), Me = pe.next_out, qe = pe.output, ie = pe.avail_out, P = pe.next_in, Ie = pe.input, be = pe.avail_in, le = J.hold, ge = J.bits, J.mode === a && (J.back = -1);
              break;
            }
            for (J.back = 0; Je = J.lencode[le & (1 << J.lenbits) - 1], ft = Je >>> 24, $ = Je >>> 16 & 255, X = Je & 65535, !(ft <= ge); ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if ($ && !($ & 240)) {
              for (ne = ft, O = $, ae = X; Je = J.lencode[ae + ((le & (1 << ne + O) - 1) >> ne)], ft = Je >>> 24, $ = Je >>> 16 & 255, X = Je & 65535, !(ne + ft <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              le >>>= ne, ge -= ne, J.back += ne;
            }
            if (le >>>= ft, ge -= ft, J.back += ft, J.length = X, $ === 0) {
              J.mode = F;
              break;
            }
            if ($ & 32) {
              J.back = -1, J.mode = a;
              break;
            }
            if ($ & 64) {
              pe.msg = "invalid literal/length code", J.mode = K;
              break;
            }
            J.extra = $ & 15, J.mode = ee;
          case ee:
            if (J.extra) {
              for (ze = J.extra; ge < ze; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.length += le & (1 << J.extra) - 1, le >>>= J.extra, ge -= J.extra, J.back += J.extra;
            }
            J.was = J.length, J.mode = oe;
          case oe:
            for (; Je = J.distcode[le & (1 << J.distbits) - 1], ft = Je >>> 24, $ = Je >>> 16 & 255, X = Je & 65535, !(ft <= ge); ) {
              if (be === 0)
                break e;
              be--, le += Ie[P++] << ge, ge += 8;
            }
            if (!($ & 240)) {
              for (ne = ft, O = $, ae = X; Je = J.distcode[ae + ((le & (1 << ne + O) - 1) >> ne)], ft = Je >>> 24, $ = Je >>> 16 & 255, X = Je & 65535, !(ne + ft <= ge); ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              le >>>= ne, ge -= ne, J.back += ne;
            }
            if (le >>>= ft, ge -= ft, J.back += ft, $ & 64) {
              pe.msg = "invalid distance code", J.mode = K;
              break;
            }
            J.offset = X, J.extra = $ & 15, J.mode = V;
          case V:
            if (J.extra) {
              for (ze = J.extra; ge < ze; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              J.offset += le & (1 << J.extra) - 1, le >>>= J.extra, ge -= J.extra, J.back += J.extra;
            }
            if (J.offset > J.dmax) {
              pe.msg = "invalid distance too far back", J.mode = K;
              break;
            }
            J.mode = W;
          case W:
            if (ie === 0)
              break e;
            if (Ne = je - ie, J.offset > Ne) {
              if (Ne = J.offset - Ne, Ne > J.whave && J.sane) {
                pe.msg = "invalid distance too far back", J.mode = K;
                break;
              }
              Ne > J.wnext ? (Ne -= J.wnext, nt = J.wsize - Ne) : nt = J.wnext - Ne, Ne > J.length && (Ne = J.length), st = J.window;
            } else
              st = qe, nt = Me - J.offset, Ne = J.length;
            Ne > ie && (Ne = ie), ie -= Ne, J.length -= Ne;
            do
              qe[Me++] = st[nt++];
            while (--Ne);
            J.length === 0 && (J.mode = R);
            break;
          case F:
            if (ie === 0)
              break e;
            qe[Me++] = J.length, ie--, J.mode = R;
            break;
          case re:
            if (J.wrap) {
              for (; ge < 32; ) {
                if (be === 0)
                  break e;
                be--, le |= Ie[P++] << ge, ge += 8;
              }
              if (je -= ie, pe.total_out += je, J.total += je, je && (pe.adler = J.check = /*UPDATE(state.check, put - _out, _out);*/
              J.flags ? r(J.check, qe, je, Me - je) : t(J.check, qe, je, Me - je)), je = ie, (J.flags ? le : G(le)) !== J.check) {
                pe.msg = "incorrect data check", J.mode = K;
                break;
              }
              le = 0, ge = 0;
            }
            J.mode = he;
          case he:
            if (J.wrap && J.flags) {
              for (; ge < 32; ) {
                if (be === 0)
                  break e;
                be--, le += Ie[P++] << ge, ge += 8;
              }
              if (le !== (J.total & 4294967295)) {
                pe.msg = "incorrect length check", J.mode = K;
                break;
              }
              le = 0, ge = 0;
            }
            J.mode = Z;
          case Z:
            xe = v;
            break e;
          case K:
            xe = M;
            break e;
          case ce:
            return I;
          case ve:
          default:
            return E;
        }
    return pe.next_out = Me, pe.avail_out = ie, pe.next_in = P, pe.avail_in = be, J.hold = le, J.bits = ge, (J.wsize || je !== pe.avail_out && J.mode < K && (J.mode < re || Ee !== c)) && ke(pe, pe.output, pe.next_out, je - pe.avail_out), Ge -= pe.avail_in, je -= pe.avail_out, pe.total_in += Ge, pe.total_out += je, J.total += je, J.wrap && je && (pe.adler = J.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    J.flags ? r(J.check, qe, je, pe.next_out - je) : t(J.check, qe, je, pe.next_out - je)), pe.data_type = J.bits + (J.last ? 64 : 0) + (J.mode === a ? 128 : 0) + (J.mode === l || J.mode === x ? 256 : 0), (Ge === 0 && je === 0 || Ee === c) && xe === p && (xe = B), xe;
  }
  function Se(pe) {
    if (!pe || !pe.state)
      return E;
    var Ee = pe.state;
    return Ee.window && (Ee.window = null), pe.state = null, p;
  }
  function Ae(pe, Ee) {
    var J;
    return !pe || !pe.state || (J = pe.state, !(J.wrap & 2)) ? E : (J.head = Ee, Ee.done = !1, p);
  }
  function $e(pe, Ee) {
    var J = Ee.length, Ie, qe, P;
    return !pe || !pe.state || (Ie = pe.state, Ie.wrap !== 0 && Ie.mode !== b) ? E : Ie.mode === b && (qe = 1, qe = t(qe, Ee, J, 0), qe !== Ie.check) ? M : (P = ke(pe, Ee, J, J), P ? (Ie.mode = ce, I) : (Ie.havedict = 1, p));
  }
  return Or.inflateReset = Te, Or.inflateReset2 = He, Or.inflateResetKeep = me, Or.inflateInit = se, Or.inflateInit2 = H, Or.inflate = Q, Or.inflateEnd = Se, Or.inflateGetHeader = Ae, Or.inflateSetDictionary = $e, Or.inflateInfo = "pako inflate (from Nodeca project)", Or;
}
var Gs, c1;
function oE() {
  return c1 || (c1 = 1, Gs = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), Gs;
}
var h1;
function fE() {
  return h1 || (h1 = 1, function(e) {
    var t = wo(), r = Qx(), i = rE(), o = aE(), n = oE();
    for (var f in n)
      e[f] = n[f];
    e.NONE = 0, e.DEFLATE = 1, e.INFLATE = 2, e.GZIP = 3, e.GUNZIP = 4, e.DEFLATERAW = 5, e.INFLATERAW = 6, e.UNZIP = 7;
    var u = 31, c = 139;
    function h(s) {
      if (typeof s != "number" || s < e.DEFLATE || s > e.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = s, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
    }
    h.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = !0;
        return;
      }
      this.pending_close = !1, t(this.init_done, "close before init"), t(this.mode <= e.UNZIP), this.mode === e.DEFLATE || this.mode === e.GZIP || this.mode === e.DEFLATERAW ? i.deflateEnd(this.strm) : (this.mode === e.INFLATE || this.mode === e.GUNZIP || this.mode === e.INFLATERAW || this.mode === e.UNZIP) && o.inflateEnd(this.strm), this.mode = e.NONE, this.dictionary = null;
    }, h.prototype.write = function(s, p, v, m, E, M, I) {
      return this._write(!0, s, p, v, m, E, M, I);
    }, h.prototype.writeSync = function(s, p, v, m, E, M, I) {
      return this._write(!1, s, p, v, m, E, M, I);
    }, h.prototype._write = function(s, p, v, m, E, M, I, B) {
      if (t.equal(arguments.length, 8), t(this.init_done, "write before init"), t(this.mode !== e.NONE, "already finalized"), t.equal(!1, this.write_in_progress, "write already in progress"), t.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, t.equal(!1, p === void 0, "must provide flush value"), this.write_in_progress = !0, p !== e.Z_NO_FLUSH && p !== e.Z_PARTIAL_FLUSH && p !== e.Z_SYNC_FLUSH && p !== e.Z_FULL_FLUSH && p !== e.Z_FINISH && p !== e.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (v == null && (v = Le.Buffer.alloc(0), E = 0, m = 0), this.strm.avail_in = E, this.strm.input = v, this.strm.next_in = m, this.strm.avail_out = B, this.strm.output = M, this.strm.next_out = I, this.flush = p, !s)
        return this._process(), this._checkError() ? this._afterSync() : void 0;
      var T = this;
      return at.nextTick(function() {
        T._process(), T._after();
      }), this;
    }, h.prototype._afterSync = function() {
      var s = this.strm.avail_out, p = this.strm.avail_in;
      return this.write_in_progress = !1, [p, s];
    }, h.prototype._process = function() {
      var s = null;
      switch (this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = i.deflate(this.strm, this.flush);
          break;
        case e.UNZIP:
          switch (this.strm.avail_in > 0 && (s = this.strm.next_in), this.gzip_id_bytes_read) {
            case 0:
              if (s === null)
                break;
              if (this.strm.input[s] === u) {
                if (this.gzip_id_bytes_read = 1, s++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = e.INFLATE;
                break;
              }
            case 1:
              if (s === null)
                break;
              this.strm.input[s] === c ? (this.gzip_id_bytes_read = 2, this.mode = e.GUNZIP) : this.mode = e.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
          for (this.err = o.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          ), this.err === e.Z_NEED_DICT && this.dictionary && (this.err = o.inflateSetDictionary(this.strm, this.dictionary), this.err === e.Z_OK ? this.err = o.inflate(this.strm, this.flush) : this.err === e.Z_DATA_ERROR && (this.err = e.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === e.GUNZIP && this.err === e.Z_STREAM_END && this.strm.next_in[0] !== 0; )
            this.reset(), this.err = o.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    }, h.prototype._checkError = function() {
      switch (this.err) {
        case e.Z_OK:
        case e.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === e.Z_FINISH)
            return this._error("unexpected end of file"), !1;
          break;
        case e.Z_STREAM_END:
          break;
        case e.Z_NEED_DICT:
          return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
        default:
          return this._error("Zlib error"), !1;
      }
      return !0;
    }, h.prototype._after = function() {
      if (this._checkError()) {
        var s = this.strm.avail_out, p = this.strm.avail_in;
        this.write_in_progress = !1, this.callback(p, s), this.pending_close && this.close();
      }
    }, h.prototype._error = function(s) {
      this.strm.msg && (s = this.strm.msg), this.onerror(
        s,
        this.err
        // no hope of rescue.
      ), this.write_in_progress = !1, this.pending_close && this.close();
    }, h.prototype.init = function(s, p, v, m, E) {
      t(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), t(s >= 8 && s <= 15, "invalid windowBits"), t(p >= -1 && p <= 9, "invalid compression level"), t(v >= 1 && v <= 9, "invalid memlevel"), t(m === e.Z_FILTERED || m === e.Z_HUFFMAN_ONLY || m === e.Z_RLE || m === e.Z_FIXED || m === e.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(p, s, v, m, E), this._setDictionary();
    }, h.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    }, h.prototype.reset = function() {
      this._reset(), this._setDictionary();
    }, h.prototype._init = function(s, p, v, m, E) {
      switch (this.level = s, this.windowBits = p, this.memLevel = v, this.strategy = m, this.flush = e.Z_NO_FLUSH, this.err = e.Z_OK, (this.mode === e.GZIP || this.mode === e.GUNZIP) && (this.windowBits += 16), this.mode === e.UNZIP && (this.windowBits += 32), (this.mode === e.DEFLATERAW || this.mode === e.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new r(), this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = i.deflateInit2(this.strm, this.level, e.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
        case e.UNZIP:
          this.err = o.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      this.err !== e.Z_OK && this._error("Init error"), this.dictionary = E, this.write_in_progress = !1, this.init_done = !0;
    }, h.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (this.err = e.Z_OK, this.mode) {
          case e.DEFLATE:
          case e.DEFLATERAW:
            this.err = i.deflateSetDictionary(this.strm, this.dictionary);
            break;
        }
        this.err !== e.Z_OK && this._error("Failed to set dictionary");
      }
    }, h.prototype._reset = function() {
      switch (this.err = e.Z_OK, this.mode) {
        case e.DEFLATE:
        case e.DEFLATERAW:
        case e.GZIP:
          this.err = i.deflateReset(this.strm);
          break;
        case e.INFLATE:
        case e.INFLATERAW:
        case e.GUNZIP:
          this.err = o.inflateReset(this.strm);
          break;
      }
      this.err !== e.Z_OK && this._error("Failed to reset stream");
    }, e.Zlib = h;
  }(Ms)), Ms;
}
var l1;
function sE() {
  return l1 || (l1 = 1, function(e) {
    var t = Le.Buffer, r = og().Transform, i = fE(), o = _n(), n = wo().ok, f = Le.kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + f.toString(16) + " bytes";
    i.Z_MIN_WINDOWBITS = 8, i.Z_MAX_WINDOWBITS = 15, i.Z_DEFAULT_WINDOWBITS = 15, i.Z_MIN_CHUNK = 64, i.Z_MAX_CHUNK = 1 / 0, i.Z_DEFAULT_CHUNK = 16 * 1024, i.Z_MIN_MEMLEVEL = 1, i.Z_MAX_MEMLEVEL = 9, i.Z_DEFAULT_MEMLEVEL = 8, i.Z_MIN_LEVEL = -1, i.Z_MAX_LEVEL = 9, i.Z_DEFAULT_LEVEL = i.Z_DEFAULT_COMPRESSION;
    for (var c = Object.keys(i), h = 0; h < c.length; h++) {
      var s = c[h];
      s.match(/^Z/) && Object.defineProperty(e, s, {
        enumerable: !0,
        value: i[s],
        writable: !1
      });
    }
    for (var p = {
      Z_OK: i.Z_OK,
      Z_STREAM_END: i.Z_STREAM_END,
      Z_NEED_DICT: i.Z_NEED_DICT,
      Z_ERRNO: i.Z_ERRNO,
      Z_STREAM_ERROR: i.Z_STREAM_ERROR,
      Z_DATA_ERROR: i.Z_DATA_ERROR,
      Z_MEM_ERROR: i.Z_MEM_ERROR,
      Z_BUF_ERROR: i.Z_BUF_ERROR,
      Z_VERSION_ERROR: i.Z_VERSION_ERROR
    }, v = Object.keys(p), m = 0; m < v.length; m++) {
      var E = v[m];
      p[p[E]] = E;
    }
    Object.defineProperty(e, "codes", {
      enumerable: !0,
      value: Object.freeze(p),
      writable: !1
    }), e.Deflate = B, e.Inflate = T, e.Gzip = k, e.Gunzip = N, e.DeflateRaw = q, e.InflateRaw = D, e.Unzip = U, e.createDeflate = function(g) {
      return new B(g);
    }, e.createInflate = function(g) {
      return new T(g);
    }, e.createDeflateRaw = function(g) {
      return new q(g);
    }, e.createInflateRaw = function(g) {
      return new D(g);
    }, e.createGzip = function(g) {
      return new k(g);
    }, e.createGunzip = function(g) {
      return new N(g);
    }, e.createUnzip = function(g) {
      return new U(g);
    }, e.deflate = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new B(b), g, a);
    }, e.deflateSync = function(g, b) {
      return I(new B(b), g);
    }, e.gzip = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new k(b), g, a);
    }, e.gzipSync = function(g, b) {
      return I(new k(b), g);
    }, e.deflateRaw = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new q(b), g, a);
    }, e.deflateRawSync = function(g, b) {
      return I(new q(b), g);
    }, e.unzip = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new U(b), g, a);
    }, e.unzipSync = function(g, b) {
      return I(new U(b), g);
    }, e.inflate = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new T(b), g, a);
    }, e.inflateSync = function(g, b) {
      return I(new T(b), g);
    }, e.gunzip = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new N(b), g, a);
    }, e.gunzipSync = function(g, b) {
      return I(new N(b), g);
    }, e.inflateRaw = function(g, b, a) {
      return typeof b == "function" && (a = b, b = {}), M(new D(b), g, a);
    }, e.inflateRawSync = function(g, b) {
      return I(new D(b), g);
    };
    function M(g, b, a) {
      var d = [], w = 0;
      g.on("error", A), g.on("end", S), g.end(b), x();
      function x() {
        for (var y; (y = g.read()) !== null; )
          d.push(y), w += y.length;
        g.once("readable", x);
      }
      function A(y) {
        g.removeListener("end", S), g.removeListener("readable", x), a(y);
      }
      function S() {
        var y, _ = null;
        w >= f ? _ = new RangeError(u) : y = t.concat(d, w), d = [], g.close(), a(_, y);
      }
    }
    function I(g, b) {
      if (typeof b == "string" && (b = t.from(b)), !t.isBuffer(b))
        throw new TypeError("Not a string or buffer");
      var a = g._finishFlushFlag;
      return g._processChunk(b, a);
    }
    function B(g) {
      if (!(this instanceof B))
        return new B(g);
      Y.call(this, g, i.DEFLATE);
    }
    function T(g) {
      if (!(this instanceof T))
        return new T(g);
      Y.call(this, g, i.INFLATE);
    }
    function k(g) {
      if (!(this instanceof k))
        return new k(g);
      Y.call(this, g, i.GZIP);
    }
    function N(g) {
      if (!(this instanceof N))
        return new N(g);
      Y.call(this, g, i.GUNZIP);
    }
    function q(g) {
      if (!(this instanceof q))
        return new q(g);
      Y.call(this, g, i.DEFLATERAW);
    }
    function D(g) {
      if (!(this instanceof D))
        return new D(g);
      Y.call(this, g, i.INFLATERAW);
    }
    function U(g) {
      if (!(this instanceof U))
        return new U(g);
      Y.call(this, g, i.UNZIP);
    }
    function z(g) {
      return g === i.Z_NO_FLUSH || g === i.Z_PARTIAL_FLUSH || g === i.Z_SYNC_FLUSH || g === i.Z_FULL_FLUSH || g === i.Z_FINISH || g === i.Z_BLOCK;
    }
    function Y(g, b) {
      var a = this;
      if (this._opts = g = g || {}, this._chunkSize = g.chunkSize || e.Z_DEFAULT_CHUNK, r.call(this, g), g.flush && !z(g.flush))
        throw new Error("Invalid flush flag: " + g.flush);
      if (g.finishFlush && !z(g.finishFlush))
        throw new Error("Invalid flush flag: " + g.finishFlush);
      if (this._flushFlag = g.flush || i.Z_NO_FLUSH, this._finishFlushFlag = typeof g.finishFlush < "u" ? g.finishFlush : i.Z_FINISH, g.chunkSize && (g.chunkSize < e.Z_MIN_CHUNK || g.chunkSize > e.Z_MAX_CHUNK))
        throw new Error("Invalid chunk size: " + g.chunkSize);
      if (g.windowBits && (g.windowBits < e.Z_MIN_WINDOWBITS || g.windowBits > e.Z_MAX_WINDOWBITS))
        throw new Error("Invalid windowBits: " + g.windowBits);
      if (g.level && (g.level < e.Z_MIN_LEVEL || g.level > e.Z_MAX_LEVEL))
        throw new Error("Invalid compression level: " + g.level);
      if (g.memLevel && (g.memLevel < e.Z_MIN_MEMLEVEL || g.memLevel > e.Z_MAX_MEMLEVEL))
        throw new Error("Invalid memLevel: " + g.memLevel);
      if (g.strategy && g.strategy != e.Z_FILTERED && g.strategy != e.Z_HUFFMAN_ONLY && g.strategy != e.Z_RLE && g.strategy != e.Z_FIXED && g.strategy != e.Z_DEFAULT_STRATEGY)
        throw new Error("Invalid strategy: " + g.strategy);
      if (g.dictionary && !t.isBuffer(g.dictionary))
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      this._handle = new i.Zlib(b);
      var d = this;
      this._hadError = !1, this._handle.onerror = function(A, S) {
        ue(d), d._hadError = !0;
        var y = new Error(A);
        y.errno = S, y.code = e.codes[S], d.emit("error", y);
      };
      var w = e.Z_DEFAULT_COMPRESSION;
      typeof g.level == "number" && (w = g.level);
      var x = e.Z_DEFAULT_STRATEGY;
      typeof g.strategy == "number" && (x = g.strategy), this._handle.init(g.windowBits || e.Z_DEFAULT_WINDOWBITS, w, g.memLevel || e.Z_DEFAULT_MEMLEVEL, x, g.dictionary), this._buffer = t.allocUnsafe(this._chunkSize), this._offset = 0, this._level = w, this._strategy = x, this.once("end", this.close), Object.defineProperty(this, "_closed", {
        get: function() {
          return !a._handle;
        },
        configurable: !0,
        enumerable: !0
      });
    }
    o.inherits(Y, r), Y.prototype.params = function(g, b, a) {
      if (g < e.Z_MIN_LEVEL || g > e.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + g);
      if (b != e.Z_FILTERED && b != e.Z_HUFFMAN_ONLY && b != e.Z_RLE && b != e.Z_FIXED && b != e.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + b);
      if (this._level !== g || this._strategy !== b) {
        var d = this;
        this.flush(i.Z_SYNC_FLUSH, function() {
          n(d._handle, "zlib binding closed"), d._handle.params(g, b), d._hadError || (d._level = g, d._strategy = b, a && a());
        });
      } else
        at.nextTick(a);
    }, Y.prototype.reset = function() {
      return n(this._handle, "zlib binding closed"), this._handle.reset();
    }, Y.prototype._flush = function(g) {
      this._transform(t.alloc(0), "", g);
    }, Y.prototype.flush = function(g, b) {
      var a = this, d = this._writableState;
      (typeof g == "function" || g === void 0 && !b) && (b = g, g = i.Z_FULL_FLUSH), d.ended ? b && at.nextTick(b) : d.ending ? b && this.once("end", b) : d.needDrain ? b && this.once("drain", function() {
        return a.flush(g, b);
      }) : (this._flushFlag = g, this.write(t.alloc(0), "", b));
    }, Y.prototype.close = function(g) {
      ue(this, g), at.nextTick(j, this);
    };
    function ue(g, b) {
      b && at.nextTick(b), g._handle && (g._handle.close(), g._handle = null);
    }
    function j(g) {
      g.emit("close");
    }
    Y.prototype._transform = function(g, b, a) {
      var d, w = this._writableState, x = w.ending || w.ended, A = x && (!g || w.length === g.length);
      if (g !== null && !t.isBuffer(g))
        return a(new Error("invalid input"));
      if (!this._handle)
        return a(new Error("zlib binding closed"));
      A ? d = this._finishFlushFlag : (d = this._flushFlag, g.length >= w.length && (this._flushFlag = this._opts.flush || i.Z_NO_FLUSH)), this._processChunk(g, d, a);
    }, Y.prototype._processChunk = function(g, b, a) {
      var d = g && g.length, w = this._chunkSize - this._offset, x = 0, A = this, S = typeof a == "function";
      if (!S) {
        var y = [], _ = 0, l;
        this.on("error", function(W) {
          l = W;
        }), n(this._handle, "zlib binding closed");
        do
          var R = this._handle.writeSync(
            b,
            g,
            // in
            x,
            // in_off
            d,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            w
          );
        while (!this._hadError && V(R[0], R[1]));
        if (this._hadError)
          throw l;
        if (_ >= f)
          throw ue(this), new RangeError(u);
        var ee = t.concat(y, _);
        return ue(this), ee;
      }
      n(this._handle, "zlib binding closed");
      var oe = this._handle.write(
        b,
        g,
        // in
        x,
        // in_off
        d,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        w
      );
      oe.buffer = g, oe.callback = V;
      function V(W, F) {
        if (this && (this.buffer = null, this.callback = null), !A._hadError) {
          var re = w - F;
          if (n(re >= 0, "have should not go down"), re > 0) {
            var he = A._buffer.slice(A._offset, A._offset + re);
            A._offset += re, S ? A.push(he) : (y.push(he), _ += he.length);
          }
          if ((F === 0 || A._offset >= A._chunkSize) && (w = A._chunkSize, A._offset = 0, A._buffer = t.allocUnsafe(A._chunkSize)), F === 0) {
            if (x += d - W, d = W, !S)
              return !0;
            var Z = A._handle.write(b, g, x, d, A._buffer, A._offset, A._chunkSize);
            Z.callback = V, Z.buffer = g;
            return;
          }
          if (!S)
            return !1;
          a();
        }
      }
    }, o.inherits(B, Y), o.inherits(T, Y), o.inherits(k, Y), o.inherits(N, Y), o.inherits(q, Y), o.inherits(D, Y), o.inherits(U, Y);
  }(Ss)), Ss;
}
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.InvalidStatusCodeError = ri.InvalidCertError = void 0;
const dg = Object.freeze({
  redirect: !0,
  expectStatusCode: 200,
  headers: {},
  full: !1,
  keepAlive: !0,
  cors: !1,
  referrer: !1,
  sslAllowSelfSigned: !1,
  _redirectCount: 0
});
class ch extends Error {
  constructor(t, r) {
    super(t), this.fingerprint256 = r;
  }
}
ri.InvalidCertError = ch;
class h0 extends Error {
  constructor(t) {
    super(`Request Failed. Status Code: ${t}`), this.statusCode = t;
  }
}
ri.InvalidStatusCodeError = h0;
function pg(e, t) {
  if (!t || t === "text" || t === "json")
    try {
      let r = new TextDecoder("utf8", { fatal: !0 }).decode(e);
      if (t === "text")
        return r;
      try {
        return JSON.parse(r);
      } catch (i) {
        if (t === "json")
          throw i;
        return r;
      }
    } catch (r) {
      if (t === "text" || t === "json")
        throw r;
    }
  return e;
}
let d1 = {};
function hh(e, t) {
  var v;
  let r = { ...dg, ...t };
  const i = ag(), o = zx(), n = sE(), { promisify: f } = _n(), { resolve: u } = u0(), c = !!/^https/.test(e);
  let h = {
    method: r.method || "GET",
    headers: { "Accept-Encoding": "gzip, deflate, br" }
  };
  const s = (m) => m.replace(/:| /g, "").toLowerCase();
  if (r.keepAlive) {
    const m = {
      keepAlive: !0,
      keepAliveMsecs: 3e4,
      maxFreeSockets: 1024,
      maxCachedSessions: 1024
    }, E = [
      c,
      c && ((v = r.sslPinnedCertificates) == null ? void 0 : v.map((M) => s(M)).sort())
    ].join();
    h.agent = d1[E] || (d1[E] = new (c ? o : i).Agent(m));
  }
  r.type === "json" && (h.headers["Content-Type"] = "application/json"), r.data && (r.method || (h.method = "POST"), h.body = r.type === "json" ? JSON.stringify(r.data) : r.data), h.headers = { ...h.headers, ...r.headers }, r.sslAllowSelfSigned && (h.rejectUnauthorized = !1);
  const p = async (m) => {
    const E = m.statusCode;
    if (r.redirect && 300 <= E && E < 400 && m.headers.location) {
      if (r._redirectCount == 10)
        throw new Error("Request failed. Too much redirects.");
      return r._redirectCount += 1, await hh(u(e, m.headers.location), r);
    }
    if (r.expectStatusCode && E !== r.expectStatusCode)
      throw m.resume(), new h0(E);
    let M = [];
    for await (const k of m)
      M.push(k);
    let I = Le.Buffer.concat(M);
    const B = m.headers["content-encoding"];
    B === "br" && (I = await f(n.brotliDecompress)(I)), (B === "gzip" || B === "deflate") && (I = await f(n.unzip)(I));
    const T = pg(I, r.type);
    return r.full ? { headers: m.headers, status: E, body: T } : T;
  };
  return new Promise((m, E) => {
    var k;
    const M = async (N) => {
      if (N && N.code === "DEPTH_ZERO_SELF_SIGNED_CERT")
        try {
          await hh(e, { ...r, sslAllowSelfSigned: !0, sslPinnedCertificates: [] });
        } catch (q) {
          q && q.fingerprint256 && (N = new ch(`Self-signed SSL certificate: ${q.fingerprint256}`, q.fingerprint256));
        }
      E(N);
    }, I = (c ? o : i).request(e, h, (N) => {
      N.on("error", M), (async () => {
        try {
          m(await p(N));
        } catch (q) {
          E(q);
        }
      })();
    });
    I.on("error", M);
    const B = (k = r.sslPinnedCertificates) == null ? void 0 : k.map((N) => s(N)), T = (N) => {
      var D;
      const q = s(((D = N.getPeerCertificate()) == null ? void 0 : D.fingerprint256) || "");
      if (!(!q && N.isSessionReused()) && !B.includes(q))
        return I.emit("error", new ch(`Invalid SSL certificate: ${q} Expected: ${B}`, q)), I.abort();
    };
    r.sslPinnedCertificates && I.on("socket", (N) => {
      N.listeners("secureConnect").map((D) => (D.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || N.on("secureConnect", T.bind(null, N));
    }), r.keepAlive && I.setNoDelay(!0), h.body && I.write(h.body), I.end();
  });
}
const uE = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((e) => e.toLowerCase())), cE = new Set([
  "Accept-Charset",
  "Accept-Encoding",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Connection",
  "Content-Length",
  "Cookie",
  "Cookie2",
  "Date",
  "DNT",
  "Expect",
  "Host",
  "Keep-Alive",
  "Origin",
  "Referer",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via"
].map((e) => e.toLowerCase()));
async function hE(e, t) {
  let r = { ...dg, ...t };
  const i = new Headers();
  r.type === "json" && i.set("Content-Type", "application/json");
  let o = new URL(e);
  if (o.username) {
    const c = btoa(`${o.username}:${o.password}`);
    i.set("Authorization", `Basic ${c}`), o.username = "", o.password = "";
  }
  e = "" + o;
  for (let c in r.headers) {
    const h = c.toLowerCase();
    (uE.has(h) || r.cors && !cE.has(h)) && i.set(c, r.headers[c]);
  }
  let n = { headers: i, redirect: r.redirect ? "follow" : "manual" };
  r.referrer || (n.referrerPolicy = "no-referrer"), r.cors && (n.mode = "cors"), r.data && (r.method || (n.method = "POST"), n.body = r.type === "json" ? JSON.stringify(r.data) : r.data);
  const f = await fetch(e, n);
  if (r.expectStatusCode && f.status !== r.expectStatusCode)
    throw new h0(f.status);
  const u = pg(new Uint8Array(await f.arrayBuffer()), r.type);
  return r.full ? { headers: Object.fromEntries(f.headers.entries()), status: f.status, body: u } : u;
}
const lE = !!(typeof at == "object" && at.versions && at.versions.node && at.versions.v8);
function dE(e, t) {
  return (lE ? hh : hE)(e, t);
}
ri.default = dE;
Object.defineProperty($i, "__esModule", { value: !0 });
$i.getProvider = $i.fetchFromProvider = void 0;
const pE = ri, vE = async (e, t) => (await (0, pE.default)(e, {
  headers: {
    "content-type": "application/json"
  },
  type: "json",
  data: {
    method: t.method,
    params: t.params,
    jsonrpc: "2.0",
    id: 1
  }
})).result;
$i.fetchFromProvider = vE;
const bE = (e) => {
  var t;
  if (typeof e == "string")
    return e;
  if (((t = e == null ? void 0 : e.connection) == null ? void 0 : t.url) !== void 0)
    return e.connection.url;
  throw new Error("Must provide valid provider URL or Web3Provider");
};
$i.getProvider = bE;
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(o, n, f, u) {
    u === void 0 && (u = f);
    var c = Object.getOwnPropertyDescriptor(n, f);
    (!c || ("get" in c ? !n.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return n[f];
    } }), Object.defineProperty(o, u, c);
  } : function(o, n, f, u) {
    u === void 0 && (u = f), o[u] = n[f];
  }), r = Ze && Ze.__exportStar || function(o, n) {
    for (var f in o)
      f !== "default" && !Object.prototype.hasOwnProperty.call(n, f) && t(n, o, f);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toAscii = e.stripHexPrefix = e.padToEven = e.isHexString = e.isHexPrefixed = e.getKeys = e.getBinarySize = e.fromUtf8 = e.fromAscii = e.arrayContainsArray = void 0, r(Zo, e), r(ef, e), r(t0, e), r(Ia, e), r(rf, e), r(br, e), r(oi, e), r(i0, e), r(Jy, e), r(of, e);
  var i = zt;
  Object.defineProperty(e, "arrayContainsArray", { enumerable: !0, get: function() {
    return i.arrayContainsArray;
  } }), Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return i.fromAscii;
  } }), Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return i.fromUtf8;
  } }), Object.defineProperty(e, "getBinarySize", { enumerable: !0, get: function() {
    return i.getBinarySize;
  } }), Object.defineProperty(e, "getKeys", { enumerable: !0, get: function() {
    return i.getKeys;
  } }), Object.defineProperty(e, "isHexPrefixed", { enumerable: !0, get: function() {
    return i.isHexPrefixed;
  } }), Object.defineProperty(e, "isHexString", { enumerable: !0, get: function() {
    return i.isHexString;
  } }), Object.defineProperty(e, "padToEven", { enumerable: !0, get: function() {
    return i.padToEven;
  } }), Object.defineProperty(e, "stripHexPrefix", { enumerable: !0, get: function() {
    return i.stripHexPrefix;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return i.toAscii;
  } }), r(ff, e), r($i, e);
})(Ra);
var rr = {}, vg = function(t) {
  if (typeof t != "string")
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof t + ", while checking isHexPrefixed.");
  return t.slice(0, 2) === "0x";
}, yE = vg, gE = function(t) {
  return typeof t != "string" ? t : yE(t) ? t.slice(2) : t;
}, mE = vg, bg = gE;
function lf(e) {
  var t = e;
  if (typeof t != "string")
    throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof t + ", while padToEven.");
  return t.length % 2 && (t = "0" + t), t;
}
function yg(e) {
  var t = e.toString(16);
  return "0x" + t;
}
function wE(e) {
  var t = yg(e);
  return new Le.Buffer(lf(t.slice(2)), "hex");
}
function _E(e) {
  if (typeof e != "string")
    throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof e + "'.");
  return Le.Buffer.byteLength(e, "utf8");
}
function xE(e, t, r) {
  if (Array.isArray(e) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof e + "'");
  if (Array.isArray(t) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof t + "'");
  return t[!!r && "some" || "every"](function(i) {
    return e.indexOf(i) >= 0;
  });
}
function EE(e) {
  var t = new Le.Buffer(lf(bg(e).replace(/^0+|0+$/g, "")), "hex");
  return t.toString("utf8");
}
function SE(e) {
  var t = "", r = 0, i = e.length;
  for (e.substring(0, 2) === "0x" && (r = 2); r < i; r += 2) {
    var o = parseInt(e.substr(r, 2), 16);
    t += String.fromCharCode(o);
  }
  return t;
}
function AE(e) {
  var t = new Le.Buffer(e, "utf8");
  return "0x" + lf(t.toString("hex")).replace(/^0+|0+$/g, "");
}
function ME(e) {
  for (var t = "", r = 0; r < e.length; r++) {
    var i = e.charCodeAt(r), o = i.toString(16);
    t += o.length < 2 ? "0" + o : o;
  }
  return "0x" + t;
}
function RE(e, t, r) {
  if (!Array.isArray(e))
    throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof e + "'");
  if (typeof t != "string")
    throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof t + "'.");
  for (var i = [], o = 0; o < e.length; o++) {
    var n = e[o][t];
    if (r && !n)
      n = "";
    else if (typeof n != "string")
      throw new Error("invalid abi");
    i.push(n);
  }
  return i;
}
function BE(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
var l0 = {
  arrayContainsArray: xE,
  intToBuffer: wE,
  getBinarySize: _E,
  isHexPrefixed: mE,
  stripHexPrefix: bg,
  padToEven: lf,
  intToHex: yg,
  fromAscii: ME,
  fromUtf8: AE,
  toAscii: SE,
  toUtf8: EE,
  getKeys: RE,
  isHexString: BE
};
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.numberToBuffer = rr.normalize = rr.recoverPublicKey = rr.concatSig = rr.legacyToBuffer = rr.isNullish = rr.padWithZeroes = void 0;
const qr = Ra, lh = l0;
function dh(e, t) {
  if (e !== "" && !/^[a-f0-9]+$/iu.test(e))
    throw new Error(`Expected an unprefixed hex string. Received: ${e}`);
  if (t < 0)
    throw new Error(`Expected a non-negative integer target length. Received: ${t}`);
  return String.prototype.padStart.call(e, t, "0");
}
rr.padWithZeroes = dh;
function IE(e) {
  return e == null;
}
rr.isNullish = IE;
function TE(e) {
  return typeof e == "string" && !(0, lh.isHexString)(e) ? Le.Buffer.from(e) : (0, qr.toBuffer)(e);
}
rr.legacyToBuffer = TE;
function OE(e, t, r) {
  const i = (0, qr.fromSigned)(t), o = (0, qr.fromSigned)(r), n = (0, qr.bufferToInt)(e), f = dh((0, qr.toUnsigned)(i).toString("hex"), 64), u = dh((0, qr.toUnsigned)(o).toString("hex"), 64), c = (0, lh.stripHexPrefix)((0, lh.intToHex)(n));
  return (0, qr.addHexPrefix)(f.concat(u, c));
}
rr.concatSig = OE;
function PE(e, t) {
  const r = (0, qr.fromRpcSig)(t);
  return (0, qr.ecrecover)(e, r.v, r.r, r.s);
}
rr.recoverPublicKey = PE;
function CE(e) {
  if (e) {
    if (typeof e == "number") {
      if (e < 0)
        return "0x";
      const t = (0, qr.toBuffer)(e);
      e = (0, qr.bufferToHex)(t);
    }
    if (typeof e != "string") {
      let t = "eth-sig-util.normalize() requires hex string or integer input.";
      throw t += ` received ${typeof e}: ${e}`, new Error(t);
    }
    return (0, qr.addHexPrefix)(e.toLowerCase());
  }
}
rr.normalize = CE;
function NE(e) {
  const t = e.toString(16), r = t.length % 2 ? "0" : "";
  return Le.Buffer.from(r + t, "hex");
}
rr.numberToBuffer = NE;
Object.defineProperty(On, "__esModule", { value: !0 });
On.extractPublicKey = On.recoverPersonalSignature = On.personalSign = void 0;
const Bi = Ra, un = rr;
function LE({ privateKey: e, data: t }) {
  if ((0, un.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, un.isNullish)(e))
    throw new Error("Missing privateKey parameter");
  const r = (0, un.legacyToBuffer)(t), i = (0, Bi.hashPersonalMessage)(r), o = (0, Bi.ecsign)(i, e);
  return (0, un.concatSig)((0, Bi.toBuffer)(o.v), o.r, o.s);
}
On.personalSign = LE;
function kE({ data: e, signature: t }) {
  if ((0, un.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, un.isNullish)(t))
    throw new Error("Missing signature parameter");
  const r = gg(e, t), i = (0, Bi.publicToAddress)(r);
  return (0, Bi.bufferToHex)(i);
}
On.recoverPersonalSignature = kE;
function qE({ data: e, signature: t }) {
  if ((0, un.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, un.isNullish)(t))
    throw new Error("Missing signature parameter");
  return `0x${gg(e, t).toString("hex")}`;
}
On.extractPublicKey = qE;
function gg(e, t) {
  const r = (0, Bi.hashPersonalMessage)((0, un.legacyToBuffer)(e));
  return (0, un.recoverPublicKey)(r, t);
}
var mg = {}, Pn = {}, d0 = { exports: {} };
d0.exports;
(function(e) {
  (function(t, r) {
    function i(j, g) {
      if (!j)
        throw new Error(g || "Assertion failed");
    }
    function o(j, g) {
      j.super_ = g;
      var b = function() {
      };
      b.prototype = g.prototype, j.prototype = new b(), j.prototype.constructor = j;
    }
    function n(j, g, b) {
      if (n.isBN(j))
        return j;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null && ((g === "le" || g === "be") && (b = g, g = 10), this._init(j || 0, g || 10, b || "be"));
    }
    typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
    var f;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? f = window.Buffer : f = Le.Buffer;
    } catch {
    }
    n.isBN = function(g) {
      return g instanceof n ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === n.wordSize && Array.isArray(g.words);
    }, n.max = function(g, b) {
      return g.cmp(b) > 0 ? g : b;
    }, n.min = function(g, b) {
      return g.cmp(b) < 0 ? g : b;
    }, n.prototype._init = function(g, b, a) {
      if (typeof g == "number")
        return this._initNumber(g, b, a);
      if (typeof g == "object")
        return this._initArray(g, b, a);
      b === "hex" && (b = 16), i(b === (b | 0) && b >= 2 && b <= 36), g = g.toString().replace(/\s+/g, "");
      var d = 0;
      g[0] === "-" && (d++, this.negative = 1), d < g.length && (b === 16 ? this._parseHex(g, d, a) : (this._parseBase(g, b, d), a === "le" && this._initArray(this.toArray(), b, a)));
    }, n.prototype._initNumber = function(g, b, a) {
      g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [
        g & 67108863,
        g / 67108864 & 67108863
      ], this.length = 2) : (i(g < 9007199254740992), this.words = [
        g & 67108863,
        g / 67108864 & 67108863,
        1
      ], this.length = 3), a === "le" && this._initArray(this.toArray(), b, a);
    }, n.prototype._initArray = function(g, b, a) {
      if (i(typeof g.length == "number"), g.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        this.words[d] = 0;
      var w, x, A = 0;
      if (a === "be")
        for (d = g.length - 1, w = 0; d >= 0; d -= 3)
          x = g[d] | g[d - 1] << 8 | g[d - 2] << 16, this.words[w] |= x << A & 67108863, this.words[w + 1] = x >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);
      else if (a === "le")
        for (d = 0, w = 0; d < g.length; d += 3)
          x = g[d] | g[d + 1] << 8 | g[d + 2] << 16, this.words[w] |= x << A & 67108863, this.words[w + 1] = x >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, w++);
      return this.strip();
    };
    function u(j, g) {
      var b = j.charCodeAt(g);
      return b >= 65 && b <= 70 ? b - 55 : b >= 97 && b <= 102 ? b - 87 : b - 48 & 15;
    }
    function c(j, g, b) {
      var a = u(j, b);
      return b - 1 >= g && (a |= u(j, b - 1) << 4), a;
    }
    n.prototype._parseHex = function(g, b, a) {
      this.length = Math.ceil((g.length - b) / 6), this.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        this.words[d] = 0;
      var w = 0, x = 0, A;
      if (a === "be")
        for (d = g.length - 1; d >= b; d -= 2)
          A = c(g, b, d) << w, this.words[x] |= A & 67108863, w >= 18 ? (w -= 18, x += 1, this.words[x] |= A >>> 26) : w += 8;
      else {
        var S = g.length - b;
        for (d = S % 2 === 0 ? b + 1 : b; d < g.length; d += 2)
          A = c(g, b, d) << w, this.words[x] |= A & 67108863, w >= 18 ? (w -= 18, x += 1, this.words[x] |= A >>> 26) : w += 8;
      }
      this.strip();
    };
    function h(j, g, b, a) {
      for (var d = 0, w = Math.min(j.length, b), x = g; x < w; x++) {
        var A = j.charCodeAt(x) - 48;
        d *= a, A >= 49 ? d += A - 49 + 10 : A >= 17 ? d += A - 17 + 10 : d += A;
      }
      return d;
    }
    n.prototype._parseBase = function(g, b, a) {
      this.words = [0], this.length = 1;
      for (var d = 0, w = 1; w <= 67108863; w *= b)
        d++;
      d--, w = w / b | 0;
      for (var x = g.length - a, A = x % d, S = Math.min(x, x - A) + a, y = 0, _ = a; _ < S; _ += d)
        y = h(g, _, _ + d, b), this.imuln(w), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      if (A !== 0) {
        var l = 1;
        for (y = h(g, _, g.length, b), _ = 0; _ < A; _++)
          l *= b;
        this.imuln(l), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
      }
      this.strip();
    }, n.prototype.copy = function(g) {
      g.words = new Array(this.length);
      for (var b = 0; b < this.length; b++)
        g.words[b] = this.words[b];
      g.length = this.length, g.negative = this.negative, g.red = this.red;
    }, n.prototype.clone = function() {
      var g = new n(null);
      return this.copy(g), g;
    }, n.prototype._expand = function(g) {
      for (; this.length < g; )
        this.words[this.length++] = 0;
      return this;
    }, n.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, n.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, n.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var s = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], p = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], v = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    n.prototype.toString = function(g, b) {
      g = g || 10, b = b | 0 || 1;
      var a;
      if (g === 16 || g === "hex") {
        a = "";
        for (var d = 0, w = 0, x = 0; x < this.length; x++) {
          var A = this.words[x], S = ((A << d | w) & 16777215).toString(16);
          w = A >>> 24 - d & 16777215, w !== 0 || x !== this.length - 1 ? a = s[6 - S.length] + S + a : a = S + a, d += 2, d >= 26 && (d -= 26, x--);
        }
        for (w !== 0 && (a = w.toString(16) + a); a.length % b !== 0; )
          a = "0" + a;
        return this.negative !== 0 && (a = "-" + a), a;
      }
      if (g === (g | 0) && g >= 2 && g <= 36) {
        var y = p[g], _ = v[g];
        a = "";
        var l = this.clone();
        for (l.negative = 0; !l.isZero(); ) {
          var R = l.modn(_).toString(g);
          l = l.idivn(_), l.isZero() ? a = R + a : a = s[y - R.length] + R + a;
        }
        for (this.isZero() && (a = "0" + a); a.length % b !== 0; )
          a = "0" + a;
        return this.negative !== 0 && (a = "-" + a), a;
      }
      i(!1, "Base should be between 2 and 36");
    }, n.prototype.toNumber = function() {
      var g = this.words[0];
      return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
    }, n.prototype.toJSON = function() {
      return this.toString(16);
    }, n.prototype.toBuffer = function(g, b) {
      return i(typeof f < "u"), this.toArrayLike(f, g, b);
    }, n.prototype.toArray = function(g, b) {
      return this.toArrayLike(Array, g, b);
    }, n.prototype.toArrayLike = function(g, b, a) {
      var d = this.byteLength(), w = a || Math.max(1, d);
      i(d <= w, "byte array longer than desired length"), i(w > 0, "Requested array length <= 0"), this.strip();
      var x = b === "le", A = new g(w), S, y, _ = this.clone();
      if (x) {
        for (y = 0; !_.isZero(); y++)
          S = _.andln(255), _.iushrn(8), A[y] = S;
        for (; y < w; y++)
          A[y] = 0;
      } else {
        for (y = 0; y < w - d; y++)
          A[y] = 0;
        for (y = 0; !_.isZero(); y++)
          S = _.andln(255), _.iushrn(8), A[w - y - 1] = S;
      }
      return A;
    }, Math.clz32 ? n.prototype._countBits = function(g) {
      return 32 - Math.clz32(g);
    } : n.prototype._countBits = function(g) {
      var b = g, a = 0;
      return b >= 4096 && (a += 13, b >>>= 13), b >= 64 && (a += 7, b >>>= 7), b >= 8 && (a += 4, b >>>= 4), b >= 2 && (a += 2, b >>>= 2), a + b;
    }, n.prototype._zeroBits = function(g) {
      if (g === 0)
        return 26;
      var b = g, a = 0;
      return b & 8191 || (a += 13, b >>>= 13), b & 127 || (a += 7, b >>>= 7), b & 15 || (a += 4, b >>>= 4), b & 3 || (a += 2, b >>>= 2), b & 1 || a++, a;
    }, n.prototype.bitLength = function() {
      var g = this.words[this.length - 1], b = this._countBits(g);
      return (this.length - 1) * 26 + b;
    };
    function m(j) {
      for (var g = new Array(j.bitLength()), b = 0; b < g.length; b++) {
        var a = b / 26 | 0, d = b % 26;
        g[b] = (j.words[a] & 1 << d) >>> d;
      }
      return g;
    }
    n.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var g = 0, b = 0; b < this.length; b++) {
        var a = this._zeroBits(this.words[b]);
        if (g += a, a !== 26)
          break;
      }
      return g;
    }, n.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, n.prototype.toTwos = function(g) {
      return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
    }, n.prototype.fromTwos = function(g) {
      return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
    }, n.prototype.isNeg = function() {
      return this.negative !== 0;
    }, n.prototype.neg = function() {
      return this.clone().ineg();
    }, n.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, n.prototype.iuor = function(g) {
      for (; this.length < g.length; )
        this.words[this.length++] = 0;
      for (var b = 0; b < g.length; b++)
        this.words[b] = this.words[b] | g.words[b];
      return this.strip();
    }, n.prototype.ior = function(g) {
      return i((this.negative | g.negative) === 0), this.iuor(g);
    }, n.prototype.or = function(g) {
      return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
    }, n.prototype.uor = function(g) {
      return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
    }, n.prototype.iuand = function(g) {
      var b;
      this.length > g.length ? b = g : b = this;
      for (var a = 0; a < b.length; a++)
        this.words[a] = this.words[a] & g.words[a];
      return this.length = b.length, this.strip();
    }, n.prototype.iand = function(g) {
      return i((this.negative | g.negative) === 0), this.iuand(g);
    }, n.prototype.and = function(g) {
      return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
    }, n.prototype.uand = function(g) {
      return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
    }, n.prototype.iuxor = function(g) {
      var b, a;
      this.length > g.length ? (b = this, a = g) : (b = g, a = this);
      for (var d = 0; d < a.length; d++)
        this.words[d] = b.words[d] ^ a.words[d];
      if (this !== b)
        for (; d < b.length; d++)
          this.words[d] = b.words[d];
      return this.length = b.length, this.strip();
    }, n.prototype.ixor = function(g) {
      return i((this.negative | g.negative) === 0), this.iuxor(g);
    }, n.prototype.xor = function(g) {
      return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
    }, n.prototype.uxor = function(g) {
      return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
    }, n.prototype.inotn = function(g) {
      i(typeof g == "number" && g >= 0);
      var b = Math.ceil(g / 26) | 0, a = g % 26;
      this._expand(b), a > 0 && b--;
      for (var d = 0; d < b; d++)
        this.words[d] = ~this.words[d] & 67108863;
      return a > 0 && (this.words[d] = ~this.words[d] & 67108863 >> 26 - a), this.strip();
    }, n.prototype.notn = function(g) {
      return this.clone().inotn(g);
    }, n.prototype.setn = function(g, b) {
      i(typeof g == "number" && g >= 0);
      var a = g / 26 | 0, d = g % 26;
      return this._expand(a + 1), b ? this.words[a] = this.words[a] | 1 << d : this.words[a] = this.words[a] & ~(1 << d), this.strip();
    }, n.prototype.iadd = function(g) {
      var b;
      if (this.negative !== 0 && g.negative === 0)
        return this.negative = 0, b = this.isub(g), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && g.negative !== 0)
        return g.negative = 0, b = this.isub(g), g.negative = 1, b._normSign();
      var a, d;
      this.length > g.length ? (a = this, d = g) : (a = g, d = this);
      for (var w = 0, x = 0; x < d.length; x++)
        b = (a.words[x] | 0) + (d.words[x] | 0) + w, this.words[x] = b & 67108863, w = b >>> 26;
      for (; w !== 0 && x < a.length; x++)
        b = (a.words[x] | 0) + w, this.words[x] = b & 67108863, w = b >>> 26;
      if (this.length = a.length, w !== 0)
        this.words[this.length] = w, this.length++;
      else if (a !== this)
        for (; x < a.length; x++)
          this.words[x] = a.words[x];
      return this;
    }, n.prototype.add = function(g) {
      var b;
      return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, b = this.sub(g), g.negative ^= 1, b) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, b = g.sub(this), this.negative = 1, b) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
    }, n.prototype.isub = function(g) {
      if (g.negative !== 0) {
        g.negative = 0;
        var b = this.iadd(g);
        return g.negative = 1, b._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
      var a = this.cmp(g);
      if (a === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var d, w;
      a > 0 ? (d = this, w = g) : (d = g, w = this);
      for (var x = 0, A = 0; A < w.length; A++)
        b = (d.words[A] | 0) - (w.words[A] | 0) + x, x = b >> 26, this.words[A] = b & 67108863;
      for (; x !== 0 && A < d.length; A++)
        b = (d.words[A] | 0) + x, x = b >> 26, this.words[A] = b & 67108863;
      if (x === 0 && A < d.length && d !== this)
        for (; A < d.length; A++)
          this.words[A] = d.words[A];
      return this.length = Math.max(this.length, A), d !== this && (this.negative = 1), this.strip();
    }, n.prototype.sub = function(g) {
      return this.clone().isub(g);
    };
    function E(j, g, b) {
      b.negative = g.negative ^ j.negative;
      var a = j.length + g.length | 0;
      b.length = a, a = a - 1 | 0;
      var d = j.words[0] | 0, w = g.words[0] | 0, x = d * w, A = x & 67108863, S = x / 67108864 | 0;
      b.words[0] = A;
      for (var y = 1; y < a; y++) {
        for (var _ = S >>> 26, l = S & 67108863, R = Math.min(y, g.length - 1), ee = Math.max(0, y - j.length + 1); ee <= R; ee++) {
          var oe = y - ee | 0;
          d = j.words[oe] | 0, w = g.words[ee] | 0, x = d * w + l, _ += x / 67108864 | 0, l = x & 67108863;
        }
        b.words[y] = l | 0, S = _ | 0;
      }
      return S !== 0 ? b.words[y] = S | 0 : b.length--, b.strip();
    }
    var M = function(g, b, a) {
      var d = g.words, w = b.words, x = a.words, A = 0, S, y, _, l = d[0] | 0, R = l & 8191, ee = l >>> 13, oe = d[1] | 0, V = oe & 8191, W = oe >>> 13, F = d[2] | 0, re = F & 8191, he = F >>> 13, Z = d[3] | 0, K = Z & 8191, ce = Z >>> 13, ve = d[4] | 0, Be = ve & 8191, te = ve >>> 13, C = d[5] | 0, L = C & 8191, G = C >>> 13, de = d[6] | 0, me = de & 8191, Te = de >>> 13, He = d[7] | 0, H = He & 8191, se = He >>> 13, fe = d[8] | 0, _e = fe & 8191, Ce = fe >>> 13, Ve = d[9] | 0, ke = Ve & 8191, Q = Ve >>> 13, Se = w[0] | 0, Ae = Se & 8191, $e = Se >>> 13, pe = w[1] | 0, Ee = pe & 8191, J = pe >>> 13, Ie = w[2] | 0, qe = Ie & 8191, P = Ie >>> 13, Me = w[3] | 0, be = Me & 8191, ie = Me >>> 13, le = w[4] | 0, ge = le & 8191, Ge = le >>> 13, je = w[5] | 0, Ne = je & 8191, nt = je >>> 13, st = w[6] | 0, Je = st & 8191, ft = st >>> 13, $ = w[7] | 0, X = $ & 8191, ne = $ >>> 13, O = w[8] | 0, ae = O & 8191, we = O >>> 13, xe = w[9] | 0, Re = xe & 8191, De = xe >>> 13;
      a.negative = g.negative ^ b.negative, a.length = 19, S = Math.imul(R, Ae), y = Math.imul(R, $e), y = y + Math.imul(ee, Ae) | 0, _ = Math.imul(ee, $e);
      var ze = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, S = Math.imul(V, Ae), y = Math.imul(V, $e), y = y + Math.imul(W, Ae) | 0, _ = Math.imul(W, $e), S = S + Math.imul(R, Ee) | 0, y = y + Math.imul(R, J) | 0, y = y + Math.imul(ee, Ee) | 0, _ = _ + Math.imul(ee, J) | 0;
      var Ue = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, S = Math.imul(re, Ae), y = Math.imul(re, $e), y = y + Math.imul(he, Ae) | 0, _ = Math.imul(he, $e), S = S + Math.imul(V, Ee) | 0, y = y + Math.imul(V, J) | 0, y = y + Math.imul(W, Ee) | 0, _ = _ + Math.imul(W, J) | 0, S = S + Math.imul(R, qe) | 0, y = y + Math.imul(R, P) | 0, y = y + Math.imul(ee, qe) | 0, _ = _ + Math.imul(ee, P) | 0;
      var mt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, S = Math.imul(K, Ae), y = Math.imul(K, $e), y = y + Math.imul(ce, Ae) | 0, _ = Math.imul(ce, $e), S = S + Math.imul(re, Ee) | 0, y = y + Math.imul(re, J) | 0, y = y + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, J) | 0, S = S + Math.imul(V, qe) | 0, y = y + Math.imul(V, P) | 0, y = y + Math.imul(W, qe) | 0, _ = _ + Math.imul(W, P) | 0, S = S + Math.imul(R, be) | 0, y = y + Math.imul(R, ie) | 0, y = y + Math.imul(ee, be) | 0, _ = _ + Math.imul(ee, ie) | 0;
      var et = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, S = Math.imul(Be, Ae), y = Math.imul(Be, $e), y = y + Math.imul(te, Ae) | 0, _ = Math.imul(te, $e), S = S + Math.imul(K, Ee) | 0, y = y + Math.imul(K, J) | 0, y = y + Math.imul(ce, Ee) | 0, _ = _ + Math.imul(ce, J) | 0, S = S + Math.imul(re, qe) | 0, y = y + Math.imul(re, P) | 0, y = y + Math.imul(he, qe) | 0, _ = _ + Math.imul(he, P) | 0, S = S + Math.imul(V, be) | 0, y = y + Math.imul(V, ie) | 0, y = y + Math.imul(W, be) | 0, _ = _ + Math.imul(W, ie) | 0, S = S + Math.imul(R, ge) | 0, y = y + Math.imul(R, Ge) | 0, y = y + Math.imul(ee, ge) | 0, _ = _ + Math.imul(ee, Ge) | 0;
      var ut = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, S = Math.imul(L, Ae), y = Math.imul(L, $e), y = y + Math.imul(G, Ae) | 0, _ = Math.imul(G, $e), S = S + Math.imul(Be, Ee) | 0, y = y + Math.imul(Be, J) | 0, y = y + Math.imul(te, Ee) | 0, _ = _ + Math.imul(te, J) | 0, S = S + Math.imul(K, qe) | 0, y = y + Math.imul(K, P) | 0, y = y + Math.imul(ce, qe) | 0, _ = _ + Math.imul(ce, P) | 0, S = S + Math.imul(re, be) | 0, y = y + Math.imul(re, ie) | 0, y = y + Math.imul(he, be) | 0, _ = _ + Math.imul(he, ie) | 0, S = S + Math.imul(V, ge) | 0, y = y + Math.imul(V, Ge) | 0, y = y + Math.imul(W, ge) | 0, _ = _ + Math.imul(W, Ge) | 0, S = S + Math.imul(R, Ne) | 0, y = y + Math.imul(R, nt) | 0, y = y + Math.imul(ee, Ne) | 0, _ = _ + Math.imul(ee, nt) | 0;
      var ct = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, S = Math.imul(me, Ae), y = Math.imul(me, $e), y = y + Math.imul(Te, Ae) | 0, _ = Math.imul(Te, $e), S = S + Math.imul(L, Ee) | 0, y = y + Math.imul(L, J) | 0, y = y + Math.imul(G, Ee) | 0, _ = _ + Math.imul(G, J) | 0, S = S + Math.imul(Be, qe) | 0, y = y + Math.imul(Be, P) | 0, y = y + Math.imul(te, qe) | 0, _ = _ + Math.imul(te, P) | 0, S = S + Math.imul(K, be) | 0, y = y + Math.imul(K, ie) | 0, y = y + Math.imul(ce, be) | 0, _ = _ + Math.imul(ce, ie) | 0, S = S + Math.imul(re, ge) | 0, y = y + Math.imul(re, Ge) | 0, y = y + Math.imul(he, ge) | 0, _ = _ + Math.imul(he, Ge) | 0, S = S + Math.imul(V, Ne) | 0, y = y + Math.imul(V, nt) | 0, y = y + Math.imul(W, Ne) | 0, _ = _ + Math.imul(W, nt) | 0, S = S + Math.imul(R, Je) | 0, y = y + Math.imul(R, ft) | 0, y = y + Math.imul(ee, Je) | 0, _ = _ + Math.imul(ee, ft) | 0;
      var vt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, S = Math.imul(H, Ae), y = Math.imul(H, $e), y = y + Math.imul(se, Ae) | 0, _ = Math.imul(se, $e), S = S + Math.imul(me, Ee) | 0, y = y + Math.imul(me, J) | 0, y = y + Math.imul(Te, Ee) | 0, _ = _ + Math.imul(Te, J) | 0, S = S + Math.imul(L, qe) | 0, y = y + Math.imul(L, P) | 0, y = y + Math.imul(G, qe) | 0, _ = _ + Math.imul(G, P) | 0, S = S + Math.imul(Be, be) | 0, y = y + Math.imul(Be, ie) | 0, y = y + Math.imul(te, be) | 0, _ = _ + Math.imul(te, ie) | 0, S = S + Math.imul(K, ge) | 0, y = y + Math.imul(K, Ge) | 0, y = y + Math.imul(ce, ge) | 0, _ = _ + Math.imul(ce, Ge) | 0, S = S + Math.imul(re, Ne) | 0, y = y + Math.imul(re, nt) | 0, y = y + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, nt) | 0, S = S + Math.imul(V, Je) | 0, y = y + Math.imul(V, ft) | 0, y = y + Math.imul(W, Je) | 0, _ = _ + Math.imul(W, ft) | 0, S = S + Math.imul(R, X) | 0, y = y + Math.imul(R, ne) | 0, y = y + Math.imul(ee, X) | 0, _ = _ + Math.imul(ee, ne) | 0;
      var pt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, S = Math.imul(_e, Ae), y = Math.imul(_e, $e), y = y + Math.imul(Ce, Ae) | 0, _ = Math.imul(Ce, $e), S = S + Math.imul(H, Ee) | 0, y = y + Math.imul(H, J) | 0, y = y + Math.imul(se, Ee) | 0, _ = _ + Math.imul(se, J) | 0, S = S + Math.imul(me, qe) | 0, y = y + Math.imul(me, P) | 0, y = y + Math.imul(Te, qe) | 0, _ = _ + Math.imul(Te, P) | 0, S = S + Math.imul(L, be) | 0, y = y + Math.imul(L, ie) | 0, y = y + Math.imul(G, be) | 0, _ = _ + Math.imul(G, ie) | 0, S = S + Math.imul(Be, ge) | 0, y = y + Math.imul(Be, Ge) | 0, y = y + Math.imul(te, ge) | 0, _ = _ + Math.imul(te, Ge) | 0, S = S + Math.imul(K, Ne) | 0, y = y + Math.imul(K, nt) | 0, y = y + Math.imul(ce, Ne) | 0, _ = _ + Math.imul(ce, nt) | 0, S = S + Math.imul(re, Je) | 0, y = y + Math.imul(re, ft) | 0, y = y + Math.imul(he, Je) | 0, _ = _ + Math.imul(he, ft) | 0, S = S + Math.imul(V, X) | 0, y = y + Math.imul(V, ne) | 0, y = y + Math.imul(W, X) | 0, _ = _ + Math.imul(W, ne) | 0, S = S + Math.imul(R, ae) | 0, y = y + Math.imul(R, we) | 0, y = y + Math.imul(ee, ae) | 0, _ = _ + Math.imul(ee, we) | 0;
      var ht = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, S = Math.imul(ke, Ae), y = Math.imul(ke, $e), y = y + Math.imul(Q, Ae) | 0, _ = Math.imul(Q, $e), S = S + Math.imul(_e, Ee) | 0, y = y + Math.imul(_e, J) | 0, y = y + Math.imul(Ce, Ee) | 0, _ = _ + Math.imul(Ce, J) | 0, S = S + Math.imul(H, qe) | 0, y = y + Math.imul(H, P) | 0, y = y + Math.imul(se, qe) | 0, _ = _ + Math.imul(se, P) | 0, S = S + Math.imul(me, be) | 0, y = y + Math.imul(me, ie) | 0, y = y + Math.imul(Te, be) | 0, _ = _ + Math.imul(Te, ie) | 0, S = S + Math.imul(L, ge) | 0, y = y + Math.imul(L, Ge) | 0, y = y + Math.imul(G, ge) | 0, _ = _ + Math.imul(G, Ge) | 0, S = S + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, nt) | 0, y = y + Math.imul(te, Ne) | 0, _ = _ + Math.imul(te, nt) | 0, S = S + Math.imul(K, Je) | 0, y = y + Math.imul(K, ft) | 0, y = y + Math.imul(ce, Je) | 0, _ = _ + Math.imul(ce, ft) | 0, S = S + Math.imul(re, X) | 0, y = y + Math.imul(re, ne) | 0, y = y + Math.imul(he, X) | 0, _ = _ + Math.imul(he, ne) | 0, S = S + Math.imul(V, ae) | 0, y = y + Math.imul(V, we) | 0, y = y + Math.imul(W, ae) | 0, _ = _ + Math.imul(W, we) | 0, S = S + Math.imul(R, Re) | 0, y = y + Math.imul(R, De) | 0, y = y + Math.imul(ee, Re) | 0, _ = _ + Math.imul(ee, De) | 0;
      var dt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, S = Math.imul(ke, Ee), y = Math.imul(ke, J), y = y + Math.imul(Q, Ee) | 0, _ = Math.imul(Q, J), S = S + Math.imul(_e, qe) | 0, y = y + Math.imul(_e, P) | 0, y = y + Math.imul(Ce, qe) | 0, _ = _ + Math.imul(Ce, P) | 0, S = S + Math.imul(H, be) | 0, y = y + Math.imul(H, ie) | 0, y = y + Math.imul(se, be) | 0, _ = _ + Math.imul(se, ie) | 0, S = S + Math.imul(me, ge) | 0, y = y + Math.imul(me, Ge) | 0, y = y + Math.imul(Te, ge) | 0, _ = _ + Math.imul(Te, Ge) | 0, S = S + Math.imul(L, Ne) | 0, y = y + Math.imul(L, nt) | 0, y = y + Math.imul(G, Ne) | 0, _ = _ + Math.imul(G, nt) | 0, S = S + Math.imul(Be, Je) | 0, y = y + Math.imul(Be, ft) | 0, y = y + Math.imul(te, Je) | 0, _ = _ + Math.imul(te, ft) | 0, S = S + Math.imul(K, X) | 0, y = y + Math.imul(K, ne) | 0, y = y + Math.imul(ce, X) | 0, _ = _ + Math.imul(ce, ne) | 0, S = S + Math.imul(re, ae) | 0, y = y + Math.imul(re, we) | 0, y = y + Math.imul(he, ae) | 0, _ = _ + Math.imul(he, we) | 0, S = S + Math.imul(V, Re) | 0, y = y + Math.imul(V, De) | 0, y = y + Math.imul(W, Re) | 0, _ = _ + Math.imul(W, De) | 0;
      var lt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, S = Math.imul(ke, qe), y = Math.imul(ke, P), y = y + Math.imul(Q, qe) | 0, _ = Math.imul(Q, P), S = S + Math.imul(_e, be) | 0, y = y + Math.imul(_e, ie) | 0, y = y + Math.imul(Ce, be) | 0, _ = _ + Math.imul(Ce, ie) | 0, S = S + Math.imul(H, ge) | 0, y = y + Math.imul(H, Ge) | 0, y = y + Math.imul(se, ge) | 0, _ = _ + Math.imul(se, Ge) | 0, S = S + Math.imul(me, Ne) | 0, y = y + Math.imul(me, nt) | 0, y = y + Math.imul(Te, Ne) | 0, _ = _ + Math.imul(Te, nt) | 0, S = S + Math.imul(L, Je) | 0, y = y + Math.imul(L, ft) | 0, y = y + Math.imul(G, Je) | 0, _ = _ + Math.imul(G, ft) | 0, S = S + Math.imul(Be, X) | 0, y = y + Math.imul(Be, ne) | 0, y = y + Math.imul(te, X) | 0, _ = _ + Math.imul(te, ne) | 0, S = S + Math.imul(K, ae) | 0, y = y + Math.imul(K, we) | 0, y = y + Math.imul(ce, ae) | 0, _ = _ + Math.imul(ce, we) | 0, S = S + Math.imul(re, Re) | 0, y = y + Math.imul(re, De) | 0, y = y + Math.imul(he, Re) | 0, _ = _ + Math.imul(he, De) | 0;
      var tt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, S = Math.imul(ke, be), y = Math.imul(ke, ie), y = y + Math.imul(Q, be) | 0, _ = Math.imul(Q, ie), S = S + Math.imul(_e, ge) | 0, y = y + Math.imul(_e, Ge) | 0, y = y + Math.imul(Ce, ge) | 0, _ = _ + Math.imul(Ce, Ge) | 0, S = S + Math.imul(H, Ne) | 0, y = y + Math.imul(H, nt) | 0, y = y + Math.imul(se, Ne) | 0, _ = _ + Math.imul(se, nt) | 0, S = S + Math.imul(me, Je) | 0, y = y + Math.imul(me, ft) | 0, y = y + Math.imul(Te, Je) | 0, _ = _ + Math.imul(Te, ft) | 0, S = S + Math.imul(L, X) | 0, y = y + Math.imul(L, ne) | 0, y = y + Math.imul(G, X) | 0, _ = _ + Math.imul(G, ne) | 0, S = S + Math.imul(Be, ae) | 0, y = y + Math.imul(Be, we) | 0, y = y + Math.imul(te, ae) | 0, _ = _ + Math.imul(te, we) | 0, S = S + Math.imul(K, Re) | 0, y = y + Math.imul(K, De) | 0, y = y + Math.imul(ce, Re) | 0, _ = _ + Math.imul(ce, De) | 0;
      var ot = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, S = Math.imul(ke, ge), y = Math.imul(ke, Ge), y = y + Math.imul(Q, ge) | 0, _ = Math.imul(Q, Ge), S = S + Math.imul(_e, Ne) | 0, y = y + Math.imul(_e, nt) | 0, y = y + Math.imul(Ce, Ne) | 0, _ = _ + Math.imul(Ce, nt) | 0, S = S + Math.imul(H, Je) | 0, y = y + Math.imul(H, ft) | 0, y = y + Math.imul(se, Je) | 0, _ = _ + Math.imul(se, ft) | 0, S = S + Math.imul(me, X) | 0, y = y + Math.imul(me, ne) | 0, y = y + Math.imul(Te, X) | 0, _ = _ + Math.imul(Te, ne) | 0, S = S + Math.imul(L, ae) | 0, y = y + Math.imul(L, we) | 0, y = y + Math.imul(G, ae) | 0, _ = _ + Math.imul(G, we) | 0, S = S + Math.imul(Be, Re) | 0, y = y + Math.imul(Be, De) | 0, y = y + Math.imul(te, Re) | 0, _ = _ + Math.imul(te, De) | 0;
      var Qe = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, S = Math.imul(ke, Ne), y = Math.imul(ke, nt), y = y + Math.imul(Q, Ne) | 0, _ = Math.imul(Q, nt), S = S + Math.imul(_e, Je) | 0, y = y + Math.imul(_e, ft) | 0, y = y + Math.imul(Ce, Je) | 0, _ = _ + Math.imul(Ce, ft) | 0, S = S + Math.imul(H, X) | 0, y = y + Math.imul(H, ne) | 0, y = y + Math.imul(se, X) | 0, _ = _ + Math.imul(se, ne) | 0, S = S + Math.imul(me, ae) | 0, y = y + Math.imul(me, we) | 0, y = y + Math.imul(Te, ae) | 0, _ = _ + Math.imul(Te, we) | 0, S = S + Math.imul(L, Re) | 0, y = y + Math.imul(L, De) | 0, y = y + Math.imul(G, Re) | 0, _ = _ + Math.imul(G, De) | 0;
      var rt = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, S = Math.imul(ke, Je), y = Math.imul(ke, ft), y = y + Math.imul(Q, Je) | 0, _ = Math.imul(Q, ft), S = S + Math.imul(_e, X) | 0, y = y + Math.imul(_e, ne) | 0, y = y + Math.imul(Ce, X) | 0, _ = _ + Math.imul(Ce, ne) | 0, S = S + Math.imul(H, ae) | 0, y = y + Math.imul(H, we) | 0, y = y + Math.imul(se, ae) | 0, _ = _ + Math.imul(se, we) | 0, S = S + Math.imul(me, Re) | 0, y = y + Math.imul(me, De) | 0, y = y + Math.imul(Te, Re) | 0, _ = _ + Math.imul(Te, De) | 0;
      var it = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, S = Math.imul(ke, X), y = Math.imul(ke, ne), y = y + Math.imul(Q, X) | 0, _ = Math.imul(Q, ne), S = S + Math.imul(_e, ae) | 0, y = y + Math.imul(_e, we) | 0, y = y + Math.imul(Ce, ae) | 0, _ = _ + Math.imul(Ce, we) | 0, S = S + Math.imul(H, Re) | 0, y = y + Math.imul(H, De) | 0, y = y + Math.imul(se, Re) | 0, _ = _ + Math.imul(se, De) | 0;
      var Ye = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, S = Math.imul(ke, ae), y = Math.imul(ke, we), y = y + Math.imul(Q, ae) | 0, _ = Math.imul(Q, we), S = S + Math.imul(_e, Re) | 0, y = y + Math.imul(_e, De) | 0, y = y + Math.imul(Ce, Re) | 0, _ = _ + Math.imul(Ce, De) | 0;
      var Oe = (A + S | 0) + ((y & 8191) << 13) | 0;
      A = (_ + (y >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, S = Math.imul(ke, Re), y = Math.imul(ke, De), y = y + Math.imul(Q, Re) | 0, _ = Math.imul(Q, De);
      var Pe = (A + S | 0) + ((y & 8191) << 13) | 0;
      return A = (_ + (y >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, x[0] = ze, x[1] = Ue, x[2] = mt, x[3] = et, x[4] = ut, x[5] = ct, x[6] = vt, x[7] = pt, x[8] = ht, x[9] = dt, x[10] = lt, x[11] = tt, x[12] = ot, x[13] = Qe, x[14] = rt, x[15] = it, x[16] = Ye, x[17] = Oe, x[18] = Pe, A !== 0 && (x[19] = A, a.length++), a;
    };
    Math.imul || (M = E);
    function I(j, g, b) {
      b.negative = g.negative ^ j.negative, b.length = j.length + g.length;
      for (var a = 0, d = 0, w = 0; w < b.length - 1; w++) {
        var x = d;
        d = 0;
        for (var A = a & 67108863, S = Math.min(w, g.length - 1), y = Math.max(0, w - j.length + 1); y <= S; y++) {
          var _ = w - y, l = j.words[_] | 0, R = g.words[y] | 0, ee = l * R, oe = ee & 67108863;
          x = x + (ee / 67108864 | 0) | 0, oe = oe + A | 0, A = oe & 67108863, x = x + (oe >>> 26) | 0, d += x >>> 26, x &= 67108863;
        }
        b.words[w] = A, a = x, x = d;
      }
      return a !== 0 ? b.words[w] = a : b.length--, b.strip();
    }
    function B(j, g, b) {
      var a = new T();
      return a.mulp(j, g, b);
    }
    n.prototype.mulTo = function(g, b) {
      var a, d = this.length + g.length;
      return this.length === 10 && g.length === 10 ? a = M(this, g, b) : d < 63 ? a = E(this, g, b) : d < 1024 ? a = I(this, g, b) : a = B(this, g, b), a;
    };
    function T(j, g) {
      this.x = j, this.y = g;
    }
    T.prototype.makeRBT = function(g) {
      for (var b = new Array(g), a = n.prototype._countBits(g) - 1, d = 0; d < g; d++)
        b[d] = this.revBin(d, a, g);
      return b;
    }, T.prototype.revBin = function(g, b, a) {
      if (g === 0 || g === a - 1)
        return g;
      for (var d = 0, w = 0; w < b; w++)
        d |= (g & 1) << b - w - 1, g >>= 1;
      return d;
    }, T.prototype.permute = function(g, b, a, d, w, x) {
      for (var A = 0; A < x; A++)
        d[A] = b[g[A]], w[A] = a[g[A]];
    }, T.prototype.transform = function(g, b, a, d, w, x) {
      this.permute(x, g, b, a, d, w);
      for (var A = 1; A < w; A <<= 1)
        for (var S = A << 1, y = Math.cos(2 * Math.PI / S), _ = Math.sin(2 * Math.PI / S), l = 0; l < w; l += S)
          for (var R = y, ee = _, oe = 0; oe < A; oe++) {
            var V = a[l + oe], W = d[l + oe], F = a[l + oe + A], re = d[l + oe + A], he = R * F - ee * re;
            re = R * re + ee * F, F = he, a[l + oe] = V + F, d[l + oe] = W + re, a[l + oe + A] = V - F, d[l + oe + A] = W - re, oe !== S && (he = y * R - _ * ee, ee = y * ee + _ * R, R = he);
          }
    }, T.prototype.guessLen13b = function(g, b) {
      var a = Math.max(b, g) | 1, d = a & 1, w = 0;
      for (a = a / 2 | 0; a; a = a >>> 1)
        w++;
      return 1 << w + 1 + d;
    }, T.prototype.conjugate = function(g, b, a) {
      if (!(a <= 1))
        for (var d = 0; d < a / 2; d++) {
          var w = g[d];
          g[d] = g[a - d - 1], g[a - d - 1] = w, w = b[d], b[d] = -b[a - d - 1], b[a - d - 1] = -w;
        }
    }, T.prototype.normalize13b = function(g, b) {
      for (var a = 0, d = 0; d < b / 2; d++) {
        var w = Math.round(g[2 * d + 1] / b) * 8192 + Math.round(g[2 * d] / b) + a;
        g[d] = w & 67108863, w < 67108864 ? a = 0 : a = w / 67108864 | 0;
      }
      return g;
    }, T.prototype.convert13b = function(g, b, a, d) {
      for (var w = 0, x = 0; x < b; x++)
        w = w + (g[x] | 0), a[2 * x] = w & 8191, w = w >>> 13, a[2 * x + 1] = w & 8191, w = w >>> 13;
      for (x = 2 * b; x < d; ++x)
        a[x] = 0;
      i(w === 0), i((w & -8192) === 0);
    }, T.prototype.stub = function(g) {
      for (var b = new Array(g), a = 0; a < g; a++)
        b[a] = 0;
      return b;
    }, T.prototype.mulp = function(g, b, a) {
      var d = 2 * this.guessLen13b(g.length, b.length), w = this.makeRBT(d), x = this.stub(d), A = new Array(d), S = new Array(d), y = new Array(d), _ = new Array(d), l = new Array(d), R = new Array(d), ee = a.words;
      ee.length = d, this.convert13b(g.words, g.length, A, d), this.convert13b(b.words, b.length, _, d), this.transform(A, x, S, y, d, w), this.transform(_, x, l, R, d, w);
      for (var oe = 0; oe < d; oe++) {
        var V = S[oe] * l[oe] - y[oe] * R[oe];
        y[oe] = S[oe] * R[oe] + y[oe] * l[oe], S[oe] = V;
      }
      return this.conjugate(S, y, d), this.transform(S, y, ee, x, d, w), this.conjugate(ee, x, d), this.normalize13b(ee, d), a.negative = g.negative ^ b.negative, a.length = g.length + b.length, a.strip();
    }, n.prototype.mul = function(g) {
      var b = new n(null);
      return b.words = new Array(this.length + g.length), this.mulTo(g, b);
    }, n.prototype.mulf = function(g) {
      var b = new n(null);
      return b.words = new Array(this.length + g.length), B(this, g, b);
    }, n.prototype.imul = function(g) {
      return this.clone().mulTo(g, this);
    }, n.prototype.imuln = function(g) {
      i(typeof g == "number"), i(g < 67108864);
      for (var b = 0, a = 0; a < this.length; a++) {
        var d = (this.words[a] | 0) * g, w = (d & 67108863) + (b & 67108863);
        b >>= 26, b += d / 67108864 | 0, b += w >>> 26, this.words[a] = w & 67108863;
      }
      return b !== 0 && (this.words[a] = b, this.length++), this;
    }, n.prototype.muln = function(g) {
      return this.clone().imuln(g);
    }, n.prototype.sqr = function() {
      return this.mul(this);
    }, n.prototype.isqr = function() {
      return this.imul(this.clone());
    }, n.prototype.pow = function(g) {
      var b = m(g);
      if (b.length === 0)
        return new n(1);
      for (var a = this, d = 0; d < b.length && b[d] === 0; d++, a = a.sqr())
        ;
      if (++d < b.length)
        for (var w = a.sqr(); d < b.length; d++, w = w.sqr())
          b[d] !== 0 && (a = a.mul(w));
      return a;
    }, n.prototype.iushln = function(g) {
      i(typeof g == "number" && g >= 0);
      var b = g % 26, a = (g - b) / 26, d = 67108863 >>> 26 - b << 26 - b, w;
      if (b !== 0) {
        var x = 0;
        for (w = 0; w < this.length; w++) {
          var A = this.words[w] & d, S = (this.words[w] | 0) - A << b;
          this.words[w] = S | x, x = A >>> 26 - b;
        }
        x && (this.words[w] = x, this.length++);
      }
      if (a !== 0) {
        for (w = this.length - 1; w >= 0; w--)
          this.words[w + a] = this.words[w];
        for (w = 0; w < a; w++)
          this.words[w] = 0;
        this.length += a;
      }
      return this.strip();
    }, n.prototype.ishln = function(g) {
      return i(this.negative === 0), this.iushln(g);
    }, n.prototype.iushrn = function(g, b, a) {
      i(typeof g == "number" && g >= 0);
      var d;
      b ? d = (b - b % 26) / 26 : d = 0;
      var w = g % 26, x = Math.min((g - w) / 26, this.length), A = 67108863 ^ 67108863 >>> w << w, S = a;
      if (d -= x, d = Math.max(0, d), S) {
        for (var y = 0; y < x; y++)
          S.words[y] = this.words[y];
        S.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + x];
        else
          this.words[0] = 0, this.length = 1;
      var _ = 0;
      for (y = this.length - 1; y >= 0 && (_ !== 0 || y >= d); y--) {
        var l = this.words[y] | 0;
        this.words[y] = _ << 26 - w | l >>> w, _ = l & A;
      }
      return S && _ !== 0 && (S.words[S.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, n.prototype.ishrn = function(g, b, a) {
      return i(this.negative === 0), this.iushrn(g, b, a);
    }, n.prototype.shln = function(g) {
      return this.clone().ishln(g);
    }, n.prototype.ushln = function(g) {
      return this.clone().iushln(g);
    }, n.prototype.shrn = function(g) {
      return this.clone().ishrn(g);
    }, n.prototype.ushrn = function(g) {
      return this.clone().iushrn(g);
    }, n.prototype.testn = function(g) {
      i(typeof g == "number" && g >= 0);
      var b = g % 26, a = (g - b) / 26, d = 1 << b;
      if (this.length <= a)
        return !1;
      var w = this.words[a];
      return !!(w & d);
    }, n.prototype.imaskn = function(g) {
      i(typeof g == "number" && g >= 0);
      var b = g % 26, a = (g - b) / 26;
      if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= a)
        return this;
      if (b !== 0 && a++, this.length = Math.min(a, this.length), b !== 0) {
        var d = 67108863 ^ 67108863 >>> b << b;
        this.words[this.length - 1] &= d;
      }
      return this.strip();
    }, n.prototype.maskn = function(g) {
      return this.clone().imaskn(g);
    }, n.prototype.iaddn = function(g) {
      return i(typeof g == "number"), i(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
    }, n.prototype._iaddn = function(g) {
      this.words[0] += g;
      for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
        this.words[b] -= 67108864, b === this.length - 1 ? this.words[b + 1] = 1 : this.words[b + 1]++;
      return this.length = Math.max(this.length, b + 1), this;
    }, n.prototype.isubn = function(g) {
      if (i(typeof g == "number"), i(g < 67108864), g < 0)
        return this.iaddn(-g);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(g), this.negative = 1, this;
      if (this.words[0] -= g, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var b = 0; b < this.length && this.words[b] < 0; b++)
          this.words[b] += 67108864, this.words[b + 1] -= 1;
      return this.strip();
    }, n.prototype.addn = function(g) {
      return this.clone().iaddn(g);
    }, n.prototype.subn = function(g) {
      return this.clone().isubn(g);
    }, n.prototype.iabs = function() {
      return this.negative = 0, this;
    }, n.prototype.abs = function() {
      return this.clone().iabs();
    }, n.prototype._ishlnsubmul = function(g, b, a) {
      var d = g.length + a, w;
      this._expand(d);
      var x, A = 0;
      for (w = 0; w < g.length; w++) {
        x = (this.words[w + a] | 0) + A;
        var S = (g.words[w] | 0) * b;
        x -= S & 67108863, A = (x >> 26) - (S / 67108864 | 0), this.words[w + a] = x & 67108863;
      }
      for (; w < this.length - a; w++)
        x = (this.words[w + a] | 0) + A, A = x >> 26, this.words[w + a] = x & 67108863;
      if (A === 0)
        return this.strip();
      for (i(A === -1), A = 0, w = 0; w < this.length; w++)
        x = -(this.words[w] | 0) + A, A = x >> 26, this.words[w] = x & 67108863;
      return this.negative = 1, this.strip();
    }, n.prototype._wordDiv = function(g, b) {
      var a = this.length - g.length, d = this.clone(), w = g, x = w.words[w.length - 1] | 0, A = this._countBits(x);
      a = 26 - A, a !== 0 && (w = w.ushln(a), d.iushln(a), x = w.words[w.length - 1] | 0);
      var S = d.length - w.length, y;
      if (b !== "mod") {
        y = new n(null), y.length = S + 1, y.words = new Array(y.length);
        for (var _ = 0; _ < y.length; _++)
          y.words[_] = 0;
      }
      var l = d.clone()._ishlnsubmul(w, 1, S);
      l.negative === 0 && (d = l, y && (y.words[S] = 1));
      for (var R = S - 1; R >= 0; R--) {
        var ee = (d.words[w.length + R] | 0) * 67108864 + (d.words[w.length + R - 1] | 0);
        for (ee = Math.min(ee / x | 0, 67108863), d._ishlnsubmul(w, ee, R); d.negative !== 0; )
          ee--, d.negative = 0, d._ishlnsubmul(w, 1, R), d.isZero() || (d.negative ^= 1);
        y && (y.words[R] = ee);
      }
      return y && y.strip(), d.strip(), b !== "div" && a !== 0 && d.iushrn(a), {
        div: y || null,
        mod: d
      };
    }, n.prototype.divmod = function(g, b, a) {
      if (i(!g.isZero()), this.isZero())
        return {
          div: new n(0),
          mod: new n(0)
        };
      var d, w, x;
      return this.negative !== 0 && g.negative === 0 ? (x = this.neg().divmod(g, b), b !== "mod" && (d = x.div.neg()), b !== "div" && (w = x.mod.neg(), a && w.negative !== 0 && w.iadd(g)), {
        div: d,
        mod: w
      }) : this.negative === 0 && g.negative !== 0 ? (x = this.divmod(g.neg(), b), b !== "mod" && (d = x.div.neg()), {
        div: d,
        mod: x.mod
      }) : this.negative & g.negative ? (x = this.neg().divmod(g.neg(), b), b !== "div" && (w = x.mod.neg(), a && w.negative !== 0 && w.isub(g)), {
        div: x.div,
        mod: w
      }) : g.length > this.length || this.cmp(g) < 0 ? {
        div: new n(0),
        mod: this
      } : g.length === 1 ? b === "div" ? {
        div: this.divn(g.words[0]),
        mod: null
      } : b === "mod" ? {
        div: null,
        mod: new n(this.modn(g.words[0]))
      } : {
        div: this.divn(g.words[0]),
        mod: new n(this.modn(g.words[0]))
      } : this._wordDiv(g, b);
    }, n.prototype.div = function(g) {
      return this.divmod(g, "div", !1).div;
    }, n.prototype.mod = function(g) {
      return this.divmod(g, "mod", !1).mod;
    }, n.prototype.umod = function(g) {
      return this.divmod(g, "mod", !0).mod;
    }, n.prototype.divRound = function(g) {
      var b = this.divmod(g);
      if (b.mod.isZero())
        return b.div;
      var a = b.div.negative !== 0 ? b.mod.isub(g) : b.mod, d = g.ushrn(1), w = g.andln(1), x = a.cmp(d);
      return x < 0 || w === 1 && x === 0 ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1);
    }, n.prototype.modn = function(g) {
      i(g <= 67108863);
      for (var b = (1 << 26) % g, a = 0, d = this.length - 1; d >= 0; d--)
        a = (b * a + (this.words[d] | 0)) % g;
      return a;
    }, n.prototype.idivn = function(g) {
      i(g <= 67108863);
      for (var b = 0, a = this.length - 1; a >= 0; a--) {
        var d = (this.words[a] | 0) + b * 67108864;
        this.words[a] = d / g | 0, b = d % g;
      }
      return this.strip();
    }, n.prototype.divn = function(g) {
      return this.clone().idivn(g);
    }, n.prototype.egcd = function(g) {
      i(g.negative === 0), i(!g.isZero());
      var b = this, a = g.clone();
      b.negative !== 0 ? b = b.umod(g) : b = b.clone();
      for (var d = new n(1), w = new n(0), x = new n(0), A = new n(1), S = 0; b.isEven() && a.isEven(); )
        b.iushrn(1), a.iushrn(1), ++S;
      for (var y = a.clone(), _ = b.clone(); !b.isZero(); ) {
        for (var l = 0, R = 1; !(b.words[0] & R) && l < 26; ++l, R <<= 1)
          ;
        if (l > 0)
          for (b.iushrn(l); l-- > 0; )
            (d.isOdd() || w.isOdd()) && (d.iadd(y), w.isub(_)), d.iushrn(1), w.iushrn(1);
        for (var ee = 0, oe = 1; !(a.words[0] & oe) && ee < 26; ++ee, oe <<= 1)
          ;
        if (ee > 0)
          for (a.iushrn(ee); ee-- > 0; )
            (x.isOdd() || A.isOdd()) && (x.iadd(y), A.isub(_)), x.iushrn(1), A.iushrn(1);
        b.cmp(a) >= 0 ? (b.isub(a), d.isub(x), w.isub(A)) : (a.isub(b), x.isub(d), A.isub(w));
      }
      return {
        a: x,
        b: A,
        gcd: a.iushln(S)
      };
    }, n.prototype._invmp = function(g) {
      i(g.negative === 0), i(!g.isZero());
      var b = this, a = g.clone();
      b.negative !== 0 ? b = b.umod(g) : b = b.clone();
      for (var d = new n(1), w = new n(0), x = a.clone(); b.cmpn(1) > 0 && a.cmpn(1) > 0; ) {
        for (var A = 0, S = 1; !(b.words[0] & S) && A < 26; ++A, S <<= 1)
          ;
        if (A > 0)
          for (b.iushrn(A); A-- > 0; )
            d.isOdd() && d.iadd(x), d.iushrn(1);
        for (var y = 0, _ = 1; !(a.words[0] & _) && y < 26; ++y, _ <<= 1)
          ;
        if (y > 0)
          for (a.iushrn(y); y-- > 0; )
            w.isOdd() && w.iadd(x), w.iushrn(1);
        b.cmp(a) >= 0 ? (b.isub(a), d.isub(w)) : (a.isub(b), w.isub(d));
      }
      var l;
      return b.cmpn(1) === 0 ? l = d : l = w, l.cmpn(0) < 0 && l.iadd(g), l;
    }, n.prototype.gcd = function(g) {
      if (this.isZero())
        return g.abs();
      if (g.isZero())
        return this.abs();
      var b = this.clone(), a = g.clone();
      b.negative = 0, a.negative = 0;
      for (var d = 0; b.isEven() && a.isEven(); d++)
        b.iushrn(1), a.iushrn(1);
      do {
        for (; b.isEven(); )
          b.iushrn(1);
        for (; a.isEven(); )
          a.iushrn(1);
        var w = b.cmp(a);
        if (w < 0) {
          var x = b;
          b = a, a = x;
        } else if (w === 0 || a.cmpn(1) === 0)
          break;
        b.isub(a);
      } while (!0);
      return a.iushln(d);
    }, n.prototype.invm = function(g) {
      return this.egcd(g).a.umod(g);
    }, n.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, n.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, n.prototype.andln = function(g) {
      return this.words[0] & g;
    }, n.prototype.bincn = function(g) {
      i(typeof g == "number");
      var b = g % 26, a = (g - b) / 26, d = 1 << b;
      if (this.length <= a)
        return this._expand(a + 1), this.words[a] |= d, this;
      for (var w = d, x = a; w !== 0 && x < this.length; x++) {
        var A = this.words[x] | 0;
        A += w, w = A >>> 26, A &= 67108863, this.words[x] = A;
      }
      return w !== 0 && (this.words[x] = w, this.length++), this;
    }, n.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, n.prototype.cmpn = function(g) {
      var b = g < 0;
      if (this.negative !== 0 && !b)
        return -1;
      if (this.negative === 0 && b)
        return 1;
      this.strip();
      var a;
      if (this.length > 1)
        a = 1;
      else {
        b && (g = -g), i(g <= 67108863, "Number is too big");
        var d = this.words[0] | 0;
        a = d === g ? 0 : d < g ? -1 : 1;
      }
      return this.negative !== 0 ? -a | 0 : a;
    }, n.prototype.cmp = function(g) {
      if (this.negative !== 0 && g.negative === 0)
        return -1;
      if (this.negative === 0 && g.negative !== 0)
        return 1;
      var b = this.ucmp(g);
      return this.negative !== 0 ? -b | 0 : b;
    }, n.prototype.ucmp = function(g) {
      if (this.length > g.length)
        return 1;
      if (this.length < g.length)
        return -1;
      for (var b = 0, a = this.length - 1; a >= 0; a--) {
        var d = this.words[a] | 0, w = g.words[a] | 0;
        if (d !== w) {
          d < w ? b = -1 : d > w && (b = 1);
          break;
        }
      }
      return b;
    }, n.prototype.gtn = function(g) {
      return this.cmpn(g) === 1;
    }, n.prototype.gt = function(g) {
      return this.cmp(g) === 1;
    }, n.prototype.gten = function(g) {
      return this.cmpn(g) >= 0;
    }, n.prototype.gte = function(g) {
      return this.cmp(g) >= 0;
    }, n.prototype.ltn = function(g) {
      return this.cmpn(g) === -1;
    }, n.prototype.lt = function(g) {
      return this.cmp(g) === -1;
    }, n.prototype.lten = function(g) {
      return this.cmpn(g) <= 0;
    }, n.prototype.lte = function(g) {
      return this.cmp(g) <= 0;
    }, n.prototype.eqn = function(g) {
      return this.cmpn(g) === 0;
    }, n.prototype.eq = function(g) {
      return this.cmp(g) === 0;
    }, n.red = function(g) {
      return new Y(g);
    }, n.prototype.toRed = function(g) {
      return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
    }, n.prototype.fromRed = function() {
      return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, n.prototype._forceRed = function(g) {
      return this.red = g, this;
    }, n.prototype.forceRed = function(g) {
      return i(!this.red, "Already a number in reduction context"), this._forceRed(g);
    }, n.prototype.redAdd = function(g) {
      return i(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
    }, n.prototype.redIAdd = function(g) {
      return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
    }, n.prototype.redSub = function(g) {
      return i(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
    }, n.prototype.redISub = function(g) {
      return i(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
    }, n.prototype.redShl = function(g) {
      return i(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
    }, n.prototype.redMul = function(g) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
    }, n.prototype.redIMul = function(g) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
    }, n.prototype.redSqr = function() {
      return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, n.prototype.redISqr = function() {
      return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, n.prototype.redSqrt = function() {
      return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, n.prototype.redInvm = function() {
      return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, n.prototype.redNeg = function() {
      return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, n.prototype.redPow = function(g) {
      return i(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
    };
    var k = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function N(j, g) {
      this.name = j, this.p = new n(g, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    N.prototype._tmp = function() {
      var g = new n(null);
      return g.words = new Array(Math.ceil(this.n / 13)), g;
    }, N.prototype.ireduce = function(g) {
      var b = g, a;
      do
        this.split(b, this.tmp), b = this.imulK(b), b = b.iadd(this.tmp), a = b.bitLength();
      while (a > this.n);
      var d = a < this.n ? -1 : b.ucmp(this.p);
      return d === 0 ? (b.words[0] = 0, b.length = 1) : d > 0 ? b.isub(this.p) : b.strip !== void 0 ? b.strip() : b._strip(), b;
    }, N.prototype.split = function(g, b) {
      g.iushrn(this.n, 0, b);
    }, N.prototype.imulK = function(g) {
      return g.imul(this.k);
    };
    function q() {
      N.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    o(q, N), q.prototype.split = function(g, b) {
      for (var a = 4194303, d = Math.min(g.length, 9), w = 0; w < d; w++)
        b.words[w] = g.words[w];
      if (b.length = d, g.length <= 9) {
        g.words[0] = 0, g.length = 1;
        return;
      }
      var x = g.words[9];
      for (b.words[b.length++] = x & a, w = 10; w < g.length; w++) {
        var A = g.words[w] | 0;
        g.words[w - 10] = (A & a) << 4 | x >>> 22, x = A;
      }
      x >>>= 22, g.words[w - 10] = x, x === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
    }, q.prototype.imulK = function(g) {
      g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
      for (var b = 0, a = 0; a < g.length; a++) {
        var d = g.words[a] | 0;
        b += d * 977, g.words[a] = b & 67108863, b = d * 64 + (b / 67108864 | 0);
      }
      return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
    };
    function D() {
      N.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    o(D, N);
    function U() {
      N.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    o(U, N);
    function z() {
      N.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    o(z, N), z.prototype.imulK = function(g) {
      for (var b = 0, a = 0; a < g.length; a++) {
        var d = (g.words[a] | 0) * 19 + b, w = d & 67108863;
        d >>>= 26, g.words[a] = w, b = d;
      }
      return b !== 0 && (g.words[g.length++] = b), g;
    }, n._prime = function(g) {
      if (k[g])
        return k[g];
      var b;
      if (g === "k256")
        b = new q();
      else if (g === "p224")
        b = new D();
      else if (g === "p192")
        b = new U();
      else if (g === "p25519")
        b = new z();
      else
        throw new Error("Unknown prime " + g);
      return k[g] = b, b;
    };
    function Y(j) {
      if (typeof j == "string") {
        var g = n._prime(j);
        this.m = g.p, this.prime = g;
      } else
        i(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
    }
    Y.prototype._verify1 = function(g) {
      i(g.negative === 0, "red works only with positives"), i(g.red, "red works only with red numbers");
    }, Y.prototype._verify2 = function(g, b) {
      i((g.negative | b.negative) === 0, "red works only with positives"), i(
        g.red && g.red === b.red,
        "red works only with red numbers"
      );
    }, Y.prototype.imod = function(g) {
      return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this);
    }, Y.prototype.neg = function(g) {
      return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
    }, Y.prototype.add = function(g, b) {
      this._verify2(g, b);
      var a = g.add(b);
      return a.cmp(this.m) >= 0 && a.isub(this.m), a._forceRed(this);
    }, Y.prototype.iadd = function(g, b) {
      this._verify2(g, b);
      var a = g.iadd(b);
      return a.cmp(this.m) >= 0 && a.isub(this.m), a;
    }, Y.prototype.sub = function(g, b) {
      this._verify2(g, b);
      var a = g.sub(b);
      return a.cmpn(0) < 0 && a.iadd(this.m), a._forceRed(this);
    }, Y.prototype.isub = function(g, b) {
      this._verify2(g, b);
      var a = g.isub(b);
      return a.cmpn(0) < 0 && a.iadd(this.m), a;
    }, Y.prototype.shl = function(g, b) {
      return this._verify1(g), this.imod(g.ushln(b));
    }, Y.prototype.imul = function(g, b) {
      return this._verify2(g, b), this.imod(g.imul(b));
    }, Y.prototype.mul = function(g, b) {
      return this._verify2(g, b), this.imod(g.mul(b));
    }, Y.prototype.isqr = function(g) {
      return this.imul(g, g.clone());
    }, Y.prototype.sqr = function(g) {
      return this.mul(g, g);
    }, Y.prototype.sqrt = function(g) {
      if (g.isZero())
        return g.clone();
      var b = this.m.andln(3);
      if (i(b % 2 === 1), b === 3) {
        var a = this.m.add(new n(1)).iushrn(2);
        return this.pow(g, a);
      }
      for (var d = this.m.subn(1), w = 0; !d.isZero() && d.andln(1) === 0; )
        w++, d.iushrn(1);
      i(!d.isZero());
      var x = new n(1).toRed(this), A = x.redNeg(), S = this.m.subn(1).iushrn(1), y = this.m.bitLength();
      for (y = new n(2 * y * y).toRed(this); this.pow(y, S).cmp(A) !== 0; )
        y.redIAdd(A);
      for (var _ = this.pow(y, d), l = this.pow(g, d.addn(1).iushrn(1)), R = this.pow(g, d), ee = w; R.cmp(x) !== 0; ) {
        for (var oe = R, V = 0; oe.cmp(x) !== 0; V++)
          oe = oe.redSqr();
        i(V < ee);
        var W = this.pow(_, new n(1).iushln(ee - V - 1));
        l = l.redMul(W), _ = W.redSqr(), R = R.redMul(_), ee = V;
      }
      return l;
    }, Y.prototype.invm = function(g) {
      var b = g._invmp(this.m);
      return b.negative !== 0 ? (b.negative = 0, this.imod(b).redNeg()) : this.imod(b);
    }, Y.prototype.pow = function(g, b) {
      if (b.isZero())
        return new n(1).toRed(this);
      if (b.cmpn(1) === 0)
        return g.clone();
      var a = 4, d = new Array(1 << a);
      d[0] = new n(1).toRed(this), d[1] = g;
      for (var w = 2; w < d.length; w++)
        d[w] = this.mul(d[w - 1], g);
      var x = d[0], A = 0, S = 0, y = b.bitLength() % 26;
      for (y === 0 && (y = 26), w = b.length - 1; w >= 0; w--) {
        for (var _ = b.words[w], l = y - 1; l >= 0; l--) {
          var R = _ >> l & 1;
          if (x !== d[0] && (x = this.sqr(x)), R === 0 && A === 0) {
            S = 0;
            continue;
          }
          A <<= 1, A |= R, S++, !(S !== a && (w !== 0 || l !== 0)) && (x = this.mul(x, d[A]), S = 0, A = 0);
        }
        y = 26;
      }
      return x;
    }, Y.prototype.convertTo = function(g) {
      var b = g.umod(this.m);
      return b === g ? b.clone() : b;
    }, Y.prototype.convertFrom = function(g) {
      var b = g.clone();
      return b.red = null, b;
    }, n.mont = function(g) {
      return new ue(g);
    };
    function ue(j) {
      Y.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o(ue, Y), ue.prototype.convertTo = function(g) {
      return this.imod(g.ushln(this.shift));
    }, ue.prototype.convertFrom = function(g) {
      var b = this.imod(g.mul(this.rinv));
      return b.red = null, b;
    }, ue.prototype.imul = function(g, b) {
      if (g.isZero() || b.isZero())
        return g.words[0] = 0, g.length = 1, g;
      var a = g.imul(b), d = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = a.isub(d).iushrn(this.shift), x = w;
      return w.cmp(this.m) >= 0 ? x = w.isub(this.m) : w.cmpn(0) < 0 && (x = w.iadd(this.m)), x._forceRed(this);
    }, ue.prototype.mul = function(g, b) {
      if (g.isZero() || b.isZero())
        return new n(0)._forceRed(this);
      var a = g.mul(b), d = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = a.isub(d).iushrn(this.shift), x = w;
      return w.cmp(this.m) >= 0 ? x = w.isub(this.m) : w.cmpn(0) < 0 && (x = w.iadd(this.m)), x._forceRed(this);
    }, ue.prototype.invm = function(g) {
      var b = this.imod(g._invmp(this.m).mul(this.r2));
      return b._forceRed(this);
    };
  })(e, Ze);
})(d0);
var ar = d0.exports, $E = Ze && Ze.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.rawEncode = Pn.parseNumber = Pn.solidityPack = void 0;
const In = Ra, Tn = $E(ar), DE = l0, wg = rr;
function jE(e, t) {
  if (e.length !== t.length)
    throw new Error("Number of types are not matching the values");
  const r = [];
  for (let i = 0; i < e.length; i++) {
    const o = xg(e[i]), n = t[i];
    r.push(_g(o, n, null));
  }
  return Le.Buffer.concat(r);
}
Pn.solidityPack = jE;
function _o(e) {
  return e.endsWith("]");
}
function df(e) {
  const t = e.match(/(.*)\[(.*?)\]$/u);
  return t ? t[2] === "" ? "dynamic" : parseInt(t[2], 10) : null;
}
function Ii(e) {
  const t = /^\D+(\d+)$/u.exec(e);
  if (t === null)
    throw new Error(`Invalid parseTypeN input "${e}".`);
  return parseInt(t[1], 10);
}
function Bn(e) {
  const t = typeof e;
  if (t === "string")
    return (0, In.isHexPrefixed)(e) ? new Tn.default((0, DE.stripHexPrefix)(e), 16) : new Tn.default(e, 10);
  if (t === "number")
    return new Tn.default(e);
  if (e && Object.prototype.hasOwnProperty.call(e, "toArray") || Tn.default.isBN(e))
    return e;
  throw new Error("Argument is not a number");
}
Pn.parseNumber = Bn;
function _g(e, t, r) {
  if (_o(e)) {
    const i = e.replace(/\[.*?\]/u, "");
    if (!_o(i)) {
      const n = df(e);
      if (n !== "dynamic" && n !== 0 && n !== null && t.length > n)
        throw new Error(`Elements exceed array size: ${n}`);
    }
    const o = t.map((n) => _g(i, n, 256));
    return Le.Buffer.concat(o);
  } else {
    if (e === "bytes")
      return t;
    if (e === "string")
      return Le.Buffer.from(t, "utf8");
    if (e === "bool") {
      r = r || 8;
      const i = Array(r / 4).join("0");
      return Le.Buffer.from(t ? `${i}1` : `${i}0`, "hex");
    } else if (e === "address") {
      let i = 20;
      return r && (i = r / 8), (0, In.setLengthLeft)((0, In.toBuffer)(t), i);
    } else if (e.startsWith("bytes")) {
      const i = Ii(e);
      if (i < 1 || i > 32)
        throw new Error(`Invalid bytes<N> width: ${i}`);
      return typeof t == "number" && (t = (0, wg.normalize)(t)), (0, In.setLengthRight)((0, In.toBuffer)(t), i);
    } else if (e.startsWith("uint")) {
      const i = Ii(e);
      if (i % 8 || i < 8 || i > 256)
        throw new Error(`Invalid uint<N> width: ${i}`);
      const o = Bn(t);
      if (o.bitLength() > i)
        throw new Error(`Supplied uint exceeds width: ${i} vs ${o.bitLength()}`);
      return r = r || i, o.toArrayLike(Le.Buffer, "be", r / 8);
    } else if (e.startsWith("int")) {
      const i = Ii(e);
      if (i % 8 || i < 8 || i > 256)
        throw new Error(`Invalid int<N> width: ${i}`);
      const o = Bn(t);
      if (o.bitLength() > i)
        throw new Error(`Supplied int exceeds width: ${i} vs ${o.bitLength()}`);
      return r = r || i, o.toTwos(i).toArrayLike(Le.Buffer, "be", r / 8);
    }
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function xg(e) {
  return e.startsWith("int[") ? `int256${e.slice(3)}` : e === "int" ? "int256" : e.startsWith("uint[") ? `uint256${e.slice(4)}` : e === "uint" ? "uint256" : e.startsWith("fixed[") ? `fixed128x128${e.slice(5)}` : e === "fixed" ? "fixed128x128" : e.startsWith("ufixed[") ? `ufixed128x128${e.slice(6)}` : e === "ufixed" ? "ufixed128x128" : e;
}
function UE(e, t) {
  const r = [], i = [];
  let o = 0;
  e.forEach((n) => {
    if (_o(n)) {
      const f = df(n);
      f !== "dynamic" && f !== null ? o += 32 * f : o += 32;
    } else
      o += 32;
  });
  for (let n = 0; n < e.length; n++) {
    const f = xg(e[n]), u = t[n], c = tn(f, u);
    FE(f) ? (r.push(tn("uint256", o)), i.push(c), o += c.length) : r.push(c);
  }
  return Le.Buffer.concat(r.concat(i));
}
Pn.rawEncode = UE;
function tn(e, t) {
  if (e === "address")
    return tn("uint160", Bn(t));
  if (e === "bool")
    return tn("uint8", t ? 1 : 0);
  if (e === "string")
    return tn("bytes", Le.Buffer.from(t, "utf8"));
  if (_o(e)) {
    if (typeof t.length > "u")
      throw new Error("Not an array?");
    const r = df(e);
    if (r !== "dynamic" && r !== 0 && r !== null && t.length > r)
      throw new Error(`Elements exceed array size: ${r}`);
    const i = [];
    e = e.slice(0, e.lastIndexOf("[")), typeof t == "string" && (t = JSON.parse(t));
    for (const o in t)
      Object.prototype.hasOwnProperty.call(t, o) && i.push(tn(e, t[o]));
    if (r === "dynamic") {
      const o = tn("uint256", t.length);
      i.unshift(o);
    }
    return Le.Buffer.concat(i);
  } else if (e === "bytes") {
    t = Le.Buffer.from(t);
    let r = Le.Buffer.concat([tn("uint256", t.length), t]);
    return t.length % 32 !== 0 && (r = Le.Buffer.concat([r, (0, In.zeros)(32 - t.length % 32)])), r;
  } else if (e.startsWith("bytes")) {
    const r = Ii(e);
    if (r < 1 || r > 32)
      throw new Error(`Invalid bytes<N> width: ${r}`);
    const i = typeof t == "number" ? (0, wg.normalize)(t) : t;
    return (0, In.setLengthRight)((0, In.toBuffer)(i), 32);
  } else if (e.startsWith("uint")) {
    const r = Ii(e);
    if (r % 8 || r < 8 || r > 256)
      throw new Error(`Invalid uint<N> width: ${r}`);
    const i = Bn(t);
    if (i.bitLength() > r)
      throw new Error(`Supplied uint exceeds width: ${r} vs ${i.bitLength()}`);
    if (i.isNeg())
      throw new Error("Supplied uint is negative");
    return i.toArrayLike(Le.Buffer, "be", 32);
  } else if (e.startsWith("int")) {
    const r = Ii(e);
    if (r % 8 || r < 8 || r > 256)
      throw new Error(`Invalid int<N> width: ${r}`);
    const i = Bn(t);
    if (i.bitLength() > r)
      throw new Error(`Supplied int exceeds width: ${r} vs ${i.bitLength()}`);
    return i.toTwos(256).toArrayLike(Le.Buffer, "be", 32);
  } else if (e.startsWith("ufixed")) {
    const r = p1(e), i = Bn(t);
    if (i.isNeg())
      throw new Error("Supplied ufixed is negative");
    return tn("uint256", i.mul(new Tn.default(2).pow(new Tn.default(r[1]))));
  } else if (e.startsWith("fixed")) {
    const r = p1(e);
    return tn("int256", Bn(t).mul(new Tn.default(2).pow(new Tn.default(r[1]))));
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function FE(e) {
  return e === "string" || e === "bytes" || df(e) === "dynamic";
}
function p1(e) {
  const t = /^\D+(\d+)x(\d+)$/u.exec(e);
  if (t === null || t.length < 1)
    throw new Error(`Invalid parseTypeNxM input "${e}".`);
  return [parseInt(t[1], 10), parseInt(t[2], 10)];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.recoverTypedSignature = e.signTypedData = e.typedSignatureHash = e.TypedDataUtils = e.TYPED_MESSAGE_SCHEMA = e.SignTypedDataVersion = void 0;
  const t = Ra, r = jr, i = l0, o = Pn, n = rr;
  var f;
  (function(q) {
    q.V1 = "V1", q.V3 = "V3", q.V4 = "V4";
  })(f = e.SignTypedDataVersion || (e.SignTypedDataVersion = {})), e.TYPED_MESSAGE_SCHEMA = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  };
  function u(q, D) {
    if (Object.keys(f).includes(q)) {
      if (D && !D.includes(q))
        throw new Error(`SignTypedDataVersion not allowed: '${q}'. Allowed versions are: ${D.join(", ")}`);
    } else
      throw new Error(`Invalid version: '${q}'`);
  }
  function c(q, D, U, z, Y) {
    if (u(Y, [f.V3, f.V4]), q[U] !== void 0)
      return [
        "bytes32",
        // TODO: return Buffer, remove string from return type
        Y === f.V4 && z == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, t.arrToBufArr)((0, r.keccak256)(h(U, z, q, Y)))
      ];
    if (z === void 0)
      throw new Error(`missing value for field ${D} of type ${U}`);
    if (U === "bytes") {
      if (typeof z == "number")
        z = (0, n.numberToBuffer)(z);
      else if ((0, i.isHexString)(z)) {
        const ue = z.length % 2 ? "0" : "";
        z = Le.Buffer.from(ue + z.slice(2), "hex");
      } else
        z = Le.Buffer.from(z, "utf8");
      return ["bytes32", (0, t.arrToBufArr)((0, r.keccak256)(z))];
    }
    if (U === "string")
      return typeof z == "number" ? z = (0, n.numberToBuffer)(z) : z = Le.Buffer.from(z ?? "", "utf8"), ["bytes32", (0, t.arrToBufArr)((0, r.keccak256)(z))];
    if (U.endsWith("]")) {
      if (Y === f.V3)
        throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
      const ue = U.slice(0, U.lastIndexOf("[")), j = z.map((g) => c(q, D, ue, g, Y));
      return [
        "bytes32",
        (0, t.arrToBufArr)((0, r.keccak256)((0, o.rawEncode)(j.map(([g]) => g), j.map(([, g]) => g))))
      ];
    }
    return [U, z];
  }
  function h(q, D, U, z) {
    u(z, [f.V3, f.V4]);
    const Y = ["bytes32"], ue = [m(q, U)];
    for (const j of U[q]) {
      if (z === f.V3 && D[j.name] === void 0)
        continue;
      const [g, b] = c(U, j.name, j.type, D[j.name], z);
      Y.push(g), ue.push(b);
    }
    return (0, o.rawEncode)(Y, ue);
  }
  function s(q, D) {
    let U = "";
    const z = p(q, D);
    z.delete(q);
    const Y = [q, ...Array.from(z).sort()];
    for (const ue of Y) {
      if (!D[ue])
        throw new Error(`No type definition specified: ${ue}`);
      U += `${ue}(${D[ue].map(({ name: g, type: b }) => `${b} ${g}`).join(",")})`;
    }
    return U;
  }
  function p(q, D, U = /* @__PURE__ */ new Set()) {
    if (typeof q != "string")
      throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(q)}`);
    if ([q] = q.match(/^\w*/u), U.has(q) || D[q] === void 0)
      return U;
    U.add(q);
    for (const Y of D[q])
      p(Y.type, D, U);
    return U;
  }
  function v(q, D, U, z) {
    u(z, [f.V3, f.V4]);
    const Y = h(q, D, U, z), ue = (0, r.keccak256)(Y);
    return (0, t.arrToBufArr)(ue);
  }
  function m(q, D) {
    const U = Le.Buffer.from(s(q, D), "utf-8");
    return (0, t.arrToBufArr)((0, r.keccak256)(U));
  }
  function E(q) {
    const D = {};
    for (const U in e.TYPED_MESSAGE_SCHEMA.properties)
      q[U] && (D[U] = q[U]);
    return "types" in D && (D.types = Object.assign({ EIP712Domain: [] }, D.types)), D;
  }
  function M(q, D) {
    u(D, [f.V3, f.V4]);
    const U = E(q), { domain: z } = U, Y = { EIP712Domain: U.types.EIP712Domain };
    return v("EIP712Domain", z, Y, D);
  }
  function I(q, D) {
    u(D, [f.V3, f.V4]);
    const U = E(q), z = [Le.Buffer.from("1901", "hex")];
    return z.push(M(q, D)), U.primaryType !== "EIP712Domain" && z.push(v(
      // TODO: Validate that this is a string, so this type cast can be removed.
      U.primaryType,
      U.message,
      U.types,
      D
    )), (0, t.arrToBufArr)((0, r.keccak256)(Le.Buffer.concat(z)));
  }
  e.TypedDataUtils = {
    encodeData: h,
    encodeType: s,
    findTypeDependencies: p,
    hashStruct: v,
    hashType: m,
    sanitizeData: E,
    eip712Hash: I,
    eip712DomainHash: M
  };
  function B(q) {
    const D = T(q);
    return (0, t.bufferToHex)(D);
  }
  e.typedSignatureHash = B;
  function T(q) {
    const D = new Error("Expect argument to be non-empty array");
    if (typeof q != "object" || !("length" in q) || !q.length)
      throw D;
    const U = q.map(function(ue) {
      return ue.type !== "bytes" ? ue.value : (0, n.legacyToBuffer)(ue.value);
    }), z = q.map(function(ue) {
      return ue.type;
    }), Y = q.map(function(ue) {
      if (!ue.name)
        throw D;
      return `${ue.type} ${ue.name}`;
    });
    return (0, t.arrToBufArr)((0, r.keccak256)((0, o.solidityPack)(["bytes32", "bytes32"], [
      (0, r.keccak256)((0, o.solidityPack)(new Array(q.length).fill("string"), Y)),
      (0, r.keccak256)((0, o.solidityPack)(z, U))
    ])));
  }
  function k({ privateKey: q, data: D, version: U }) {
    if (u(U), (0, n.isNullish)(D))
      throw new Error("Missing data parameter");
    if ((0, n.isNullish)(q))
      throw new Error("Missing private key parameter");
    const z = U === f.V1 ? T(D) : e.TypedDataUtils.eip712Hash(D, U), Y = (0, t.ecsign)(z, q);
    return (0, n.concatSig)((0, t.toBuffer)(Y.v), Y.r, Y.s);
  }
  e.signTypedData = k;
  function N({ data: q, signature: D, version: U }) {
    if (u(U), (0, n.isNullish)(q))
      throw new Error("Missing data parameter");
    if ((0, n.isNullish)(D))
      throw new Error("Missing signature parameter");
    const z = U === f.V1 ? T(q) : e.TypedDataUtils.eip712Hash(q, U), Y = (0, n.recoverPublicKey)(z, D), ue = (0, t.publicToAddress)(Y);
    return (0, t.bufferToHex)(ue);
  }
  e.recoverTypedSignature = N;
})(mg);
var Dr = {}, Eg = { exports: {} }, At = {}, Ga = { exports: {} }, v1;
function Ki() {
  if (v1)
    return Ga.exports;
  v1 = 1;
  var e = 65536, t = 4294967295;
  function r() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var i = Bt().Buffer, o = Ze.crypto || Ze.msCrypto;
  o && o.getRandomValues ? Ga.exports = n : Ga.exports = r;
  function n(f, u) {
    if (f > t)
      throw new RangeError("requested too many random bytes");
    var c = i.allocUnsafe(f);
    if (f > 0)
      if (f > e)
        for (var h = 0; h < f; h += e)
          o.getRandomValues(c.slice(h, h + e));
      else
        o.getRandomValues(c);
    return typeof u == "function" ? at.nextTick(function() {
      u(null, c);
    }) : c;
  }
  return Ga.exports;
}
var Js, b1;
function Sg() {
  if (b1)
    return Js;
  b1 = 1;
  var e = Bt().Buffer, t = uf().Transform, r = Et();
  function i(n, f) {
    if (!e.isBuffer(n) && typeof n != "string")
      throw new TypeError(f + " must be a string or a buffer");
  }
  function o(n) {
    t.call(this), this._block = e.allocUnsafe(n), this._blockSize = n, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return r(o, t), o.prototype._transform = function(n, f, u) {
    var c = null;
    try {
      this.update(n, f);
    } catch (h) {
      c = h;
    }
    u(c);
  }, o.prototype._flush = function(n) {
    var f = null;
    try {
      this.push(this.digest());
    } catch (u) {
      f = u;
    }
    n(f);
  }, o.prototype.update = function(n, f) {
    if (i(n, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(n) || (n = e.from(n, f));
    for (var u = this._block, c = 0; this._blockOffset + n.length - c >= this._blockSize; ) {
      for (var h = this._blockOffset; h < this._blockSize; )
        u[h++] = n[c++];
      this._update(), this._blockOffset = 0;
    }
    for (; c < n.length; )
      u[this._blockOffset++] = n[c++];
    for (var s = 0, p = n.length * 8; p > 0; ++s)
      this._length[s] += p, p = this._length[s] / 4294967296 | 0, p > 0 && (this._length[s] -= 4294967296 * p);
    return this;
  }, o.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, o.prototype.digest = function(n) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var f = this._digest();
    n !== void 0 && (f = f.toString(n)), this._block.fill(0), this._blockOffset = 0;
    for (var u = 0; u < 4; ++u)
      this._length[u] = 0;
    return f;
  }, o.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, Js = o, Js;
}
var Xs, y1;
function p0() {
  if (y1)
    return Xs;
  y1 = 1;
  var e = Et(), t = Sg(), r = Bt().Buffer, i = new Array(16);
  function o() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(o, t), o.prototype._update = function() {
    for (var s = i, p = 0; p < 16; ++p)
      s[p] = this._block.readInt32LE(p * 4);
    var v = this._a, m = this._b, E = this._c, M = this._d;
    v = f(v, m, E, M, s[0], 3614090360, 7), M = f(M, v, m, E, s[1], 3905402710, 12), E = f(E, M, v, m, s[2], 606105819, 17), m = f(m, E, M, v, s[3], 3250441966, 22), v = f(v, m, E, M, s[4], 4118548399, 7), M = f(M, v, m, E, s[5], 1200080426, 12), E = f(E, M, v, m, s[6], 2821735955, 17), m = f(m, E, M, v, s[7], 4249261313, 22), v = f(v, m, E, M, s[8], 1770035416, 7), M = f(M, v, m, E, s[9], 2336552879, 12), E = f(E, M, v, m, s[10], 4294925233, 17), m = f(m, E, M, v, s[11], 2304563134, 22), v = f(v, m, E, M, s[12], 1804603682, 7), M = f(M, v, m, E, s[13], 4254626195, 12), E = f(E, M, v, m, s[14], 2792965006, 17), m = f(m, E, M, v, s[15], 1236535329, 22), v = u(v, m, E, M, s[1], 4129170786, 5), M = u(M, v, m, E, s[6], 3225465664, 9), E = u(E, M, v, m, s[11], 643717713, 14), m = u(m, E, M, v, s[0], 3921069994, 20), v = u(v, m, E, M, s[5], 3593408605, 5), M = u(M, v, m, E, s[10], 38016083, 9), E = u(E, M, v, m, s[15], 3634488961, 14), m = u(m, E, M, v, s[4], 3889429448, 20), v = u(v, m, E, M, s[9], 568446438, 5), M = u(M, v, m, E, s[14], 3275163606, 9), E = u(E, M, v, m, s[3], 4107603335, 14), m = u(m, E, M, v, s[8], 1163531501, 20), v = u(v, m, E, M, s[13], 2850285829, 5), M = u(M, v, m, E, s[2], 4243563512, 9), E = u(E, M, v, m, s[7], 1735328473, 14), m = u(m, E, M, v, s[12], 2368359562, 20), v = c(v, m, E, M, s[5], 4294588738, 4), M = c(M, v, m, E, s[8], 2272392833, 11), E = c(E, M, v, m, s[11], 1839030562, 16), m = c(m, E, M, v, s[14], 4259657740, 23), v = c(v, m, E, M, s[1], 2763975236, 4), M = c(M, v, m, E, s[4], 1272893353, 11), E = c(E, M, v, m, s[7], 4139469664, 16), m = c(m, E, M, v, s[10], 3200236656, 23), v = c(v, m, E, M, s[13], 681279174, 4), M = c(M, v, m, E, s[0], 3936430074, 11), E = c(E, M, v, m, s[3], 3572445317, 16), m = c(m, E, M, v, s[6], 76029189, 23), v = c(v, m, E, M, s[9], 3654602809, 4), M = c(M, v, m, E, s[12], 3873151461, 11), E = c(E, M, v, m, s[15], 530742520, 16), m = c(m, E, M, v, s[2], 3299628645, 23), v = h(v, m, E, M, s[0], 4096336452, 6), M = h(M, v, m, E, s[7], 1126891415, 10), E = h(E, M, v, m, s[14], 2878612391, 15), m = h(m, E, M, v, s[5], 4237533241, 21), v = h(v, m, E, M, s[12], 1700485571, 6), M = h(M, v, m, E, s[3], 2399980690, 10), E = h(E, M, v, m, s[10], 4293915773, 15), m = h(m, E, M, v, s[1], 2240044497, 21), v = h(v, m, E, M, s[8], 1873313359, 6), M = h(M, v, m, E, s[15], 4264355552, 10), E = h(E, M, v, m, s[6], 2734768916, 15), m = h(m, E, M, v, s[13], 1309151649, 21), v = h(v, m, E, M, s[4], 4149444226, 6), M = h(M, v, m, E, s[11], 3174756917, 10), E = h(E, M, v, m, s[2], 718787259, 15), m = h(m, E, M, v, s[9], 3951481745, 21), this._a = this._a + v | 0, this._b = this._b + m | 0, this._c = this._c + E | 0, this._d = this._d + M | 0;
  }, o.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var s = r.allocUnsafe(16);
    return s.writeInt32LE(this._a, 0), s.writeInt32LE(this._b, 4), s.writeInt32LE(this._c, 8), s.writeInt32LE(this._d, 12), s;
  };
  function n(s, p) {
    return s << p | s >>> 32 - p;
  }
  function f(s, p, v, m, E, M, I) {
    return n(s + (p & v | ~p & m) + E + M | 0, I) + p | 0;
  }
  function u(s, p, v, m, E, M, I) {
    return n(s + (p & m | v & ~m) + E + M | 0, I) + p | 0;
  }
  function c(s, p, v, m, E, M, I) {
    return n(s + (p ^ v ^ m) + E + M | 0, I) + p | 0;
  }
  function h(s, p, v, m, E, M, I) {
    return n(s + (v ^ (p | ~m)) + E + M | 0, I) + p | 0;
  }
  return Xs = o, Xs;
}
var Ys, g1;
function v0() {
  if (g1)
    return Ys;
  g1 = 1;
  var e = Le.Buffer, t = Et(), r = Sg(), i = new Array(16), o = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], n = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], f = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], u = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], c = [0, 1518500249, 1859775393, 2400959708, 2840853838], h = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function s() {
    r.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(s, r), s.prototype._update = function() {
    for (var B = i, T = 0; T < 16; ++T)
      B[T] = this._block.readInt32LE(T * 4);
    for (var k = this._a | 0, N = this._b | 0, q = this._c | 0, D = this._d | 0, U = this._e | 0, z = this._a | 0, Y = this._b | 0, ue = this._c | 0, j = this._d | 0, g = this._e | 0, b = 0; b < 80; b += 1) {
      var a, d;
      b < 16 ? (a = v(k, N, q, D, U, B[o[b]], c[0], f[b]), d = I(z, Y, ue, j, g, B[n[b]], h[0], u[b])) : b < 32 ? (a = m(k, N, q, D, U, B[o[b]], c[1], f[b]), d = M(z, Y, ue, j, g, B[n[b]], h[1], u[b])) : b < 48 ? (a = E(k, N, q, D, U, B[o[b]], c[2], f[b]), d = E(z, Y, ue, j, g, B[n[b]], h[2], u[b])) : b < 64 ? (a = M(k, N, q, D, U, B[o[b]], c[3], f[b]), d = m(z, Y, ue, j, g, B[n[b]], h[3], u[b])) : (a = I(k, N, q, D, U, B[o[b]], c[4], f[b]), d = v(z, Y, ue, j, g, B[n[b]], h[4], u[b])), k = U, U = D, D = p(q, 10), q = N, N = a, z = g, g = j, j = p(ue, 10), ue = Y, Y = d;
    }
    var w = this._b + q + j | 0;
    this._b = this._c + D + g | 0, this._c = this._d + U + z | 0, this._d = this._e + k + Y | 0, this._e = this._a + N + ue | 0, this._a = w;
  }, s.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var B = e.alloc ? e.alloc(20) : new e(20);
    return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B.writeInt32LE(this._e, 16), B;
  };
  function p(B, T) {
    return B << T | B >>> 32 - T;
  }
  function v(B, T, k, N, q, D, U, z) {
    return p(B + (T ^ k ^ N) + D + U | 0, z) + q | 0;
  }
  function m(B, T, k, N, q, D, U, z) {
    return p(B + (T & k | ~T & N) + D + U | 0, z) + q | 0;
  }
  function E(B, T, k, N, q, D, U, z) {
    return p(B + ((T | ~k) ^ N) + D + U | 0, z) + q | 0;
  }
  function M(B, T, k, N, q, D, U, z) {
    return p(B + (T & N | k & ~N) + D + U | 0, z) + q | 0;
  }
  function I(B, T, k, N, q, D, U, z) {
    return p(B + (T ^ (k | ~N)) + D + U | 0, z) + q | 0;
  }
  return Ys = s, Ys;
}
var Qs = { exports: {} }, eu, m1;
function Zi() {
  if (m1)
    return eu;
  m1 = 1;
  var e = Bt().Buffer;
  function t(r, i) {
    this._block = e.alloc(r), this._finalSize = i, this._blockSize = r, this._len = 0;
  }
  return t.prototype.update = function(r, i) {
    typeof r == "string" && (i = i || "utf8", r = e.from(r, i));
    for (var o = this._block, n = this._blockSize, f = r.length, u = this._len, c = 0; c < f; ) {
      for (var h = u % n, s = Math.min(f - c, n - h), p = 0; p < s; p++)
        o[h + p] = r[c + p];
      u += s, c += s, u % n === 0 && this._update(o);
    }
    return this._len += f, this;
  }, t.prototype.digest = function(r) {
    var i = this._len % this._blockSize;
    this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var o = this._len * 8;
    if (o <= 4294967295)
      this._block.writeUInt32BE(o, this._blockSize - 4);
    else {
      var n = (o & 4294967295) >>> 0, f = (o - n) / 4294967296;
      this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
    }
    this._update(this._block);
    var u = this._hash();
    return r ? u.toString(r) : u;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, eu = t, eu;
}
var tu, w1;
function HE() {
  if (w1)
    return tu;
  w1 = 1;
  var e = Et(), t = Zi(), r = Bt().Buffer, i = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], o = new Array(80);
  function n() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function f(h) {
    return h << 5 | h >>> 27;
  }
  function u(h) {
    return h << 30 | h >>> 2;
  }
  function c(h, s, p, v) {
    return h === 0 ? s & p | ~s & v : h === 2 ? s & p | s & v | p & v : s ^ p ^ v;
  }
  return n.prototype._update = function(h) {
    for (var s = this._w, p = this._a | 0, v = this._b | 0, m = this._c | 0, E = this._d | 0, M = this._e | 0, I = 0; I < 16; ++I)
      s[I] = h.readInt32BE(I * 4);
    for (; I < 80; ++I)
      s[I] = s[I - 3] ^ s[I - 8] ^ s[I - 14] ^ s[I - 16];
    for (var B = 0; B < 80; ++B) {
      var T = ~~(B / 20), k = f(p) + c(T, v, m, E) + M + s[B] + i[T] | 0;
      M = E, E = m, m = u(v), v = p, p = k;
    }
    this._a = p + this._a | 0, this._b = v + this._b | 0, this._c = m + this._c | 0, this._d = E + this._d | 0, this._e = M + this._e | 0;
  }, n.prototype._hash = function() {
    var h = r.allocUnsafe(20);
    return h.writeInt32BE(this._a | 0, 0), h.writeInt32BE(this._b | 0, 4), h.writeInt32BE(this._c | 0, 8), h.writeInt32BE(this._d | 0, 12), h.writeInt32BE(this._e | 0, 16), h;
  }, tu = n, tu;
}
var ru, _1;
function zE() {
  if (_1)
    return ru;
  _1 = 1;
  var e = Et(), t = Zi(), r = Bt().Buffer, i = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], o = new Array(80);
  function n() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function f(s) {
    return s << 1 | s >>> 31;
  }
  function u(s) {
    return s << 5 | s >>> 27;
  }
  function c(s) {
    return s << 30 | s >>> 2;
  }
  function h(s, p, v, m) {
    return s === 0 ? p & v | ~p & m : s === 2 ? p & v | p & m | v & m : p ^ v ^ m;
  }
  return n.prototype._update = function(s) {
    for (var p = this._w, v = this._a | 0, m = this._b | 0, E = this._c | 0, M = this._d | 0, I = this._e | 0, B = 0; B < 16; ++B)
      p[B] = s.readInt32BE(B * 4);
    for (; B < 80; ++B)
      p[B] = f(p[B - 3] ^ p[B - 8] ^ p[B - 14] ^ p[B - 16]);
    for (var T = 0; T < 80; ++T) {
      var k = ~~(T / 20), N = u(v) + h(k, m, E, M) + I + p[T] + i[k] | 0;
      I = M, M = E, E = c(m), m = v, v = N;
    }
    this._a = v + this._a | 0, this._b = m + this._b | 0, this._c = E + this._c | 0, this._d = M + this._d | 0, this._e = I + this._e | 0;
  }, n.prototype._hash = function() {
    var s = r.allocUnsafe(20);
    return s.writeInt32BE(this._a | 0, 0), s.writeInt32BE(this._b | 0, 4), s.writeInt32BE(this._c | 0, 8), s.writeInt32BE(this._d | 0, 12), s.writeInt32BE(this._e | 0, 16), s;
  }, ru = n, ru;
}
var nu, x1;
function Ag() {
  if (x1)
    return nu;
  x1 = 1;
  var e = Et(), t = Zi(), r = Bt().Buffer, i = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], o = new Array(64);
  function n() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function f(v, m, E) {
    return E ^ v & (m ^ E);
  }
  function u(v, m, E) {
    return v & m | E & (v | m);
  }
  function c(v) {
    return (v >>> 2 | v << 30) ^ (v >>> 13 | v << 19) ^ (v >>> 22 | v << 10);
  }
  function h(v) {
    return (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7);
  }
  function s(v) {
    return (v >>> 7 | v << 25) ^ (v >>> 18 | v << 14) ^ v >>> 3;
  }
  function p(v) {
    return (v >>> 17 | v << 15) ^ (v >>> 19 | v << 13) ^ v >>> 10;
  }
  return n.prototype._update = function(v) {
    for (var m = this._w, E = this._a | 0, M = this._b | 0, I = this._c | 0, B = this._d | 0, T = this._e | 0, k = this._f | 0, N = this._g | 0, q = this._h | 0, D = 0; D < 16; ++D)
      m[D] = v.readInt32BE(D * 4);
    for (; D < 64; ++D)
      m[D] = p(m[D - 2]) + m[D - 7] + s(m[D - 15]) + m[D - 16] | 0;
    for (var U = 0; U < 64; ++U) {
      var z = q + h(T) + f(T, k, N) + i[U] + m[U] | 0, Y = c(E) + u(E, M, I) | 0;
      q = N, N = k, k = T, T = B + z | 0, B = I, I = M, M = E, E = z + Y | 0;
    }
    this._a = E + this._a | 0, this._b = M + this._b | 0, this._c = I + this._c | 0, this._d = B + this._d | 0, this._e = T + this._e | 0, this._f = k + this._f | 0, this._g = N + this._g | 0, this._h = q + this._h | 0;
  }, n.prototype._hash = function() {
    var v = r.allocUnsafe(32);
    return v.writeInt32BE(this._a, 0), v.writeInt32BE(this._b, 4), v.writeInt32BE(this._c, 8), v.writeInt32BE(this._d, 12), v.writeInt32BE(this._e, 16), v.writeInt32BE(this._f, 20), v.writeInt32BE(this._g, 24), v.writeInt32BE(this._h, 28), v;
  }, nu = n, nu;
}
var iu, E1;
function VE() {
  if (E1)
    return iu;
  E1 = 1;
  var e = Et(), t = Ag(), r = Zi(), i = Bt().Buffer, o = new Array(64);
  function n() {
    this.init(), this._w = o, r.call(this, 64, 56);
  }
  return e(n, t), n.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, n.prototype._hash = function() {
    var f = i.allocUnsafe(28);
    return f.writeInt32BE(this._a, 0), f.writeInt32BE(this._b, 4), f.writeInt32BE(this._c, 8), f.writeInt32BE(this._d, 12), f.writeInt32BE(this._e, 16), f.writeInt32BE(this._f, 20), f.writeInt32BE(this._g, 24), f;
  }, iu = n, iu;
}
var au, S1;
function Mg() {
  if (S1)
    return au;
  S1 = 1;
  var e = Et(), t = Zi(), r = Bt().Buffer, i = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], o = new Array(160);
  function n() {
    this.init(), this._w = o, t.call(this, 128, 112);
  }
  e(n, t), n.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function f(M, I, B) {
    return B ^ M & (I ^ B);
  }
  function u(M, I, B) {
    return M & I | B & (M | I);
  }
  function c(M, I) {
    return (M >>> 28 | I << 4) ^ (I >>> 2 | M << 30) ^ (I >>> 7 | M << 25);
  }
  function h(M, I) {
    return (M >>> 14 | I << 18) ^ (M >>> 18 | I << 14) ^ (I >>> 9 | M << 23);
  }
  function s(M, I) {
    return (M >>> 1 | I << 31) ^ (M >>> 8 | I << 24) ^ M >>> 7;
  }
  function p(M, I) {
    return (M >>> 1 | I << 31) ^ (M >>> 8 | I << 24) ^ (M >>> 7 | I << 25);
  }
  function v(M, I) {
    return (M >>> 19 | I << 13) ^ (I >>> 29 | M << 3) ^ M >>> 6;
  }
  function m(M, I) {
    return (M >>> 19 | I << 13) ^ (I >>> 29 | M << 3) ^ (M >>> 6 | I << 26);
  }
  function E(M, I) {
    return M >>> 0 < I >>> 0 ? 1 : 0;
  }
  return n.prototype._update = function(M) {
    for (var I = this._w, B = this._ah | 0, T = this._bh | 0, k = this._ch | 0, N = this._dh | 0, q = this._eh | 0, D = this._fh | 0, U = this._gh | 0, z = this._hh | 0, Y = this._al | 0, ue = this._bl | 0, j = this._cl | 0, g = this._dl | 0, b = this._el | 0, a = this._fl | 0, d = this._gl | 0, w = this._hl | 0, x = 0; x < 32; x += 2)
      I[x] = M.readInt32BE(x * 4), I[x + 1] = M.readInt32BE(x * 4 + 4);
    for (; x < 160; x += 2) {
      var A = I[x - 30], S = I[x - 15 * 2 + 1], y = s(A, S), _ = p(S, A);
      A = I[x - 2 * 2], S = I[x - 2 * 2 + 1];
      var l = v(A, S), R = m(S, A), ee = I[x - 7 * 2], oe = I[x - 7 * 2 + 1], V = I[x - 16 * 2], W = I[x - 16 * 2 + 1], F = _ + oe | 0, re = y + ee + E(F, _) | 0;
      F = F + R | 0, re = re + l + E(F, R) | 0, F = F + W | 0, re = re + V + E(F, W) | 0, I[x] = re, I[x + 1] = F;
    }
    for (var he = 0; he < 160; he += 2) {
      re = I[he], F = I[he + 1];
      var Z = u(B, T, k), K = u(Y, ue, j), ce = c(B, Y), ve = c(Y, B), Be = h(q, b), te = h(b, q), C = i[he], L = i[he + 1], G = f(q, D, U), de = f(b, a, d), me = w + te | 0, Te = z + Be + E(me, w) | 0;
      me = me + de | 0, Te = Te + G + E(me, de) | 0, me = me + L | 0, Te = Te + C + E(me, L) | 0, me = me + F | 0, Te = Te + re + E(me, F) | 0;
      var He = ve + K | 0, H = ce + Z + E(He, ve) | 0;
      z = U, w = d, U = D, d = a, D = q, a = b, b = g + me | 0, q = N + Te + E(b, g) | 0, N = k, g = j, k = T, j = ue, T = B, ue = Y, Y = me + He | 0, B = Te + H + E(Y, me) | 0;
    }
    this._al = this._al + Y | 0, this._bl = this._bl + ue | 0, this._cl = this._cl + j | 0, this._dl = this._dl + g | 0, this._el = this._el + b | 0, this._fl = this._fl + a | 0, this._gl = this._gl + d | 0, this._hl = this._hl + w | 0, this._ah = this._ah + B + E(this._al, Y) | 0, this._bh = this._bh + T + E(this._bl, ue) | 0, this._ch = this._ch + k + E(this._cl, j) | 0, this._dh = this._dh + N + E(this._dl, g) | 0, this._eh = this._eh + q + E(this._el, b) | 0, this._fh = this._fh + D + E(this._fl, a) | 0, this._gh = this._gh + U + E(this._gl, d) | 0, this._hh = this._hh + z + E(this._hl, w) | 0;
  }, n.prototype._hash = function() {
    var M = r.allocUnsafe(64);
    function I(B, T, k) {
      M.writeInt32BE(B, k), M.writeInt32BE(T, k + 4);
    }
    return I(this._ah, this._al, 0), I(this._bh, this._bl, 8), I(this._ch, this._cl, 16), I(this._dh, this._dl, 24), I(this._eh, this._el, 32), I(this._fh, this._fl, 40), I(this._gh, this._gl, 48), I(this._hh, this._hl, 56), M;
  }, au = n, au;
}
var ou, A1;
function WE() {
  if (A1)
    return ou;
  A1 = 1;
  var e = Et(), t = Mg(), r = Zi(), i = Bt().Buffer, o = new Array(160);
  function n() {
    this.init(), this._w = o, r.call(this, 128, 112);
  }
  return e(n, t), n.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, n.prototype._hash = function() {
    var f = i.allocUnsafe(48);
    function u(c, h, s) {
      f.writeInt32BE(c, s), f.writeInt32BE(h, s + 4);
    }
    return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), f;
  }, ou = n, ou;
}
var M1;
function b0() {
  if (M1)
    return Qs.exports;
  M1 = 1;
  var e = Qs.exports = function(r) {
    r = r.toLowerCase();
    var i = e[r];
    if (!i)
      throw new Error(r + " is not supported (we accept pull requests)");
    return new i();
  };
  return e.sha = HE(), e.sha1 = zE(), e.sha224 = VE(), e.sha256 = Ag(), e.sha384 = WE(), e.sha512 = Mg(), Qs.exports;
}
var fu, R1;
function qn() {
  if (R1)
    return fu;
  R1 = 1;
  var e = Bt().Buffer, t = og().Transform, r = uh().StringDecoder, i = Et();
  function o(n) {
    t.call(this), this.hashMode = typeof n == "string", this.hashMode ? this[n] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return i(o, t), o.prototype.update = function(n, f, u) {
    typeof n == "string" && (n = e.from(n, f));
    var c = this._update(n);
    return this.hashMode ? this : (u && (c = this._toString(c, u)), c);
  }, o.prototype.setAutoPadding = function() {
  }, o.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, o.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, o.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, o.prototype._transform = function(n, f, u) {
    var c;
    try {
      this.hashMode ? this._update(n) : this.push(this._update(n));
    } catch (h) {
      c = h;
    } finally {
      u(c);
    }
  }, o.prototype._flush = function(n) {
    var f;
    try {
      this.push(this.__final());
    } catch (u) {
      f = u;
    }
    n(f);
  }, o.prototype._finalOrDigest = function(n) {
    var f = this.__final() || e.alloc(0);
    return n && (f = this._toString(f, n, !0)), f;
  }, o.prototype._toString = function(n, f, u) {
    if (this._decoder || (this._decoder = new r(f), this._encoding = f), this._encoding !== f)
      throw new Error("can't switch encodings");
    var c = this._decoder.write(n);
    return u && (c += this._decoder.end()), c;
  }, fu = o, fu;
}
var su, B1;
function Ta() {
  if (B1)
    return su;
  B1 = 1;
  var e = Et(), t = p0(), r = v0(), i = b0(), o = qn();
  function n(f) {
    o.call(this, "digest"), this._hash = f;
  }
  return e(n, o), n.prototype._update = function(f) {
    this._hash.update(f);
  }, n.prototype._final = function() {
    return this._hash.digest();
  }, su = function(u) {
    return u = u.toLowerCase(), u === "md5" ? new t() : u === "rmd160" || u === "ripemd160" ? new r() : new n(i(u));
  }, su;
}
var uu, I1;
function KE() {
  if (I1)
    return uu;
  I1 = 1;
  var e = Et(), t = Bt().Buffer, r = qn(), i = t.alloc(128), o = 64;
  function n(f, u) {
    r.call(this, "digest"), typeof u == "string" && (u = t.from(u)), this._alg = f, this._key = u, u.length > o ? u = f(u) : u.length < o && (u = t.concat([u, i], o));
    for (var c = this._ipad = t.allocUnsafe(o), h = this._opad = t.allocUnsafe(o), s = 0; s < o; s++)
      c[s] = u[s] ^ 54, h[s] = u[s] ^ 92;
    this._hash = [c];
  }
  return e(n, r), n.prototype._update = function(f) {
    this._hash.push(f);
  }, n.prototype._final = function() {
    var f = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, f]));
  }, uu = n, uu;
}
var cu, T1;
function Rg() {
  if (T1)
    return cu;
  T1 = 1;
  var e = p0();
  return cu = function(t) {
    return new e().update(t).digest();
  }, cu;
}
var hu, O1;
function Bg() {
  if (O1)
    return hu;
  O1 = 1;
  var e = Et(), t = KE(), r = qn(), i = Bt().Buffer, o = Rg(), n = v0(), f = b0(), u = i.alloc(128);
  function c(h, s) {
    r.call(this, "digest"), typeof s == "string" && (s = i.from(s));
    var p = h === "sha512" || h === "sha384" ? 128 : 64;
    if (this._alg = h, this._key = s, s.length > p) {
      var v = h === "rmd160" ? new n() : f(h);
      s = v.update(s).digest();
    } else
      s.length < p && (s = i.concat([s, u], p));
    for (var m = this._ipad = i.allocUnsafe(p), E = this._opad = i.allocUnsafe(p), M = 0; M < p; M++)
      m[M] = s[M] ^ 54, E[M] = s[M] ^ 92;
    this._hash = h === "rmd160" ? new n() : f(h), this._hash.update(m);
  }
  return e(c, r), c.prototype._update = function(h) {
    this._hash.update(h);
  }, c.prototype._final = function() {
    var h = this._hash.digest(), s = this._alg === "rmd160" ? new n() : f(this._alg);
    return s.update(this._opad).update(h).digest();
  }, hu = function(s, p) {
    return s = s.toLowerCase(), s === "rmd160" || s === "ripemd160" ? new c("rmd160", p) : s === "md5" ? new t(o, p) : new c(s, p);
  }, hu;
}
const ZE = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, GE = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, JE = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, XE = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, YE = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, QE = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, e7 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, t7 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, r7 = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, n7 = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, i7 = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, Ig = {
  sha224WithRSAEncryption: ZE,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: GE,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: JE,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: XE,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: YE,
  sha224: QE,
  sha384: e7,
  sha512: t7,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: r7,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: n7,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: i7,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var lu, P1;
function a7() {
  return P1 || (P1 = 1, lu = Ig), lu;
}
var Ja = {}, du, C1;
function Tg() {
  if (C1)
    return du;
  C1 = 1;
  var e = Math.pow(2, 30) - 1;
  return du = function(t, r) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof r != "number")
      throw new TypeError("Key length not a number");
    if (r < 0 || r > e || r !== r)
      throw new TypeError("Bad key length");
  }, du;
}
var pu, N1;
function Og() {
  if (N1)
    return pu;
  N1 = 1;
  var e;
  if (Ze.process && Ze.process.browser)
    e = "utf-8";
  else if (Ze.process && Ze.process.version) {
    var t = parseInt(at.version.split(".")[0].slice(1), 10);
    e = t >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return pu = e, pu;
}
var vu, L1;
function Pg() {
  if (L1)
    return vu;
  L1 = 1;
  var e = Bt().Buffer;
  return vu = function(t, r, i) {
    if (e.isBuffer(t))
      return t;
    if (typeof t == "string")
      return e.from(t, r);
    if (ArrayBuffer.isView(t))
      return e.from(t.buffer);
    throw new TypeError(i + " must be a string, a Buffer, a typed array or a DataView");
  }, vu;
}
var bu, k1;
function Cg() {
  if (k1)
    return bu;
  k1 = 1;
  var e = Rg(), t = v0(), r = b0(), i = Bt().Buffer, o = Tg(), n = Og(), f = Pg(), u = i.alloc(128), c = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function h(v, m, E) {
    var M = s(v), I = v === "sha512" || v === "sha384" ? 128 : 64;
    m.length > I ? m = M(m) : m.length < I && (m = i.concat([m, u], I));
    for (var B = i.allocUnsafe(I + c[v]), T = i.allocUnsafe(I + c[v]), k = 0; k < I; k++)
      B[k] = m[k] ^ 54, T[k] = m[k] ^ 92;
    var N = i.allocUnsafe(I + E + 4);
    B.copy(N, 0, 0, I), this.ipad1 = N, this.ipad2 = B, this.opad = T, this.alg = v, this.blocksize = I, this.hash = M, this.size = c[v];
  }
  h.prototype.run = function(v, m) {
    v.copy(m, this.blocksize);
    var E = this.hash(m);
    return E.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function s(v) {
    function m(M) {
      return r(v).update(M).digest();
    }
    function E(M) {
      return new t().update(M).digest();
    }
    return v === "rmd160" || v === "ripemd160" ? E : v === "md5" ? e : m;
  }
  function p(v, m, E, M, I) {
    o(E, M), v = f(v, n, "Password"), m = f(m, n, "Salt"), I = I || "sha1";
    var B = new h(I, v, m.length), T = i.allocUnsafe(M), k = i.allocUnsafe(m.length + 4);
    m.copy(k, 0, 0, m.length);
    for (var N = 0, q = c[I], D = Math.ceil(M / q), U = 1; U <= D; U++) {
      k.writeUInt32BE(U, m.length);
      for (var z = B.run(k, B.ipad1), Y = z, ue = 1; ue < E; ue++) {
        Y = B.run(Y, B.ipad2);
        for (var j = 0; j < q; j++)
          z[j] ^= Y[j];
      }
      z.copy(T, N), N += q;
    }
    return T;
  }
  return bu = p, bu;
}
var yu, q1;
function o7() {
  if (q1)
    return yu;
  q1 = 1;
  var e = Bt().Buffer, t = Tg(), r = Og(), i = Cg(), o = Pg(), n, f = Ze.crypto && Ze.crypto.subtle, u = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, c = [];
  function h(E) {
    if (Ze.process && !Ze.process.browser || !f || !f.importKey || !f.deriveBits)
      return Promise.resolve(!1);
    if (c[E] !== void 0)
      return c[E];
    n = n || e.alloc(8);
    var M = v(n, n, 10, 128, E).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return c[E] = M, M;
  }
  var s;
  function p() {
    return s || (Ze.process && Ze.process.nextTick ? s = Ze.process.nextTick : Ze.queueMicrotask ? s = Ze.queueMicrotask : Ze.setImmediate ? s = Ze.setImmediate : s = Ze.setTimeout, s);
  }
  function v(E, M, I, B, T) {
    return f.importKey(
      "raw",
      E,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(k) {
      return f.deriveBits({
        name: "PBKDF2",
        salt: M,
        iterations: I,
        hash: {
          name: T
        }
      }, k, B << 3);
    }).then(function(k) {
      return e.from(k);
    });
  }
  function m(E, M) {
    E.then(function(I) {
      p()(function() {
        M(null, I);
      });
    }, function(I) {
      p()(function() {
        M(I);
      });
    });
  }
  return yu = function(E, M, I, B, T, k) {
    typeof T == "function" && (k = T, T = void 0), T = T || "sha1";
    var N = u[T.toLowerCase()];
    if (!N || typeof Ze.Promise != "function") {
      p()(function() {
        var q;
        try {
          q = i(E, M, I, B, T);
        } catch (D) {
          return k(D);
        }
        k(null, q);
      });
      return;
    }
    if (t(I, B), E = o(E, r, "Password"), M = o(M, r, "Salt"), typeof k != "function")
      throw new Error("No callback provided to pbkdf2");
    m(h(N).then(function(q) {
      return q ? v(E, M, I, B, N) : i(E, M, I, B, T);
    }), k);
  }, yu;
}
var $1;
function Ng() {
  return $1 || ($1 = 1, Ja.pbkdf2 = o7(), Ja.pbkdf2Sync = Cg()), Ja;
}
var Pr = {}, Dn = {}, xr = {}, D1;
function Lg() {
  if (D1)
    return xr;
  D1 = 1, xr.readUInt32BE = function(o, n) {
    var f = o[0 + n] << 24 | o[1 + n] << 16 | o[2 + n] << 8 | o[3 + n];
    return f >>> 0;
  }, xr.writeUInt32BE = function(o, n, f) {
    o[0 + f] = n >>> 24, o[1 + f] = n >>> 16 & 255, o[2 + f] = n >>> 8 & 255, o[3 + f] = n & 255;
  }, xr.ip = function(o, n, f, u) {
    for (var c = 0, h = 0, s = 6; s >= 0; s -= 2) {
      for (var p = 0; p <= 24; p += 8)
        c <<= 1, c |= n >>> p + s & 1;
      for (var p = 0; p <= 24; p += 8)
        c <<= 1, c |= o >>> p + s & 1;
    }
    for (var s = 6; s >= 0; s -= 2) {
      for (var p = 1; p <= 25; p += 8)
        h <<= 1, h |= n >>> p + s & 1;
      for (var p = 1; p <= 25; p += 8)
        h <<= 1, h |= o >>> p + s & 1;
    }
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, xr.rip = function(o, n, f, u) {
    for (var c = 0, h = 0, s = 0; s < 4; s++)
      for (var p = 24; p >= 0; p -= 8)
        c <<= 1, c |= n >>> p + s & 1, c <<= 1, c |= o >>> p + s & 1;
    for (var s = 4; s < 8; s++)
      for (var p = 24; p >= 0; p -= 8)
        h <<= 1, h |= n >>> p + s & 1, h <<= 1, h |= o >>> p + s & 1;
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, xr.pc1 = function(o, n, f, u) {
    for (var c = 0, h = 0, s = 7; s >= 5; s--) {
      for (var p = 0; p <= 24; p += 8)
        c <<= 1, c |= n >> p + s & 1;
      for (var p = 0; p <= 24; p += 8)
        c <<= 1, c |= o >> p + s & 1;
    }
    for (var p = 0; p <= 24; p += 8)
      c <<= 1, c |= n >> p + s & 1;
    for (var s = 1; s <= 3; s++) {
      for (var p = 0; p <= 24; p += 8)
        h <<= 1, h |= n >> p + s & 1;
      for (var p = 0; p <= 24; p += 8)
        h <<= 1, h |= o >> p + s & 1;
    }
    for (var p = 0; p <= 24; p += 8)
      h <<= 1, h |= o >> p + s & 1;
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, xr.r28shl = function(o, n) {
    return o << n & 268435455 | o >>> 28 - n;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  xr.pc2 = function(o, n, f, u) {
    for (var c = 0, h = 0, s = e.length >>> 1, p = 0; p < s; p++)
      c <<= 1, c |= o >>> e[p] & 1;
    for (var p = s; p < e.length; p++)
      h <<= 1, h |= n >>> e[p] & 1;
    f[u + 0] = c >>> 0, f[u + 1] = h >>> 0;
  }, xr.expand = function(o, n, f) {
    var u = 0, c = 0;
    u = (o & 1) << 5 | o >>> 27;
    for (var h = 23; h >= 15; h -= 4)
      u <<= 6, u |= o >>> h & 63;
    for (var h = 11; h >= 3; h -= 4)
      c |= o >>> h & 63, c <<= 6;
    c |= (o & 31) << 1 | o >>> 31, n[f + 0] = u >>> 0, n[f + 1] = c >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  xr.substitute = function(o, n) {
    for (var f = 0, u = 0; u < 4; u++) {
      var c = o >>> 18 - u * 6 & 63, h = t[u * 64 + c];
      f <<= 4, f |= h;
    }
    for (var u = 0; u < 4; u++) {
      var c = n >>> 18 - u * 6 & 63, h = t[4 * 64 + u * 64 + c];
      f <<= 4, f |= h;
    }
    return f >>> 0;
  };
  var r = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return xr.permute = function(o) {
    for (var n = 0, f = 0; f < r.length; f++)
      n <<= 1, n |= o >>> r[f] & 1;
    return n >>> 0;
  }, xr.padSplit = function(o, n, f) {
    for (var u = o.toString(2); u.length < n; )
      u = "0" + u;
    for (var c = [], h = 0; h < n; h += f)
      c.push(u.slice(h, h + f));
    return c.join(" ");
  }, xr;
}
var gu, j1;
function Hr() {
  if (j1)
    return gu;
  j1 = 1, gu = e;
  function e(t, r) {
    if (!t)
      throw new Error(r || "Assertion failed");
  }
  return e.equal = function(r, i, o) {
    if (r != i)
      throw new Error(o || "Assertion failed: " + r + " != " + i);
  }, gu;
}
var mu, U1;
function y0() {
  if (U1)
    return mu;
  U1 = 1;
  var e = Hr();
  function t(r) {
    this.options = r, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = r.padding !== !1;
  }
  return mu = t, t.prototype._init = function() {
  }, t.prototype.update = function(i) {
    return i.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(i) : this._updateEncrypt(i);
  }, t.prototype._buffer = function(i, o) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, i.length - o), f = 0; f < n; f++)
      this.buffer[this.bufferOff + f] = i[o + f];
    return this.bufferOff += n, n;
  }, t.prototype._flushBuffer = function(i, o) {
    return this._update(this.buffer, 0, i, o), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(i) {
    var o = 0, n = 0, f = (this.bufferOff + i.length) / this.blockSize | 0, u = new Array(f * this.blockSize);
    this.bufferOff !== 0 && (o += this._buffer(i, o), this.bufferOff === this.buffer.length && (n += this._flushBuffer(u, n)));
    for (var c = i.length - (i.length - o) % this.blockSize; o < c; o += this.blockSize)
      this._update(i, o, u, n), n += this.blockSize;
    for (; o < i.length; o++, this.bufferOff++)
      this.buffer[this.bufferOff] = i[o];
    return u;
  }, t.prototype._updateDecrypt = function(i) {
    for (var o = 0, n = 0, f = Math.ceil((this.bufferOff + i.length) / this.blockSize) - 1, u = new Array(f * this.blockSize); f > 0; f--)
      o += this._buffer(i, o), n += this._flushBuffer(u, n);
    return o += this._buffer(i, o), u;
  }, t.prototype.final = function(i) {
    var o;
    i && (o = this.update(i));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), o ? o.concat(n) : n;
  }, t.prototype._pad = function(i, o) {
    if (o === 0)
      return !1;
    for (; o < i.length; )
      i[o++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var i = new Array(this.blockSize);
    return this._update(this.buffer, 0, i, 0), i;
  }, t.prototype._unpad = function(i) {
    return i;
  }, t.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var i = new Array(this.blockSize);
    return this._flushBuffer(i, 0), this._unpad(i);
  }, mu;
}
var wu, F1;
function kg() {
  if (F1)
    return wu;
  F1 = 1;
  var e = Hr(), t = Et(), r = Lg(), i = y0();
  function o() {
    this.tmp = new Array(2), this.keys = null;
  }
  function n(u) {
    i.call(this, u);
    var c = new o();
    this._desState = c, this.deriveKeys(c, u.key);
  }
  t(n, i), wu = n, n.create = function(c) {
    return new n(c);
  };
  var f = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return n.prototype.deriveKeys = function(c, h) {
    c.keys = new Array(16 * 2), e.equal(h.length, this.blockSize, "Invalid key length");
    var s = r.readUInt32BE(h, 0), p = r.readUInt32BE(h, 4);
    r.pc1(s, p, c.tmp, 0), s = c.tmp[0], p = c.tmp[1];
    for (var v = 0; v < c.keys.length; v += 2) {
      var m = f[v >>> 1];
      s = r.r28shl(s, m), p = r.r28shl(p, m), r.pc2(s, p, c.keys, v);
    }
  }, n.prototype._update = function(c, h, s, p) {
    var v = this._desState, m = r.readUInt32BE(c, h), E = r.readUInt32BE(c, h + 4);
    r.ip(m, E, v.tmp, 0), m = v.tmp[0], E = v.tmp[1], this.type === "encrypt" ? this._encrypt(v, m, E, v.tmp, 0) : this._decrypt(v, m, E, v.tmp, 0), m = v.tmp[0], E = v.tmp[1], r.writeUInt32BE(s, m, p), r.writeUInt32BE(s, E, p + 4);
  }, n.prototype._pad = function(c, h) {
    if (this.padding === !1)
      return !1;
    for (var s = c.length - h, p = h; p < c.length; p++)
      c[p] = s;
    return !0;
  }, n.prototype._unpad = function(c) {
    if (this.padding === !1)
      return c;
    for (var h = c[c.length - 1], s = c.length - h; s < c.length; s++)
      e.equal(c[s], h);
    return c.slice(0, c.length - h);
  }, n.prototype._encrypt = function(c, h, s, p, v) {
    for (var m = h, E = s, M = 0; M < c.keys.length; M += 2) {
      var I = c.keys[M], B = c.keys[M + 1];
      r.expand(E, c.tmp, 0), I ^= c.tmp[0], B ^= c.tmp[1];
      var T = r.substitute(I, B), k = r.permute(T), N = E;
      E = (m ^ k) >>> 0, m = N;
    }
    r.rip(E, m, p, v);
  }, n.prototype._decrypt = function(c, h, s, p, v) {
    for (var m = s, E = h, M = c.keys.length - 2; M >= 0; M -= 2) {
      var I = c.keys[M], B = c.keys[M + 1];
      r.expand(m, c.tmp, 0), I ^= c.tmp[0], B ^= c.tmp[1];
      var T = r.substitute(I, B), k = r.permute(T), N = m;
      m = (E ^ k) >>> 0, E = N;
    }
    r.rip(m, E, p, v);
  }, wu;
}
var _u = {}, H1;
function f7() {
  if (H1)
    return _u;
  H1 = 1;
  var e = Hr(), t = Et(), r = {};
  function i(n) {
    e.equal(n.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var f = 0; f < this.iv.length; f++)
      this.iv[f] = n[f];
  }
  function o(n) {
    function f(s) {
      n.call(this, s), this._cbcInit();
    }
    t(f, n);
    for (var u = Object.keys(r), c = 0; c < u.length; c++) {
      var h = u[c];
      f.prototype[h] = r[h];
    }
    return f.create = function(p) {
      return new f(p);
    }, f;
  }
  return _u.instantiate = o, r._cbcInit = function() {
    var f = new i(this.options.iv);
    this._cbcState = f;
  }, r._update = function(f, u, c, h) {
    var s = this._cbcState, p = this.constructor.super_.prototype, v = s.iv;
    if (this.type === "encrypt") {
      for (var m = 0; m < this.blockSize; m++)
        v[m] ^= f[u + m];
      p._update.call(this, v, 0, c, h);
      for (var m = 0; m < this.blockSize; m++)
        v[m] = c[h + m];
    } else {
      p._update.call(this, f, u, c, h);
      for (var m = 0; m < this.blockSize; m++)
        c[h + m] ^= v[m];
      for (var m = 0; m < this.blockSize; m++)
        v[m] = f[u + m];
    }
  }, _u;
}
var xu, z1;
function s7() {
  if (z1)
    return xu;
  z1 = 1;
  var e = Hr(), t = Et(), r = y0(), i = kg();
  function o(f, u) {
    e.equal(u.length, 24, "Invalid key length");
    var c = u.slice(0, 8), h = u.slice(8, 16), s = u.slice(16, 24);
    f === "encrypt" ? this.ciphers = [
      i.create({ type: "encrypt", key: c }),
      i.create({ type: "decrypt", key: h }),
      i.create({ type: "encrypt", key: s })
    ] : this.ciphers = [
      i.create({ type: "decrypt", key: s }),
      i.create({ type: "encrypt", key: h }),
      i.create({ type: "decrypt", key: c })
    ];
  }
  function n(f) {
    r.call(this, f);
    var u = new o(this.type, this.options.key);
    this._edeState = u;
  }
  return t(n, r), xu = n, n.create = function(u) {
    return new n(u);
  }, n.prototype._update = function(u, c, h, s) {
    var p = this._edeState;
    p.ciphers[0]._update(u, c, h, s), p.ciphers[1]._update(h, s, h, s), p.ciphers[2]._update(h, s, h, s);
  }, n.prototype._pad = i.prototype._pad, n.prototype._unpad = i.prototype._unpad, xu;
}
var V1;
function u7() {
  return V1 || (V1 = 1, Dn.utils = Lg(), Dn.Cipher = y0(), Dn.DES = kg(), Dn.CBC = f7(), Dn.EDE = s7()), Dn;
}
var Eu, W1;
function c7() {
  if (W1)
    return Eu;
  W1 = 1;
  var e = qn(), t = u7(), r = Et(), i = Bt().Buffer, o = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  o.des = o["des-cbc"], o.des3 = o["des-ede3-cbc"], Eu = n, r(n, e);
  function n(f) {
    e.call(this);
    var u = f.mode.toLowerCase(), c = o[u], h;
    f.decrypt ? h = "decrypt" : h = "encrypt";
    var s = f.key;
    i.isBuffer(s) || (s = i.from(s)), (u === "des-ede" || u === "des-ede-cbc") && (s = i.concat([s, s.slice(0, 8)]));
    var p = f.iv;
    i.isBuffer(p) || (p = i.from(p)), this._des = c.create({
      key: s,
      iv: p,
      type: h
    });
  }
  return n.prototype._update = function(f) {
    return i.from(this._des.update(f));
  }, n.prototype._final = function() {
    return i.from(this._des.final());
  }, Eu;
}
var Cr = {}, Xa = {}, Ya = {}, K1;
function h7() {
  return K1 || (K1 = 1, Ya.encrypt = function(e, t) {
    return e._cipher.encryptBlock(t);
  }, Ya.decrypt = function(e, t) {
    return e._cipher.decryptBlock(t);
  }), Ya;
}
var Qa = {}, Su, Z1;
function Oa() {
  return Z1 || (Z1 = 1, Su = function(t, r) {
    for (var i = Math.min(t.length, r.length), o = new Le.Buffer(i), n = 0; n < i; ++n)
      o[n] = t[n] ^ r[n];
    return o;
  }), Su;
}
var G1;
function l7() {
  if (G1)
    return Qa;
  G1 = 1;
  var e = Oa();
  return Qa.encrypt = function(t, r) {
    var i = e(r, t._prev);
    return t._prev = t._cipher.encryptBlock(i), t._prev;
  }, Qa.decrypt = function(t, r) {
    var i = t._prev;
    t._prev = r;
    var o = t._cipher.decryptBlock(r);
    return e(o, i);
  }, Qa;
}
var Au = {}, J1;
function d7() {
  if (J1)
    return Au;
  J1 = 1;
  var e = Bt().Buffer, t = Oa();
  function r(i, o, n) {
    var f = o.length, u = t(o, i._cache);
    return i._cache = i._cache.slice(f), i._prev = e.concat([i._prev, n ? o : u]), u;
  }
  return Au.encrypt = function(i, o, n) {
    for (var f = e.allocUnsafe(0), u; o.length; )
      if (i._cache.length === 0 && (i._cache = i._cipher.encryptBlock(i._prev), i._prev = e.allocUnsafe(0)), i._cache.length <= o.length)
        u = i._cache.length, f = e.concat([f, r(i, o.slice(0, u), n)]), o = o.slice(u);
      else {
        f = e.concat([f, r(i, o, n)]);
        break;
      }
    return f;
  }, Au;
}
var Mu = {}, X1;
function p7() {
  if (X1)
    return Mu;
  X1 = 1;
  var e = Bt().Buffer;
  function t(r, i, o) {
    var n = r._cipher.encryptBlock(r._prev), f = n[0] ^ i;
    return r._prev = e.concat([
      r._prev.slice(1),
      e.from([o ? i : f])
    ]), f;
  }
  return Mu.encrypt = function(r, i, o) {
    for (var n = i.length, f = e.allocUnsafe(n), u = -1; ++u < n; )
      f[u] = t(r, i[u], o);
    return f;
  }, Mu;
}
var Ru = {}, Y1;
function v7() {
  if (Y1)
    return Ru;
  Y1 = 1;
  var e = Bt().Buffer;
  function t(i, o, n) {
    for (var f, u = -1, c = 8, h = 0, s, p; ++u < c; )
      f = i._cipher.encryptBlock(i._prev), s = o & 1 << 7 - u ? 128 : 0, p = f[0] ^ s, h += (p & 128) >> u % 8, i._prev = r(i._prev, n ? s : p);
    return h;
  }
  function r(i, o) {
    var n = i.length, f = -1, u = e.allocUnsafe(i.length);
    for (i = e.concat([i, e.from([o])]); ++f < n; )
      u[f] = i[f] << 1 | i[f + 1] >> 7;
    return u;
  }
  return Ru.encrypt = function(i, o, n) {
    for (var f = o.length, u = e.allocUnsafe(f), c = -1; ++c < f; )
      u[c] = t(i, o[c], n);
    return u;
  }, Ru;
}
var Bu = {}, Q1;
function b7() {
  if (Q1)
    return Bu;
  Q1 = 1;
  var e = Oa();
  function t(r) {
    return r._prev = r._cipher.encryptBlock(r._prev), r._prev;
  }
  return Bu.encrypt = function(r, i) {
    for (; r._cache.length < i.length; )
      r._cache = Le.Buffer.concat([r._cache, t(r)]);
    var o = r._cache.slice(0, i.length);
    return r._cache = r._cache.slice(i.length), e(i, o);
  }, Bu;
}
var Iu = {}, Tu, ep;
function qg() {
  if (ep)
    return Tu;
  ep = 1;
  function e(t) {
    for (var r = t.length, i; r--; )
      if (i = t.readUInt8(r), i === 255)
        t.writeUInt8(0, r);
      else {
        i++, t.writeUInt8(i, r);
        break;
      }
  }
  return Tu = e, Tu;
}
var tp;
function rp() {
  if (tp)
    return Iu;
  tp = 1;
  var e = Oa(), t = Bt().Buffer, r = qg();
  function i(n) {
    var f = n._cipher.encryptBlockRaw(n._prev);
    return r(n._prev), f;
  }
  var o = 16;
  return Iu.encrypt = function(n, f) {
    var u = Math.ceil(f.length / o), c = n._cache.length;
    n._cache = t.concat([
      n._cache,
      t.allocUnsafe(u * o)
    ]);
    for (var h = 0; h < u; h++) {
      var s = i(n), p = c + h * o;
      n._cache.writeUInt32BE(s[0], p + 0), n._cache.writeUInt32BE(s[1], p + 4), n._cache.writeUInt32BE(s[2], p + 8), n._cache.writeUInt32BE(s[3], p + 12);
    }
    var v = n._cache.slice(0, f.length);
    return n._cache = n._cache.slice(f.length), e(f, v);
  }, Iu;
}
const y7 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, g7 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, m7 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, $g = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: y7,
  aes192: g7,
  aes256: m7,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var Ou, np;
function g0() {
  if (np)
    return Ou;
  np = 1;
  var e = {
    ECB: h7(),
    CBC: l7(),
    CFB: d7(),
    CFB8: p7(),
    CFB1: v7(),
    OFB: b7(),
    CTR: rp(),
    GCM: rp()
  }, t = $g;
  for (var r in t)
    t[r].module = e[t[r].mode];
  return Ou = t, Ou;
}
var Pu = {}, ip;
function pf() {
  if (ip)
    return Pu;
  ip = 1;
  var e = Bt().Buffer;
  function t(u) {
    e.isBuffer(u) || (u = e.from(u));
    for (var c = u.length / 4 | 0, h = new Array(c), s = 0; s < c; s++)
      h[s] = u.readUInt32BE(s * 4);
    return h;
  }
  function r(u) {
    for (var c = 0; c < u.length; u++)
      u[c] = 0;
  }
  function i(u, c, h, s, p) {
    for (var v = h[0], m = h[1], E = h[2], M = h[3], I = u[0] ^ c[0], B = u[1] ^ c[1], T = u[2] ^ c[2], k = u[3] ^ c[3], N, q, D, U, z = 4, Y = 1; Y < p; Y++)
      N = v[I >>> 24] ^ m[B >>> 16 & 255] ^ E[T >>> 8 & 255] ^ M[k & 255] ^ c[z++], q = v[B >>> 24] ^ m[T >>> 16 & 255] ^ E[k >>> 8 & 255] ^ M[I & 255] ^ c[z++], D = v[T >>> 24] ^ m[k >>> 16 & 255] ^ E[I >>> 8 & 255] ^ M[B & 255] ^ c[z++], U = v[k >>> 24] ^ m[I >>> 16 & 255] ^ E[B >>> 8 & 255] ^ M[T & 255] ^ c[z++], I = N, B = q, T = D, k = U;
    return N = (s[I >>> 24] << 24 | s[B >>> 16 & 255] << 16 | s[T >>> 8 & 255] << 8 | s[k & 255]) ^ c[z++], q = (s[B >>> 24] << 24 | s[T >>> 16 & 255] << 16 | s[k >>> 8 & 255] << 8 | s[I & 255]) ^ c[z++], D = (s[T >>> 24] << 24 | s[k >>> 16 & 255] << 16 | s[I >>> 8 & 255] << 8 | s[B & 255]) ^ c[z++], U = (s[k >>> 24] << 24 | s[I >>> 16 & 255] << 16 | s[B >>> 8 & 255] << 8 | s[T & 255]) ^ c[z++], N = N >>> 0, q = q >>> 0, D = D >>> 0, U = U >>> 0, [N, q, D, U];
  }
  var o = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], n = function() {
    for (var u = new Array(256), c = 0; c < 256; c++)
      c < 128 ? u[c] = c << 1 : u[c] = c << 1 ^ 283;
    for (var h = [], s = [], p = [[], [], [], []], v = [[], [], [], []], m = 0, E = 0, M = 0; M < 256; ++M) {
      var I = E ^ E << 1 ^ E << 2 ^ E << 3 ^ E << 4;
      I = I >>> 8 ^ I & 255 ^ 99, h[m] = I, s[I] = m;
      var B = u[m], T = u[B], k = u[T], N = u[I] * 257 ^ I * 16843008;
      p[0][m] = N << 24 | N >>> 8, p[1][m] = N << 16 | N >>> 16, p[2][m] = N << 8 | N >>> 24, p[3][m] = N, N = k * 16843009 ^ T * 65537 ^ B * 257 ^ m * 16843008, v[0][I] = N << 24 | N >>> 8, v[1][I] = N << 16 | N >>> 16, v[2][I] = N << 8 | N >>> 24, v[3][I] = N, m === 0 ? m = E = 1 : (m = B ^ u[u[u[k ^ B]]], E ^= u[u[E]]);
    }
    return {
      SBOX: h,
      INV_SBOX: s,
      SUB_MIX: p,
      INV_SUB_MIX: v
    };
  }();
  function f(u) {
    this._key = t(u), this._reset();
  }
  return f.blockSize = 4 * 4, f.keySize = 256 / 8, f.prototype.blockSize = f.blockSize, f.prototype.keySize = f.keySize, f.prototype._reset = function() {
    for (var u = this._key, c = u.length, h = c + 6, s = (h + 1) * 4, p = [], v = 0; v < c; v++)
      p[v] = u[v];
    for (v = c; v < s; v++) {
      var m = p[v - 1];
      v % c === 0 ? (m = m << 8 | m >>> 24, m = n.SBOX[m >>> 24] << 24 | n.SBOX[m >>> 16 & 255] << 16 | n.SBOX[m >>> 8 & 255] << 8 | n.SBOX[m & 255], m ^= o[v / c | 0] << 24) : c > 6 && v % c === 4 && (m = n.SBOX[m >>> 24] << 24 | n.SBOX[m >>> 16 & 255] << 16 | n.SBOX[m >>> 8 & 255] << 8 | n.SBOX[m & 255]), p[v] = p[v - c] ^ m;
    }
    for (var E = [], M = 0; M < s; M++) {
      var I = s - M, B = p[I - (M % 4 ? 0 : 4)];
      M < 4 || I <= 4 ? E[M] = B : E[M] = n.INV_SUB_MIX[0][n.SBOX[B >>> 24]] ^ n.INV_SUB_MIX[1][n.SBOX[B >>> 16 & 255]] ^ n.INV_SUB_MIX[2][n.SBOX[B >>> 8 & 255]] ^ n.INV_SUB_MIX[3][n.SBOX[B & 255]];
    }
    this._nRounds = h, this._keySchedule = p, this._invKeySchedule = E;
  }, f.prototype.encryptBlockRaw = function(u) {
    return u = t(u), i(u, this._keySchedule, n.SUB_MIX, n.SBOX, this._nRounds);
  }, f.prototype.encryptBlock = function(u) {
    var c = this.encryptBlockRaw(u), h = e.allocUnsafe(16);
    return h.writeUInt32BE(c[0], 0), h.writeUInt32BE(c[1], 4), h.writeUInt32BE(c[2], 8), h.writeUInt32BE(c[3], 12), h;
  }, f.prototype.decryptBlock = function(u) {
    u = t(u);
    var c = u[1];
    u[1] = u[3], u[3] = c;
    var h = i(u, this._invKeySchedule, n.INV_SUB_MIX, n.INV_SBOX, this._nRounds), s = e.allocUnsafe(16);
    return s.writeUInt32BE(h[0], 0), s.writeUInt32BE(h[3], 4), s.writeUInt32BE(h[2], 8), s.writeUInt32BE(h[1], 12), s;
  }, f.prototype.scrub = function() {
    r(this._keySchedule), r(this._invKeySchedule), r(this._key);
  }, Pu.AES = f, Pu;
}
var Cu, ap;
function w7() {
  if (ap)
    return Cu;
  ap = 1;
  var e = Bt().Buffer, t = e.alloc(16, 0);
  function r(n) {
    return [
      n.readUInt32BE(0),
      n.readUInt32BE(4),
      n.readUInt32BE(8),
      n.readUInt32BE(12)
    ];
  }
  function i(n) {
    var f = e.allocUnsafe(16);
    return f.writeUInt32BE(n[0] >>> 0, 0), f.writeUInt32BE(n[1] >>> 0, 4), f.writeUInt32BE(n[2] >>> 0, 8), f.writeUInt32BE(n[3] >>> 0, 12), f;
  }
  function o(n) {
    this.h = n, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return o.prototype.ghash = function(n) {
    for (var f = -1; ++f < n.length; )
      this.state[f] ^= n[f];
    this._multiply();
  }, o.prototype._multiply = function() {
    for (var n = r(this.h), f = [0, 0, 0, 0], u, c, h, s = -1; ++s < 128; ) {
      for (c = (this.state[~~(s / 8)] & 1 << 7 - s % 8) !== 0, c && (f[0] ^= n[0], f[1] ^= n[1], f[2] ^= n[2], f[3] ^= n[3]), h = (n[3] & 1) !== 0, u = 3; u > 0; u--)
        n[u] = n[u] >>> 1 | (n[u - 1] & 1) << 31;
      n[0] = n[0] >>> 1, h && (n[0] = n[0] ^ 225 << 24);
    }
    this.state = i(f);
  }, o.prototype.update = function(n) {
    this.cache = e.concat([this.cache, n]);
    for (var f; this.cache.length >= 16; )
      f = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(f);
  }, o.prototype.final = function(n, f) {
    return this.cache.length && this.ghash(e.concat([this.cache, t], 16)), this.ghash(i([0, n, 0, f])), this.state;
  }, Cu = o, Cu;
}
var Nu, op;
function Dg() {
  if (op)
    return Nu;
  op = 1;
  var e = pf(), t = Bt().Buffer, r = qn(), i = Et(), o = w7(), n = Oa(), f = qg();
  function u(s, p) {
    var v = 0;
    s.length !== p.length && v++;
    for (var m = Math.min(s.length, p.length), E = 0; E < m; ++E)
      v += s[E] ^ p[E];
    return v;
  }
  function c(s, p, v) {
    if (p.length === 12)
      return s._finID = t.concat([p, t.from([0, 0, 0, 1])]), t.concat([p, t.from([0, 0, 0, 2])]);
    var m = new o(v), E = p.length, M = E % 16;
    m.update(p), M && (M = 16 - M, m.update(t.alloc(M, 0))), m.update(t.alloc(8, 0));
    var I = E * 8, B = t.alloc(8);
    B.writeUIntBE(I, 0, 8), m.update(B), s._finID = m.state;
    var T = t.from(s._finID);
    return f(T), T;
  }
  function h(s, p, v, m) {
    r.call(this);
    var E = t.alloc(4, 0);
    this._cipher = new e.AES(p);
    var M = this._cipher.encryptBlock(E);
    this._ghash = new o(M), v = c(this, v, M), this._prev = t.from(v), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = m, this._alen = 0, this._len = 0, this._mode = s, this._authTag = null, this._called = !1;
  }
  return i(h, r), h.prototype._update = function(s) {
    if (!this._called && this._alen) {
      var p = 16 - this._alen % 16;
      p < 16 && (p = t.alloc(p, 0), this._ghash.update(p));
    }
    this._called = !0;
    var v = this._mode.encrypt(this, s);
    return this._decrypt ? this._ghash.update(s) : this._ghash.update(v), this._len += s.length, v;
  }, h.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var s = n(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && u(s, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = s, this._cipher.scrub();
  }, h.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, h.prototype.setAuthTag = function(p) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = p;
  }, h.prototype.setAAD = function(p) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(p), this._alen += p.length;
  }, Nu = h, Nu;
}
var Lu, fp;
function jg() {
  if (fp)
    return Lu;
  fp = 1;
  var e = pf(), t = Bt().Buffer, r = qn(), i = Et();
  function o(n, f, u, c) {
    r.call(this), this._cipher = new e.AES(f), this._prev = t.from(u), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = c, this._mode = n;
  }
  return i(o, r), o.prototype._update = function(n) {
    return this._mode.encrypt(this, n, this._decrypt);
  }, o.prototype._final = function() {
    this._cipher.scrub();
  }, Lu = o, Lu;
}
var ku, sp;
function vf() {
  if (sp)
    return ku;
  sp = 1;
  var e = Bt().Buffer, t = p0();
  function r(i, o, n, f) {
    if (e.isBuffer(i) || (i = e.from(i, "binary")), o && (e.isBuffer(o) || (o = e.from(o, "binary")), o.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var u = n / 8, c = e.alloc(u), h = e.alloc(f || 0), s = e.alloc(0); u > 0 || f > 0; ) {
      var p = new t();
      p.update(s), p.update(i), o && p.update(o), s = p.digest();
      var v = 0;
      if (u > 0) {
        var m = c.length - u;
        v = Math.min(u, s.length), s.copy(c, m, 0, v), u -= v;
      }
      if (v < s.length && f > 0) {
        var E = h.length - f, M = Math.min(f, s.length - v);
        s.copy(h, E, v, v + M), f -= M;
      }
    }
    return s.fill(0), { key: c, iv: h };
  }
  return ku = r, ku;
}
var up;
function _7() {
  if (up)
    return Xa;
  up = 1;
  var e = g0(), t = Dg(), r = Bt().Buffer, i = jg(), o = qn(), n = pf(), f = vf(), u = Et();
  function c(m, E, M) {
    o.call(this), this._cache = new s(), this._cipher = new n.AES(E), this._prev = r.from(M), this._mode = m, this._autopadding = !0;
  }
  u(c, o), c.prototype._update = function(m) {
    this._cache.add(m);
    for (var E, M, I = []; E = this._cache.get(); )
      M = this._mode.encrypt(this, E), I.push(M);
    return r.concat(I);
  };
  var h = r.alloc(16, 16);
  c.prototype._final = function() {
    var m = this._cache.flush();
    if (this._autopadding)
      return m = this._mode.encrypt(this, m), this._cipher.scrub(), m;
    if (!m.equals(h))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(m) {
    return this._autopadding = !!m, this;
  };
  function s() {
    this.cache = r.allocUnsafe(0);
  }
  s.prototype.add = function(m) {
    this.cache = r.concat([this.cache, m]);
  }, s.prototype.get = function() {
    if (this.cache.length > 15) {
      var m = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), m;
    }
    return null;
  }, s.prototype.flush = function() {
    for (var m = 16 - this.cache.length, E = r.allocUnsafe(m), M = -1; ++M < m; )
      E.writeUInt8(m, M);
    return r.concat([this.cache, E]);
  };
  function p(m, E, M) {
    var I = e[m.toLowerCase()];
    if (!I)
      throw new TypeError("invalid suite type");
    if (typeof E == "string" && (E = r.from(E)), E.length !== I.key / 8)
      throw new TypeError("invalid key length " + E.length);
    if (typeof M == "string" && (M = r.from(M)), I.mode !== "GCM" && M.length !== I.iv)
      throw new TypeError("invalid iv length " + M.length);
    return I.type === "stream" ? new i(I.module, E, M) : I.type === "auth" ? new t(I.module, E, M) : new c(I.module, E, M);
  }
  function v(m, E) {
    var M = e[m.toLowerCase()];
    if (!M)
      throw new TypeError("invalid suite type");
    var I = f(E, !1, M.key, M.iv);
    return p(m, I.key, I.iv);
  }
  return Xa.createCipheriv = p, Xa.createCipher = v, Xa;
}
var eo = {}, cp;
function x7() {
  if (cp)
    return eo;
  cp = 1;
  var e = Dg(), t = Bt().Buffer, r = g0(), i = jg(), o = qn(), n = pf(), f = vf(), u = Et();
  function c(m, E, M) {
    o.call(this), this._cache = new h(), this._last = void 0, this._cipher = new n.AES(E), this._prev = t.from(M), this._mode = m, this._autopadding = !0;
  }
  u(c, o), c.prototype._update = function(m) {
    this._cache.add(m);
    for (var E, M, I = []; E = this._cache.get(this._autopadding); )
      M = this._mode.decrypt(this, E), I.push(M);
    return t.concat(I);
  }, c.prototype._final = function() {
    var m = this._cache.flush();
    if (this._autopadding)
      return s(this._mode.decrypt(this, m));
    if (m)
      throw new Error("data not multiple of block length");
  }, c.prototype.setAutoPadding = function(m) {
    return this._autopadding = !!m, this;
  };
  function h() {
    this.cache = t.allocUnsafe(0);
  }
  h.prototype.add = function(m) {
    this.cache = t.concat([this.cache, m]);
  }, h.prototype.get = function(m) {
    var E;
    if (m) {
      if (this.cache.length > 16)
        return E = this.cache.slice(0, 16), this.cache = this.cache.slice(16), E;
    } else if (this.cache.length >= 16)
      return E = this.cache.slice(0, 16), this.cache = this.cache.slice(16), E;
    return null;
  }, h.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function s(m) {
    var E = m[15];
    if (E < 1 || E > 16)
      throw new Error("unable to decrypt data");
    for (var M = -1; ++M < E; )
      if (m[M + (16 - E)] !== E)
        throw new Error("unable to decrypt data");
    if (E !== 16)
      return m.slice(0, 16 - E);
  }
  function p(m, E, M) {
    var I = r[m.toLowerCase()];
    if (!I)
      throw new TypeError("invalid suite type");
    if (typeof M == "string" && (M = t.from(M)), I.mode !== "GCM" && M.length !== I.iv)
      throw new TypeError("invalid iv length " + M.length);
    if (typeof E == "string" && (E = t.from(E)), E.length !== I.key / 8)
      throw new TypeError("invalid key length " + E.length);
    return I.type === "stream" ? new i(I.module, E, M, !0) : I.type === "auth" ? new e(I.module, E, M, !0) : new c(I.module, E, M);
  }
  function v(m, E) {
    var M = r[m.toLowerCase()];
    if (!M)
      throw new TypeError("invalid suite type");
    var I = f(E, !1, M.key, M.iv);
    return p(m, I.key, I.iv);
  }
  return eo.createDecipher = v, eo.createDecipheriv = p, eo;
}
var hp;
function m0() {
  if (hp)
    return Cr;
  hp = 1;
  var e = _7(), t = x7(), r = $g;
  function i() {
    return Object.keys(r);
  }
  return Cr.createCipher = Cr.Cipher = e.createCipher, Cr.createCipheriv = Cr.Cipheriv = e.createCipheriv, Cr.createDecipher = Cr.Decipher = t.createDecipher, Cr.createDecipheriv = Cr.Decipheriv = t.createDecipheriv, Cr.listCiphers = Cr.getCiphers = i, Cr;
}
var qu = {}, lp;
function E7() {
  return lp || (lp = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(qu)), qu;
}
var dp;
function S7() {
  if (dp)
    return Pr;
  dp = 1;
  var e = c7(), t = m0(), r = g0(), i = E7(), o = vf();
  function n(s, p) {
    s = s.toLowerCase();
    var v, m;
    if (r[s])
      v = r[s].key, m = r[s].iv;
    else if (i[s])
      v = i[s].key * 8, m = i[s].iv;
    else
      throw new TypeError("invalid suite type");
    var E = o(p, !1, v, m);
    return u(s, E.key, E.iv);
  }
  function f(s, p) {
    s = s.toLowerCase();
    var v, m;
    if (r[s])
      v = r[s].key, m = r[s].iv;
    else if (i[s])
      v = i[s].key * 8, m = i[s].iv;
    else
      throw new TypeError("invalid suite type");
    var E = o(p, !1, v, m);
    return c(s, E.key, E.iv);
  }
  function u(s, p, v) {
    if (s = s.toLowerCase(), r[s])
      return t.createCipheriv(s, p, v);
    if (i[s])
      return new e({ key: p, iv: v, mode: s });
    throw new TypeError("invalid suite type");
  }
  function c(s, p, v) {
    if (s = s.toLowerCase(), r[s])
      return t.createDecipheriv(s, p, v);
    if (i[s])
      return new e({ key: p, iv: v, mode: s, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function h() {
    return Object.keys(i).concat(t.getCiphers());
  }
  return Pr.createCipher = Pr.Cipher = n, Pr.createCipheriv = Pr.Cipheriv = u, Pr.createDecipher = Pr.Decipher = f, Pr.createDecipheriv = Pr.Decipheriv = c, Pr.listCiphers = Pr.getCiphers = h, Pr;
}
var jn = {}, to = { exports: {} }, pp;
function w0() {
  if (pp)
    return to.exports;
  pp = 1;
  var e;
  to.exports = function(o) {
    return e || (e = new t(null)), e.generate(o);
  };
  function t(i) {
    this.rand = i;
  }
  if (to.exports.Rand = t, t.prototype.generate = function(o) {
    return this._rand(o);
  }, t.prototype._rand = function(o) {
    if (this.rand.getBytes)
      return this.rand.getBytes(o);
    for (var n = new Uint8Array(o), f = 0; f < n.length; f++)
      n[f] = this.rand.getByte();
    return n;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(o) {
      var n = new Uint8Array(o);
      return self.crypto.getRandomValues(n), n;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(o) {
      var n = new Uint8Array(o);
      return self.msCrypto.getRandomValues(n), n;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var r = im();
      if (typeof r.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(o) {
        return r.randomBytes(o);
      };
    } catch {
    }
  return to.exports;
}
var $u, vp;
function Ug() {
  if (vp)
    return $u;
  vp = 1;
  var e = ar, t = w0();
  function r(i) {
    this.rand = i || new t.Rand();
  }
  return $u = r, r.create = function(o) {
    return new r(o);
  }, r.prototype._randbelow = function(o) {
    var n = o.bitLength(), f = Math.ceil(n / 8);
    do
      var u = new e(this.rand.generate(f));
    while (u.cmp(o) >= 0);
    return u;
  }, r.prototype._randrange = function(o, n) {
    var f = n.sub(o);
    return o.add(this._randbelow(f));
  }, r.prototype.test = function(o, n, f) {
    var u = o.bitLength(), c = e.mont(o), h = new e(1).toRed(c);
    n || (n = Math.max(1, u / 48 | 0));
    for (var s = o.subn(1), p = 0; !s.testn(p); p++)
      ;
    for (var v = o.shrn(p), m = s.toRed(c), E = !0; n > 0; n--) {
      var M = this._randrange(new e(2), s);
      f && f(M);
      var I = M.toRed(c).redPow(v);
      if (!(I.cmp(h) === 0 || I.cmp(m) === 0)) {
        for (var B = 1; B < p; B++) {
          if (I = I.redSqr(), I.cmp(h) === 0)
            return !1;
          if (I.cmp(m) === 0)
            break;
        }
        if (B === p)
          return !1;
      }
    }
    return E;
  }, r.prototype.getDivisor = function(o, n) {
    var f = o.bitLength(), u = e.mont(o), c = new e(1).toRed(u);
    n || (n = Math.max(1, f / 48 | 0));
    for (var h = o.subn(1), s = 0; !h.testn(s); s++)
      ;
    for (var p = o.shrn(s), v = h.toRed(u); n > 0; n--) {
      var m = this._randrange(new e(2), h), E = o.gcd(m);
      if (E.cmpn(1) !== 0)
        return E;
      var M = m.toRed(u).redPow(p);
      if (!(M.cmp(c) === 0 || M.cmp(v) === 0)) {
        for (var I = 1; I < s; I++) {
          if (M = M.redSqr(), M.cmp(c) === 0)
            return M.fromRed().subn(1).gcd(o);
          if (M.cmp(v) === 0)
            break;
        }
        if (I === s)
          return M = M.redSqr(), M.fromRed().subn(1).gcd(o);
      }
    }
    return !1;
  }, $u;
}
var Du, bp;
function Fg() {
  if (bp)
    return Du;
  bp = 1;
  var e = Ki();
  Du = I, I.simpleSieve = E, I.fermatTest = M;
  var t = ar, r = new t(24), i = Ug(), o = new i(), n = new t(1), f = new t(2), u = new t(5);
  new t(16), new t(8);
  var c = new t(10), h = new t(3);
  new t(7);
  var s = new t(11), p = new t(4);
  new t(12);
  var v = null;
  function m() {
    if (v !== null)
      return v;
    var B = 1048576, T = [];
    T[0] = 2;
    for (var k = 1, N = 3; N < B; N += 2) {
      for (var q = Math.ceil(Math.sqrt(N)), D = 0; D < k && T[D] <= q && N % T[D] !== 0; D++)
        ;
      k !== D && T[D] <= q || (T[k++] = N);
    }
    return v = T, T;
  }
  function E(B) {
    for (var T = m(), k = 0; k < T.length; k++)
      if (B.modn(T[k]) === 0)
        return B.cmpn(T[k]) === 0;
    return !0;
  }
  function M(B) {
    var T = t.mont(B);
    return f.toRed(T).redPow(B.subn(1)).fromRed().cmpn(1) === 0;
  }
  function I(B, T) {
    if (B < 16)
      return T === 2 || T === 5 ? new t([140, 123]) : new t([140, 39]);
    T = new t(T);
    for (var k, N; ; ) {
      for (k = new t(e(Math.ceil(B / 8))); k.bitLength() > B; )
        k.ishrn(1);
      if (k.isEven() && k.iadd(n), k.testn(1) || k.iadd(f), T.cmp(f)) {
        if (!T.cmp(u))
          for (; k.mod(c).cmp(h); )
            k.iadd(p);
      } else
        for (; k.mod(r).cmp(s); )
          k.iadd(p);
      if (N = k.shrn(1), E(N) && E(k) && M(N) && M(k) && o.test(N) && o.test(k))
        return k;
    }
  }
  return Du;
}
const A7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, M7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, R7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, B7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, I7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, T7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, O7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, P7 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, C7 = {
  modp1: A7,
  modp2: M7,
  modp5: R7,
  modp14: B7,
  modp15: I7,
  modp16: T7,
  modp17: O7,
  modp18: P7
};
var ju, yp;
function N7() {
  if (yp)
    return ju;
  yp = 1;
  var e = ar, t = Ug(), r = new t(), i = new e(24), o = new e(11), n = new e(10), f = new e(3), u = new e(7), c = Fg(), h = Ki();
  ju = E;
  function s(I, B) {
    return B = B || "utf8", Le.Buffer.isBuffer(I) || (I = new Le.Buffer(I, B)), this._pub = new e(I), this;
  }
  function p(I, B) {
    return B = B || "utf8", Le.Buffer.isBuffer(I) || (I = new Le.Buffer(I, B)), this._priv = new e(I), this;
  }
  var v = {};
  function m(I, B) {
    var T = B.toString("hex"), k = [T, I.toString(16)].join("_");
    if (k in v)
      return v[k];
    var N = 0;
    if (I.isEven() || !c.simpleSieve || !c.fermatTest(I) || !r.test(I))
      return N += 1, T === "02" || T === "05" ? N += 8 : N += 4, v[k] = N, N;
    r.test(I.shrn(1)) || (N += 2);
    var q;
    switch (T) {
      case "02":
        I.mod(i).cmp(o) && (N += 8);
        break;
      case "05":
        q = I.mod(n), q.cmp(f) && q.cmp(u) && (N += 8);
        break;
      default:
        N += 4;
    }
    return v[k] = N, N;
  }
  function E(I, B, T) {
    this.setGenerator(B), this.__prime = new e(I), this._prime = e.mont(this.__prime), this._primeLen = I.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, T ? (this.setPublicKey = s, this.setPrivateKey = p) : this._primeCode = 8;
  }
  Object.defineProperty(E.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = m(this.__prime, this.__gen)), this._primeCode;
    }
  }), E.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(h(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, E.prototype.computeSecret = function(I) {
    I = new e(I), I = I.toRed(this._prime);
    var B = I.redPow(this._priv).fromRed(), T = new Le.Buffer(B.toArray()), k = this.getPrime();
    if (T.length < k.length) {
      var N = new Le.Buffer(k.length - T.length);
      N.fill(0), T = Le.Buffer.concat([N, T]);
    }
    return T;
  }, E.prototype.getPublicKey = function(B) {
    return M(this._pub, B);
  }, E.prototype.getPrivateKey = function(B) {
    return M(this._priv, B);
  }, E.prototype.getPrime = function(I) {
    return M(this.__prime, I);
  }, E.prototype.getGenerator = function(I) {
    return M(this._gen, I);
  }, E.prototype.setGenerator = function(I, B) {
    return B = B || "utf8", Le.Buffer.isBuffer(I) || (I = new Le.Buffer(I, B)), this.__gen = I, this._gen = new e(I), this;
  };
  function M(I, B) {
    var T = new Le.Buffer(I.toArray());
    return B ? T.toString(B) : T;
  }
  return ju;
}
var gp;
function L7() {
  if (gp)
    return jn;
  gp = 1;
  var e = Fg(), t = C7, r = N7();
  function i(f) {
    var u = new Le.Buffer(t[f].prime, "hex"), c = new Le.Buffer(t[f].gen, "hex");
    return new r(u, c);
  }
  var o = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function n(f, u, c, h) {
    return Le.Buffer.isBuffer(u) || o[u] === void 0 ? n(f, "binary", u, c) : (u = u || "binary", h = h || "binary", c = c || new Le.Buffer([2]), Le.Buffer.isBuffer(c) || (c = new Le.Buffer(c, h)), typeof f == "number" ? new r(e(f, c), c, !0) : (Le.Buffer.isBuffer(f) || (f = new Le.Buffer(f, u)), new r(f, c, !0)));
  }
  return jn.DiffieHellmanGroup = jn.createDiffieHellmanGroup = jn.getDiffieHellman = i, jn.createDiffieHellman = jn.DiffieHellman = n, jn;
}
var ra = { exports: {} }, fo = { exports: {} };
fo.exports;
var mp;
function k7() {
  return mp || (mp = 1, function(e) {
    (function(t, r) {
      function i(b, a) {
        if (!b)
          throw new Error(a || "Assertion failed");
      }
      function o(b, a) {
        b.super_ = a;
        var d = function() {
        };
        d.prototype = a.prototype, b.prototype = new d(), b.prototype.constructor = b;
      }
      function n(b, a, d) {
        if (n.isBN(b))
          return b;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, b !== null && ((a === "le" || a === "be") && (d = a, a = 10), this._init(b || 0, a || 10, d || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var f;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? f = window.Buffer : f = Le.Buffer;
      } catch {
      }
      n.isBN = function(a) {
        return a instanceof n ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words);
      }, n.max = function(a, d) {
        return a.cmp(d) > 0 ? a : d;
      }, n.min = function(a, d) {
        return a.cmp(d) < 0 ? a : d;
      }, n.prototype._init = function(a, d, w) {
        if (typeof a == "number")
          return this._initNumber(a, d, w);
        if (typeof a == "object")
          return this._initArray(a, d, w);
        d === "hex" && (d = 16), i(d === (d | 0) && d >= 2 && d <= 36), a = a.toString().replace(/\s+/g, "");
        var x = 0;
        a[0] === "-" && (x++, this.negative = 1), x < a.length && (d === 16 ? this._parseHex(a, x, w) : (this._parseBase(a, d, x), w === "le" && this._initArray(this.toArray(), d, w)));
      }, n.prototype._initNumber = function(a, d, w) {
        a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
          a & 67108863,
          a / 67108864 & 67108863
        ], this.length = 2) : (i(a < 9007199254740992), this.words = [
          a & 67108863,
          a / 67108864 & 67108863,
          1
        ], this.length = 3), w === "le" && this._initArray(this.toArray(), d, w);
      }, n.prototype._initArray = function(a, d, w) {
        if (i(typeof a.length == "number"), a.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A, S, y = 0;
        if (w === "be")
          for (x = a.length - 1, A = 0; x >= 0; x -= 3)
            S = a[x] | a[x - 1] << 8 | a[x - 2] << 16, this.words[A] |= S << y & 67108863, this.words[A + 1] = S >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, A++);
        else if (w === "le")
          for (x = 0, A = 0; x < a.length; x += 3)
            S = a[x] | a[x + 1] << 8 | a[x + 2] << 16, this.words[A] |= S << y & 67108863, this.words[A + 1] = S >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, A++);
        return this._strip();
      };
      function u(b, a) {
        var d = b.charCodeAt(a);
        if (d >= 48 && d <= 57)
          return d - 48;
        if (d >= 65 && d <= 70)
          return d - 55;
        if (d >= 97 && d <= 102)
          return d - 87;
        i(!1, "Invalid character in " + b);
      }
      function c(b, a, d) {
        var w = u(b, d);
        return d - 1 >= a && (w |= u(b, d - 1) << 4), w;
      }
      n.prototype._parseHex = function(a, d, w) {
        this.length = Math.ceil((a.length - d) / 6), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A = 0, S = 0, y;
        if (w === "be")
          for (x = a.length - 1; x >= d; x -= 2)
            y = c(a, d, x) << A, this.words[S] |= y & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= y >>> 26) : A += 8;
        else {
          var _ = a.length - d;
          for (x = _ % 2 === 0 ? d + 1 : d; x < a.length; x += 2)
            y = c(a, d, x) << A, this.words[S] |= y & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= y >>> 26) : A += 8;
        }
        this._strip();
      };
      function h(b, a, d, w) {
        for (var x = 0, A = 0, S = Math.min(b.length, d), y = a; y < S; y++) {
          var _ = b.charCodeAt(y) - 48;
          x *= w, _ >= 49 ? A = _ - 49 + 10 : _ >= 17 ? A = _ - 17 + 10 : A = _, i(_ >= 0 && A < w, "Invalid character"), x += A;
        }
        return x;
      }
      n.prototype._parseBase = function(a, d, w) {
        this.words = [0], this.length = 1;
        for (var x = 0, A = 1; A <= 67108863; A *= d)
          x++;
        x--, A = A / d | 0;
        for (var S = a.length - w, y = S % x, _ = Math.min(S, S - y) + w, l = 0, R = w; R < _; R += x)
          l = h(a, R, R + x, d), this.imuln(A), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        if (y !== 0) {
          var ee = 1;
          for (l = h(a, R, a.length, d), R = 0; R < y; R++)
            ee *= d;
          this.imuln(ee), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        }
        this._strip();
      }, n.prototype.copy = function(a) {
        a.words = new Array(this.length);
        for (var d = 0; d < this.length; d++)
          a.words[d] = this.words[d];
        a.length = this.length, a.negative = this.negative, a.red = this.red;
      };
      function s(b, a) {
        b.words = a.words, b.length = a.length, b.negative = a.negative, b.red = a.red;
      }
      if (n.prototype._move = function(a) {
        s(a, this);
      }, n.prototype.clone = function() {
        var a = new n(null);
        return this.copy(a), a;
      }, n.prototype._expand = function(a) {
        for (; this.length < a; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
        } catch {
          n.prototype.inspect = p;
        }
      else
        n.prototype.inspect = p;
      function p() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var v = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], E = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(a, d) {
        a = a || 10, d = d | 0 || 1;
        var w;
        if (a === 16 || a === "hex") {
          w = "";
          for (var x = 0, A = 0, S = 0; S < this.length; S++) {
            var y = this.words[S], _ = ((y << x | A) & 16777215).toString(16);
            A = y >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), A !== 0 || S !== this.length - 1 ? w = v[6 - _.length] + _ + w : w = _ + w;
          }
          for (A !== 0 && (w = A.toString(16) + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        if (a === (a | 0) && a >= 2 && a <= 36) {
          var l = m[a], R = E[a];
          w = "";
          var ee = this.clone();
          for (ee.negative = 0; !ee.isZero(); ) {
            var oe = ee.modrn(R).toString(a);
            ee = ee.idivn(R), ee.isZero() ? w = oe + w : w = v[l - oe.length] + oe + w;
          }
          for (this.isZero() && (w = "0" + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        i(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var a = this.words[0];
        return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, f && (n.prototype.toBuffer = function(a, d) {
        return this.toArrayLike(f, a, d);
      }), n.prototype.toArray = function(a, d) {
        return this.toArrayLike(Array, a, d);
      };
      var M = function(a, d) {
        return a.allocUnsafe ? a.allocUnsafe(d) : new a(d);
      };
      n.prototype.toArrayLike = function(a, d, w) {
        this._strip();
        var x = this.byteLength(), A = w || Math.max(1, x);
        i(x <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var S = M(a, A), y = d === "le" ? "LE" : "BE";
        return this["_toArrayLike" + y](S, x), S;
      }, n.prototype._toArrayLikeLE = function(a, d) {
        for (var w = 0, x = 0, A = 0, S = 0; A < this.length; A++) {
          var y = this.words[A] << S | x;
          a[w++] = y & 255, w < a.length && (a[w++] = y >> 8 & 255), w < a.length && (a[w++] = y >> 16 & 255), S === 6 ? (w < a.length && (a[w++] = y >> 24 & 255), x = 0, S = 0) : (x = y >>> 24, S += 2);
        }
        if (w < a.length)
          for (a[w++] = x; w < a.length; )
            a[w++] = 0;
      }, n.prototype._toArrayLikeBE = function(a, d) {
        for (var w = a.length - 1, x = 0, A = 0, S = 0; A < this.length; A++) {
          var y = this.words[A] << S | x;
          a[w--] = y & 255, w >= 0 && (a[w--] = y >> 8 & 255), w >= 0 && (a[w--] = y >> 16 & 255), S === 6 ? (w >= 0 && (a[w--] = y >> 24 & 255), x = 0, S = 0) : (x = y >>> 24, S += 2);
        }
        if (w >= 0)
          for (a[w--] = x; w >= 0; )
            a[w--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(a) {
        return 32 - Math.clz32(a);
      } : n.prototype._countBits = function(a) {
        var d = a, w = 0;
        return d >= 4096 && (w += 13, d >>>= 13), d >= 64 && (w += 7, d >>>= 7), d >= 8 && (w += 4, d >>>= 4), d >= 2 && (w += 2, d >>>= 2), w + d;
      }, n.prototype._zeroBits = function(a) {
        if (a === 0)
          return 26;
        var d = a, w = 0;
        return d & 8191 || (w += 13, d >>>= 13), d & 127 || (w += 7, d >>>= 7), d & 15 || (w += 4, d >>>= 4), d & 3 || (w += 2, d >>>= 2), d & 1 || w++, w;
      }, n.prototype.bitLength = function() {
        var a = this.words[this.length - 1], d = this._countBits(a);
        return (this.length - 1) * 26 + d;
      };
      function I(b) {
        for (var a = new Array(b.bitLength()), d = 0; d < a.length; d++) {
          var w = d / 26 | 0, x = d % 26;
          a[d] = b.words[w] >>> x & 1;
        }
        return a;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var a = 0, d = 0; d < this.length; d++) {
          var w = this._zeroBits(this.words[d]);
          if (a += w, w !== 26)
            break;
        }
        return a;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(a) {
        return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(a) {
        return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(a) {
        for (; this.length < a.length; )
          this.words[this.length++] = 0;
        for (var d = 0; d < a.length; d++)
          this.words[d] = this.words[d] | a.words[d];
        return this._strip();
      }, n.prototype.ior = function(a) {
        return i((this.negative | a.negative) === 0), this.iuor(a);
      }, n.prototype.or = function(a) {
        return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
      }, n.prototype.uor = function(a) {
        return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
      }, n.prototype.iuand = function(a) {
        var d;
        this.length > a.length ? d = a : d = this;
        for (var w = 0; w < d.length; w++)
          this.words[w] = this.words[w] & a.words[w];
        return this.length = d.length, this._strip();
      }, n.prototype.iand = function(a) {
        return i((this.negative | a.negative) === 0), this.iuand(a);
      }, n.prototype.and = function(a) {
        return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
      }, n.prototype.uand = function(a) {
        return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
      }, n.prototype.iuxor = function(a) {
        var d, w;
        this.length > a.length ? (d = this, w = a) : (d = a, w = this);
        for (var x = 0; x < w.length; x++)
          this.words[x] = d.words[x] ^ w.words[x];
        if (this !== d)
          for (; x < d.length; x++)
            this.words[x] = d.words[x];
        return this.length = d.length, this._strip();
      }, n.prototype.ixor = function(a) {
        return i((this.negative | a.negative) === 0), this.iuxor(a);
      }, n.prototype.xor = function(a) {
        return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
      }, n.prototype.uxor = function(a) {
        return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
      }, n.prototype.inotn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = Math.ceil(a / 26) | 0, w = a % 26;
        this._expand(d), w > 0 && d--;
        for (var x = 0; x < d; x++)
          this.words[x] = ~this.words[x] & 67108863;
        return w > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - w), this._strip();
      }, n.prototype.notn = function(a) {
        return this.clone().inotn(a);
      }, n.prototype.setn = function(a, d) {
        i(typeof a == "number" && a >= 0);
        var w = a / 26 | 0, x = a % 26;
        return this._expand(w + 1), d ? this.words[w] = this.words[w] | 1 << x : this.words[w] = this.words[w] & ~(1 << x), this._strip();
      }, n.prototype.iadd = function(a) {
        var d;
        if (this.negative !== 0 && a.negative === 0)
          return this.negative = 0, d = this.isub(a), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && a.negative !== 0)
          return a.negative = 0, d = this.isub(a), a.negative = 1, d._normSign();
        var w, x;
        this.length > a.length ? (w = this, x = a) : (w = a, x = this);
        for (var A = 0, S = 0; S < x.length; S++)
          d = (w.words[S] | 0) + (x.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        for (; A !== 0 && S < w.length; S++)
          d = (w.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        if (this.length = w.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (w !== this)
          for (; S < w.length; S++)
            this.words[S] = w.words[S];
        return this;
      }, n.prototype.add = function(a) {
        var d;
        return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, d = this.sub(a), a.negative ^= 1, d) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, d = a.sub(this), this.negative = 1, d) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
      }, n.prototype.isub = function(a) {
        if (a.negative !== 0) {
          a.negative = 0;
          var d = this.iadd(a);
          return a.negative = 1, d._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
        var w = this.cmp(a);
        if (w === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var x, A;
        w > 0 ? (x = this, A = a) : (x = a, A = this);
        for (var S = 0, y = 0; y < A.length; y++)
          d = (x.words[y] | 0) - (A.words[y] | 0) + S, S = d >> 26, this.words[y] = d & 67108863;
        for (; S !== 0 && y < x.length; y++)
          d = (x.words[y] | 0) + S, S = d >> 26, this.words[y] = d & 67108863;
        if (S === 0 && y < x.length && x !== this)
          for (; y < x.length; y++)
            this.words[y] = x.words[y];
        return this.length = Math.max(this.length, y), x !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(a) {
        return this.clone().isub(a);
      };
      function B(b, a, d) {
        d.negative = a.negative ^ b.negative;
        var w = b.length + a.length | 0;
        d.length = w, w = w - 1 | 0;
        var x = b.words[0] | 0, A = a.words[0] | 0, S = x * A, y = S & 67108863, _ = S / 67108864 | 0;
        d.words[0] = y;
        for (var l = 1; l < w; l++) {
          for (var R = _ >>> 26, ee = _ & 67108863, oe = Math.min(l, a.length - 1), V = Math.max(0, l - b.length + 1); V <= oe; V++) {
            var W = l - V | 0;
            x = b.words[W] | 0, A = a.words[V] | 0, S = x * A + ee, R += S / 67108864 | 0, ee = S & 67108863;
          }
          d.words[l] = ee | 0, _ = R | 0;
        }
        return _ !== 0 ? d.words[l] = _ | 0 : d.length--, d._strip();
      }
      var T = function(a, d, w) {
        var x = a.words, A = d.words, S = w.words, y = 0, _, l, R, ee = x[0] | 0, oe = ee & 8191, V = ee >>> 13, W = x[1] | 0, F = W & 8191, re = W >>> 13, he = x[2] | 0, Z = he & 8191, K = he >>> 13, ce = x[3] | 0, ve = ce & 8191, Be = ce >>> 13, te = x[4] | 0, C = te & 8191, L = te >>> 13, G = x[5] | 0, de = G & 8191, me = G >>> 13, Te = x[6] | 0, He = Te & 8191, H = Te >>> 13, se = x[7] | 0, fe = se & 8191, _e = se >>> 13, Ce = x[8] | 0, Ve = Ce & 8191, ke = Ce >>> 13, Q = x[9] | 0, Se = Q & 8191, Ae = Q >>> 13, $e = A[0] | 0, pe = $e & 8191, Ee = $e >>> 13, J = A[1] | 0, Ie = J & 8191, qe = J >>> 13, P = A[2] | 0, Me = P & 8191, be = P >>> 13, ie = A[3] | 0, le = ie & 8191, ge = ie >>> 13, Ge = A[4] | 0, je = Ge & 8191, Ne = Ge >>> 13, nt = A[5] | 0, st = nt & 8191, Je = nt >>> 13, ft = A[6] | 0, $ = ft & 8191, X = ft >>> 13, ne = A[7] | 0, O = ne & 8191, ae = ne >>> 13, we = A[8] | 0, xe = we & 8191, Re = we >>> 13, De = A[9] | 0, ze = De & 8191, Ue = De >>> 13;
        w.negative = a.negative ^ d.negative, w.length = 19, _ = Math.imul(oe, pe), l = Math.imul(oe, Ee), l = l + Math.imul(V, pe) | 0, R = Math.imul(V, Ee);
        var mt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, _ = Math.imul(F, pe), l = Math.imul(F, Ee), l = l + Math.imul(re, pe) | 0, R = Math.imul(re, Ee), _ = _ + Math.imul(oe, Ie) | 0, l = l + Math.imul(oe, qe) | 0, l = l + Math.imul(V, Ie) | 0, R = R + Math.imul(V, qe) | 0;
        var et = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _ = Math.imul(Z, pe), l = Math.imul(Z, Ee), l = l + Math.imul(K, pe) | 0, R = Math.imul(K, Ee), _ = _ + Math.imul(F, Ie) | 0, l = l + Math.imul(F, qe) | 0, l = l + Math.imul(re, Ie) | 0, R = R + Math.imul(re, qe) | 0, _ = _ + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, be) | 0, l = l + Math.imul(V, Me) | 0, R = R + Math.imul(V, be) | 0;
        var ut = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, _ = Math.imul(ve, pe), l = Math.imul(ve, Ee), l = l + Math.imul(Be, pe) | 0, R = Math.imul(Be, Ee), _ = _ + Math.imul(Z, Ie) | 0, l = l + Math.imul(Z, qe) | 0, l = l + Math.imul(K, Ie) | 0, R = R + Math.imul(K, qe) | 0, _ = _ + Math.imul(F, Me) | 0, l = l + Math.imul(F, be) | 0, l = l + Math.imul(re, Me) | 0, R = R + Math.imul(re, be) | 0, _ = _ + Math.imul(oe, le) | 0, l = l + Math.imul(oe, ge) | 0, l = l + Math.imul(V, le) | 0, R = R + Math.imul(V, ge) | 0;
        var ct = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, _ = Math.imul(C, pe), l = Math.imul(C, Ee), l = l + Math.imul(L, pe) | 0, R = Math.imul(L, Ee), _ = _ + Math.imul(ve, Ie) | 0, l = l + Math.imul(ve, qe) | 0, l = l + Math.imul(Be, Ie) | 0, R = R + Math.imul(Be, qe) | 0, _ = _ + Math.imul(Z, Me) | 0, l = l + Math.imul(Z, be) | 0, l = l + Math.imul(K, Me) | 0, R = R + Math.imul(K, be) | 0, _ = _ + Math.imul(F, le) | 0, l = l + Math.imul(F, ge) | 0, l = l + Math.imul(re, le) | 0, R = R + Math.imul(re, ge) | 0, _ = _ + Math.imul(oe, je) | 0, l = l + Math.imul(oe, Ne) | 0, l = l + Math.imul(V, je) | 0, R = R + Math.imul(V, Ne) | 0;
        var vt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, _ = Math.imul(de, pe), l = Math.imul(de, Ee), l = l + Math.imul(me, pe) | 0, R = Math.imul(me, Ee), _ = _ + Math.imul(C, Ie) | 0, l = l + Math.imul(C, qe) | 0, l = l + Math.imul(L, Ie) | 0, R = R + Math.imul(L, qe) | 0, _ = _ + Math.imul(ve, Me) | 0, l = l + Math.imul(ve, be) | 0, l = l + Math.imul(Be, Me) | 0, R = R + Math.imul(Be, be) | 0, _ = _ + Math.imul(Z, le) | 0, l = l + Math.imul(Z, ge) | 0, l = l + Math.imul(K, le) | 0, R = R + Math.imul(K, ge) | 0, _ = _ + Math.imul(F, je) | 0, l = l + Math.imul(F, Ne) | 0, l = l + Math.imul(re, je) | 0, R = R + Math.imul(re, Ne) | 0, _ = _ + Math.imul(oe, st) | 0, l = l + Math.imul(oe, Je) | 0, l = l + Math.imul(V, st) | 0, R = R + Math.imul(V, Je) | 0;
        var pt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, _ = Math.imul(He, pe), l = Math.imul(He, Ee), l = l + Math.imul(H, pe) | 0, R = Math.imul(H, Ee), _ = _ + Math.imul(de, Ie) | 0, l = l + Math.imul(de, qe) | 0, l = l + Math.imul(me, Ie) | 0, R = R + Math.imul(me, qe) | 0, _ = _ + Math.imul(C, Me) | 0, l = l + Math.imul(C, be) | 0, l = l + Math.imul(L, Me) | 0, R = R + Math.imul(L, be) | 0, _ = _ + Math.imul(ve, le) | 0, l = l + Math.imul(ve, ge) | 0, l = l + Math.imul(Be, le) | 0, R = R + Math.imul(Be, ge) | 0, _ = _ + Math.imul(Z, je) | 0, l = l + Math.imul(Z, Ne) | 0, l = l + Math.imul(K, je) | 0, R = R + Math.imul(K, Ne) | 0, _ = _ + Math.imul(F, st) | 0, l = l + Math.imul(F, Je) | 0, l = l + Math.imul(re, st) | 0, R = R + Math.imul(re, Je) | 0, _ = _ + Math.imul(oe, $) | 0, l = l + Math.imul(oe, X) | 0, l = l + Math.imul(V, $) | 0, R = R + Math.imul(V, X) | 0;
        var ht = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, _ = Math.imul(fe, pe), l = Math.imul(fe, Ee), l = l + Math.imul(_e, pe) | 0, R = Math.imul(_e, Ee), _ = _ + Math.imul(He, Ie) | 0, l = l + Math.imul(He, qe) | 0, l = l + Math.imul(H, Ie) | 0, R = R + Math.imul(H, qe) | 0, _ = _ + Math.imul(de, Me) | 0, l = l + Math.imul(de, be) | 0, l = l + Math.imul(me, Me) | 0, R = R + Math.imul(me, be) | 0, _ = _ + Math.imul(C, le) | 0, l = l + Math.imul(C, ge) | 0, l = l + Math.imul(L, le) | 0, R = R + Math.imul(L, ge) | 0, _ = _ + Math.imul(ve, je) | 0, l = l + Math.imul(ve, Ne) | 0, l = l + Math.imul(Be, je) | 0, R = R + Math.imul(Be, Ne) | 0, _ = _ + Math.imul(Z, st) | 0, l = l + Math.imul(Z, Je) | 0, l = l + Math.imul(K, st) | 0, R = R + Math.imul(K, Je) | 0, _ = _ + Math.imul(F, $) | 0, l = l + Math.imul(F, X) | 0, l = l + Math.imul(re, $) | 0, R = R + Math.imul(re, X) | 0, _ = _ + Math.imul(oe, O) | 0, l = l + Math.imul(oe, ae) | 0, l = l + Math.imul(V, O) | 0, R = R + Math.imul(V, ae) | 0;
        var dt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, _ = Math.imul(Ve, pe), l = Math.imul(Ve, Ee), l = l + Math.imul(ke, pe) | 0, R = Math.imul(ke, Ee), _ = _ + Math.imul(fe, Ie) | 0, l = l + Math.imul(fe, qe) | 0, l = l + Math.imul(_e, Ie) | 0, R = R + Math.imul(_e, qe) | 0, _ = _ + Math.imul(He, Me) | 0, l = l + Math.imul(He, be) | 0, l = l + Math.imul(H, Me) | 0, R = R + Math.imul(H, be) | 0, _ = _ + Math.imul(de, le) | 0, l = l + Math.imul(de, ge) | 0, l = l + Math.imul(me, le) | 0, R = R + Math.imul(me, ge) | 0, _ = _ + Math.imul(C, je) | 0, l = l + Math.imul(C, Ne) | 0, l = l + Math.imul(L, je) | 0, R = R + Math.imul(L, Ne) | 0, _ = _ + Math.imul(ve, st) | 0, l = l + Math.imul(ve, Je) | 0, l = l + Math.imul(Be, st) | 0, R = R + Math.imul(Be, Je) | 0, _ = _ + Math.imul(Z, $) | 0, l = l + Math.imul(Z, X) | 0, l = l + Math.imul(K, $) | 0, R = R + Math.imul(K, X) | 0, _ = _ + Math.imul(F, O) | 0, l = l + Math.imul(F, ae) | 0, l = l + Math.imul(re, O) | 0, R = R + Math.imul(re, ae) | 0, _ = _ + Math.imul(oe, xe) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(V, xe) | 0, R = R + Math.imul(V, Re) | 0;
        var lt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, _ = Math.imul(Se, pe), l = Math.imul(Se, Ee), l = l + Math.imul(Ae, pe) | 0, R = Math.imul(Ae, Ee), _ = _ + Math.imul(Ve, Ie) | 0, l = l + Math.imul(Ve, qe) | 0, l = l + Math.imul(ke, Ie) | 0, R = R + Math.imul(ke, qe) | 0, _ = _ + Math.imul(fe, Me) | 0, l = l + Math.imul(fe, be) | 0, l = l + Math.imul(_e, Me) | 0, R = R + Math.imul(_e, be) | 0, _ = _ + Math.imul(He, le) | 0, l = l + Math.imul(He, ge) | 0, l = l + Math.imul(H, le) | 0, R = R + Math.imul(H, ge) | 0, _ = _ + Math.imul(de, je) | 0, l = l + Math.imul(de, Ne) | 0, l = l + Math.imul(me, je) | 0, R = R + Math.imul(me, Ne) | 0, _ = _ + Math.imul(C, st) | 0, l = l + Math.imul(C, Je) | 0, l = l + Math.imul(L, st) | 0, R = R + Math.imul(L, Je) | 0, _ = _ + Math.imul(ve, $) | 0, l = l + Math.imul(ve, X) | 0, l = l + Math.imul(Be, $) | 0, R = R + Math.imul(Be, X) | 0, _ = _ + Math.imul(Z, O) | 0, l = l + Math.imul(Z, ae) | 0, l = l + Math.imul(K, O) | 0, R = R + Math.imul(K, ae) | 0, _ = _ + Math.imul(F, xe) | 0, l = l + Math.imul(F, Re) | 0, l = l + Math.imul(re, xe) | 0, R = R + Math.imul(re, Re) | 0, _ = _ + Math.imul(oe, ze) | 0, l = l + Math.imul(oe, Ue) | 0, l = l + Math.imul(V, ze) | 0, R = R + Math.imul(V, Ue) | 0;
        var tt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, _ = Math.imul(Se, Ie), l = Math.imul(Se, qe), l = l + Math.imul(Ae, Ie) | 0, R = Math.imul(Ae, qe), _ = _ + Math.imul(Ve, Me) | 0, l = l + Math.imul(Ve, be) | 0, l = l + Math.imul(ke, Me) | 0, R = R + Math.imul(ke, be) | 0, _ = _ + Math.imul(fe, le) | 0, l = l + Math.imul(fe, ge) | 0, l = l + Math.imul(_e, le) | 0, R = R + Math.imul(_e, ge) | 0, _ = _ + Math.imul(He, je) | 0, l = l + Math.imul(He, Ne) | 0, l = l + Math.imul(H, je) | 0, R = R + Math.imul(H, Ne) | 0, _ = _ + Math.imul(de, st) | 0, l = l + Math.imul(de, Je) | 0, l = l + Math.imul(me, st) | 0, R = R + Math.imul(me, Je) | 0, _ = _ + Math.imul(C, $) | 0, l = l + Math.imul(C, X) | 0, l = l + Math.imul(L, $) | 0, R = R + Math.imul(L, X) | 0, _ = _ + Math.imul(ve, O) | 0, l = l + Math.imul(ve, ae) | 0, l = l + Math.imul(Be, O) | 0, R = R + Math.imul(Be, ae) | 0, _ = _ + Math.imul(Z, xe) | 0, l = l + Math.imul(Z, Re) | 0, l = l + Math.imul(K, xe) | 0, R = R + Math.imul(K, Re) | 0, _ = _ + Math.imul(F, ze) | 0, l = l + Math.imul(F, Ue) | 0, l = l + Math.imul(re, ze) | 0, R = R + Math.imul(re, Ue) | 0;
        var ot = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, _ = Math.imul(Se, Me), l = Math.imul(Se, be), l = l + Math.imul(Ae, Me) | 0, R = Math.imul(Ae, be), _ = _ + Math.imul(Ve, le) | 0, l = l + Math.imul(Ve, ge) | 0, l = l + Math.imul(ke, le) | 0, R = R + Math.imul(ke, ge) | 0, _ = _ + Math.imul(fe, je) | 0, l = l + Math.imul(fe, Ne) | 0, l = l + Math.imul(_e, je) | 0, R = R + Math.imul(_e, Ne) | 0, _ = _ + Math.imul(He, st) | 0, l = l + Math.imul(He, Je) | 0, l = l + Math.imul(H, st) | 0, R = R + Math.imul(H, Je) | 0, _ = _ + Math.imul(de, $) | 0, l = l + Math.imul(de, X) | 0, l = l + Math.imul(me, $) | 0, R = R + Math.imul(me, X) | 0, _ = _ + Math.imul(C, O) | 0, l = l + Math.imul(C, ae) | 0, l = l + Math.imul(L, O) | 0, R = R + Math.imul(L, ae) | 0, _ = _ + Math.imul(ve, xe) | 0, l = l + Math.imul(ve, Re) | 0, l = l + Math.imul(Be, xe) | 0, R = R + Math.imul(Be, Re) | 0, _ = _ + Math.imul(Z, ze) | 0, l = l + Math.imul(Z, Ue) | 0, l = l + Math.imul(K, ze) | 0, R = R + Math.imul(K, Ue) | 0;
        var Qe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, _ = Math.imul(Se, le), l = Math.imul(Se, ge), l = l + Math.imul(Ae, le) | 0, R = Math.imul(Ae, ge), _ = _ + Math.imul(Ve, je) | 0, l = l + Math.imul(Ve, Ne) | 0, l = l + Math.imul(ke, je) | 0, R = R + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(fe, st) | 0, l = l + Math.imul(fe, Je) | 0, l = l + Math.imul(_e, st) | 0, R = R + Math.imul(_e, Je) | 0, _ = _ + Math.imul(He, $) | 0, l = l + Math.imul(He, X) | 0, l = l + Math.imul(H, $) | 0, R = R + Math.imul(H, X) | 0, _ = _ + Math.imul(de, O) | 0, l = l + Math.imul(de, ae) | 0, l = l + Math.imul(me, O) | 0, R = R + Math.imul(me, ae) | 0, _ = _ + Math.imul(C, xe) | 0, l = l + Math.imul(C, Re) | 0, l = l + Math.imul(L, xe) | 0, R = R + Math.imul(L, Re) | 0, _ = _ + Math.imul(ve, ze) | 0, l = l + Math.imul(ve, Ue) | 0, l = l + Math.imul(Be, ze) | 0, R = R + Math.imul(Be, Ue) | 0;
        var rt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, _ = Math.imul(Se, je), l = Math.imul(Se, Ne), l = l + Math.imul(Ae, je) | 0, R = Math.imul(Ae, Ne), _ = _ + Math.imul(Ve, st) | 0, l = l + Math.imul(Ve, Je) | 0, l = l + Math.imul(ke, st) | 0, R = R + Math.imul(ke, Je) | 0, _ = _ + Math.imul(fe, $) | 0, l = l + Math.imul(fe, X) | 0, l = l + Math.imul(_e, $) | 0, R = R + Math.imul(_e, X) | 0, _ = _ + Math.imul(He, O) | 0, l = l + Math.imul(He, ae) | 0, l = l + Math.imul(H, O) | 0, R = R + Math.imul(H, ae) | 0, _ = _ + Math.imul(de, xe) | 0, l = l + Math.imul(de, Re) | 0, l = l + Math.imul(me, xe) | 0, R = R + Math.imul(me, Re) | 0, _ = _ + Math.imul(C, ze) | 0, l = l + Math.imul(C, Ue) | 0, l = l + Math.imul(L, ze) | 0, R = R + Math.imul(L, Ue) | 0;
        var it = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, _ = Math.imul(Se, st), l = Math.imul(Se, Je), l = l + Math.imul(Ae, st) | 0, R = Math.imul(Ae, Je), _ = _ + Math.imul(Ve, $) | 0, l = l + Math.imul(Ve, X) | 0, l = l + Math.imul(ke, $) | 0, R = R + Math.imul(ke, X) | 0, _ = _ + Math.imul(fe, O) | 0, l = l + Math.imul(fe, ae) | 0, l = l + Math.imul(_e, O) | 0, R = R + Math.imul(_e, ae) | 0, _ = _ + Math.imul(He, xe) | 0, l = l + Math.imul(He, Re) | 0, l = l + Math.imul(H, xe) | 0, R = R + Math.imul(H, Re) | 0, _ = _ + Math.imul(de, ze) | 0, l = l + Math.imul(de, Ue) | 0, l = l + Math.imul(me, ze) | 0, R = R + Math.imul(me, Ue) | 0;
        var Ye = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, _ = Math.imul(Se, $), l = Math.imul(Se, X), l = l + Math.imul(Ae, $) | 0, R = Math.imul(Ae, X), _ = _ + Math.imul(Ve, O) | 0, l = l + Math.imul(Ve, ae) | 0, l = l + Math.imul(ke, O) | 0, R = R + Math.imul(ke, ae) | 0, _ = _ + Math.imul(fe, xe) | 0, l = l + Math.imul(fe, Re) | 0, l = l + Math.imul(_e, xe) | 0, R = R + Math.imul(_e, Re) | 0, _ = _ + Math.imul(He, ze) | 0, l = l + Math.imul(He, Ue) | 0, l = l + Math.imul(H, ze) | 0, R = R + Math.imul(H, Ue) | 0;
        var Oe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, _ = Math.imul(Se, O), l = Math.imul(Se, ae), l = l + Math.imul(Ae, O) | 0, R = Math.imul(Ae, ae), _ = _ + Math.imul(Ve, xe) | 0, l = l + Math.imul(Ve, Re) | 0, l = l + Math.imul(ke, xe) | 0, R = R + Math.imul(ke, Re) | 0, _ = _ + Math.imul(fe, ze) | 0, l = l + Math.imul(fe, Ue) | 0, l = l + Math.imul(_e, ze) | 0, R = R + Math.imul(_e, Ue) | 0;
        var Pe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, _ = Math.imul(Se, xe), l = Math.imul(Se, Re), l = l + Math.imul(Ae, xe) | 0, R = Math.imul(Ae, Re), _ = _ + Math.imul(Ve, ze) | 0, l = l + Math.imul(Ve, Ue) | 0, l = l + Math.imul(ke, ze) | 0, R = R + Math.imul(ke, Ue) | 0;
        var Ke = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, _ = Math.imul(Se, ze), l = Math.imul(Se, Ue), l = l + Math.imul(Ae, ze) | 0, R = Math.imul(Ae, Ue);
        var Fe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        return y = (R + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, S[0] = mt, S[1] = et, S[2] = ut, S[3] = ct, S[4] = vt, S[5] = pt, S[6] = ht, S[7] = dt, S[8] = lt, S[9] = tt, S[10] = ot, S[11] = Qe, S[12] = rt, S[13] = it, S[14] = Ye, S[15] = Oe, S[16] = Pe, S[17] = Ke, S[18] = Fe, y !== 0 && (S[19] = y, w.length++), w;
      };
      Math.imul || (T = B);
      function k(b, a, d) {
        d.negative = a.negative ^ b.negative, d.length = b.length + a.length;
        for (var w = 0, x = 0, A = 0; A < d.length - 1; A++) {
          var S = x;
          x = 0;
          for (var y = w & 67108863, _ = Math.min(A, a.length - 1), l = Math.max(0, A - b.length + 1); l <= _; l++) {
            var R = A - l, ee = b.words[R] | 0, oe = a.words[l] | 0, V = ee * oe, W = V & 67108863;
            S = S + (V / 67108864 | 0) | 0, W = W + y | 0, y = W & 67108863, S = S + (W >>> 26) | 0, x += S >>> 26, S &= 67108863;
          }
          d.words[A] = y, w = S, S = x;
        }
        return w !== 0 ? d.words[A] = w : d.length--, d._strip();
      }
      function N(b, a, d) {
        return k(b, a, d);
      }
      n.prototype.mulTo = function(a, d) {
        var w, x = this.length + a.length;
        return this.length === 10 && a.length === 10 ? w = T(this, a, d) : x < 63 ? w = B(this, a, d) : x < 1024 ? w = k(this, a, d) : w = N(this, a, d), w;
      }, n.prototype.mul = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), this.mulTo(a, d);
      }, n.prototype.mulf = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), N(this, a, d);
      }, n.prototype.imul = function(a) {
        return this.clone().mulTo(a, this);
      }, n.prototype.imuln = function(a) {
        var d = a < 0;
        d && (a = -a), i(typeof a == "number"), i(a < 67108864);
        for (var w = 0, x = 0; x < this.length; x++) {
          var A = (this.words[x] | 0) * a, S = (A & 67108863) + (w & 67108863);
          w >>= 26, w += A / 67108864 | 0, w += S >>> 26, this.words[x] = S & 67108863;
        }
        return w !== 0 && (this.words[x] = w, this.length++), d ? this.ineg() : this;
      }, n.prototype.muln = function(a) {
        return this.clone().imuln(a);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(a) {
        var d = I(a);
        if (d.length === 0)
          return new n(1);
        for (var w = this, x = 0; x < d.length && d[x] === 0; x++, w = w.sqr())
          ;
        if (++x < d.length)
          for (var A = w.sqr(); x < d.length; x++, A = A.sqr())
            d[x] !== 0 && (w = w.mul(A));
        return w;
      }, n.prototype.iushln = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 67108863 >>> 26 - d << 26 - d, A;
        if (d !== 0) {
          var S = 0;
          for (A = 0; A < this.length; A++) {
            var y = this.words[A] & x, _ = (this.words[A] | 0) - y << d;
            this.words[A] = _ | S, S = y >>> 26 - d;
          }
          S && (this.words[A] = S, this.length++);
        }
        if (w !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + w] = this.words[A];
          for (A = 0; A < w; A++)
            this.words[A] = 0;
          this.length += w;
        }
        return this._strip();
      }, n.prototype.ishln = function(a) {
        return i(this.negative === 0), this.iushln(a);
      }, n.prototype.iushrn = function(a, d, w) {
        i(typeof a == "number" && a >= 0);
        var x;
        d ? x = (d - d % 26) / 26 : x = 0;
        var A = a % 26, S = Math.min((a - A) / 26, this.length), y = 67108863 ^ 67108863 >>> A << A, _ = w;
        if (x -= S, x = Math.max(0, x), _) {
          for (var l = 0; l < S; l++)
            _.words[l] = this.words[l];
          _.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, l = 0; l < this.length; l++)
              this.words[l] = this.words[l + S];
          else
            this.words[0] = 0, this.length = 1;
        var R = 0;
        for (l = this.length - 1; l >= 0 && (R !== 0 || l >= x); l--) {
          var ee = this.words[l] | 0;
          this.words[l] = R << 26 - A | ee >>> A, R = ee & y;
        }
        return _ && R !== 0 && (_.words[_.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(a, d, w) {
        return i(this.negative === 0), this.iushrn(a, d, w);
      }, n.prototype.shln = function(a) {
        return this.clone().ishln(a);
      }, n.prototype.ushln = function(a) {
        return this.clone().iushln(a);
      }, n.prototype.shrn = function(a) {
        return this.clone().ishrn(a);
      }, n.prototype.ushrn = function(a) {
        return this.clone().iushrn(a);
      }, n.prototype.testn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return !1;
        var A = this.words[w];
        return !!(A & x);
      }, n.prototype.imaskn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w)
          return this;
        if (d !== 0 && w++, this.length = Math.min(w, this.length), d !== 0) {
          var x = 67108863 ^ 67108863 >>> d << d;
          this.words[this.length - 1] &= x;
        }
        return this._strip();
      }, n.prototype.maskn = function(a) {
        return this.clone().imaskn(a);
      }, n.prototype.iaddn = function(a) {
        return i(typeof a == "number"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
      }, n.prototype._iaddn = function(a) {
        this.words[0] += a;
        for (var d = 0; d < this.length && this.words[d] >= 67108864; d++)
          this.words[d] -= 67108864, d === this.length - 1 ? this.words[d + 1] = 1 : this.words[d + 1]++;
        return this.length = Math.max(this.length, d + 1), this;
      }, n.prototype.isubn = function(a) {
        if (i(typeof a == "number"), i(a < 67108864), a < 0)
          return this.iaddn(-a);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(a), this.negative = 1, this;
        if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var d = 0; d < this.length && this.words[d] < 0; d++)
            this.words[d] += 67108864, this.words[d + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(a) {
        return this.clone().iaddn(a);
      }, n.prototype.subn = function(a) {
        return this.clone().isubn(a);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(a, d, w) {
        var x = a.length + w, A;
        this._expand(x);
        var S, y = 0;
        for (A = 0; A < a.length; A++) {
          S = (this.words[A + w] | 0) + y;
          var _ = (a.words[A] | 0) * d;
          S -= _ & 67108863, y = (S >> 26) - (_ / 67108864 | 0), this.words[A + w] = S & 67108863;
        }
        for (; A < this.length - w; A++)
          S = (this.words[A + w] | 0) + y, y = S >> 26, this.words[A + w] = S & 67108863;
        if (y === 0)
          return this._strip();
        for (i(y === -1), y = 0, A = 0; A < this.length; A++)
          S = -(this.words[A] | 0) + y, y = S >> 26, this.words[A] = S & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(a, d) {
        var w = this.length - a.length, x = this.clone(), A = a, S = A.words[A.length - 1] | 0, y = this._countBits(S);
        w = 26 - y, w !== 0 && (A = A.ushln(w), x.iushln(w), S = A.words[A.length - 1] | 0);
        var _ = x.length - A.length, l;
        if (d !== "mod") {
          l = new n(null), l.length = _ + 1, l.words = new Array(l.length);
          for (var R = 0; R < l.length; R++)
            l.words[R] = 0;
        }
        var ee = x.clone()._ishlnsubmul(A, 1, _);
        ee.negative === 0 && (x = ee, l && (l.words[_] = 1));
        for (var oe = _ - 1; oe >= 0; oe--) {
          var V = (x.words[A.length + oe] | 0) * 67108864 + (x.words[A.length + oe - 1] | 0);
          for (V = Math.min(V / S | 0, 67108863), x._ishlnsubmul(A, V, oe); x.negative !== 0; )
            V--, x.negative = 0, x._ishlnsubmul(A, 1, oe), x.isZero() || (x.negative ^= 1);
          l && (l.words[oe] = V);
        }
        return l && l._strip(), x._strip(), d !== "div" && w !== 0 && x.iushrn(w), {
          div: l || null,
          mod: x
        };
      }, n.prototype.divmod = function(a, d, w) {
        if (i(!a.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var x, A, S;
        return this.negative !== 0 && a.negative === 0 ? (S = this.neg().divmod(a, d), d !== "mod" && (x = S.div.neg()), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.iadd(a)), {
          div: x,
          mod: A
        }) : this.negative === 0 && a.negative !== 0 ? (S = this.divmod(a.neg(), d), d !== "mod" && (x = S.div.neg()), {
          div: x,
          mod: S.mod
        }) : this.negative & a.negative ? (S = this.neg().divmod(a.neg(), d), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.isub(a)), {
          div: S.div,
          mod: A
        }) : a.length > this.length || this.cmp(a) < 0 ? {
          div: new n(0),
          mod: this
        } : a.length === 1 ? d === "div" ? {
          div: this.divn(a.words[0]),
          mod: null
        } : d === "mod" ? {
          div: null,
          mod: new n(this.modrn(a.words[0]))
        } : {
          div: this.divn(a.words[0]),
          mod: new n(this.modrn(a.words[0]))
        } : this._wordDiv(a, d);
      }, n.prototype.div = function(a) {
        return this.divmod(a, "div", !1).div;
      }, n.prototype.mod = function(a) {
        return this.divmod(a, "mod", !1).mod;
      }, n.prototype.umod = function(a) {
        return this.divmod(a, "mod", !0).mod;
      }, n.prototype.divRound = function(a) {
        var d = this.divmod(a);
        if (d.mod.isZero())
          return d.div;
        var w = d.div.negative !== 0 ? d.mod.isub(a) : d.mod, x = a.ushrn(1), A = a.andln(1), S = w.cmp(x);
        return S < 0 || A === 1 && S === 0 ? d.div : d.div.negative !== 0 ? d.div.isubn(1) : d.div.iaddn(1);
      }, n.prototype.modrn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = (1 << 26) % a, x = 0, A = this.length - 1; A >= 0; A--)
          x = (w * x + (this.words[A] | 0)) % a;
        return d ? -x : x;
      }, n.prototype.modn = function(a) {
        return this.modrn(a);
      }, n.prototype.idivn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = 0, x = this.length - 1; x >= 0; x--) {
          var A = (this.words[x] | 0) + w * 67108864;
          this.words[x] = A / a | 0, w = A % a;
        }
        return this._strip(), d ? this.ineg() : this;
      }, n.prototype.divn = function(a) {
        return this.clone().idivn(a);
      }, n.prototype.egcd = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = new n(0), y = new n(1), _ = 0; d.isEven() && w.isEven(); )
          d.iushrn(1), w.iushrn(1), ++_;
        for (var l = w.clone(), R = d.clone(); !d.isZero(); ) {
          for (var ee = 0, oe = 1; !(d.words[0] & oe) && ee < 26; ++ee, oe <<= 1)
            ;
          if (ee > 0)
            for (d.iushrn(ee); ee-- > 0; )
              (x.isOdd() || A.isOdd()) && (x.iadd(l), A.isub(R)), x.iushrn(1), A.iushrn(1);
          for (var V = 0, W = 1; !(w.words[0] & W) && V < 26; ++V, W <<= 1)
            ;
          if (V > 0)
            for (w.iushrn(V); V-- > 0; )
              (S.isOdd() || y.isOdd()) && (S.iadd(l), y.isub(R)), S.iushrn(1), y.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(S), A.isub(y)) : (w.isub(d), S.isub(x), y.isub(A));
        }
        return {
          a: S,
          b: y,
          gcd: w.iushln(_)
        };
      }, n.prototype._invmp = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = w.clone(); d.cmpn(1) > 0 && w.cmpn(1) > 0; ) {
          for (var y = 0, _ = 1; !(d.words[0] & _) && y < 26; ++y, _ <<= 1)
            ;
          if (y > 0)
            for (d.iushrn(y); y-- > 0; )
              x.isOdd() && x.iadd(S), x.iushrn(1);
          for (var l = 0, R = 1; !(w.words[0] & R) && l < 26; ++l, R <<= 1)
            ;
          if (l > 0)
            for (w.iushrn(l); l-- > 0; )
              A.isOdd() && A.iadd(S), A.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(A)) : (w.isub(d), A.isub(x));
        }
        var ee;
        return d.cmpn(1) === 0 ? ee = x : ee = A, ee.cmpn(0) < 0 && ee.iadd(a), ee;
      }, n.prototype.gcd = function(a) {
        if (this.isZero())
          return a.abs();
        if (a.isZero())
          return this.abs();
        var d = this.clone(), w = a.clone();
        d.negative = 0, w.negative = 0;
        for (var x = 0; d.isEven() && w.isEven(); x++)
          d.iushrn(1), w.iushrn(1);
        do {
          for (; d.isEven(); )
            d.iushrn(1);
          for (; w.isEven(); )
            w.iushrn(1);
          var A = d.cmp(w);
          if (A < 0) {
            var S = d;
            d = w, w = S;
          } else if (A === 0 || w.cmpn(1) === 0)
            break;
          d.isub(w);
        } while (!0);
        return w.iushln(x);
      }, n.prototype.invm = function(a) {
        return this.egcd(a).a.umod(a);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(a) {
        return this.words[0] & a;
      }, n.prototype.bincn = function(a) {
        i(typeof a == "number");
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return this._expand(w + 1), this.words[w] |= x, this;
        for (var A = x, S = w; A !== 0 && S < this.length; S++) {
          var y = this.words[S] | 0;
          y += A, A = y >>> 26, y &= 67108863, this.words[S] = y;
        }
        return A !== 0 && (this.words[S] = A, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(a) {
        var d = a < 0;
        if (this.negative !== 0 && !d)
          return -1;
        if (this.negative === 0 && d)
          return 1;
        this._strip();
        var w;
        if (this.length > 1)
          w = 1;
        else {
          d && (a = -a), i(a <= 67108863, "Number is too big");
          var x = this.words[0] | 0;
          w = x === a ? 0 : x < a ? -1 : 1;
        }
        return this.negative !== 0 ? -w | 0 : w;
      }, n.prototype.cmp = function(a) {
        if (this.negative !== 0 && a.negative === 0)
          return -1;
        if (this.negative === 0 && a.negative !== 0)
          return 1;
        var d = this.ucmp(a);
        return this.negative !== 0 ? -d | 0 : d;
      }, n.prototype.ucmp = function(a) {
        if (this.length > a.length)
          return 1;
        if (this.length < a.length)
          return -1;
        for (var d = 0, w = this.length - 1; w >= 0; w--) {
          var x = this.words[w] | 0, A = a.words[w] | 0;
          if (x !== A) {
            x < A ? d = -1 : x > A && (d = 1);
            break;
          }
        }
        return d;
      }, n.prototype.gtn = function(a) {
        return this.cmpn(a) === 1;
      }, n.prototype.gt = function(a) {
        return this.cmp(a) === 1;
      }, n.prototype.gten = function(a) {
        return this.cmpn(a) >= 0;
      }, n.prototype.gte = function(a) {
        return this.cmp(a) >= 0;
      }, n.prototype.ltn = function(a) {
        return this.cmpn(a) === -1;
      }, n.prototype.lt = function(a) {
        return this.cmp(a) === -1;
      }, n.prototype.lten = function(a) {
        return this.cmpn(a) <= 0;
      }, n.prototype.lte = function(a) {
        return this.cmp(a) <= 0;
      }, n.prototype.eqn = function(a) {
        return this.cmpn(a) === 0;
      }, n.prototype.eq = function(a) {
        return this.cmp(a) === 0;
      }, n.red = function(a) {
        return new j(a);
      }, n.prototype.toRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
      }, n.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(a) {
        return this.red = a, this;
      }, n.prototype.forceRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(a);
      }, n.prototype.redAdd = function(a) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
      }, n.prototype.redIAdd = function(a) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
      }, n.prototype.redSub = function(a) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
      }, n.prototype.redISub = function(a) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
      }, n.prototype.redShl = function(a) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
      }, n.prototype.redMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
      }, n.prototype.redIMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
      }, n.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(a) {
        return i(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
      };
      var q = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function D(b, a) {
        this.name = b, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      D.prototype._tmp = function() {
        var a = new n(null);
        return a.words = new Array(Math.ceil(this.n / 13)), a;
      }, D.prototype.ireduce = function(a) {
        var d = a, w;
        do
          this.split(d, this.tmp), d = this.imulK(d), d = d.iadd(this.tmp), w = d.bitLength();
        while (w > this.n);
        var x = w < this.n ? -1 : d.ucmp(this.p);
        return x === 0 ? (d.words[0] = 0, d.length = 1) : x > 0 ? d.isub(this.p) : d.strip !== void 0 ? d.strip() : d._strip(), d;
      }, D.prototype.split = function(a, d) {
        a.iushrn(this.n, 0, d);
      }, D.prototype.imulK = function(a) {
        return a.imul(this.k);
      };
      function U() {
        D.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      o(U, D), U.prototype.split = function(a, d) {
        for (var w = 4194303, x = Math.min(a.length, 9), A = 0; A < x; A++)
          d.words[A] = a.words[A];
        if (d.length = x, a.length <= 9) {
          a.words[0] = 0, a.length = 1;
          return;
        }
        var S = a.words[9];
        for (d.words[d.length++] = S & w, A = 10; A < a.length; A++) {
          var y = a.words[A] | 0;
          a.words[A - 10] = (y & w) << 4 | S >>> 22, S = y;
        }
        S >>>= 22, a.words[A - 10] = S, S === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
      }, U.prototype.imulK = function(a) {
        a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = a.words[w] | 0;
          d += x * 977, a.words[w] = d & 67108863, d = x * 64 + (d / 67108864 | 0);
        }
        return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
      };
      function z() {
        D.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      o(z, D);
      function Y() {
        D.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      o(Y, D);
      function ue() {
        D.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      o(ue, D), ue.prototype.imulK = function(a) {
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = (a.words[w] | 0) * 19 + d, A = x & 67108863;
          x >>>= 26, a.words[w] = A, d = x;
        }
        return d !== 0 && (a.words[a.length++] = d), a;
      }, n._prime = function(a) {
        if (q[a])
          return q[a];
        var d;
        if (a === "k256")
          d = new U();
        else if (a === "p224")
          d = new z();
        else if (a === "p192")
          d = new Y();
        else if (a === "p25519")
          d = new ue();
        else
          throw new Error("Unknown prime " + a);
        return q[a] = d, d;
      };
      function j(b) {
        if (typeof b == "string") {
          var a = n._prime(b);
          this.m = a.p, this.prime = a;
        } else
          i(b.gtn(1), "modulus must be greater than 1"), this.m = b, this.prime = null;
      }
      j.prototype._verify1 = function(a) {
        i(a.negative === 0, "red works only with positives"), i(a.red, "red works only with red numbers");
      }, j.prototype._verify2 = function(a, d) {
        i((a.negative | d.negative) === 0, "red works only with positives"), i(
          a.red && a.red === d.red,
          "red works only with red numbers"
        );
      }, j.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : (s(a, a.umod(this.m)._forceRed(this)), a);
      }, j.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      }, j.prototype.add = function(a, d) {
        this._verify2(a, d);
        var w = a.add(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
      }, j.prototype.iadd = function(a, d) {
        this._verify2(a, d);
        var w = a.iadd(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w;
      }, j.prototype.sub = function(a, d) {
        this._verify2(a, d);
        var w = a.sub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
      }, j.prototype.isub = function(a, d) {
        this._verify2(a, d);
        var w = a.isub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w;
      }, j.prototype.shl = function(a, d) {
        return this._verify1(a), this.imod(a.ushln(d));
      }, j.prototype.imul = function(a, d) {
        return this._verify2(a, d), this.imod(a.imul(d));
      }, j.prototype.mul = function(a, d) {
        return this._verify2(a, d), this.imod(a.mul(d));
      }, j.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      }, j.prototype.sqr = function(a) {
        return this.mul(a, a);
      }, j.prototype.sqrt = function(a) {
        if (a.isZero())
          return a.clone();
        var d = this.m.andln(3);
        if (i(d % 2 === 1), d === 3) {
          var w = this.m.add(new n(1)).iushrn(2);
          return this.pow(a, w);
        }
        for (var x = this.m.subn(1), A = 0; !x.isZero() && x.andln(1) === 0; )
          A++, x.iushrn(1);
        i(!x.isZero());
        var S = new n(1).toRed(this), y = S.redNeg(), _ = this.m.subn(1).iushrn(1), l = this.m.bitLength();
        for (l = new n(2 * l * l).toRed(this); this.pow(l, _).cmp(y) !== 0; )
          l.redIAdd(y);
        for (var R = this.pow(l, x), ee = this.pow(a, x.addn(1).iushrn(1)), oe = this.pow(a, x), V = A; oe.cmp(S) !== 0; ) {
          for (var W = oe, F = 0; W.cmp(S) !== 0; F++)
            W = W.redSqr();
          i(F < V);
          var re = this.pow(R, new n(1).iushln(V - F - 1));
          ee = ee.redMul(re), R = re.redSqr(), oe = oe.redMul(R), V = F;
        }
        return ee;
      }, j.prototype.invm = function(a) {
        var d = a._invmp(this.m);
        return d.negative !== 0 ? (d.negative = 0, this.imod(d).redNeg()) : this.imod(d);
      }, j.prototype.pow = function(a, d) {
        if (d.isZero())
          return new n(1).toRed(this);
        if (d.cmpn(1) === 0)
          return a.clone();
        var w = 4, x = new Array(1 << w);
        x[0] = new n(1).toRed(this), x[1] = a;
        for (var A = 2; A < x.length; A++)
          x[A] = this.mul(x[A - 1], a);
        var S = x[0], y = 0, _ = 0, l = d.bitLength() % 26;
        for (l === 0 && (l = 26), A = d.length - 1; A >= 0; A--) {
          for (var R = d.words[A], ee = l - 1; ee >= 0; ee--) {
            var oe = R >> ee & 1;
            if (S !== x[0] && (S = this.sqr(S)), oe === 0 && y === 0) {
              _ = 0;
              continue;
            }
            y <<= 1, y |= oe, _++, !(_ !== w && (A !== 0 || ee !== 0)) && (S = this.mul(S, x[y]), _ = 0, y = 0);
          }
          l = 26;
        }
        return S;
      }, j.prototype.convertTo = function(a) {
        var d = a.umod(this.m);
        return d === a ? d.clone() : d;
      }, j.prototype.convertFrom = function(a) {
        var d = a.clone();
        return d.red = null, d;
      }, n.mont = function(a) {
        return new g(a);
      };
      function g(b) {
        j.call(this, b), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(g, j), g.prototype.convertTo = function(a) {
        return this.imod(a.ushln(this.shift));
      }, g.prototype.convertFrom = function(a) {
        var d = this.imod(a.mul(this.rinv));
        return d.red = null, d;
      }, g.prototype.imul = function(a, d) {
        if (a.isZero() || d.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var w = a.imul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, g.prototype.mul = function(a, d) {
        if (a.isZero() || d.isZero())
          return new n(0)._forceRed(this);
        var w = a.mul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, g.prototype.invm = function(a) {
        var d = this.imod(a._invmp(this.m).mul(this.r2));
        return d._forceRed(this);
      };
    })(e, Ze);
  }(fo)), fo.exports;
}
var Uu, wp;
function _0() {
  if (wp)
    return Uu;
  wp = 1;
  var e = k7(), t = Ki();
  function r(n) {
    var f = i(n), u = f.toRed(e.mont(n.modulus)).redPow(new e(n.publicExponent)).fromRed();
    return { blinder: u, unblinder: f.invm(n.modulus) };
  }
  function i(n) {
    var f = n.modulus.byteLength(), u;
    do
      u = new e(t(f));
    while (u.cmp(n.modulus) >= 0 || !u.umod(n.prime1) || !u.umod(n.prime2));
    return u;
  }
  function o(n, f) {
    var u = r(f), c = f.modulus.byteLength(), h = new e(n).mul(u.blinder).umod(f.modulus), s = h.toRed(e.mont(f.prime1)), p = h.toRed(e.mont(f.prime2)), v = f.coefficient, m = f.prime1, E = f.prime2, M = s.redPow(f.exponent1).fromRed(), I = p.redPow(f.exponent2).fromRed(), B = M.isub(I).imul(v).umod(m).imul(E);
    return I.iadd(B).imul(u.unblinder).umod(f.modulus).toArrayLike(Le.Buffer, "be", c);
  }
  return o.getr = i, Uu = o, Uu;
}
var Fu = {};
const q7 = "elliptic", $7 = "6.5.4", D7 = "EC cryptography", j7 = "lib/elliptic.js", U7 = [
  "lib"
], F7 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, H7 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, z7 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], V7 = "Fedor Indutny <fedor@indutny.com>", W7 = "MIT", K7 = {
  url: "https://github.com/indutny/elliptic/issues"
}, Z7 = "https://github.com/indutny/elliptic", G7 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, J7 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, X7 = {
  name: q7,
  version: $7,
  description: D7,
  main: j7,
  files: U7,
  scripts: F7,
  repository: H7,
  keywords: z7,
  author: V7,
  license: W7,
  bugs: K7,
  homepage: Z7,
  devDependencies: G7,
  dependencies: J7
};
var Hu = {}, zu = {}, _p;
function Hg() {
  return _p || (_p = 1, function(e) {
    var t = e;
    function r(n, f) {
      if (Array.isArray(n))
        return n.slice();
      if (!n)
        return [];
      var u = [];
      if (typeof n != "string") {
        for (var c = 0; c < n.length; c++)
          u[c] = n[c] | 0;
        return u;
      }
      if (f === "hex") {
        n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n);
        for (var c = 0; c < n.length; c += 2)
          u.push(parseInt(n[c] + n[c + 1], 16));
      } else
        for (var c = 0; c < n.length; c++) {
          var h = n.charCodeAt(c), s = h >> 8, p = h & 255;
          s ? u.push(s, p) : u.push(p);
        }
      return u;
    }
    t.toArray = r;
    function i(n) {
      return n.length === 1 ? "0" + n : n;
    }
    t.zero2 = i;
    function o(n) {
      for (var f = "", u = 0; u < n.length; u++)
        f += i(n[u].toString(16));
      return f;
    }
    t.toHex = o, t.encode = function(f, u) {
      return u === "hex" ? o(f) : f;
    };
  }(zu)), zu;
}
var xp;
function zr() {
  return xp || (xp = 1, function(e) {
    var t = e, r = ar, i = Hr(), o = Hg();
    t.assert = i, t.toArray = o.toArray, t.zero2 = o.zero2, t.toHex = o.toHex, t.encode = o.encode;
    function n(s, p, v) {
      var m = new Array(Math.max(s.bitLength(), v) + 1);
      m.fill(0);
      for (var E = 1 << p + 1, M = s.clone(), I = 0; I < m.length; I++) {
        var B, T = M.andln(E - 1);
        M.isOdd() ? (T > (E >> 1) - 1 ? B = (E >> 1) - T : B = T, M.isubn(B)) : B = 0, m[I] = B, M.iushrn(1);
      }
      return m;
    }
    t.getNAF = n;
    function f(s, p) {
      var v = [
        [],
        []
      ];
      s = s.clone(), p = p.clone();
      for (var m = 0, E = 0, M; s.cmpn(-m) > 0 || p.cmpn(-E) > 0; ) {
        var I = s.andln(3) + m & 3, B = p.andln(3) + E & 3;
        I === 3 && (I = -1), B === 3 && (B = -1);
        var T;
        I & 1 ? (M = s.andln(7) + m & 7, (M === 3 || M === 5) && B === 2 ? T = -I : T = I) : T = 0, v[0].push(T);
        var k;
        B & 1 ? (M = p.andln(7) + E & 7, (M === 3 || M === 5) && I === 2 ? k = -B : k = B) : k = 0, v[1].push(k), 2 * m === T + 1 && (m = 1 - m), 2 * E === k + 1 && (E = 1 - E), s.iushrn(1), p.iushrn(1);
      }
      return v;
    }
    t.getJSF = f;
    function u(s, p, v) {
      var m = "_" + p;
      s.prototype[p] = function() {
        return this[m] !== void 0 ? this[m] : this[m] = v.call(this);
      };
    }
    t.cachedProperty = u;
    function c(s) {
      return typeof s == "string" ? t.toArray(s, "hex") : s;
    }
    t.parseBytes = c;
    function h(s) {
      return new r(s, "hex", "le");
    }
    t.intFromLE = h;
  }(Hu)), Hu;
}
var Vu = {}, Wu, Ep;
function bf() {
  if (Ep)
    return Wu;
  Ep = 1;
  var e = ar, t = zr(), r = t.getNAF, i = t.getJSF, o = t.assert;
  function n(u, c) {
    this.type = u, this.p = new e(c.p, 16), this.red = c.prime ? e.red(c.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = c.n && new e(c.n, 16), this.g = c.g && this.pointFromJSON(c.g, c.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var h = this.n && this.p.div(this.n);
    !h || h.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  Wu = n, n.prototype.point = function() {
    throw new Error("Not implemented");
  }, n.prototype.validate = function() {
    throw new Error("Not implemented");
  }, n.prototype._fixedNafMul = function(c, h) {
    o(c.precomputed);
    var s = c._getDoubles(), p = r(h, 1, this._bitLength), v = (1 << s.step + 1) - (s.step % 2 === 0 ? 2 : 1);
    v /= 3;
    var m = [], E, M;
    for (E = 0; E < p.length; E += s.step) {
      M = 0;
      for (var I = E + s.step - 1; I >= E; I--)
        M = (M << 1) + p[I];
      m.push(M);
    }
    for (var B = this.jpoint(null, null, null), T = this.jpoint(null, null, null), k = v; k > 0; k--) {
      for (E = 0; E < m.length; E++)
        M = m[E], M === k ? T = T.mixedAdd(s.points[E]) : M === -k && (T = T.mixedAdd(s.points[E].neg()));
      B = B.add(T);
    }
    return B.toP();
  }, n.prototype._wnafMul = function(c, h) {
    var s = 4, p = c._getNAFPoints(s);
    s = p.wnd;
    for (var v = p.points, m = r(h, s, this._bitLength), E = this.jpoint(null, null, null), M = m.length - 1; M >= 0; M--) {
      for (var I = 0; M >= 0 && m[M] === 0; M--)
        I++;
      if (M >= 0 && I++, E = E.dblp(I), M < 0)
        break;
      var B = m[M];
      o(B !== 0), c.type === "affine" ? B > 0 ? E = E.mixedAdd(v[B - 1 >> 1]) : E = E.mixedAdd(v[-B - 1 >> 1].neg()) : B > 0 ? E = E.add(v[B - 1 >> 1]) : E = E.add(v[-B - 1 >> 1].neg());
    }
    return c.type === "affine" ? E.toP() : E;
  }, n.prototype._wnafMulAdd = function(c, h, s, p, v) {
    var m = this._wnafT1, E = this._wnafT2, M = this._wnafT3, I = 0, B, T, k;
    for (B = 0; B < p; B++) {
      k = h[B];
      var N = k._getNAFPoints(c);
      m[B] = N.wnd, E[B] = N.points;
    }
    for (B = p - 1; B >= 1; B -= 2) {
      var q = B - 1, D = B;
      if (m[q] !== 1 || m[D] !== 1) {
        M[q] = r(s[q], m[q], this._bitLength), M[D] = r(s[D], m[D], this._bitLength), I = Math.max(M[q].length, I), I = Math.max(M[D].length, I);
        continue;
      }
      var U = [
        h[q],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        h[D]
        /* 7 */
      ];
      h[q].y.cmp(h[D].y) === 0 ? (U[1] = h[q].add(h[D]), U[2] = h[q].toJ().mixedAdd(h[D].neg())) : h[q].y.cmp(h[D].y.redNeg()) === 0 ? (U[1] = h[q].toJ().mixedAdd(h[D]), U[2] = h[q].add(h[D].neg())) : (U[1] = h[q].toJ().mixedAdd(h[D]), U[2] = h[q].toJ().mixedAdd(h[D].neg()));
      var z = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Y = i(s[q], s[D]);
      for (I = Math.max(Y[0].length, I), M[q] = new Array(I), M[D] = new Array(I), T = 0; T < I; T++) {
        var ue = Y[0][T] | 0, j = Y[1][T] | 0;
        M[q][T] = z[(ue + 1) * 3 + (j + 1)], M[D][T] = 0, E[q] = U;
      }
    }
    var g = this.jpoint(null, null, null), b = this._wnafT4;
    for (B = I; B >= 0; B--) {
      for (var a = 0; B >= 0; ) {
        var d = !0;
        for (T = 0; T < p; T++)
          b[T] = M[T][B] | 0, b[T] !== 0 && (d = !1);
        if (!d)
          break;
        a++, B--;
      }
      if (B >= 0 && a++, g = g.dblp(a), B < 0)
        break;
      for (T = 0; T < p; T++) {
        var w = b[T];
        w !== 0 && (w > 0 ? k = E[T][w - 1 >> 1] : w < 0 && (k = E[T][-w - 1 >> 1].neg()), k.type === "affine" ? g = g.mixedAdd(k) : g = g.add(k));
      }
    }
    for (B = 0; B < p; B++)
      E[B] = null;
    return v ? g : g.toP();
  };
  function f(u, c) {
    this.curve = u, this.type = c, this.precomputed = null;
  }
  return n.BasePoint = f, f.prototype.eq = function() {
    throw new Error("Not implemented");
  }, f.prototype.validate = function() {
    return this.curve.validate(this);
  }, n.prototype.decodePoint = function(c, h) {
    c = t.toArray(c, h);
    var s = this.p.byteLength();
    if ((c[0] === 4 || c[0] === 6 || c[0] === 7) && c.length - 1 === 2 * s) {
      c[0] === 6 ? o(c[c.length - 1] % 2 === 0) : c[0] === 7 && o(c[c.length - 1] % 2 === 1);
      var p = this.point(
        c.slice(1, 1 + s),
        c.slice(1 + s, 1 + 2 * s)
      );
      return p;
    } else if ((c[0] === 2 || c[0] === 3) && c.length - 1 === s)
      return this.pointFromX(c.slice(1, 1 + s), c[0] === 3);
    throw new Error("Unknown point format");
  }, f.prototype.encodeCompressed = function(c) {
    return this.encode(c, !0);
  }, f.prototype._encode = function(c) {
    var h = this.curve.p.byteLength(), s = this.getX().toArray("be", h);
    return c ? [this.getY().isEven() ? 2 : 3].concat(s) : [4].concat(s, this.getY().toArray("be", h));
  }, f.prototype.encode = function(c, h) {
    return t.encode(this._encode(h), c);
  }, f.prototype.precompute = function(c) {
    if (this.precomputed)
      return this;
    var h = {
      doubles: null,
      naf: null,
      beta: null
    };
    return h.naf = this._getNAFPoints(8), h.doubles = this._getDoubles(4, c), h.beta = this._getBeta(), this.precomputed = h, this;
  }, f.prototype._hasDoubles = function(c) {
    if (!this.precomputed)
      return !1;
    var h = this.precomputed.doubles;
    return h ? h.points.length >= Math.ceil((c.bitLength() + 1) / h.step) : !1;
  }, f.prototype._getDoubles = function(c, h) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var s = [this], p = this, v = 0; v < h; v += c) {
      for (var m = 0; m < c; m++)
        p = p.dbl();
      s.push(p);
    }
    return {
      step: c,
      points: s
    };
  }, f.prototype._getNAFPoints = function(c) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var h = [this], s = (1 << c) - 1, p = s === 1 ? null : this.dbl(), v = 1; v < s; v++)
      h[v] = h[v - 1].add(p);
    return {
      wnd: c,
      points: h
    };
  }, f.prototype._getBeta = function() {
    return null;
  }, f.prototype.dblp = function(c) {
    for (var h = this, s = 0; s < c; s++)
      h = h.dbl();
    return h;
  }, Wu;
}
var Ku, Sp;
function Y7() {
  if (Sp)
    return Ku;
  Sp = 1;
  var e = zr(), t = ar, r = Et(), i = bf(), o = e.assert;
  function n(c) {
    i.call(this, "short", c), this.a = new t(c.a, 16).toRed(this.red), this.b = new t(c.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(c), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  r(n, i), Ku = n, n.prototype._getEndomorphism = function(h) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var s, p;
      if (h.beta)
        s = new t(h.beta, 16).toRed(this.red);
      else {
        var v = this._getEndoRoots(this.p);
        s = v[0].cmp(v[1]) < 0 ? v[0] : v[1], s = s.toRed(this.red);
      }
      if (h.lambda)
        p = new t(h.lambda, 16);
      else {
        var m = this._getEndoRoots(this.n);
        this.g.mul(m[0]).x.cmp(this.g.x.redMul(s)) === 0 ? p = m[0] : (p = m[1], o(this.g.mul(p).x.cmp(this.g.x.redMul(s)) === 0));
      }
      var E;
      return h.basis ? E = h.basis.map(function(M) {
        return {
          a: new t(M.a, 16),
          b: new t(M.b, 16)
        };
      }) : E = this._getEndoBasis(p), {
        beta: s,
        lambda: p,
        basis: E
      };
    }
  }, n.prototype._getEndoRoots = function(h) {
    var s = h === this.p ? this.red : t.mont(h), p = new t(2).toRed(s).redInvm(), v = p.redNeg(), m = new t(3).toRed(s).redNeg().redSqrt().redMul(p), E = v.redAdd(m).fromRed(), M = v.redSub(m).fromRed();
    return [E, M];
  }, n.prototype._getEndoBasis = function(h) {
    for (var s = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), p = h, v = this.n.clone(), m = new t(1), E = new t(0), M = new t(0), I = new t(1), B, T, k, N, q, D, U, z = 0, Y, ue; p.cmpn(0) !== 0; ) {
      var j = v.div(p);
      Y = v.sub(j.mul(p)), ue = M.sub(j.mul(m));
      var g = I.sub(j.mul(E));
      if (!k && Y.cmp(s) < 0)
        B = U.neg(), T = m, k = Y.neg(), N = ue;
      else if (k && ++z === 2)
        break;
      U = Y, v = p, p = Y, M = m, m = ue, I = E, E = g;
    }
    q = Y.neg(), D = ue;
    var b = k.sqr().add(N.sqr()), a = q.sqr().add(D.sqr());
    return a.cmp(b) >= 0 && (q = B, D = T), k.negative && (k = k.neg(), N = N.neg()), q.negative && (q = q.neg(), D = D.neg()), [
      { a: k, b: N },
      { a: q, b: D }
    ];
  }, n.prototype._endoSplit = function(h) {
    var s = this.endo.basis, p = s[0], v = s[1], m = v.b.mul(h).divRound(this.n), E = p.b.neg().mul(h).divRound(this.n), M = m.mul(p.a), I = E.mul(v.a), B = m.mul(p.b), T = E.mul(v.b), k = h.sub(M).sub(I), N = B.add(T).neg();
    return { k1: k, k2: N };
  }, n.prototype.pointFromX = function(h, s) {
    h = new t(h, 16), h.red || (h = h.toRed(this.red));
    var p = h.redSqr().redMul(h).redIAdd(h.redMul(this.a)).redIAdd(this.b), v = p.redSqrt();
    if (v.redSqr().redSub(p).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var m = v.fromRed().isOdd();
    return (s && !m || !s && m) && (v = v.redNeg()), this.point(h, v);
  }, n.prototype.validate = function(h) {
    if (h.inf)
      return !0;
    var s = h.x, p = h.y, v = this.a.redMul(s), m = s.redSqr().redMul(s).redIAdd(v).redIAdd(this.b);
    return p.redSqr().redISub(m).cmpn(0) === 0;
  }, n.prototype._endoWnafMulAdd = function(h, s, p) {
    for (var v = this._endoWnafT1, m = this._endoWnafT2, E = 0; E < h.length; E++) {
      var M = this._endoSplit(s[E]), I = h[E], B = I._getBeta();
      M.k1.negative && (M.k1.ineg(), I = I.neg(!0)), M.k2.negative && (M.k2.ineg(), B = B.neg(!0)), v[E * 2] = I, v[E * 2 + 1] = B, m[E * 2] = M.k1, m[E * 2 + 1] = M.k2;
    }
    for (var T = this._wnafMulAdd(1, v, m, E * 2, p), k = 0; k < E * 2; k++)
      v[k] = null, m[k] = null;
    return T;
  };
  function f(c, h, s, p) {
    i.BasePoint.call(this, c, "affine"), h === null && s === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(h, 16), this.y = new t(s, 16), p && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  r(f, i.BasePoint), n.prototype.point = function(h, s, p) {
    return new f(this, h, s, p);
  }, n.prototype.pointFromJSON = function(h, s) {
    return f.fromJSON(this, h, s);
  }, f.prototype._getBeta = function() {
    if (this.curve.endo) {
      var h = this.precomputed;
      if (h && h.beta)
        return h.beta;
      var s = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (h) {
        var p = this.curve, v = function(m) {
          return p.point(m.x.redMul(p.endo.beta), m.y);
        };
        h.beta = s, s.precomputed = {
          beta: null,
          naf: h.naf && {
            wnd: h.naf.wnd,
            points: h.naf.points.map(v)
          },
          doubles: h.doubles && {
            step: h.doubles.step,
            points: h.doubles.points.map(v)
          }
        };
      }
      return s;
    }
  }, f.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, f.fromJSON = function(h, s, p) {
    typeof s == "string" && (s = JSON.parse(s));
    var v = h.point(s[0], s[1], p);
    if (!s[2])
      return v;
    function m(M) {
      return h.point(M[0], M[1], p);
    }
    var E = s[2];
    return v.precomputed = {
      beta: null,
      doubles: E.doubles && {
        step: E.doubles.step,
        points: [v].concat(E.doubles.points.map(m))
      },
      naf: E.naf && {
        wnd: E.naf.wnd,
        points: [v].concat(E.naf.points.map(m))
      }
    }, v;
  }, f.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, f.prototype.isInfinity = function() {
    return this.inf;
  }, f.prototype.add = function(h) {
    if (this.inf)
      return h;
    if (h.inf)
      return this;
    if (this.eq(h))
      return this.dbl();
    if (this.neg().eq(h))
      return this.curve.point(null, null);
    if (this.x.cmp(h.x) === 0)
      return this.curve.point(null, null);
    var s = this.y.redSub(h.y);
    s.cmpn(0) !== 0 && (s = s.redMul(this.x.redSub(h.x).redInvm()));
    var p = s.redSqr().redISub(this.x).redISub(h.x), v = s.redMul(this.x.redSub(p)).redISub(this.y);
    return this.curve.point(p, v);
  }, f.prototype.dbl = function() {
    if (this.inf)
      return this;
    var h = this.y.redAdd(this.y);
    if (h.cmpn(0) === 0)
      return this.curve.point(null, null);
    var s = this.curve.a, p = this.x.redSqr(), v = h.redInvm(), m = p.redAdd(p).redIAdd(p).redIAdd(s).redMul(v), E = m.redSqr().redISub(this.x.redAdd(this.x)), M = m.redMul(this.x.redSub(E)).redISub(this.y);
    return this.curve.point(E, M);
  }, f.prototype.getX = function() {
    return this.x.fromRed();
  }, f.prototype.getY = function() {
    return this.y.fromRed();
  }, f.prototype.mul = function(h) {
    return h = new t(h, 16), this.isInfinity() ? this : this._hasDoubles(h) ? this.curve._fixedNafMul(this, h) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [h]) : this.curve._wnafMul(this, h);
  }, f.prototype.mulAdd = function(h, s, p) {
    var v = [this, s], m = [h, p];
    return this.curve.endo ? this.curve._endoWnafMulAdd(v, m) : this.curve._wnafMulAdd(1, v, m, 2);
  }, f.prototype.jmulAdd = function(h, s, p) {
    var v = [this, s], m = [h, p];
    return this.curve.endo ? this.curve._endoWnafMulAdd(v, m, !0) : this.curve._wnafMulAdd(1, v, m, 2, !0);
  }, f.prototype.eq = function(h) {
    return this === h || this.inf === h.inf && (this.inf || this.x.cmp(h.x) === 0 && this.y.cmp(h.y) === 0);
  }, f.prototype.neg = function(h) {
    if (this.inf)
      return this;
    var s = this.curve.point(this.x, this.y.redNeg());
    if (h && this.precomputed) {
      var p = this.precomputed, v = function(m) {
        return m.neg();
      };
      s.precomputed = {
        naf: p.naf && {
          wnd: p.naf.wnd,
          points: p.naf.points.map(v)
        },
        doubles: p.doubles && {
          step: p.doubles.step,
          points: p.doubles.points.map(v)
        }
      };
    }
    return s;
  }, f.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var h = this.curve.jpoint(this.x, this.y, this.curve.one);
    return h;
  };
  function u(c, h, s, p) {
    i.BasePoint.call(this, c, "jacobian"), h === null && s === null && p === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(h, 16), this.y = new t(s, 16), this.z = new t(p, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return r(u, i.BasePoint), n.prototype.jpoint = function(h, s, p) {
    return new u(this, h, s, p);
  }, u.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var h = this.z.redInvm(), s = h.redSqr(), p = this.x.redMul(s), v = this.y.redMul(s).redMul(h);
    return this.curve.point(p, v);
  }, u.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, u.prototype.add = function(h) {
    if (this.isInfinity())
      return h;
    if (h.isInfinity())
      return this;
    var s = h.z.redSqr(), p = this.z.redSqr(), v = this.x.redMul(s), m = h.x.redMul(p), E = this.y.redMul(s.redMul(h.z)), M = h.y.redMul(p.redMul(this.z)), I = v.redSub(m), B = E.redSub(M);
    if (I.cmpn(0) === 0)
      return B.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var T = I.redSqr(), k = T.redMul(I), N = v.redMul(T), q = B.redSqr().redIAdd(k).redISub(N).redISub(N), D = B.redMul(N.redISub(q)).redISub(E.redMul(k)), U = this.z.redMul(h.z).redMul(I);
    return this.curve.jpoint(q, D, U);
  }, u.prototype.mixedAdd = function(h) {
    if (this.isInfinity())
      return h.toJ();
    if (h.isInfinity())
      return this;
    var s = this.z.redSqr(), p = this.x, v = h.x.redMul(s), m = this.y, E = h.y.redMul(s).redMul(this.z), M = p.redSub(v), I = m.redSub(E);
    if (M.cmpn(0) === 0)
      return I.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var B = M.redSqr(), T = B.redMul(M), k = p.redMul(B), N = I.redSqr().redIAdd(T).redISub(k).redISub(k), q = I.redMul(k.redISub(N)).redISub(m.redMul(T)), D = this.z.redMul(M);
    return this.curve.jpoint(N, q, D);
  }, u.prototype.dblp = function(h) {
    if (h === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!h)
      return this.dbl();
    var s;
    if (this.curve.zeroA || this.curve.threeA) {
      var p = this;
      for (s = 0; s < h; s++)
        p = p.dbl();
      return p;
    }
    var v = this.curve.a, m = this.curve.tinv, E = this.x, M = this.y, I = this.z, B = I.redSqr().redSqr(), T = M.redAdd(M);
    for (s = 0; s < h; s++) {
      var k = E.redSqr(), N = T.redSqr(), q = N.redSqr(), D = k.redAdd(k).redIAdd(k).redIAdd(v.redMul(B)), U = E.redMul(N), z = D.redSqr().redISub(U.redAdd(U)), Y = U.redISub(z), ue = D.redMul(Y);
      ue = ue.redIAdd(ue).redISub(q);
      var j = T.redMul(I);
      s + 1 < h && (B = B.redMul(q)), E = z, I = j, T = ue;
    }
    return this.curve.jpoint(E, T.redMul(m), I);
  }, u.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, u.prototype._zeroDbl = function() {
    var h, s, p;
    if (this.zOne) {
      var v = this.x.redSqr(), m = this.y.redSqr(), E = m.redSqr(), M = this.x.redAdd(m).redSqr().redISub(v).redISub(E);
      M = M.redIAdd(M);
      var I = v.redAdd(v).redIAdd(v), B = I.redSqr().redISub(M).redISub(M), T = E.redIAdd(E);
      T = T.redIAdd(T), T = T.redIAdd(T), h = B, s = I.redMul(M.redISub(B)).redISub(T), p = this.y.redAdd(this.y);
    } else {
      var k = this.x.redSqr(), N = this.y.redSqr(), q = N.redSqr(), D = this.x.redAdd(N).redSqr().redISub(k).redISub(q);
      D = D.redIAdd(D);
      var U = k.redAdd(k).redIAdd(k), z = U.redSqr(), Y = q.redIAdd(q);
      Y = Y.redIAdd(Y), Y = Y.redIAdd(Y), h = z.redISub(D).redISub(D), s = U.redMul(D.redISub(h)).redISub(Y), p = this.y.redMul(this.z), p = p.redIAdd(p);
    }
    return this.curve.jpoint(h, s, p);
  }, u.prototype._threeDbl = function() {
    var h, s, p;
    if (this.zOne) {
      var v = this.x.redSqr(), m = this.y.redSqr(), E = m.redSqr(), M = this.x.redAdd(m).redSqr().redISub(v).redISub(E);
      M = M.redIAdd(M);
      var I = v.redAdd(v).redIAdd(v).redIAdd(this.curve.a), B = I.redSqr().redISub(M).redISub(M);
      h = B;
      var T = E.redIAdd(E);
      T = T.redIAdd(T), T = T.redIAdd(T), s = I.redMul(M.redISub(B)).redISub(T), p = this.y.redAdd(this.y);
    } else {
      var k = this.z.redSqr(), N = this.y.redSqr(), q = this.x.redMul(N), D = this.x.redSub(k).redMul(this.x.redAdd(k));
      D = D.redAdd(D).redIAdd(D);
      var U = q.redIAdd(q);
      U = U.redIAdd(U);
      var z = U.redAdd(U);
      h = D.redSqr().redISub(z), p = this.y.redAdd(this.z).redSqr().redISub(N).redISub(k);
      var Y = N.redSqr();
      Y = Y.redIAdd(Y), Y = Y.redIAdd(Y), Y = Y.redIAdd(Y), s = D.redMul(U.redISub(h)).redISub(Y);
    }
    return this.curve.jpoint(h, s, p);
  }, u.prototype._dbl = function() {
    var h = this.curve.a, s = this.x, p = this.y, v = this.z, m = v.redSqr().redSqr(), E = s.redSqr(), M = p.redSqr(), I = E.redAdd(E).redIAdd(E).redIAdd(h.redMul(m)), B = s.redAdd(s);
    B = B.redIAdd(B);
    var T = B.redMul(M), k = I.redSqr().redISub(T.redAdd(T)), N = T.redISub(k), q = M.redSqr();
    q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
    var D = I.redMul(N).redISub(q), U = p.redAdd(p).redMul(v);
    return this.curve.jpoint(k, D, U);
  }, u.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var h = this.x.redSqr(), s = this.y.redSqr(), p = this.z.redSqr(), v = s.redSqr(), m = h.redAdd(h).redIAdd(h), E = m.redSqr(), M = this.x.redAdd(s).redSqr().redISub(h).redISub(v);
    M = M.redIAdd(M), M = M.redAdd(M).redIAdd(M), M = M.redISub(E);
    var I = M.redSqr(), B = v.redIAdd(v);
    B = B.redIAdd(B), B = B.redIAdd(B), B = B.redIAdd(B);
    var T = m.redIAdd(M).redSqr().redISub(E).redISub(I).redISub(B), k = s.redMul(T);
    k = k.redIAdd(k), k = k.redIAdd(k);
    var N = this.x.redMul(I).redISub(k);
    N = N.redIAdd(N), N = N.redIAdd(N);
    var q = this.y.redMul(T.redMul(B.redISub(T)).redISub(M.redMul(I)));
    q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
    var D = this.z.redAdd(M).redSqr().redISub(p).redISub(I);
    return this.curve.jpoint(N, q, D);
  }, u.prototype.mul = function(h, s) {
    return h = new t(h, s), this.curve._wnafMul(this, h);
  }, u.prototype.eq = function(h) {
    if (h.type === "affine")
      return this.eq(h.toJ());
    if (this === h)
      return !0;
    var s = this.z.redSqr(), p = h.z.redSqr();
    if (this.x.redMul(p).redISub(h.x.redMul(s)).cmpn(0) !== 0)
      return !1;
    var v = s.redMul(this.z), m = p.redMul(h.z);
    return this.y.redMul(m).redISub(h.y.redMul(v)).cmpn(0) === 0;
  }, u.prototype.eqXToP = function(h) {
    var s = this.z.redSqr(), p = h.toRed(this.curve.red).redMul(s);
    if (this.x.cmp(p) === 0)
      return !0;
    for (var v = h.clone(), m = this.curve.redN.redMul(s); ; ) {
      if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
        return !1;
      if (p.redIAdd(m), this.x.cmp(p) === 0)
        return !0;
    }
  }, u.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, u.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, Ku;
}
var Zu, Ap;
function Q7() {
  if (Ap)
    return Zu;
  Ap = 1;
  var e = ar, t = Et(), r = bf(), i = zr();
  function o(f) {
    r.call(this, "mont", f), this.a = new e(f.a, 16).toRed(this.red), this.b = new e(f.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(o, r), Zu = o, o.prototype.validate = function(u) {
    var c = u.normalize().x, h = c.redSqr(), s = h.redMul(c).redAdd(h.redMul(this.a)).redAdd(c), p = s.redSqrt();
    return p.redSqr().cmp(s) === 0;
  };
  function n(f, u, c) {
    r.BasePoint.call(this, f, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(u, 16), this.z = new e(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(n, r.BasePoint), o.prototype.decodePoint = function(u, c) {
    return this.point(i.toArray(u, c), 1);
  }, o.prototype.point = function(u, c) {
    return new n(this, u, c);
  }, o.prototype.pointFromJSON = function(u) {
    return n.fromJSON(this, u);
  }, n.prototype.precompute = function() {
  }, n.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, n.fromJSON = function(u, c) {
    return new n(u, c[0], c[1] || u.one);
  }, n.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, n.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, n.prototype.dbl = function() {
    var u = this.x.redAdd(this.z), c = u.redSqr(), h = this.x.redSub(this.z), s = h.redSqr(), p = c.redSub(s), v = c.redMul(s), m = p.redMul(s.redAdd(this.curve.a24.redMul(p)));
    return this.curve.point(v, m);
  }, n.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.diffAdd = function(u, c) {
    var h = this.x.redAdd(this.z), s = this.x.redSub(this.z), p = u.x.redAdd(u.z), v = u.x.redSub(u.z), m = v.redMul(h), E = p.redMul(s), M = c.z.redMul(m.redAdd(E).redSqr()), I = c.x.redMul(m.redISub(E).redSqr());
    return this.curve.point(M, I);
  }, n.prototype.mul = function(u) {
    for (var c = u.clone(), h = this, s = this.curve.point(null, null), p = this, v = []; c.cmpn(0) !== 0; c.iushrn(1))
      v.push(c.andln(1));
    for (var m = v.length - 1; m >= 0; m--)
      v[m] === 0 ? (h = h.diffAdd(s, p), s = s.dbl()) : (s = h.diffAdd(s, p), h = h.dbl());
    return s;
  }, n.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.eq = function(u) {
    return this.getX().cmp(u.getX()) === 0;
  }, n.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, n.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, Zu;
}
var Gu, Mp;
function e9() {
  if (Mp)
    return Gu;
  Mp = 1;
  var e = zr(), t = ar, r = Et(), i = bf(), o = e.assert;
  function n(u) {
    this.twisted = (u.a | 0) !== 1, this.mOneA = this.twisted && (u.a | 0) === -1, this.extended = this.mOneA, i.call(this, "edwards", u), this.a = new t(u.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(u.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(u.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), o(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (u.c | 0) === 1;
  }
  r(n, i), Gu = n, n.prototype._mulA = function(c) {
    return this.mOneA ? c.redNeg() : this.a.redMul(c);
  }, n.prototype._mulC = function(c) {
    return this.oneC ? c : this.c.redMul(c);
  }, n.prototype.jpoint = function(c, h, s, p) {
    return this.point(c, h, s, p);
  }, n.prototype.pointFromX = function(c, h) {
    c = new t(c, 16), c.red || (c = c.toRed(this.red));
    var s = c.redSqr(), p = this.c2.redSub(this.a.redMul(s)), v = this.one.redSub(this.c2.redMul(this.d).redMul(s)), m = p.redMul(v.redInvm()), E = m.redSqrt();
    if (E.redSqr().redSub(m).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var M = E.fromRed().isOdd();
    return (h && !M || !h && M) && (E = E.redNeg()), this.point(c, E);
  }, n.prototype.pointFromY = function(c, h) {
    c = new t(c, 16), c.red || (c = c.toRed(this.red));
    var s = c.redSqr(), p = s.redSub(this.c2), v = s.redMul(this.d).redMul(this.c2).redSub(this.a), m = p.redMul(v.redInvm());
    if (m.cmp(this.zero) === 0) {
      if (h)
        throw new Error("invalid point");
      return this.point(this.zero, c);
    }
    var E = m.redSqrt();
    if (E.redSqr().redSub(m).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return E.fromRed().isOdd() !== h && (E = E.redNeg()), this.point(E, c);
  }, n.prototype.validate = function(c) {
    if (c.isInfinity())
      return !0;
    c.normalize();
    var h = c.x.redSqr(), s = c.y.redSqr(), p = h.redMul(this.a).redAdd(s), v = this.c2.redMul(this.one.redAdd(this.d.redMul(h).redMul(s)));
    return p.cmp(v) === 0;
  };
  function f(u, c, h, s, p) {
    i.BasePoint.call(this, u, "projective"), c === null && h === null && s === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(c, 16), this.y = new t(h, 16), this.z = s ? new t(s, 16) : this.curve.one, this.t = p && new t(p, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return r(f, i.BasePoint), n.prototype.pointFromJSON = function(c) {
    return f.fromJSON(this, c);
  }, n.prototype.point = function(c, h, s, p) {
    return new f(this, c, h, s, p);
  }, f.fromJSON = function(c, h) {
    return new f(c, h[0], h[1], h[2]);
  }, f.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, f.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, f.prototype._extDbl = function() {
    var c = this.x.redSqr(), h = this.y.redSqr(), s = this.z.redSqr();
    s = s.redIAdd(s);
    var p = this.curve._mulA(c), v = this.x.redAdd(this.y).redSqr().redISub(c).redISub(h), m = p.redAdd(h), E = m.redSub(s), M = p.redSub(h), I = v.redMul(E), B = m.redMul(M), T = v.redMul(M), k = E.redMul(m);
    return this.curve.point(I, B, k, T);
  }, f.prototype._projDbl = function() {
    var c = this.x.redAdd(this.y).redSqr(), h = this.x.redSqr(), s = this.y.redSqr(), p, v, m, E, M, I;
    if (this.curve.twisted) {
      E = this.curve._mulA(h);
      var B = E.redAdd(s);
      this.zOne ? (p = c.redSub(h).redSub(s).redMul(B.redSub(this.curve.two)), v = B.redMul(E.redSub(s)), m = B.redSqr().redSub(B).redSub(B)) : (M = this.z.redSqr(), I = B.redSub(M).redISub(M), p = c.redSub(h).redISub(s).redMul(I), v = B.redMul(E.redSub(s)), m = B.redMul(I));
    } else
      E = h.redAdd(s), M = this.curve._mulC(this.z).redSqr(), I = E.redSub(M).redSub(M), p = this.curve._mulC(c.redISub(E)).redMul(I), v = this.curve._mulC(E).redMul(h.redISub(s)), m = E.redMul(I);
    return this.curve.point(p, v, m);
  }, f.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, f.prototype._extAdd = function(c) {
    var h = this.y.redSub(this.x).redMul(c.y.redSub(c.x)), s = this.y.redAdd(this.x).redMul(c.y.redAdd(c.x)), p = this.t.redMul(this.curve.dd).redMul(c.t), v = this.z.redMul(c.z.redAdd(c.z)), m = s.redSub(h), E = v.redSub(p), M = v.redAdd(p), I = s.redAdd(h), B = m.redMul(E), T = M.redMul(I), k = m.redMul(I), N = E.redMul(M);
    return this.curve.point(B, T, N, k);
  }, f.prototype._projAdd = function(c) {
    var h = this.z.redMul(c.z), s = h.redSqr(), p = this.x.redMul(c.x), v = this.y.redMul(c.y), m = this.curve.d.redMul(p).redMul(v), E = s.redSub(m), M = s.redAdd(m), I = this.x.redAdd(this.y).redMul(c.x.redAdd(c.y)).redISub(p).redISub(v), B = h.redMul(E).redMul(I), T, k;
    return this.curve.twisted ? (T = h.redMul(M).redMul(v.redSub(this.curve._mulA(p))), k = E.redMul(M)) : (T = h.redMul(M).redMul(v.redSub(p)), k = this.curve._mulC(E).redMul(M)), this.curve.point(B, T, k);
  }, f.prototype.add = function(c) {
    return this.isInfinity() ? c : c.isInfinity() ? this : this.curve.extended ? this._extAdd(c) : this._projAdd(c);
  }, f.prototype.mul = function(c) {
    return this._hasDoubles(c) ? this.curve._fixedNafMul(this, c) : this.curve._wnafMul(this, c);
  }, f.prototype.mulAdd = function(c, h, s) {
    return this.curve._wnafMulAdd(1, [this, h], [c, s], 2, !1);
  }, f.prototype.jmulAdd = function(c, h, s) {
    return this.curve._wnafMulAdd(1, [this, h], [c, s], 2, !0);
  }, f.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var c = this.z.redInvm();
    return this.x = this.x.redMul(c), this.y = this.y.redMul(c), this.t && (this.t = this.t.redMul(c)), this.z = this.curve.one, this.zOne = !0, this;
  }, f.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, f.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, f.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, f.prototype.eq = function(c) {
    return this === c || this.getX().cmp(c.getX()) === 0 && this.getY().cmp(c.getY()) === 0;
  }, f.prototype.eqXToP = function(c) {
    var h = c.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(h) === 0)
      return !0;
    for (var s = c.clone(), p = this.curve.redN.redMul(this.z); ; ) {
      if (s.iadd(this.curve.n), s.cmp(this.curve.p) >= 0)
        return !1;
      if (h.redIAdd(p), this.x.cmp(h) === 0)
        return !0;
    }
  }, f.prototype.toP = f.prototype.normalize, f.prototype.mixedAdd = f.prototype.add, Gu;
}
var Rp;
function zg() {
  return Rp || (Rp = 1, function(e) {
    var t = e;
    t.base = bf(), t.short = Y7(), t.mont = Q7(), t.edwards = e9();
  }(Vu)), Vu;
}
var Ju = {}, Xu = {}, Dt = {}, Bp;
function hn() {
  if (Bp)
    return Dt;
  Bp = 1;
  var e = Hr(), t = Et();
  Dt.inherits = t;
  function r(g, b) {
    return (g.charCodeAt(b) & 64512) !== 55296 || b < 0 || b + 1 >= g.length ? !1 : (g.charCodeAt(b + 1) & 64512) === 56320;
  }
  function i(g, b) {
    if (Array.isArray(g))
      return g.slice();
    if (!g)
      return [];
    var a = [];
    if (typeof g == "string")
      if (b) {
        if (b === "hex")
          for (g = g.replace(/[^a-z0-9]+/ig, ""), g.length % 2 !== 0 && (g = "0" + g), w = 0; w < g.length; w += 2)
            a.push(parseInt(g[w] + g[w + 1], 16));
      } else
        for (var d = 0, w = 0; w < g.length; w++) {
          var x = g.charCodeAt(w);
          x < 128 ? a[d++] = x : x < 2048 ? (a[d++] = x >> 6 | 192, a[d++] = x & 63 | 128) : r(g, w) ? (x = 65536 + ((x & 1023) << 10) + (g.charCodeAt(++w) & 1023), a[d++] = x >> 18 | 240, a[d++] = x >> 12 & 63 | 128, a[d++] = x >> 6 & 63 | 128, a[d++] = x & 63 | 128) : (a[d++] = x >> 12 | 224, a[d++] = x >> 6 & 63 | 128, a[d++] = x & 63 | 128);
        }
    else
      for (w = 0; w < g.length; w++)
        a[w] = g[w] | 0;
    return a;
  }
  Dt.toArray = i;
  function o(g) {
    for (var b = "", a = 0; a < g.length; a++)
      b += u(g[a].toString(16));
    return b;
  }
  Dt.toHex = o;
  function n(g) {
    var b = g >>> 24 | g >>> 8 & 65280 | g << 8 & 16711680 | (g & 255) << 24;
    return b >>> 0;
  }
  Dt.htonl = n;
  function f(g, b) {
    for (var a = "", d = 0; d < g.length; d++) {
      var w = g[d];
      b === "little" && (w = n(w)), a += c(w.toString(16));
    }
    return a;
  }
  Dt.toHex32 = f;
  function u(g) {
    return g.length === 1 ? "0" + g : g;
  }
  Dt.zero2 = u;
  function c(g) {
    return g.length === 7 ? "0" + g : g.length === 6 ? "00" + g : g.length === 5 ? "000" + g : g.length === 4 ? "0000" + g : g.length === 3 ? "00000" + g : g.length === 2 ? "000000" + g : g.length === 1 ? "0000000" + g : g;
  }
  Dt.zero8 = c;
  function h(g, b, a, d) {
    var w = a - b;
    e(w % 4 === 0);
    for (var x = new Array(w / 4), A = 0, S = b; A < x.length; A++, S += 4) {
      var y;
      d === "big" ? y = g[S] << 24 | g[S + 1] << 16 | g[S + 2] << 8 | g[S + 3] : y = g[S + 3] << 24 | g[S + 2] << 16 | g[S + 1] << 8 | g[S], x[A] = y >>> 0;
    }
    return x;
  }
  Dt.join32 = h;
  function s(g, b) {
    for (var a = new Array(g.length * 4), d = 0, w = 0; d < g.length; d++, w += 4) {
      var x = g[d];
      b === "big" ? (a[w] = x >>> 24, a[w + 1] = x >>> 16 & 255, a[w + 2] = x >>> 8 & 255, a[w + 3] = x & 255) : (a[w + 3] = x >>> 24, a[w + 2] = x >>> 16 & 255, a[w + 1] = x >>> 8 & 255, a[w] = x & 255);
    }
    return a;
  }
  Dt.split32 = s;
  function p(g, b) {
    return g >>> b | g << 32 - b;
  }
  Dt.rotr32 = p;
  function v(g, b) {
    return g << b | g >>> 32 - b;
  }
  Dt.rotl32 = v;
  function m(g, b) {
    return g + b >>> 0;
  }
  Dt.sum32 = m;
  function E(g, b, a) {
    return g + b + a >>> 0;
  }
  Dt.sum32_3 = E;
  function M(g, b, a, d) {
    return g + b + a + d >>> 0;
  }
  Dt.sum32_4 = M;
  function I(g, b, a, d, w) {
    return g + b + a + d + w >>> 0;
  }
  Dt.sum32_5 = I;
  function B(g, b, a, d) {
    var w = g[b], x = g[b + 1], A = d + x >>> 0, S = (A < d ? 1 : 0) + a + w;
    g[b] = S >>> 0, g[b + 1] = A;
  }
  Dt.sum64 = B;
  function T(g, b, a, d) {
    var w = b + d >>> 0, x = (w < b ? 1 : 0) + g + a;
    return x >>> 0;
  }
  Dt.sum64_hi = T;
  function k(g, b, a, d) {
    var w = b + d;
    return w >>> 0;
  }
  Dt.sum64_lo = k;
  function N(g, b, a, d, w, x, A, S) {
    var y = 0, _ = b;
    _ = _ + d >>> 0, y += _ < b ? 1 : 0, _ = _ + x >>> 0, y += _ < x ? 1 : 0, _ = _ + S >>> 0, y += _ < S ? 1 : 0;
    var l = g + a + w + A + y;
    return l >>> 0;
  }
  Dt.sum64_4_hi = N;
  function q(g, b, a, d, w, x, A, S) {
    var y = b + d + x + S;
    return y >>> 0;
  }
  Dt.sum64_4_lo = q;
  function D(g, b, a, d, w, x, A, S, y, _) {
    var l = 0, R = b;
    R = R + d >>> 0, l += R < b ? 1 : 0, R = R + x >>> 0, l += R < x ? 1 : 0, R = R + S >>> 0, l += R < S ? 1 : 0, R = R + _ >>> 0, l += R < _ ? 1 : 0;
    var ee = g + a + w + A + y + l;
    return ee >>> 0;
  }
  Dt.sum64_5_hi = D;
  function U(g, b, a, d, w, x, A, S, y, _) {
    var l = b + d + x + S + _;
    return l >>> 0;
  }
  Dt.sum64_5_lo = U;
  function z(g, b, a) {
    var d = b << 32 - a | g >>> a;
    return d >>> 0;
  }
  Dt.rotr64_hi = z;
  function Y(g, b, a) {
    var d = g << 32 - a | b >>> a;
    return d >>> 0;
  }
  Dt.rotr64_lo = Y;
  function ue(g, b, a) {
    return g >>> a;
  }
  Dt.shr64_hi = ue;
  function j(g, b, a) {
    var d = g << 32 - a | b >>> a;
    return d >>> 0;
  }
  return Dt.shr64_lo = j, Dt;
}
var Yu = {}, Ip;
function Pa() {
  if (Ip)
    return Yu;
  Ip = 1;
  var e = hn(), t = Hr();
  function r() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return Yu.BlockHash = r, r.prototype.update = function(o, n) {
    if (o = e.toArray(o, n), this.pending ? this.pending = this.pending.concat(o) : this.pending = o, this.pendingTotal += o.length, this.pending.length >= this._delta8) {
      o = this.pending;
      var f = o.length % this._delta8;
      this.pending = o.slice(o.length - f, o.length), this.pending.length === 0 && (this.pending = null), o = e.join32(o, 0, o.length - f, this.endian);
      for (var u = 0; u < o.length; u += this._delta32)
        this._update(o, u, u + this._delta32);
    }
    return this;
  }, r.prototype.digest = function(o) {
    return this.update(this._pad()), t(this.pending === null), this._digest(o);
  }, r.prototype._pad = function() {
    var o = this.pendingTotal, n = this._delta8, f = n - (o + this.padLength) % n, u = new Array(f + this.padLength);
    u[0] = 128;
    for (var c = 1; c < f; c++)
      u[c] = 0;
    if (o <<= 3, this.endian === "big") {
      for (var h = 8; h < this.padLength; h++)
        u[c++] = 0;
      u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = o >>> 24 & 255, u[c++] = o >>> 16 & 255, u[c++] = o >>> 8 & 255, u[c++] = o & 255;
    } else
      for (u[c++] = o & 255, u[c++] = o >>> 8 & 255, u[c++] = o >>> 16 & 255, u[c++] = o >>> 24 & 255, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, h = 8; h < this.padLength; h++)
        u[c++] = 0;
    return u;
  }, Yu;
}
var Un = {}, Qr = {}, Tp;
function Vg() {
  if (Tp)
    return Qr;
  Tp = 1;
  var e = hn(), t = e.rotr32;
  function r(s, p, v, m) {
    if (s === 0)
      return i(p, v, m);
    if (s === 1 || s === 3)
      return n(p, v, m);
    if (s === 2)
      return o(p, v, m);
  }
  Qr.ft_1 = r;
  function i(s, p, v) {
    return s & p ^ ~s & v;
  }
  Qr.ch32 = i;
  function o(s, p, v) {
    return s & p ^ s & v ^ p & v;
  }
  Qr.maj32 = o;
  function n(s, p, v) {
    return s ^ p ^ v;
  }
  Qr.p32 = n;
  function f(s) {
    return t(s, 2) ^ t(s, 13) ^ t(s, 22);
  }
  Qr.s0_256 = f;
  function u(s) {
    return t(s, 6) ^ t(s, 11) ^ t(s, 25);
  }
  Qr.s1_256 = u;
  function c(s) {
    return t(s, 7) ^ t(s, 18) ^ s >>> 3;
  }
  Qr.g0_256 = c;
  function h(s) {
    return t(s, 17) ^ t(s, 19) ^ s >>> 10;
  }
  return Qr.g1_256 = h, Qr;
}
var Qu, Op;
function t9() {
  if (Op)
    return Qu;
  Op = 1;
  var e = hn(), t = Pa(), r = Vg(), i = e.rotl32, o = e.sum32, n = e.sum32_5, f = r.ft_1, u = t.BlockHash, c = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function h() {
    if (!(this instanceof h))
      return new h();
    u.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(h, u), Qu = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(p, v) {
    for (var m = this.W, E = 0; E < 16; E++)
      m[E] = p[v + E];
    for (; E < m.length; E++)
      m[E] = i(m[E - 3] ^ m[E - 8] ^ m[E - 14] ^ m[E - 16], 1);
    var M = this.h[0], I = this.h[1], B = this.h[2], T = this.h[3], k = this.h[4];
    for (E = 0; E < m.length; E++) {
      var N = ~~(E / 20), q = n(i(M, 5), f(N, I, B, T), k, m[E], c[N]);
      k = T, T = B, B = i(I, 30), I = M, M = q;
    }
    this.h[0] = o(this.h[0], M), this.h[1] = o(this.h[1], I), this.h[2] = o(this.h[2], B), this.h[3] = o(this.h[3], T), this.h[4] = o(this.h[4], k);
  }, h.prototype._digest = function(p) {
    return p === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, Qu;
}
var ec, Pp;
function Wg() {
  if (Pp)
    return ec;
  Pp = 1;
  var e = hn(), t = Pa(), r = Vg(), i = Hr(), o = e.sum32, n = e.sum32_4, f = e.sum32_5, u = r.ch32, c = r.maj32, h = r.s0_256, s = r.s1_256, p = r.g0_256, v = r.g1_256, m = t.BlockHash, E = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function M() {
    if (!(this instanceof M))
      return new M();
    m.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = E, this.W = new Array(64);
  }
  return e.inherits(M, m), ec = M, M.blockSize = 512, M.outSize = 256, M.hmacStrength = 192, M.padLength = 64, M.prototype._update = function(B, T) {
    for (var k = this.W, N = 0; N < 16; N++)
      k[N] = B[T + N];
    for (; N < k.length; N++)
      k[N] = n(v(k[N - 2]), k[N - 7], p(k[N - 15]), k[N - 16]);
    var q = this.h[0], D = this.h[1], U = this.h[2], z = this.h[3], Y = this.h[4], ue = this.h[5], j = this.h[6], g = this.h[7];
    for (i(this.k.length === k.length), N = 0; N < k.length; N++) {
      var b = f(g, s(Y), u(Y, ue, j), this.k[N], k[N]), a = o(h(q), c(q, D, U));
      g = j, j = ue, ue = Y, Y = o(z, b), z = U, U = D, D = q, q = o(b, a);
    }
    this.h[0] = o(this.h[0], q), this.h[1] = o(this.h[1], D), this.h[2] = o(this.h[2], U), this.h[3] = o(this.h[3], z), this.h[4] = o(this.h[4], Y), this.h[5] = o(this.h[5], ue), this.h[6] = o(this.h[6], j), this.h[7] = o(this.h[7], g);
  }, M.prototype._digest = function(B) {
    return B === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, ec;
}
var tc, Cp;
function r9() {
  if (Cp)
    return tc;
  Cp = 1;
  var e = hn(), t = Wg();
  function r() {
    if (!(this instanceof r))
      return new r();
    t.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(r, t), tc = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(o) {
    return o === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, tc;
}
var rc, Np;
function Kg() {
  if (Np)
    return rc;
  Np = 1;
  var e = hn(), t = Pa(), r = Hr(), i = e.rotr64_hi, o = e.rotr64_lo, n = e.shr64_hi, f = e.shr64_lo, u = e.sum64, c = e.sum64_hi, h = e.sum64_lo, s = e.sum64_4_hi, p = e.sum64_4_lo, v = e.sum64_5_hi, m = e.sum64_5_lo, E = t.BlockHash, M = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function I() {
    if (!(this instanceof I))
      return new I();
    E.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = M, this.W = new Array(160);
  }
  e.inherits(I, E), rc = I, I.blockSize = 1024, I.outSize = 512, I.hmacStrength = 192, I.padLength = 128, I.prototype._prepareBlock = function(a, d) {
    for (var w = this.W, x = 0; x < 32; x++)
      w[x] = a[d + x];
    for (; x < w.length; x += 2) {
      var A = j(w[x - 4], w[x - 3]), S = g(w[x - 4], w[x - 3]), y = w[x - 14], _ = w[x - 13], l = Y(w[x - 30], w[x - 29]), R = ue(w[x - 30], w[x - 29]), ee = w[x - 32], oe = w[x - 31];
      w[x] = s(
        A,
        S,
        y,
        _,
        l,
        R,
        ee,
        oe
      ), w[x + 1] = p(
        A,
        S,
        y,
        _,
        l,
        R,
        ee,
        oe
      );
    }
  }, I.prototype._update = function(a, d) {
    this._prepareBlock(a, d);
    var w = this.W, x = this.h[0], A = this.h[1], S = this.h[2], y = this.h[3], _ = this.h[4], l = this.h[5], R = this.h[6], ee = this.h[7], oe = this.h[8], V = this.h[9], W = this.h[10], F = this.h[11], re = this.h[12], he = this.h[13], Z = this.h[14], K = this.h[15];
    r(this.k.length === w.length);
    for (var ce = 0; ce < w.length; ce += 2) {
      var ve = Z, Be = K, te = U(oe, V), C = z(oe, V), L = B(oe, V, W, F, re), G = T(oe, V, W, F, re, he), de = this.k[ce], me = this.k[ce + 1], Te = w[ce], He = w[ce + 1], H = v(
        ve,
        Be,
        te,
        C,
        L,
        G,
        de,
        me,
        Te,
        He
      ), se = m(
        ve,
        Be,
        te,
        C,
        L,
        G,
        de,
        me,
        Te,
        He
      );
      ve = q(x, A), Be = D(x, A), te = k(x, A, S, y, _), C = N(x, A, S, y, _, l);
      var fe = c(ve, Be, te, C), _e = h(ve, Be, te, C);
      Z = re, K = he, re = W, he = F, W = oe, F = V, oe = c(R, ee, H, se), V = h(ee, ee, H, se), R = _, ee = l, _ = S, l = y, S = x, y = A, x = c(H, se, fe, _e), A = h(H, se, fe, _e);
    }
    u(this.h, 0, x, A), u(this.h, 2, S, y), u(this.h, 4, _, l), u(this.h, 6, R, ee), u(this.h, 8, oe, V), u(this.h, 10, W, F), u(this.h, 12, re, he), u(this.h, 14, Z, K);
  }, I.prototype._digest = function(a) {
    return a === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function B(b, a, d, w, x) {
    var A = b & d ^ ~b & x;
    return A < 0 && (A += 4294967296), A;
  }
  function T(b, a, d, w, x, A) {
    var S = a & w ^ ~a & A;
    return S < 0 && (S += 4294967296), S;
  }
  function k(b, a, d, w, x) {
    var A = b & d ^ b & x ^ d & x;
    return A < 0 && (A += 4294967296), A;
  }
  function N(b, a, d, w, x, A) {
    var S = a & w ^ a & A ^ w & A;
    return S < 0 && (S += 4294967296), S;
  }
  function q(b, a) {
    var d = i(b, a, 28), w = i(a, b, 2), x = i(a, b, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function D(b, a) {
    var d = o(b, a, 28), w = o(a, b, 2), x = o(a, b, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function U(b, a) {
    var d = i(b, a, 14), w = i(b, a, 18), x = i(a, b, 9), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function z(b, a) {
    var d = o(b, a, 14), w = o(b, a, 18), x = o(a, b, 9), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function Y(b, a) {
    var d = i(b, a, 1), w = i(b, a, 8), x = n(b, a, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function ue(b, a) {
    var d = o(b, a, 1), w = o(b, a, 8), x = f(b, a, 7), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function j(b, a) {
    var d = i(b, a, 19), w = i(a, b, 29), x = n(b, a, 6), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  function g(b, a) {
    var d = o(b, a, 19), w = o(a, b, 29), x = f(b, a, 6), A = d ^ w ^ x;
    return A < 0 && (A += 4294967296), A;
  }
  return rc;
}
var nc, Lp;
function n9() {
  if (Lp)
    return nc;
  Lp = 1;
  var e = hn(), t = Kg();
  function r() {
    if (!(this instanceof r))
      return new r();
    t.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(r, t), nc = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(o) {
    return o === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, nc;
}
var kp;
function i9() {
  return kp || (kp = 1, Un.sha1 = t9(), Un.sha224 = r9(), Un.sha256 = Wg(), Un.sha384 = n9(), Un.sha512 = Kg()), Un;
}
var ic = {}, qp;
function a9() {
  if (qp)
    return ic;
  qp = 1;
  var e = hn(), t = Pa(), r = e.rotl32, i = e.sum32, o = e.sum32_3, n = e.sum32_4, f = t.BlockHash;
  function u() {
    if (!(this instanceof u))
      return new u();
    f.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(u, f), ic.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(I, B) {
    for (var T = this.h[0], k = this.h[1], N = this.h[2], q = this.h[3], D = this.h[4], U = T, z = k, Y = N, ue = q, j = D, g = 0; g < 80; g++) {
      var b = i(
        r(
          n(T, c(g, k, N, q), I[p[g] + B], h(g)),
          m[g]
        ),
        D
      );
      T = D, D = q, q = r(N, 10), N = k, k = b, b = i(
        r(
          n(U, c(79 - g, z, Y, ue), I[v[g] + B], s(g)),
          E[g]
        ),
        j
      ), U = j, j = ue, ue = r(Y, 10), Y = z, z = b;
    }
    b = o(this.h[1], N, ue), this.h[1] = o(this.h[2], q, j), this.h[2] = o(this.h[3], D, U), this.h[3] = o(this.h[4], T, z), this.h[4] = o(this.h[0], k, Y), this.h[0] = b;
  }, u.prototype._digest = function(I) {
    return I === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function c(M, I, B, T) {
    return M <= 15 ? I ^ B ^ T : M <= 31 ? I & B | ~I & T : M <= 47 ? (I | ~B) ^ T : M <= 63 ? I & T | B & ~T : I ^ (B | ~T);
  }
  function h(M) {
    return M <= 15 ? 0 : M <= 31 ? 1518500249 : M <= 47 ? 1859775393 : M <= 63 ? 2400959708 : 2840853838;
  }
  function s(M) {
    return M <= 15 ? 1352829926 : M <= 31 ? 1548603684 : M <= 47 ? 1836072691 : M <= 63 ? 2053994217 : 0;
  }
  var p = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], v = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], m = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], E = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ic;
}
var ac, $p;
function o9() {
  if ($p)
    return ac;
  $p = 1;
  var e = hn(), t = Hr();
  function r(i, o, n) {
    if (!(this instanceof r))
      return new r(i, o, n);
    this.Hash = i, this.blockSize = i.blockSize / 8, this.outSize = i.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(o, n));
  }
  return ac = r, r.prototype._init = function(o) {
    o.length > this.blockSize && (o = new this.Hash().update(o).digest()), t(o.length <= this.blockSize);
    for (var n = o.length; n < this.blockSize; n++)
      o.push(0);
    for (n = 0; n < o.length; n++)
      o[n] ^= 54;
    for (this.inner = new this.Hash().update(o), n = 0; n < o.length; n++)
      o[n] ^= 106;
    this.outer = new this.Hash().update(o);
  }, r.prototype.update = function(o, n) {
    return this.inner.update(o, n), this;
  }, r.prototype.digest = function(o) {
    return this.outer.update(this.inner.digest()), this.outer.digest(o);
  }, ac;
}
var Dp;
function x0() {
  return Dp || (Dp = 1, function(e) {
    var t = e;
    t.utils = hn(), t.common = Pa(), t.sha = i9(), t.ripemd = a9(), t.hmac = o9(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
  }(Xu)), Xu;
}
var oc, jp;
function f9() {
  return jp || (jp = 1, oc = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), oc;
}
var Up;
function E0() {
  return Up || (Up = 1, function(e) {
    var t = e, r = x0(), i = zg(), o = zr(), n = o.assert;
    function f(h) {
      h.type === "short" ? this.curve = new i.short(h) : h.type === "edwards" ? this.curve = new i.edwards(h) : this.curve = new i.mont(h), this.g = this.curve.g, this.n = this.curve.n, this.hash = h.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = f;
    function u(h, s) {
      Object.defineProperty(t, h, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var p = new f(s);
          return Object.defineProperty(t, h, {
            configurable: !0,
            enumerable: !0,
            value: p
          }), p;
        }
      });
    }
    u("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: r.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), u("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: r.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), u("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: r.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), u("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: r.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), u("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: r.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), u("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: r.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), u("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: r.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var c;
    try {
      c = f9();
    } catch {
      c = void 0;
    }
    u("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: r.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        c
      ]
    });
  }(Ju)), Ju;
}
var fc, Fp;
function s9() {
  if (Fp)
    return fc;
  Fp = 1;
  var e = x0(), t = Hg(), r = Hr();
  function i(o) {
    if (!(this instanceof i))
      return new i(o);
    this.hash = o.hash, this.predResist = !!o.predResist, this.outLen = this.hash.outSize, this.minEntropy = o.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var n = t.toArray(o.entropy, o.entropyEnc || "hex"), f = t.toArray(o.nonce, o.nonceEnc || "hex"), u = t.toArray(o.pers, o.persEnc || "hex");
    r(
      n.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(n, f, u);
  }
  return fc = i, i.prototype._init = function(n, f, u) {
    var c = n.concat(f).concat(u);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var h = 0; h < this.V.length; h++)
      this.K[h] = 0, this.V[h] = 1;
    this._update(c), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, i.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, i.prototype._update = function(n) {
    var f = this._hmac().update(this.V).update([0]);
    n && (f = f.update(n)), this.K = f.digest(), this.V = this._hmac().update(this.V).digest(), n && (this.K = this._hmac().update(this.V).update([1]).update(n).digest(), this.V = this._hmac().update(this.V).digest());
  }, i.prototype.reseed = function(n, f, u, c) {
    typeof f != "string" && (c = u, u = f, f = null), n = t.toArray(n, f), u = t.toArray(u, c), r(
      n.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(n.concat(u || [])), this._reseed = 1;
  }, i.prototype.generate = function(n, f, u, c) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof f != "string" && (c = u, u = f, f = null), u && (u = t.toArray(u, c || "hex"), this._update(u));
    for (var h = []; h.length < n; )
      this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
    var s = h.slice(0, n);
    return this._update(u), this._reseed++, t.encode(s, f);
  }, fc;
}
var sc, Hp;
function u9() {
  if (Hp)
    return sc;
  Hp = 1;
  var e = ar, t = zr(), r = t.assert;
  function i(o, n) {
    this.ec = o, this.priv = null, this.pub = null, n.priv && this._importPrivate(n.priv, n.privEnc), n.pub && this._importPublic(n.pub, n.pubEnc);
  }
  return sc = i, i.fromPublic = function(n, f, u) {
    return f instanceof i ? f : new i(n, {
      pub: f,
      pubEnc: u
    });
  }, i.fromPrivate = function(n, f, u) {
    return f instanceof i ? f : new i(n, {
      priv: f,
      privEnc: u
    });
  }, i.prototype.validate = function() {
    var n = this.getPublic();
    return n.isInfinity() ? { result: !1, reason: "Invalid public key" } : n.validate() ? n.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, i.prototype.getPublic = function(n, f) {
    return typeof n == "string" && (f = n, n = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), f ? this.pub.encode(f, n) : this.pub;
  }, i.prototype.getPrivate = function(n) {
    return n === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, i.prototype._importPrivate = function(n, f) {
    this.priv = new e(n, f || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, i.prototype._importPublic = function(n, f) {
    if (n.x || n.y) {
      this.ec.curve.type === "mont" ? r(n.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && r(n.x && n.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(n.x, n.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(n, f);
  }, i.prototype.derive = function(n) {
    return n.validate() || r(n.validate(), "public point not validated"), n.mul(this.priv).getX();
  }, i.prototype.sign = function(n, f, u) {
    return this.ec.sign(n, this, f, u);
  }, i.prototype.verify = function(n, f) {
    return this.ec.verify(n, f, this);
  }, i.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, sc;
}
var uc, zp;
function c9() {
  if (zp)
    return uc;
  zp = 1;
  var e = ar, t = zr(), r = t.assert;
  function i(c, h) {
    if (c instanceof i)
      return c;
    this._importDER(c, h) || (r(c.r && c.s, "Signature without r or s"), this.r = new e(c.r, 16), this.s = new e(c.s, 16), c.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = c.recoveryParam);
  }
  uc = i;
  function o() {
    this.place = 0;
  }
  function n(c, h) {
    var s = c[h.place++];
    if (!(s & 128))
      return s;
    var p = s & 15;
    if (p === 0 || p > 4)
      return !1;
    for (var v = 0, m = 0, E = h.place; m < p; m++, E++)
      v <<= 8, v |= c[E], v >>>= 0;
    return v <= 127 ? !1 : (h.place = E, v);
  }
  function f(c) {
    for (var h = 0, s = c.length - 1; !c[h] && !(c[h + 1] & 128) && h < s; )
      h++;
    return h === 0 ? c : c.slice(h);
  }
  i.prototype._importDER = function(h, s) {
    h = t.toArray(h, s);
    var p = new o();
    if (h[p.place++] !== 48)
      return !1;
    var v = n(h, p);
    if (v === !1 || v + p.place !== h.length || h[p.place++] !== 2)
      return !1;
    var m = n(h, p);
    if (m === !1)
      return !1;
    var E = h.slice(p.place, m + p.place);
    if (p.place += m, h[p.place++] !== 2)
      return !1;
    var M = n(h, p);
    if (M === !1 || h.length !== M + p.place)
      return !1;
    var I = h.slice(p.place, M + p.place);
    if (E[0] === 0)
      if (E[1] & 128)
        E = E.slice(1);
      else
        return !1;
    if (I[0] === 0)
      if (I[1] & 128)
        I = I.slice(1);
      else
        return !1;
    return this.r = new e(E), this.s = new e(I), this.recoveryParam = null, !0;
  };
  function u(c, h) {
    if (h < 128) {
      c.push(h);
      return;
    }
    var s = 1 + (Math.log(h) / Math.LN2 >>> 3);
    for (c.push(s | 128); --s; )
      c.push(h >>> (s << 3) & 255);
    c.push(h);
  }
  return i.prototype.toDER = function(h) {
    var s = this.r.toArray(), p = this.s.toArray();
    for (s[0] & 128 && (s = [0].concat(s)), p[0] & 128 && (p = [0].concat(p)), s = f(s), p = f(p); !p[0] && !(p[1] & 128); )
      p = p.slice(1);
    var v = [2];
    u(v, s.length), v = v.concat(s), v.push(2), u(v, p.length);
    var m = v.concat(p), E = [48];
    return u(E, m.length), E = E.concat(m), t.encode(E, h);
  }, uc;
}
var cc, Vp;
function h9() {
  if (Vp)
    return cc;
  Vp = 1;
  var e = ar, t = s9(), r = zr(), i = E0(), o = w0(), n = r.assert, f = u9(), u = c9();
  function c(h) {
    if (!(this instanceof c))
      return new c(h);
    typeof h == "string" && (n(
      Object.prototype.hasOwnProperty.call(i, h),
      "Unknown curve " + h
    ), h = i[h]), h instanceof i.PresetCurve && (h = { curve: h }), this.curve = h.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = h.curve.g, this.g.precompute(h.curve.n.bitLength() + 1), this.hash = h.hash || h.curve.hash;
  }
  return cc = c, c.prototype.keyPair = function(s) {
    return new f(this, s);
  }, c.prototype.keyFromPrivate = function(s, p) {
    return f.fromPrivate(this, s, p);
  }, c.prototype.keyFromPublic = function(s, p) {
    return f.fromPublic(this, s, p);
  }, c.prototype.genKeyPair = function(s) {
    s || (s = {});
    for (var p = new t({
      hash: this.hash,
      pers: s.pers,
      persEnc: s.persEnc || "utf8",
      entropy: s.entropy || o(this.hash.hmacStrength),
      entropyEnc: s.entropy && s.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), v = this.n.byteLength(), m = this.n.sub(new e(2)); ; ) {
      var E = new e(p.generate(v));
      if (!(E.cmp(m) > 0))
        return E.iaddn(1), this.keyFromPrivate(E);
    }
  }, c.prototype._truncateToN = function(s, p) {
    var v = s.byteLength() * 8 - this.n.bitLength();
    return v > 0 && (s = s.ushrn(v)), !p && s.cmp(this.n) >= 0 ? s.sub(this.n) : s;
  }, c.prototype.sign = function(s, p, v, m) {
    typeof v == "object" && (m = v, v = null), m || (m = {}), p = this.keyFromPrivate(p, v), s = this._truncateToN(new e(s, 16));
    for (var E = this.n.byteLength(), M = p.getPrivate().toArray("be", E), I = s.toArray("be", E), B = new t({
      hash: this.hash,
      entropy: M,
      nonce: I,
      pers: m.pers,
      persEnc: m.persEnc || "utf8"
    }), T = this.n.sub(new e(1)), k = 0; ; k++) {
      var N = m.k ? m.k(k) : new e(B.generate(this.n.byteLength()));
      if (N = this._truncateToN(N, !0), !(N.cmpn(1) <= 0 || N.cmp(T) >= 0)) {
        var q = this.g.mul(N);
        if (!q.isInfinity()) {
          var D = q.getX(), U = D.umod(this.n);
          if (U.cmpn(0) !== 0) {
            var z = N.invm(this.n).mul(U.mul(p.getPrivate()).iadd(s));
            if (z = z.umod(this.n), z.cmpn(0) !== 0) {
              var Y = (q.getY().isOdd() ? 1 : 0) | (D.cmp(U) !== 0 ? 2 : 0);
              return m.canonical && z.cmp(this.nh) > 0 && (z = this.n.sub(z), Y ^= 1), new u({ r: U, s: z, recoveryParam: Y });
            }
          }
        }
      }
    }
  }, c.prototype.verify = function(s, p, v, m) {
    s = this._truncateToN(new e(s, 16)), v = this.keyFromPublic(v, m), p = new u(p, "hex");
    var E = p.r, M = p.s;
    if (E.cmpn(1) < 0 || E.cmp(this.n) >= 0 || M.cmpn(1) < 0 || M.cmp(this.n) >= 0)
      return !1;
    var I = M.invm(this.n), B = I.mul(s).umod(this.n), T = I.mul(E).umod(this.n), k;
    return this.curve._maxwellTrick ? (k = this.g.jmulAdd(B, v.getPublic(), T), k.isInfinity() ? !1 : k.eqXToP(E)) : (k = this.g.mulAdd(B, v.getPublic(), T), k.isInfinity() ? !1 : k.getX().umod(this.n).cmp(E) === 0);
  }, c.prototype.recoverPubKey = function(h, s, p, v) {
    n((3 & p) === p, "The recovery param is more than two bits"), s = new u(s, v);
    var m = this.n, E = new e(h), M = s.r, I = s.s, B = p & 1, T = p >> 1;
    if (M.cmp(this.curve.p.umod(this.curve.n)) >= 0 && T)
      throw new Error("Unable to find sencond key candinate");
    T ? M = this.curve.pointFromX(M.add(this.curve.n), B) : M = this.curve.pointFromX(M, B);
    var k = s.r.invm(m), N = m.sub(E).mul(k).umod(m), q = I.mul(k).umod(m);
    return this.g.mulAdd(N, M, q);
  }, c.prototype.getKeyRecoveryParam = function(h, s, p, v) {
    if (s = new u(s, v), s.recoveryParam !== null)
      return s.recoveryParam;
    for (var m = 0; m < 4; m++) {
      var E;
      try {
        E = this.recoverPubKey(h, s, m);
      } catch {
        continue;
      }
      if (E.eq(p))
        return m;
    }
    throw new Error("Unable to find valid recovery factor");
  }, cc;
}
var hc, Wp;
function l9() {
  if (Wp)
    return hc;
  Wp = 1;
  var e = zr(), t = e.assert, r = e.parseBytes, i = e.cachedProperty;
  function o(n, f) {
    this.eddsa = n, this._secret = r(f.secret), n.isPoint(f.pub) ? this._pub = f.pub : this._pubBytes = r(f.pub);
  }
  return o.fromPublic = function(f, u) {
    return u instanceof o ? u : new o(f, { pub: u });
  }, o.fromSecret = function(f, u) {
    return u instanceof o ? u : new o(f, { secret: u });
  }, o.prototype.secret = function() {
    return this._secret;
  }, i(o, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), i(o, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), i(o, "privBytes", function() {
    var f = this.eddsa, u = this.hash(), c = f.encodingLength - 1, h = u.slice(0, f.encodingLength);
    return h[0] &= 248, h[c] &= 127, h[c] |= 64, h;
  }), i(o, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), i(o, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), i(o, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), o.prototype.sign = function(f) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(f, this);
  }, o.prototype.verify = function(f, u) {
    return this.eddsa.verify(f, u, this);
  }, o.prototype.getSecret = function(f) {
    return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), f);
  }, o.prototype.getPublic = function(f) {
    return e.encode(this.pubBytes(), f);
  }, hc = o, hc;
}
var lc, Kp;
function d9() {
  if (Kp)
    return lc;
  Kp = 1;
  var e = ar, t = zr(), r = t.assert, i = t.cachedProperty, o = t.parseBytes;
  function n(f, u) {
    this.eddsa = f, typeof u != "object" && (u = o(u)), Array.isArray(u) && (u = {
      R: u.slice(0, f.encodingLength),
      S: u.slice(f.encodingLength)
    }), r(u.R && u.S, "Signature without R or S"), f.isPoint(u.R) && (this._R = u.R), u.S instanceof e && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
  }
  return i(n, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), i(n, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), i(n, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), i(n, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), n.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, n.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, lc = n, lc;
}
var dc, Zp;
function p9() {
  if (Zp)
    return dc;
  Zp = 1;
  var e = x0(), t = E0(), r = zr(), i = r.assert, o = r.parseBytes, n = l9(), f = d9();
  function u(c) {
    if (i(c === "ed25519", "only tested with ed25519 so far"), !(this instanceof u))
      return new u(c);
    c = t[c].curve, this.curve = c, this.g = c.g, this.g.precompute(c.n.bitLength() + 1), this.pointClass = c.point().constructor, this.encodingLength = Math.ceil(c.n.bitLength() / 8), this.hash = e.sha512;
  }
  return dc = u, u.prototype.sign = function(h, s) {
    h = o(h);
    var p = this.keyFromSecret(s), v = this.hashInt(p.messagePrefix(), h), m = this.g.mul(v), E = this.encodePoint(m), M = this.hashInt(E, p.pubBytes(), h).mul(p.priv()), I = v.add(M).umod(this.curve.n);
    return this.makeSignature({ R: m, S: I, Rencoded: E });
  }, u.prototype.verify = function(h, s, p) {
    h = o(h), s = this.makeSignature(s);
    var v = this.keyFromPublic(p), m = this.hashInt(s.Rencoded(), v.pubBytes(), h), E = this.g.mul(s.S()), M = s.R().add(v.pub().mul(m));
    return M.eq(E);
  }, u.prototype.hashInt = function() {
    for (var h = this.hash(), s = 0; s < arguments.length; s++)
      h.update(arguments[s]);
    return r.intFromLE(h.digest()).umod(this.curve.n);
  }, u.prototype.keyFromPublic = function(h) {
    return n.fromPublic(this, h);
  }, u.prototype.keyFromSecret = function(h) {
    return n.fromSecret(this, h);
  }, u.prototype.makeSignature = function(h) {
    return h instanceof f ? h : new f(this, h);
  }, u.prototype.encodePoint = function(h) {
    var s = h.getY().toArray("le", this.encodingLength);
    return s[this.encodingLength - 1] |= h.getX().isOdd() ? 128 : 0, s;
  }, u.prototype.decodePoint = function(h) {
    h = r.parseBytes(h);
    var s = h.length - 1, p = h.slice(0, s).concat(h[s] & -129), v = (h[s] & 128) !== 0, m = r.intFromLE(p);
    return this.curve.pointFromY(m, v);
  }, u.prototype.encodeInt = function(h) {
    return h.toArray("le", this.encodingLength);
  }, u.prototype.decodeInt = function(h) {
    return r.intFromLE(h);
  }, u.prototype.isPoint = function(h) {
    return h instanceof this.pointClass;
  }, dc;
}
var Gp;
function S0() {
  return Gp || (Gp = 1, function(e) {
    var t = e;
    t.version = X7.version, t.utils = zr(), t.rand = w0(), t.curve = zg(), t.curves = E0(), t.ec = h9(), t.eddsa = p9();
  }(Fu)), Fu;
}
var so = { exports: {} };
so.exports;
var Jp;
function Zg() {
  return Jp || (Jp = 1, function(e) {
    (function(t, r) {
      function i(b, a) {
        if (!b)
          throw new Error(a || "Assertion failed");
      }
      function o(b, a) {
        b.super_ = a;
        var d = function() {
        };
        d.prototype = a.prototype, b.prototype = new d(), b.prototype.constructor = b;
      }
      function n(b, a, d) {
        if (n.isBN(b))
          return b;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, b !== null && ((a === "le" || a === "be") && (d = a, a = 10), this._init(b || 0, a || 10, d || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var f;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? f = window.Buffer : f = Le.Buffer;
      } catch {
      }
      n.isBN = function(a) {
        return a instanceof n ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words);
      }, n.max = function(a, d) {
        return a.cmp(d) > 0 ? a : d;
      }, n.min = function(a, d) {
        return a.cmp(d) < 0 ? a : d;
      }, n.prototype._init = function(a, d, w) {
        if (typeof a == "number")
          return this._initNumber(a, d, w);
        if (typeof a == "object")
          return this._initArray(a, d, w);
        d === "hex" && (d = 16), i(d === (d | 0) && d >= 2 && d <= 36), a = a.toString().replace(/\s+/g, "");
        var x = 0;
        a[0] === "-" && (x++, this.negative = 1), x < a.length && (d === 16 ? this._parseHex(a, x, w) : (this._parseBase(a, d, x), w === "le" && this._initArray(this.toArray(), d, w)));
      }, n.prototype._initNumber = function(a, d, w) {
        a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
          a & 67108863,
          a / 67108864 & 67108863
        ], this.length = 2) : (i(a < 9007199254740992), this.words = [
          a & 67108863,
          a / 67108864 & 67108863,
          1
        ], this.length = 3), w === "le" && this._initArray(this.toArray(), d, w);
      }, n.prototype._initArray = function(a, d, w) {
        if (i(typeof a.length == "number"), a.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A, S, y = 0;
        if (w === "be")
          for (x = a.length - 1, A = 0; x >= 0; x -= 3)
            S = a[x] | a[x - 1] << 8 | a[x - 2] << 16, this.words[A] |= S << y & 67108863, this.words[A + 1] = S >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, A++);
        else if (w === "le")
          for (x = 0, A = 0; x < a.length; x += 3)
            S = a[x] | a[x + 1] << 8 | a[x + 2] << 16, this.words[A] |= S << y & 67108863, this.words[A + 1] = S >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, A++);
        return this._strip();
      };
      function u(b, a) {
        var d = b.charCodeAt(a);
        if (d >= 48 && d <= 57)
          return d - 48;
        if (d >= 65 && d <= 70)
          return d - 55;
        if (d >= 97 && d <= 102)
          return d - 87;
        i(!1, "Invalid character in " + b);
      }
      function c(b, a, d) {
        var w = u(b, d);
        return d - 1 >= a && (w |= u(b, d - 1) << 4), w;
      }
      n.prototype._parseHex = function(a, d, w) {
        this.length = Math.ceil((a.length - d) / 6), this.words = new Array(this.length);
        for (var x = 0; x < this.length; x++)
          this.words[x] = 0;
        var A = 0, S = 0, y;
        if (w === "be")
          for (x = a.length - 1; x >= d; x -= 2)
            y = c(a, d, x) << A, this.words[S] |= y & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= y >>> 26) : A += 8;
        else {
          var _ = a.length - d;
          for (x = _ % 2 === 0 ? d + 1 : d; x < a.length; x += 2)
            y = c(a, d, x) << A, this.words[S] |= y & 67108863, A >= 18 ? (A -= 18, S += 1, this.words[S] |= y >>> 26) : A += 8;
        }
        this._strip();
      };
      function h(b, a, d, w) {
        for (var x = 0, A = 0, S = Math.min(b.length, d), y = a; y < S; y++) {
          var _ = b.charCodeAt(y) - 48;
          x *= w, _ >= 49 ? A = _ - 49 + 10 : _ >= 17 ? A = _ - 17 + 10 : A = _, i(_ >= 0 && A < w, "Invalid character"), x += A;
        }
        return x;
      }
      n.prototype._parseBase = function(a, d, w) {
        this.words = [0], this.length = 1;
        for (var x = 0, A = 1; A <= 67108863; A *= d)
          x++;
        x--, A = A / d | 0;
        for (var S = a.length - w, y = S % x, _ = Math.min(S, S - y) + w, l = 0, R = w; R < _; R += x)
          l = h(a, R, R + x, d), this.imuln(A), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        if (y !== 0) {
          var ee = 1;
          for (l = h(a, R, a.length, d), R = 0; R < y; R++)
            ee *= d;
          this.imuln(ee), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
        }
        this._strip();
      }, n.prototype.copy = function(a) {
        a.words = new Array(this.length);
        for (var d = 0; d < this.length; d++)
          a.words[d] = this.words[d];
        a.length = this.length, a.negative = this.negative, a.red = this.red;
      };
      function s(b, a) {
        b.words = a.words, b.length = a.length, b.negative = a.negative, b.red = a.red;
      }
      if (n.prototype._move = function(a) {
        s(a, this);
      }, n.prototype.clone = function() {
        var a = new n(null);
        return this.copy(a), a;
      }, n.prototype._expand = function(a) {
        for (; this.length < a; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
        } catch {
          n.prototype.inspect = p;
        }
      else
        n.prototype.inspect = p;
      function p() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var v = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], E = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(a, d) {
        a = a || 10, d = d | 0 || 1;
        var w;
        if (a === 16 || a === "hex") {
          w = "";
          for (var x = 0, A = 0, S = 0; S < this.length; S++) {
            var y = this.words[S], _ = ((y << x | A) & 16777215).toString(16);
            A = y >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), A !== 0 || S !== this.length - 1 ? w = v[6 - _.length] + _ + w : w = _ + w;
          }
          for (A !== 0 && (w = A.toString(16) + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        if (a === (a | 0) && a >= 2 && a <= 36) {
          var l = m[a], R = E[a];
          w = "";
          var ee = this.clone();
          for (ee.negative = 0; !ee.isZero(); ) {
            var oe = ee.modrn(R).toString(a);
            ee = ee.idivn(R), ee.isZero() ? w = oe + w : w = v[l - oe.length] + oe + w;
          }
          for (this.isZero() && (w = "0" + w); w.length % d !== 0; )
            w = "0" + w;
          return this.negative !== 0 && (w = "-" + w), w;
        }
        i(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var a = this.words[0];
        return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, f && (n.prototype.toBuffer = function(a, d) {
        return this.toArrayLike(f, a, d);
      }), n.prototype.toArray = function(a, d) {
        return this.toArrayLike(Array, a, d);
      };
      var M = function(a, d) {
        return a.allocUnsafe ? a.allocUnsafe(d) : new a(d);
      };
      n.prototype.toArrayLike = function(a, d, w) {
        this._strip();
        var x = this.byteLength(), A = w || Math.max(1, x);
        i(x <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var S = M(a, A), y = d === "le" ? "LE" : "BE";
        return this["_toArrayLike" + y](S, x), S;
      }, n.prototype._toArrayLikeLE = function(a, d) {
        for (var w = 0, x = 0, A = 0, S = 0; A < this.length; A++) {
          var y = this.words[A] << S | x;
          a[w++] = y & 255, w < a.length && (a[w++] = y >> 8 & 255), w < a.length && (a[w++] = y >> 16 & 255), S === 6 ? (w < a.length && (a[w++] = y >> 24 & 255), x = 0, S = 0) : (x = y >>> 24, S += 2);
        }
        if (w < a.length)
          for (a[w++] = x; w < a.length; )
            a[w++] = 0;
      }, n.prototype._toArrayLikeBE = function(a, d) {
        for (var w = a.length - 1, x = 0, A = 0, S = 0; A < this.length; A++) {
          var y = this.words[A] << S | x;
          a[w--] = y & 255, w >= 0 && (a[w--] = y >> 8 & 255), w >= 0 && (a[w--] = y >> 16 & 255), S === 6 ? (w >= 0 && (a[w--] = y >> 24 & 255), x = 0, S = 0) : (x = y >>> 24, S += 2);
        }
        if (w >= 0)
          for (a[w--] = x; w >= 0; )
            a[w--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(a) {
        return 32 - Math.clz32(a);
      } : n.prototype._countBits = function(a) {
        var d = a, w = 0;
        return d >= 4096 && (w += 13, d >>>= 13), d >= 64 && (w += 7, d >>>= 7), d >= 8 && (w += 4, d >>>= 4), d >= 2 && (w += 2, d >>>= 2), w + d;
      }, n.prototype._zeroBits = function(a) {
        if (a === 0)
          return 26;
        var d = a, w = 0;
        return d & 8191 || (w += 13, d >>>= 13), d & 127 || (w += 7, d >>>= 7), d & 15 || (w += 4, d >>>= 4), d & 3 || (w += 2, d >>>= 2), d & 1 || w++, w;
      }, n.prototype.bitLength = function() {
        var a = this.words[this.length - 1], d = this._countBits(a);
        return (this.length - 1) * 26 + d;
      };
      function I(b) {
        for (var a = new Array(b.bitLength()), d = 0; d < a.length; d++) {
          var w = d / 26 | 0, x = d % 26;
          a[d] = b.words[w] >>> x & 1;
        }
        return a;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var a = 0, d = 0; d < this.length; d++) {
          var w = this._zeroBits(this.words[d]);
          if (a += w, w !== 26)
            break;
        }
        return a;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(a) {
        return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(a) {
        return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(a) {
        for (; this.length < a.length; )
          this.words[this.length++] = 0;
        for (var d = 0; d < a.length; d++)
          this.words[d] = this.words[d] | a.words[d];
        return this._strip();
      }, n.prototype.ior = function(a) {
        return i((this.negative | a.negative) === 0), this.iuor(a);
      }, n.prototype.or = function(a) {
        return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
      }, n.prototype.uor = function(a) {
        return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
      }, n.prototype.iuand = function(a) {
        var d;
        this.length > a.length ? d = a : d = this;
        for (var w = 0; w < d.length; w++)
          this.words[w] = this.words[w] & a.words[w];
        return this.length = d.length, this._strip();
      }, n.prototype.iand = function(a) {
        return i((this.negative | a.negative) === 0), this.iuand(a);
      }, n.prototype.and = function(a) {
        return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
      }, n.prototype.uand = function(a) {
        return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
      }, n.prototype.iuxor = function(a) {
        var d, w;
        this.length > a.length ? (d = this, w = a) : (d = a, w = this);
        for (var x = 0; x < w.length; x++)
          this.words[x] = d.words[x] ^ w.words[x];
        if (this !== d)
          for (; x < d.length; x++)
            this.words[x] = d.words[x];
        return this.length = d.length, this._strip();
      }, n.prototype.ixor = function(a) {
        return i((this.negative | a.negative) === 0), this.iuxor(a);
      }, n.prototype.xor = function(a) {
        return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
      }, n.prototype.uxor = function(a) {
        return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
      }, n.prototype.inotn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = Math.ceil(a / 26) | 0, w = a % 26;
        this._expand(d), w > 0 && d--;
        for (var x = 0; x < d; x++)
          this.words[x] = ~this.words[x] & 67108863;
        return w > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - w), this._strip();
      }, n.prototype.notn = function(a) {
        return this.clone().inotn(a);
      }, n.prototype.setn = function(a, d) {
        i(typeof a == "number" && a >= 0);
        var w = a / 26 | 0, x = a % 26;
        return this._expand(w + 1), d ? this.words[w] = this.words[w] | 1 << x : this.words[w] = this.words[w] & ~(1 << x), this._strip();
      }, n.prototype.iadd = function(a) {
        var d;
        if (this.negative !== 0 && a.negative === 0)
          return this.negative = 0, d = this.isub(a), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && a.negative !== 0)
          return a.negative = 0, d = this.isub(a), a.negative = 1, d._normSign();
        var w, x;
        this.length > a.length ? (w = this, x = a) : (w = a, x = this);
        for (var A = 0, S = 0; S < x.length; S++)
          d = (w.words[S] | 0) + (x.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        for (; A !== 0 && S < w.length; S++)
          d = (w.words[S] | 0) + A, this.words[S] = d & 67108863, A = d >>> 26;
        if (this.length = w.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (w !== this)
          for (; S < w.length; S++)
            this.words[S] = w.words[S];
        return this;
      }, n.prototype.add = function(a) {
        var d;
        return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, d = this.sub(a), a.negative ^= 1, d) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, d = a.sub(this), this.negative = 1, d) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
      }, n.prototype.isub = function(a) {
        if (a.negative !== 0) {
          a.negative = 0;
          var d = this.iadd(a);
          return a.negative = 1, d._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
        var w = this.cmp(a);
        if (w === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var x, A;
        w > 0 ? (x = this, A = a) : (x = a, A = this);
        for (var S = 0, y = 0; y < A.length; y++)
          d = (x.words[y] | 0) - (A.words[y] | 0) + S, S = d >> 26, this.words[y] = d & 67108863;
        for (; S !== 0 && y < x.length; y++)
          d = (x.words[y] | 0) + S, S = d >> 26, this.words[y] = d & 67108863;
        if (S === 0 && y < x.length && x !== this)
          for (; y < x.length; y++)
            this.words[y] = x.words[y];
        return this.length = Math.max(this.length, y), x !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(a) {
        return this.clone().isub(a);
      };
      function B(b, a, d) {
        d.negative = a.negative ^ b.negative;
        var w = b.length + a.length | 0;
        d.length = w, w = w - 1 | 0;
        var x = b.words[0] | 0, A = a.words[0] | 0, S = x * A, y = S & 67108863, _ = S / 67108864 | 0;
        d.words[0] = y;
        for (var l = 1; l < w; l++) {
          for (var R = _ >>> 26, ee = _ & 67108863, oe = Math.min(l, a.length - 1), V = Math.max(0, l - b.length + 1); V <= oe; V++) {
            var W = l - V | 0;
            x = b.words[W] | 0, A = a.words[V] | 0, S = x * A + ee, R += S / 67108864 | 0, ee = S & 67108863;
          }
          d.words[l] = ee | 0, _ = R | 0;
        }
        return _ !== 0 ? d.words[l] = _ | 0 : d.length--, d._strip();
      }
      var T = function(a, d, w) {
        var x = a.words, A = d.words, S = w.words, y = 0, _, l, R, ee = x[0] | 0, oe = ee & 8191, V = ee >>> 13, W = x[1] | 0, F = W & 8191, re = W >>> 13, he = x[2] | 0, Z = he & 8191, K = he >>> 13, ce = x[3] | 0, ve = ce & 8191, Be = ce >>> 13, te = x[4] | 0, C = te & 8191, L = te >>> 13, G = x[5] | 0, de = G & 8191, me = G >>> 13, Te = x[6] | 0, He = Te & 8191, H = Te >>> 13, se = x[7] | 0, fe = se & 8191, _e = se >>> 13, Ce = x[8] | 0, Ve = Ce & 8191, ke = Ce >>> 13, Q = x[9] | 0, Se = Q & 8191, Ae = Q >>> 13, $e = A[0] | 0, pe = $e & 8191, Ee = $e >>> 13, J = A[1] | 0, Ie = J & 8191, qe = J >>> 13, P = A[2] | 0, Me = P & 8191, be = P >>> 13, ie = A[3] | 0, le = ie & 8191, ge = ie >>> 13, Ge = A[4] | 0, je = Ge & 8191, Ne = Ge >>> 13, nt = A[5] | 0, st = nt & 8191, Je = nt >>> 13, ft = A[6] | 0, $ = ft & 8191, X = ft >>> 13, ne = A[7] | 0, O = ne & 8191, ae = ne >>> 13, we = A[8] | 0, xe = we & 8191, Re = we >>> 13, De = A[9] | 0, ze = De & 8191, Ue = De >>> 13;
        w.negative = a.negative ^ d.negative, w.length = 19, _ = Math.imul(oe, pe), l = Math.imul(oe, Ee), l = l + Math.imul(V, pe) | 0, R = Math.imul(V, Ee);
        var mt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, _ = Math.imul(F, pe), l = Math.imul(F, Ee), l = l + Math.imul(re, pe) | 0, R = Math.imul(re, Ee), _ = _ + Math.imul(oe, Ie) | 0, l = l + Math.imul(oe, qe) | 0, l = l + Math.imul(V, Ie) | 0, R = R + Math.imul(V, qe) | 0;
        var et = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, _ = Math.imul(Z, pe), l = Math.imul(Z, Ee), l = l + Math.imul(K, pe) | 0, R = Math.imul(K, Ee), _ = _ + Math.imul(F, Ie) | 0, l = l + Math.imul(F, qe) | 0, l = l + Math.imul(re, Ie) | 0, R = R + Math.imul(re, qe) | 0, _ = _ + Math.imul(oe, Me) | 0, l = l + Math.imul(oe, be) | 0, l = l + Math.imul(V, Me) | 0, R = R + Math.imul(V, be) | 0;
        var ut = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, _ = Math.imul(ve, pe), l = Math.imul(ve, Ee), l = l + Math.imul(Be, pe) | 0, R = Math.imul(Be, Ee), _ = _ + Math.imul(Z, Ie) | 0, l = l + Math.imul(Z, qe) | 0, l = l + Math.imul(K, Ie) | 0, R = R + Math.imul(K, qe) | 0, _ = _ + Math.imul(F, Me) | 0, l = l + Math.imul(F, be) | 0, l = l + Math.imul(re, Me) | 0, R = R + Math.imul(re, be) | 0, _ = _ + Math.imul(oe, le) | 0, l = l + Math.imul(oe, ge) | 0, l = l + Math.imul(V, le) | 0, R = R + Math.imul(V, ge) | 0;
        var ct = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, _ = Math.imul(C, pe), l = Math.imul(C, Ee), l = l + Math.imul(L, pe) | 0, R = Math.imul(L, Ee), _ = _ + Math.imul(ve, Ie) | 0, l = l + Math.imul(ve, qe) | 0, l = l + Math.imul(Be, Ie) | 0, R = R + Math.imul(Be, qe) | 0, _ = _ + Math.imul(Z, Me) | 0, l = l + Math.imul(Z, be) | 0, l = l + Math.imul(K, Me) | 0, R = R + Math.imul(K, be) | 0, _ = _ + Math.imul(F, le) | 0, l = l + Math.imul(F, ge) | 0, l = l + Math.imul(re, le) | 0, R = R + Math.imul(re, ge) | 0, _ = _ + Math.imul(oe, je) | 0, l = l + Math.imul(oe, Ne) | 0, l = l + Math.imul(V, je) | 0, R = R + Math.imul(V, Ne) | 0;
        var vt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, _ = Math.imul(de, pe), l = Math.imul(de, Ee), l = l + Math.imul(me, pe) | 0, R = Math.imul(me, Ee), _ = _ + Math.imul(C, Ie) | 0, l = l + Math.imul(C, qe) | 0, l = l + Math.imul(L, Ie) | 0, R = R + Math.imul(L, qe) | 0, _ = _ + Math.imul(ve, Me) | 0, l = l + Math.imul(ve, be) | 0, l = l + Math.imul(Be, Me) | 0, R = R + Math.imul(Be, be) | 0, _ = _ + Math.imul(Z, le) | 0, l = l + Math.imul(Z, ge) | 0, l = l + Math.imul(K, le) | 0, R = R + Math.imul(K, ge) | 0, _ = _ + Math.imul(F, je) | 0, l = l + Math.imul(F, Ne) | 0, l = l + Math.imul(re, je) | 0, R = R + Math.imul(re, Ne) | 0, _ = _ + Math.imul(oe, st) | 0, l = l + Math.imul(oe, Je) | 0, l = l + Math.imul(V, st) | 0, R = R + Math.imul(V, Je) | 0;
        var pt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, _ = Math.imul(He, pe), l = Math.imul(He, Ee), l = l + Math.imul(H, pe) | 0, R = Math.imul(H, Ee), _ = _ + Math.imul(de, Ie) | 0, l = l + Math.imul(de, qe) | 0, l = l + Math.imul(me, Ie) | 0, R = R + Math.imul(me, qe) | 0, _ = _ + Math.imul(C, Me) | 0, l = l + Math.imul(C, be) | 0, l = l + Math.imul(L, Me) | 0, R = R + Math.imul(L, be) | 0, _ = _ + Math.imul(ve, le) | 0, l = l + Math.imul(ve, ge) | 0, l = l + Math.imul(Be, le) | 0, R = R + Math.imul(Be, ge) | 0, _ = _ + Math.imul(Z, je) | 0, l = l + Math.imul(Z, Ne) | 0, l = l + Math.imul(K, je) | 0, R = R + Math.imul(K, Ne) | 0, _ = _ + Math.imul(F, st) | 0, l = l + Math.imul(F, Je) | 0, l = l + Math.imul(re, st) | 0, R = R + Math.imul(re, Je) | 0, _ = _ + Math.imul(oe, $) | 0, l = l + Math.imul(oe, X) | 0, l = l + Math.imul(V, $) | 0, R = R + Math.imul(V, X) | 0;
        var ht = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, _ = Math.imul(fe, pe), l = Math.imul(fe, Ee), l = l + Math.imul(_e, pe) | 0, R = Math.imul(_e, Ee), _ = _ + Math.imul(He, Ie) | 0, l = l + Math.imul(He, qe) | 0, l = l + Math.imul(H, Ie) | 0, R = R + Math.imul(H, qe) | 0, _ = _ + Math.imul(de, Me) | 0, l = l + Math.imul(de, be) | 0, l = l + Math.imul(me, Me) | 0, R = R + Math.imul(me, be) | 0, _ = _ + Math.imul(C, le) | 0, l = l + Math.imul(C, ge) | 0, l = l + Math.imul(L, le) | 0, R = R + Math.imul(L, ge) | 0, _ = _ + Math.imul(ve, je) | 0, l = l + Math.imul(ve, Ne) | 0, l = l + Math.imul(Be, je) | 0, R = R + Math.imul(Be, Ne) | 0, _ = _ + Math.imul(Z, st) | 0, l = l + Math.imul(Z, Je) | 0, l = l + Math.imul(K, st) | 0, R = R + Math.imul(K, Je) | 0, _ = _ + Math.imul(F, $) | 0, l = l + Math.imul(F, X) | 0, l = l + Math.imul(re, $) | 0, R = R + Math.imul(re, X) | 0, _ = _ + Math.imul(oe, O) | 0, l = l + Math.imul(oe, ae) | 0, l = l + Math.imul(V, O) | 0, R = R + Math.imul(V, ae) | 0;
        var dt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, _ = Math.imul(Ve, pe), l = Math.imul(Ve, Ee), l = l + Math.imul(ke, pe) | 0, R = Math.imul(ke, Ee), _ = _ + Math.imul(fe, Ie) | 0, l = l + Math.imul(fe, qe) | 0, l = l + Math.imul(_e, Ie) | 0, R = R + Math.imul(_e, qe) | 0, _ = _ + Math.imul(He, Me) | 0, l = l + Math.imul(He, be) | 0, l = l + Math.imul(H, Me) | 0, R = R + Math.imul(H, be) | 0, _ = _ + Math.imul(de, le) | 0, l = l + Math.imul(de, ge) | 0, l = l + Math.imul(me, le) | 0, R = R + Math.imul(me, ge) | 0, _ = _ + Math.imul(C, je) | 0, l = l + Math.imul(C, Ne) | 0, l = l + Math.imul(L, je) | 0, R = R + Math.imul(L, Ne) | 0, _ = _ + Math.imul(ve, st) | 0, l = l + Math.imul(ve, Je) | 0, l = l + Math.imul(Be, st) | 0, R = R + Math.imul(Be, Je) | 0, _ = _ + Math.imul(Z, $) | 0, l = l + Math.imul(Z, X) | 0, l = l + Math.imul(K, $) | 0, R = R + Math.imul(K, X) | 0, _ = _ + Math.imul(F, O) | 0, l = l + Math.imul(F, ae) | 0, l = l + Math.imul(re, O) | 0, R = R + Math.imul(re, ae) | 0, _ = _ + Math.imul(oe, xe) | 0, l = l + Math.imul(oe, Re) | 0, l = l + Math.imul(V, xe) | 0, R = R + Math.imul(V, Re) | 0;
        var lt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, _ = Math.imul(Se, pe), l = Math.imul(Se, Ee), l = l + Math.imul(Ae, pe) | 0, R = Math.imul(Ae, Ee), _ = _ + Math.imul(Ve, Ie) | 0, l = l + Math.imul(Ve, qe) | 0, l = l + Math.imul(ke, Ie) | 0, R = R + Math.imul(ke, qe) | 0, _ = _ + Math.imul(fe, Me) | 0, l = l + Math.imul(fe, be) | 0, l = l + Math.imul(_e, Me) | 0, R = R + Math.imul(_e, be) | 0, _ = _ + Math.imul(He, le) | 0, l = l + Math.imul(He, ge) | 0, l = l + Math.imul(H, le) | 0, R = R + Math.imul(H, ge) | 0, _ = _ + Math.imul(de, je) | 0, l = l + Math.imul(de, Ne) | 0, l = l + Math.imul(me, je) | 0, R = R + Math.imul(me, Ne) | 0, _ = _ + Math.imul(C, st) | 0, l = l + Math.imul(C, Je) | 0, l = l + Math.imul(L, st) | 0, R = R + Math.imul(L, Je) | 0, _ = _ + Math.imul(ve, $) | 0, l = l + Math.imul(ve, X) | 0, l = l + Math.imul(Be, $) | 0, R = R + Math.imul(Be, X) | 0, _ = _ + Math.imul(Z, O) | 0, l = l + Math.imul(Z, ae) | 0, l = l + Math.imul(K, O) | 0, R = R + Math.imul(K, ae) | 0, _ = _ + Math.imul(F, xe) | 0, l = l + Math.imul(F, Re) | 0, l = l + Math.imul(re, xe) | 0, R = R + Math.imul(re, Re) | 0, _ = _ + Math.imul(oe, ze) | 0, l = l + Math.imul(oe, Ue) | 0, l = l + Math.imul(V, ze) | 0, R = R + Math.imul(V, Ue) | 0;
        var tt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, _ = Math.imul(Se, Ie), l = Math.imul(Se, qe), l = l + Math.imul(Ae, Ie) | 0, R = Math.imul(Ae, qe), _ = _ + Math.imul(Ve, Me) | 0, l = l + Math.imul(Ve, be) | 0, l = l + Math.imul(ke, Me) | 0, R = R + Math.imul(ke, be) | 0, _ = _ + Math.imul(fe, le) | 0, l = l + Math.imul(fe, ge) | 0, l = l + Math.imul(_e, le) | 0, R = R + Math.imul(_e, ge) | 0, _ = _ + Math.imul(He, je) | 0, l = l + Math.imul(He, Ne) | 0, l = l + Math.imul(H, je) | 0, R = R + Math.imul(H, Ne) | 0, _ = _ + Math.imul(de, st) | 0, l = l + Math.imul(de, Je) | 0, l = l + Math.imul(me, st) | 0, R = R + Math.imul(me, Je) | 0, _ = _ + Math.imul(C, $) | 0, l = l + Math.imul(C, X) | 0, l = l + Math.imul(L, $) | 0, R = R + Math.imul(L, X) | 0, _ = _ + Math.imul(ve, O) | 0, l = l + Math.imul(ve, ae) | 0, l = l + Math.imul(Be, O) | 0, R = R + Math.imul(Be, ae) | 0, _ = _ + Math.imul(Z, xe) | 0, l = l + Math.imul(Z, Re) | 0, l = l + Math.imul(K, xe) | 0, R = R + Math.imul(K, Re) | 0, _ = _ + Math.imul(F, ze) | 0, l = l + Math.imul(F, Ue) | 0, l = l + Math.imul(re, ze) | 0, R = R + Math.imul(re, Ue) | 0;
        var ot = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, _ = Math.imul(Se, Me), l = Math.imul(Se, be), l = l + Math.imul(Ae, Me) | 0, R = Math.imul(Ae, be), _ = _ + Math.imul(Ve, le) | 0, l = l + Math.imul(Ve, ge) | 0, l = l + Math.imul(ke, le) | 0, R = R + Math.imul(ke, ge) | 0, _ = _ + Math.imul(fe, je) | 0, l = l + Math.imul(fe, Ne) | 0, l = l + Math.imul(_e, je) | 0, R = R + Math.imul(_e, Ne) | 0, _ = _ + Math.imul(He, st) | 0, l = l + Math.imul(He, Je) | 0, l = l + Math.imul(H, st) | 0, R = R + Math.imul(H, Je) | 0, _ = _ + Math.imul(de, $) | 0, l = l + Math.imul(de, X) | 0, l = l + Math.imul(me, $) | 0, R = R + Math.imul(me, X) | 0, _ = _ + Math.imul(C, O) | 0, l = l + Math.imul(C, ae) | 0, l = l + Math.imul(L, O) | 0, R = R + Math.imul(L, ae) | 0, _ = _ + Math.imul(ve, xe) | 0, l = l + Math.imul(ve, Re) | 0, l = l + Math.imul(Be, xe) | 0, R = R + Math.imul(Be, Re) | 0, _ = _ + Math.imul(Z, ze) | 0, l = l + Math.imul(Z, Ue) | 0, l = l + Math.imul(K, ze) | 0, R = R + Math.imul(K, Ue) | 0;
        var Qe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, _ = Math.imul(Se, le), l = Math.imul(Se, ge), l = l + Math.imul(Ae, le) | 0, R = Math.imul(Ae, ge), _ = _ + Math.imul(Ve, je) | 0, l = l + Math.imul(Ve, Ne) | 0, l = l + Math.imul(ke, je) | 0, R = R + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(fe, st) | 0, l = l + Math.imul(fe, Je) | 0, l = l + Math.imul(_e, st) | 0, R = R + Math.imul(_e, Je) | 0, _ = _ + Math.imul(He, $) | 0, l = l + Math.imul(He, X) | 0, l = l + Math.imul(H, $) | 0, R = R + Math.imul(H, X) | 0, _ = _ + Math.imul(de, O) | 0, l = l + Math.imul(de, ae) | 0, l = l + Math.imul(me, O) | 0, R = R + Math.imul(me, ae) | 0, _ = _ + Math.imul(C, xe) | 0, l = l + Math.imul(C, Re) | 0, l = l + Math.imul(L, xe) | 0, R = R + Math.imul(L, Re) | 0, _ = _ + Math.imul(ve, ze) | 0, l = l + Math.imul(ve, Ue) | 0, l = l + Math.imul(Be, ze) | 0, R = R + Math.imul(Be, Ue) | 0;
        var rt = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, _ = Math.imul(Se, je), l = Math.imul(Se, Ne), l = l + Math.imul(Ae, je) | 0, R = Math.imul(Ae, Ne), _ = _ + Math.imul(Ve, st) | 0, l = l + Math.imul(Ve, Je) | 0, l = l + Math.imul(ke, st) | 0, R = R + Math.imul(ke, Je) | 0, _ = _ + Math.imul(fe, $) | 0, l = l + Math.imul(fe, X) | 0, l = l + Math.imul(_e, $) | 0, R = R + Math.imul(_e, X) | 0, _ = _ + Math.imul(He, O) | 0, l = l + Math.imul(He, ae) | 0, l = l + Math.imul(H, O) | 0, R = R + Math.imul(H, ae) | 0, _ = _ + Math.imul(de, xe) | 0, l = l + Math.imul(de, Re) | 0, l = l + Math.imul(me, xe) | 0, R = R + Math.imul(me, Re) | 0, _ = _ + Math.imul(C, ze) | 0, l = l + Math.imul(C, Ue) | 0, l = l + Math.imul(L, ze) | 0, R = R + Math.imul(L, Ue) | 0;
        var it = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, _ = Math.imul(Se, st), l = Math.imul(Se, Je), l = l + Math.imul(Ae, st) | 0, R = Math.imul(Ae, Je), _ = _ + Math.imul(Ve, $) | 0, l = l + Math.imul(Ve, X) | 0, l = l + Math.imul(ke, $) | 0, R = R + Math.imul(ke, X) | 0, _ = _ + Math.imul(fe, O) | 0, l = l + Math.imul(fe, ae) | 0, l = l + Math.imul(_e, O) | 0, R = R + Math.imul(_e, ae) | 0, _ = _ + Math.imul(He, xe) | 0, l = l + Math.imul(He, Re) | 0, l = l + Math.imul(H, xe) | 0, R = R + Math.imul(H, Re) | 0, _ = _ + Math.imul(de, ze) | 0, l = l + Math.imul(de, Ue) | 0, l = l + Math.imul(me, ze) | 0, R = R + Math.imul(me, Ue) | 0;
        var Ye = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, _ = Math.imul(Se, $), l = Math.imul(Se, X), l = l + Math.imul(Ae, $) | 0, R = Math.imul(Ae, X), _ = _ + Math.imul(Ve, O) | 0, l = l + Math.imul(Ve, ae) | 0, l = l + Math.imul(ke, O) | 0, R = R + Math.imul(ke, ae) | 0, _ = _ + Math.imul(fe, xe) | 0, l = l + Math.imul(fe, Re) | 0, l = l + Math.imul(_e, xe) | 0, R = R + Math.imul(_e, Re) | 0, _ = _ + Math.imul(He, ze) | 0, l = l + Math.imul(He, Ue) | 0, l = l + Math.imul(H, ze) | 0, R = R + Math.imul(H, Ue) | 0;
        var Oe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, _ = Math.imul(Se, O), l = Math.imul(Se, ae), l = l + Math.imul(Ae, O) | 0, R = Math.imul(Ae, ae), _ = _ + Math.imul(Ve, xe) | 0, l = l + Math.imul(Ve, Re) | 0, l = l + Math.imul(ke, xe) | 0, R = R + Math.imul(ke, Re) | 0, _ = _ + Math.imul(fe, ze) | 0, l = l + Math.imul(fe, Ue) | 0, l = l + Math.imul(_e, ze) | 0, R = R + Math.imul(_e, Ue) | 0;
        var Pe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, _ = Math.imul(Se, xe), l = Math.imul(Se, Re), l = l + Math.imul(Ae, xe) | 0, R = Math.imul(Ae, Re), _ = _ + Math.imul(Ve, ze) | 0, l = l + Math.imul(Ve, Ue) | 0, l = l + Math.imul(ke, ze) | 0, R = R + Math.imul(ke, Ue) | 0;
        var Ke = (y + _ | 0) + ((l & 8191) << 13) | 0;
        y = (R + (l >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, _ = Math.imul(Se, ze), l = Math.imul(Se, Ue), l = l + Math.imul(Ae, ze) | 0, R = Math.imul(Ae, Ue);
        var Fe = (y + _ | 0) + ((l & 8191) << 13) | 0;
        return y = (R + (l >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, S[0] = mt, S[1] = et, S[2] = ut, S[3] = ct, S[4] = vt, S[5] = pt, S[6] = ht, S[7] = dt, S[8] = lt, S[9] = tt, S[10] = ot, S[11] = Qe, S[12] = rt, S[13] = it, S[14] = Ye, S[15] = Oe, S[16] = Pe, S[17] = Ke, S[18] = Fe, y !== 0 && (S[19] = y, w.length++), w;
      };
      Math.imul || (T = B);
      function k(b, a, d) {
        d.negative = a.negative ^ b.negative, d.length = b.length + a.length;
        for (var w = 0, x = 0, A = 0; A < d.length - 1; A++) {
          var S = x;
          x = 0;
          for (var y = w & 67108863, _ = Math.min(A, a.length - 1), l = Math.max(0, A - b.length + 1); l <= _; l++) {
            var R = A - l, ee = b.words[R] | 0, oe = a.words[l] | 0, V = ee * oe, W = V & 67108863;
            S = S + (V / 67108864 | 0) | 0, W = W + y | 0, y = W & 67108863, S = S + (W >>> 26) | 0, x += S >>> 26, S &= 67108863;
          }
          d.words[A] = y, w = S, S = x;
        }
        return w !== 0 ? d.words[A] = w : d.length--, d._strip();
      }
      function N(b, a, d) {
        return k(b, a, d);
      }
      n.prototype.mulTo = function(a, d) {
        var w, x = this.length + a.length;
        return this.length === 10 && a.length === 10 ? w = T(this, a, d) : x < 63 ? w = B(this, a, d) : x < 1024 ? w = k(this, a, d) : w = N(this, a, d), w;
      }, n.prototype.mul = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), this.mulTo(a, d);
      }, n.prototype.mulf = function(a) {
        var d = new n(null);
        return d.words = new Array(this.length + a.length), N(this, a, d);
      }, n.prototype.imul = function(a) {
        return this.clone().mulTo(a, this);
      }, n.prototype.imuln = function(a) {
        var d = a < 0;
        d && (a = -a), i(typeof a == "number"), i(a < 67108864);
        for (var w = 0, x = 0; x < this.length; x++) {
          var A = (this.words[x] | 0) * a, S = (A & 67108863) + (w & 67108863);
          w >>= 26, w += A / 67108864 | 0, w += S >>> 26, this.words[x] = S & 67108863;
        }
        return w !== 0 && (this.words[x] = w, this.length++), d ? this.ineg() : this;
      }, n.prototype.muln = function(a) {
        return this.clone().imuln(a);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(a) {
        var d = I(a);
        if (d.length === 0)
          return new n(1);
        for (var w = this, x = 0; x < d.length && d[x] === 0; x++, w = w.sqr())
          ;
        if (++x < d.length)
          for (var A = w.sqr(); x < d.length; x++, A = A.sqr())
            d[x] !== 0 && (w = w.mul(A));
        return w;
      }, n.prototype.iushln = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 67108863 >>> 26 - d << 26 - d, A;
        if (d !== 0) {
          var S = 0;
          for (A = 0; A < this.length; A++) {
            var y = this.words[A] & x, _ = (this.words[A] | 0) - y << d;
            this.words[A] = _ | S, S = y >>> 26 - d;
          }
          S && (this.words[A] = S, this.length++);
        }
        if (w !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + w] = this.words[A];
          for (A = 0; A < w; A++)
            this.words[A] = 0;
          this.length += w;
        }
        return this._strip();
      }, n.prototype.ishln = function(a) {
        return i(this.negative === 0), this.iushln(a);
      }, n.prototype.iushrn = function(a, d, w) {
        i(typeof a == "number" && a >= 0);
        var x;
        d ? x = (d - d % 26) / 26 : x = 0;
        var A = a % 26, S = Math.min((a - A) / 26, this.length), y = 67108863 ^ 67108863 >>> A << A, _ = w;
        if (x -= S, x = Math.max(0, x), _) {
          for (var l = 0; l < S; l++)
            _.words[l] = this.words[l];
          _.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, l = 0; l < this.length; l++)
              this.words[l] = this.words[l + S];
          else
            this.words[0] = 0, this.length = 1;
        var R = 0;
        for (l = this.length - 1; l >= 0 && (R !== 0 || l >= x); l--) {
          var ee = this.words[l] | 0;
          this.words[l] = R << 26 - A | ee >>> A, R = ee & y;
        }
        return _ && R !== 0 && (_.words[_.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(a, d, w) {
        return i(this.negative === 0), this.iushrn(a, d, w);
      }, n.prototype.shln = function(a) {
        return this.clone().ishln(a);
      }, n.prototype.ushln = function(a) {
        return this.clone().iushln(a);
      }, n.prototype.shrn = function(a) {
        return this.clone().ishrn(a);
      }, n.prototype.ushrn = function(a) {
        return this.clone().iushrn(a);
      }, n.prototype.testn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return !1;
        var A = this.words[w];
        return !!(A & x);
      }, n.prototype.imaskn = function(a) {
        i(typeof a == "number" && a >= 0);
        var d = a % 26, w = (a - d) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w)
          return this;
        if (d !== 0 && w++, this.length = Math.min(w, this.length), d !== 0) {
          var x = 67108863 ^ 67108863 >>> d << d;
          this.words[this.length - 1] &= x;
        }
        return this._strip();
      }, n.prototype.maskn = function(a) {
        return this.clone().imaskn(a);
      }, n.prototype.iaddn = function(a) {
        return i(typeof a == "number"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
      }, n.prototype._iaddn = function(a) {
        this.words[0] += a;
        for (var d = 0; d < this.length && this.words[d] >= 67108864; d++)
          this.words[d] -= 67108864, d === this.length - 1 ? this.words[d + 1] = 1 : this.words[d + 1]++;
        return this.length = Math.max(this.length, d + 1), this;
      }, n.prototype.isubn = function(a) {
        if (i(typeof a == "number"), i(a < 67108864), a < 0)
          return this.iaddn(-a);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(a), this.negative = 1, this;
        if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var d = 0; d < this.length && this.words[d] < 0; d++)
            this.words[d] += 67108864, this.words[d + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(a) {
        return this.clone().iaddn(a);
      }, n.prototype.subn = function(a) {
        return this.clone().isubn(a);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(a, d, w) {
        var x = a.length + w, A;
        this._expand(x);
        var S, y = 0;
        for (A = 0; A < a.length; A++) {
          S = (this.words[A + w] | 0) + y;
          var _ = (a.words[A] | 0) * d;
          S -= _ & 67108863, y = (S >> 26) - (_ / 67108864 | 0), this.words[A + w] = S & 67108863;
        }
        for (; A < this.length - w; A++)
          S = (this.words[A + w] | 0) + y, y = S >> 26, this.words[A + w] = S & 67108863;
        if (y === 0)
          return this._strip();
        for (i(y === -1), y = 0, A = 0; A < this.length; A++)
          S = -(this.words[A] | 0) + y, y = S >> 26, this.words[A] = S & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(a, d) {
        var w = this.length - a.length, x = this.clone(), A = a, S = A.words[A.length - 1] | 0, y = this._countBits(S);
        w = 26 - y, w !== 0 && (A = A.ushln(w), x.iushln(w), S = A.words[A.length - 1] | 0);
        var _ = x.length - A.length, l;
        if (d !== "mod") {
          l = new n(null), l.length = _ + 1, l.words = new Array(l.length);
          for (var R = 0; R < l.length; R++)
            l.words[R] = 0;
        }
        var ee = x.clone()._ishlnsubmul(A, 1, _);
        ee.negative === 0 && (x = ee, l && (l.words[_] = 1));
        for (var oe = _ - 1; oe >= 0; oe--) {
          var V = (x.words[A.length + oe] | 0) * 67108864 + (x.words[A.length + oe - 1] | 0);
          for (V = Math.min(V / S | 0, 67108863), x._ishlnsubmul(A, V, oe); x.negative !== 0; )
            V--, x.negative = 0, x._ishlnsubmul(A, 1, oe), x.isZero() || (x.negative ^= 1);
          l && (l.words[oe] = V);
        }
        return l && l._strip(), x._strip(), d !== "div" && w !== 0 && x.iushrn(w), {
          div: l || null,
          mod: x
        };
      }, n.prototype.divmod = function(a, d, w) {
        if (i(!a.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var x, A, S;
        return this.negative !== 0 && a.negative === 0 ? (S = this.neg().divmod(a, d), d !== "mod" && (x = S.div.neg()), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.iadd(a)), {
          div: x,
          mod: A
        }) : this.negative === 0 && a.negative !== 0 ? (S = this.divmod(a.neg(), d), d !== "mod" && (x = S.div.neg()), {
          div: x,
          mod: S.mod
        }) : this.negative & a.negative ? (S = this.neg().divmod(a.neg(), d), d !== "div" && (A = S.mod.neg(), w && A.negative !== 0 && A.isub(a)), {
          div: S.div,
          mod: A
        }) : a.length > this.length || this.cmp(a) < 0 ? {
          div: new n(0),
          mod: this
        } : a.length === 1 ? d === "div" ? {
          div: this.divn(a.words[0]),
          mod: null
        } : d === "mod" ? {
          div: null,
          mod: new n(this.modrn(a.words[0]))
        } : {
          div: this.divn(a.words[0]),
          mod: new n(this.modrn(a.words[0]))
        } : this._wordDiv(a, d);
      }, n.prototype.div = function(a) {
        return this.divmod(a, "div", !1).div;
      }, n.prototype.mod = function(a) {
        return this.divmod(a, "mod", !1).mod;
      }, n.prototype.umod = function(a) {
        return this.divmod(a, "mod", !0).mod;
      }, n.prototype.divRound = function(a) {
        var d = this.divmod(a);
        if (d.mod.isZero())
          return d.div;
        var w = d.div.negative !== 0 ? d.mod.isub(a) : d.mod, x = a.ushrn(1), A = a.andln(1), S = w.cmp(x);
        return S < 0 || A === 1 && S === 0 ? d.div : d.div.negative !== 0 ? d.div.isubn(1) : d.div.iaddn(1);
      }, n.prototype.modrn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = (1 << 26) % a, x = 0, A = this.length - 1; A >= 0; A--)
          x = (w * x + (this.words[A] | 0)) % a;
        return d ? -x : x;
      }, n.prototype.modn = function(a) {
        return this.modrn(a);
      }, n.prototype.idivn = function(a) {
        var d = a < 0;
        d && (a = -a), i(a <= 67108863);
        for (var w = 0, x = this.length - 1; x >= 0; x--) {
          var A = (this.words[x] | 0) + w * 67108864;
          this.words[x] = A / a | 0, w = A % a;
        }
        return this._strip(), d ? this.ineg() : this;
      }, n.prototype.divn = function(a) {
        return this.clone().idivn(a);
      }, n.prototype.egcd = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = new n(0), y = new n(1), _ = 0; d.isEven() && w.isEven(); )
          d.iushrn(1), w.iushrn(1), ++_;
        for (var l = w.clone(), R = d.clone(); !d.isZero(); ) {
          for (var ee = 0, oe = 1; !(d.words[0] & oe) && ee < 26; ++ee, oe <<= 1)
            ;
          if (ee > 0)
            for (d.iushrn(ee); ee-- > 0; )
              (x.isOdd() || A.isOdd()) && (x.iadd(l), A.isub(R)), x.iushrn(1), A.iushrn(1);
          for (var V = 0, W = 1; !(w.words[0] & W) && V < 26; ++V, W <<= 1)
            ;
          if (V > 0)
            for (w.iushrn(V); V-- > 0; )
              (S.isOdd() || y.isOdd()) && (S.iadd(l), y.isub(R)), S.iushrn(1), y.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(S), A.isub(y)) : (w.isub(d), S.isub(x), y.isub(A));
        }
        return {
          a: S,
          b: y,
          gcd: w.iushln(_)
        };
      }, n.prototype._invmp = function(a) {
        i(a.negative === 0), i(!a.isZero());
        var d = this, w = a.clone();
        d.negative !== 0 ? d = d.umod(a) : d = d.clone();
        for (var x = new n(1), A = new n(0), S = w.clone(); d.cmpn(1) > 0 && w.cmpn(1) > 0; ) {
          for (var y = 0, _ = 1; !(d.words[0] & _) && y < 26; ++y, _ <<= 1)
            ;
          if (y > 0)
            for (d.iushrn(y); y-- > 0; )
              x.isOdd() && x.iadd(S), x.iushrn(1);
          for (var l = 0, R = 1; !(w.words[0] & R) && l < 26; ++l, R <<= 1)
            ;
          if (l > 0)
            for (w.iushrn(l); l-- > 0; )
              A.isOdd() && A.iadd(S), A.iushrn(1);
          d.cmp(w) >= 0 ? (d.isub(w), x.isub(A)) : (w.isub(d), A.isub(x));
        }
        var ee;
        return d.cmpn(1) === 0 ? ee = x : ee = A, ee.cmpn(0) < 0 && ee.iadd(a), ee;
      }, n.prototype.gcd = function(a) {
        if (this.isZero())
          return a.abs();
        if (a.isZero())
          return this.abs();
        var d = this.clone(), w = a.clone();
        d.negative = 0, w.negative = 0;
        for (var x = 0; d.isEven() && w.isEven(); x++)
          d.iushrn(1), w.iushrn(1);
        do {
          for (; d.isEven(); )
            d.iushrn(1);
          for (; w.isEven(); )
            w.iushrn(1);
          var A = d.cmp(w);
          if (A < 0) {
            var S = d;
            d = w, w = S;
          } else if (A === 0 || w.cmpn(1) === 0)
            break;
          d.isub(w);
        } while (!0);
        return w.iushln(x);
      }, n.prototype.invm = function(a) {
        return this.egcd(a).a.umod(a);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(a) {
        return this.words[0] & a;
      }, n.prototype.bincn = function(a) {
        i(typeof a == "number");
        var d = a % 26, w = (a - d) / 26, x = 1 << d;
        if (this.length <= w)
          return this._expand(w + 1), this.words[w] |= x, this;
        for (var A = x, S = w; A !== 0 && S < this.length; S++) {
          var y = this.words[S] | 0;
          y += A, A = y >>> 26, y &= 67108863, this.words[S] = y;
        }
        return A !== 0 && (this.words[S] = A, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(a) {
        var d = a < 0;
        if (this.negative !== 0 && !d)
          return -1;
        if (this.negative === 0 && d)
          return 1;
        this._strip();
        var w;
        if (this.length > 1)
          w = 1;
        else {
          d && (a = -a), i(a <= 67108863, "Number is too big");
          var x = this.words[0] | 0;
          w = x === a ? 0 : x < a ? -1 : 1;
        }
        return this.negative !== 0 ? -w | 0 : w;
      }, n.prototype.cmp = function(a) {
        if (this.negative !== 0 && a.negative === 0)
          return -1;
        if (this.negative === 0 && a.negative !== 0)
          return 1;
        var d = this.ucmp(a);
        return this.negative !== 0 ? -d | 0 : d;
      }, n.prototype.ucmp = function(a) {
        if (this.length > a.length)
          return 1;
        if (this.length < a.length)
          return -1;
        for (var d = 0, w = this.length - 1; w >= 0; w--) {
          var x = this.words[w] | 0, A = a.words[w] | 0;
          if (x !== A) {
            x < A ? d = -1 : x > A && (d = 1);
            break;
          }
        }
        return d;
      }, n.prototype.gtn = function(a) {
        return this.cmpn(a) === 1;
      }, n.prototype.gt = function(a) {
        return this.cmp(a) === 1;
      }, n.prototype.gten = function(a) {
        return this.cmpn(a) >= 0;
      }, n.prototype.gte = function(a) {
        return this.cmp(a) >= 0;
      }, n.prototype.ltn = function(a) {
        return this.cmpn(a) === -1;
      }, n.prototype.lt = function(a) {
        return this.cmp(a) === -1;
      }, n.prototype.lten = function(a) {
        return this.cmpn(a) <= 0;
      }, n.prototype.lte = function(a) {
        return this.cmp(a) <= 0;
      }, n.prototype.eqn = function(a) {
        return this.cmpn(a) === 0;
      }, n.prototype.eq = function(a) {
        return this.cmp(a) === 0;
      }, n.red = function(a) {
        return new j(a);
      }, n.prototype.toRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
      }, n.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(a) {
        return this.red = a, this;
      }, n.prototype.forceRed = function(a) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(a);
      }, n.prototype.redAdd = function(a) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
      }, n.prototype.redIAdd = function(a) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
      }, n.prototype.redSub = function(a) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
      }, n.prototype.redISub = function(a) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
      }, n.prototype.redShl = function(a) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
      }, n.prototype.redMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
      }, n.prototype.redIMul = function(a) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
      }, n.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(a) {
        return i(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
      };
      var q = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function D(b, a) {
        this.name = b, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      D.prototype._tmp = function() {
        var a = new n(null);
        return a.words = new Array(Math.ceil(this.n / 13)), a;
      }, D.prototype.ireduce = function(a) {
        var d = a, w;
        do
          this.split(d, this.tmp), d = this.imulK(d), d = d.iadd(this.tmp), w = d.bitLength();
        while (w > this.n);
        var x = w < this.n ? -1 : d.ucmp(this.p);
        return x === 0 ? (d.words[0] = 0, d.length = 1) : x > 0 ? d.isub(this.p) : d.strip !== void 0 ? d.strip() : d._strip(), d;
      }, D.prototype.split = function(a, d) {
        a.iushrn(this.n, 0, d);
      }, D.prototype.imulK = function(a) {
        return a.imul(this.k);
      };
      function U() {
        D.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      o(U, D), U.prototype.split = function(a, d) {
        for (var w = 4194303, x = Math.min(a.length, 9), A = 0; A < x; A++)
          d.words[A] = a.words[A];
        if (d.length = x, a.length <= 9) {
          a.words[0] = 0, a.length = 1;
          return;
        }
        var S = a.words[9];
        for (d.words[d.length++] = S & w, A = 10; A < a.length; A++) {
          var y = a.words[A] | 0;
          a.words[A - 10] = (y & w) << 4 | S >>> 22, S = y;
        }
        S >>>= 22, a.words[A - 10] = S, S === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
      }, U.prototype.imulK = function(a) {
        a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = a.words[w] | 0;
          d += x * 977, a.words[w] = d & 67108863, d = x * 64 + (d / 67108864 | 0);
        }
        return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
      };
      function z() {
        D.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      o(z, D);
      function Y() {
        D.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      o(Y, D);
      function ue() {
        D.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      o(ue, D), ue.prototype.imulK = function(a) {
        for (var d = 0, w = 0; w < a.length; w++) {
          var x = (a.words[w] | 0) * 19 + d, A = x & 67108863;
          x >>>= 26, a.words[w] = A, d = x;
        }
        return d !== 0 && (a.words[a.length++] = d), a;
      }, n._prime = function(a) {
        if (q[a])
          return q[a];
        var d;
        if (a === "k256")
          d = new U();
        else if (a === "p224")
          d = new z();
        else if (a === "p192")
          d = new Y();
        else if (a === "p25519")
          d = new ue();
        else
          throw new Error("Unknown prime " + a);
        return q[a] = d, d;
      };
      function j(b) {
        if (typeof b == "string") {
          var a = n._prime(b);
          this.m = a.p, this.prime = a;
        } else
          i(b.gtn(1), "modulus must be greater than 1"), this.m = b, this.prime = null;
      }
      j.prototype._verify1 = function(a) {
        i(a.negative === 0, "red works only with positives"), i(a.red, "red works only with red numbers");
      }, j.prototype._verify2 = function(a, d) {
        i((a.negative | d.negative) === 0, "red works only with positives"), i(
          a.red && a.red === d.red,
          "red works only with red numbers"
        );
      }, j.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : (s(a, a.umod(this.m)._forceRed(this)), a);
      }, j.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      }, j.prototype.add = function(a, d) {
        this._verify2(a, d);
        var w = a.add(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
      }, j.prototype.iadd = function(a, d) {
        this._verify2(a, d);
        var w = a.iadd(d);
        return w.cmp(this.m) >= 0 && w.isub(this.m), w;
      }, j.prototype.sub = function(a, d) {
        this._verify2(a, d);
        var w = a.sub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
      }, j.prototype.isub = function(a, d) {
        this._verify2(a, d);
        var w = a.isub(d);
        return w.cmpn(0) < 0 && w.iadd(this.m), w;
      }, j.prototype.shl = function(a, d) {
        return this._verify1(a), this.imod(a.ushln(d));
      }, j.prototype.imul = function(a, d) {
        return this._verify2(a, d), this.imod(a.imul(d));
      }, j.prototype.mul = function(a, d) {
        return this._verify2(a, d), this.imod(a.mul(d));
      }, j.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      }, j.prototype.sqr = function(a) {
        return this.mul(a, a);
      }, j.prototype.sqrt = function(a) {
        if (a.isZero())
          return a.clone();
        var d = this.m.andln(3);
        if (i(d % 2 === 1), d === 3) {
          var w = this.m.add(new n(1)).iushrn(2);
          return this.pow(a, w);
        }
        for (var x = this.m.subn(1), A = 0; !x.isZero() && x.andln(1) === 0; )
          A++, x.iushrn(1);
        i(!x.isZero());
        var S = new n(1).toRed(this), y = S.redNeg(), _ = this.m.subn(1).iushrn(1), l = this.m.bitLength();
        for (l = new n(2 * l * l).toRed(this); this.pow(l, _).cmp(y) !== 0; )
          l.redIAdd(y);
        for (var R = this.pow(l, x), ee = this.pow(a, x.addn(1).iushrn(1)), oe = this.pow(a, x), V = A; oe.cmp(S) !== 0; ) {
          for (var W = oe, F = 0; W.cmp(S) !== 0; F++)
            W = W.redSqr();
          i(F < V);
          var re = this.pow(R, new n(1).iushln(V - F - 1));
          ee = ee.redMul(re), R = re.redSqr(), oe = oe.redMul(R), V = F;
        }
        return ee;
      }, j.prototype.invm = function(a) {
        var d = a._invmp(this.m);
        return d.negative !== 0 ? (d.negative = 0, this.imod(d).redNeg()) : this.imod(d);
      }, j.prototype.pow = function(a, d) {
        if (d.isZero())
          return new n(1).toRed(this);
        if (d.cmpn(1) === 0)
          return a.clone();
        var w = 4, x = new Array(1 << w);
        x[0] = new n(1).toRed(this), x[1] = a;
        for (var A = 2; A < x.length; A++)
          x[A] = this.mul(x[A - 1], a);
        var S = x[0], y = 0, _ = 0, l = d.bitLength() % 26;
        for (l === 0 && (l = 26), A = d.length - 1; A >= 0; A--) {
          for (var R = d.words[A], ee = l - 1; ee >= 0; ee--) {
            var oe = R >> ee & 1;
            if (S !== x[0] && (S = this.sqr(S)), oe === 0 && y === 0) {
              _ = 0;
              continue;
            }
            y <<= 1, y |= oe, _++, !(_ !== w && (A !== 0 || ee !== 0)) && (S = this.mul(S, x[y]), _ = 0, y = 0);
          }
          l = 26;
        }
        return S;
      }, j.prototype.convertTo = function(a) {
        var d = a.umod(this.m);
        return d === a ? d.clone() : d;
      }, j.prototype.convertFrom = function(a) {
        var d = a.clone();
        return d.red = null, d;
      }, n.mont = function(a) {
        return new g(a);
      };
      function g(b) {
        j.call(this, b), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(g, j), g.prototype.convertTo = function(a) {
        return this.imod(a.ushln(this.shift));
      }, g.prototype.convertFrom = function(a) {
        var d = this.imod(a.mul(this.rinv));
        return d.red = null, d;
      }, g.prototype.imul = function(a, d) {
        if (a.isZero() || d.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var w = a.imul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, g.prototype.mul = function(a, d) {
        if (a.isZero() || d.isZero())
          return new n(0)._forceRed(this);
        var w = a.mul(d), x = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = w.isub(x).iushrn(this.shift), S = A;
        return A.cmp(this.m) >= 0 ? S = A.isub(this.m) : A.cmpn(0) < 0 && (S = A.iadd(this.m)), S._forceRed(this);
      }, g.prototype.invm = function(a) {
        var d = this.imod(a._invmp(this.m).mul(this.r2));
        return d._forceRed(this);
      };
    })(e, Ze);
  }(so)), so.exports;
}
var Nr = {}, pc = {}, vc = {}, bc = {}, yc, Xp;
function A0() {
  if (Xp)
    return yc;
  Xp = 1;
  var e = Le, t = e.Buffer, r = {}, i;
  for (i in e)
    e.hasOwnProperty(i) && (i === "SlowBuffer" || i === "Buffer" || (r[i] = e[i]));
  var o = r.Buffer = {};
  for (i in t)
    t.hasOwnProperty(i) && (i === "allocUnsafe" || i === "allocUnsafeSlow" || (o[i] = t[i]));
  if (r.Buffer.prototype = t.prototype, (!o.from || o.from === Uint8Array.from) && (o.from = function(n, f, u) {
    if (typeof n == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof n);
    if (n && typeof n.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n);
    return t(n, f, u);
  }), o.alloc || (o.alloc = function(n, f, u) {
    if (typeof n != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof n);
    if (n < 0 || n >= 2 * (1 << 30))
      throw new RangeError('The value "' + n + '" is invalid for option "size"');
    var c = t(n);
    return !f || f.length === 0 ? c.fill(0) : typeof u == "string" ? c.fill(f, u) : c.fill(f), c;
  }), !r.kStringMaxLength)
    try {
      r.kStringMaxLength = at.binding("buffer").kStringMaxLength;
    } catch {
    }
  return r.constants || (r.constants = {
    MAX_LENGTH: r.kMaxLength
  }, r.kStringMaxLength && (r.constants.MAX_STRING_LENGTH = r.kStringMaxLength)), yc = r, yc;
}
var gc = {}, Yp;
function M0() {
  if (Yp)
    return gc;
  Yp = 1;
  const e = Et();
  function t(i) {
    this._reporterState = {
      obj: null,
      path: [],
      options: i || {},
      errors: []
    };
  }
  gc.Reporter = t, t.prototype.isError = function(o) {
    return o instanceof r;
  }, t.prototype.save = function() {
    const o = this._reporterState;
    return { obj: o.obj, pathLen: o.path.length };
  }, t.prototype.restore = function(o) {
    const n = this._reporterState;
    n.obj = o.obj, n.path = n.path.slice(0, o.pathLen);
  }, t.prototype.enterKey = function(o) {
    return this._reporterState.path.push(o);
  }, t.prototype.exitKey = function(o) {
    const n = this._reporterState;
    n.path = n.path.slice(0, o - 1);
  }, t.prototype.leaveKey = function(o, n, f) {
    const u = this._reporterState;
    this.exitKey(o), u.obj !== null && (u.obj[n] = f);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    const o = this._reporterState, n = o.obj;
    return o.obj = {}, n;
  }, t.prototype.leaveObject = function(o) {
    const n = this._reporterState, f = n.obj;
    return n.obj = o, f;
  }, t.prototype.error = function(o) {
    let n;
    const f = this._reporterState, u = o instanceof r;
    if (u ? n = o : n = new r(f.path.map(function(c) {
      return "[" + JSON.stringify(c) + "]";
    }).join(""), o.message || o, o.stack), !f.options.partial)
      throw n;
    return u || f.errors.push(n), n;
  }, t.prototype.wrapResult = function(o) {
    const n = this._reporterState;
    return n.options.partial ? {
      result: this.isError(o) ? null : o,
      errors: n.errors
    } : o;
  };
  function r(i, o) {
    this.path = i, this.rethrow(o);
  }
  return e(r, Error), r.prototype.rethrow = function(o) {
    if (this.message = o + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, r), !this.stack)
      try {
        throw new Error(this.message);
      } catch (n) {
        this.stack = n.stack;
      }
    return this;
  }, gc;
}
var ro = {}, Qp;
function ba() {
  if (Qp)
    return ro;
  Qp = 1;
  const e = Et(), t = M0().Reporter, r = A0().Buffer;
  function i(n, f) {
    if (t.call(this, f), !r.isBuffer(n)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = n, this.offset = 0, this.length = n.length;
  }
  e(i, t), ro.DecoderBuffer = i, i.isDecoderBuffer = function(f) {
    return f instanceof i ? !0 : typeof f == "object" && r.isBuffer(f.base) && f.constructor.name === "DecoderBuffer" && typeof f.offset == "number" && typeof f.length == "number" && typeof f.save == "function" && typeof f.restore == "function" && typeof f.isEmpty == "function" && typeof f.readUInt8 == "function" && typeof f.skip == "function" && typeof f.raw == "function";
  }, i.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, i.prototype.restore = function(f) {
    const u = new i(this.base);
    return u.offset = f.offset, u.length = this.offset, this.offset = f.offset, t.prototype.restore.call(this, f.reporter), u;
  }, i.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, i.prototype.readUInt8 = function(f) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(f || "DecoderBuffer overrun");
  }, i.prototype.skip = function(f, u) {
    if (!(this.offset + f <= this.length))
      return this.error(u || "DecoderBuffer overrun");
    const c = new i(this.base);
    return c._reporterState = this._reporterState, c.offset = this.offset, c.length = this.offset + f, this.offset += f, c;
  }, i.prototype.raw = function(f) {
    return this.base.slice(f ? f.offset : this.offset, this.length);
  };
  function o(n, f) {
    if (Array.isArray(n))
      this.length = 0, this.value = n.map(function(u) {
        return o.isEncoderBuffer(u) || (u = new o(u, f)), this.length += u.length, u;
      }, this);
    else if (typeof n == "number") {
      if (!(0 <= n && n <= 255))
        return f.error("non-byte EncoderBuffer value");
      this.value = n, this.length = 1;
    } else if (typeof n == "string")
      this.value = n, this.length = r.byteLength(n);
    else if (r.isBuffer(n))
      this.value = n, this.length = n.length;
    else
      return f.error("Unsupported type: " + typeof n);
  }
  return ro.EncoderBuffer = o, o.isEncoderBuffer = function(f) {
    return f instanceof o ? !0 : typeof f == "object" && f.constructor.name === "EncoderBuffer" && typeof f.length == "number" && typeof f.join == "function";
  }, o.prototype.join = function(f, u) {
    return f || (f = r.alloc(this.length)), u || (u = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(c) {
      c.join(f, u), u += c.length;
    }) : (typeof this.value == "number" ? f[u] = this.value : typeof this.value == "string" ? f.write(this.value, u) : r.isBuffer(this.value) && this.value.copy(f, u), u += this.length)), f;
  }, ro;
}
var mc, ev;
function R0() {
  if (ev)
    return mc;
  ev = 1;
  const e = M0().Reporter, t = ba().EncoderBuffer, r = ba().DecoderBuffer, i = Hr(), o = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], n = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(o), f = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function u(h, s, p) {
    const v = {};
    this._baseState = v, v.name = p, v.enc = h, v.parent = s || null, v.children = null, v.tag = null, v.args = null, v.reverseArgs = null, v.choice = null, v.optional = !1, v.any = !1, v.obj = !1, v.use = null, v.useDecoder = null, v.key = null, v.default = null, v.explicit = null, v.implicit = null, v.contains = null, v.parent || (v.children = [], this._wrap());
  }
  mc = u;
  const c = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return u.prototype.clone = function() {
    const s = this._baseState, p = {};
    c.forEach(function(m) {
      p[m] = s[m];
    });
    const v = new this.constructor(p.parent);
    return v._baseState = p, v;
  }, u.prototype._wrap = function() {
    const s = this._baseState;
    n.forEach(function(p) {
      this[p] = function() {
        const m = new this.constructor(this);
        return s.children.push(m), m[p].apply(m, arguments);
      };
    }, this);
  }, u.prototype._init = function(s) {
    const p = this._baseState;
    i(p.parent === null), s.call(this), p.children = p.children.filter(function(v) {
      return v._baseState.parent === this;
    }, this), i.equal(p.children.length, 1, "Root node can have only one child");
  }, u.prototype._useArgs = function(s) {
    const p = this._baseState, v = s.filter(function(m) {
      return m instanceof this.constructor;
    }, this);
    s = s.filter(function(m) {
      return !(m instanceof this.constructor);
    }, this), v.length !== 0 && (i(p.children === null), p.children = v, v.forEach(function(m) {
      m._baseState.parent = this;
    }, this)), s.length !== 0 && (i(p.args === null), p.args = s, p.reverseArgs = s.map(function(m) {
      if (typeof m != "object" || m.constructor !== Object)
        return m;
      const E = {};
      return Object.keys(m).forEach(function(M) {
        M == (M | 0) && (M |= 0);
        const I = m[M];
        E[I] = M;
      }), E;
    }));
  }, f.forEach(function(h) {
    u.prototype[h] = function() {
      const p = this._baseState;
      throw new Error(h + " not implemented for encoding: " + p.enc);
    };
  }), o.forEach(function(h) {
    u.prototype[h] = function() {
      const p = this._baseState, v = Array.prototype.slice.call(arguments);
      return i(p.tag === null), p.tag = h, this._useArgs(v), this;
    };
  }), u.prototype.use = function(s) {
    i(s);
    const p = this._baseState;
    return i(p.use === null), p.use = s, this;
  }, u.prototype.optional = function() {
    const s = this._baseState;
    return s.optional = !0, this;
  }, u.prototype.def = function(s) {
    const p = this._baseState;
    return i(p.default === null), p.default = s, p.optional = !0, this;
  }, u.prototype.explicit = function(s) {
    const p = this._baseState;
    return i(p.explicit === null && p.implicit === null), p.explicit = s, this;
  }, u.prototype.implicit = function(s) {
    const p = this._baseState;
    return i(p.explicit === null && p.implicit === null), p.implicit = s, this;
  }, u.prototype.obj = function() {
    const s = this._baseState, p = Array.prototype.slice.call(arguments);
    return s.obj = !0, p.length !== 0 && this._useArgs(p), this;
  }, u.prototype.key = function(s) {
    const p = this._baseState;
    return i(p.key === null), p.key = s, this;
  }, u.prototype.any = function() {
    const s = this._baseState;
    return s.any = !0, this;
  }, u.prototype.choice = function(s) {
    const p = this._baseState;
    return i(p.choice === null), p.choice = s, this._useArgs(Object.keys(s).map(function(v) {
      return s[v];
    })), this;
  }, u.prototype.contains = function(s) {
    const p = this._baseState;
    return i(p.use === null), p.contains = s, this;
  }, u.prototype._decode = function(s, p) {
    const v = this._baseState;
    if (v.parent === null)
      return s.wrapResult(v.children[0]._decode(s, p));
    let m = v.default, E = !0, M = null;
    if (v.key !== null && (M = s.enterKey(v.key)), v.optional) {
      let B = null;
      if (v.explicit !== null ? B = v.explicit : v.implicit !== null ? B = v.implicit : v.tag !== null && (B = v.tag), B === null && !v.any) {
        const T = s.save();
        try {
          v.choice === null ? this._decodeGeneric(v.tag, s, p) : this._decodeChoice(s, p), E = !0;
        } catch {
          E = !1;
        }
        s.restore(T);
      } else if (E = this._peekTag(s, B, v.any), s.isError(E))
        return E;
    }
    let I;
    if (v.obj && E && (I = s.enterObject()), E) {
      if (v.explicit !== null) {
        const T = this._decodeTag(s, v.explicit);
        if (s.isError(T))
          return T;
        s = T;
      }
      const B = s.offset;
      if (v.use === null && v.choice === null) {
        let T;
        v.any && (T = s.save());
        const k = this._decodeTag(
          s,
          v.implicit !== null ? v.implicit : v.tag,
          v.any
        );
        if (s.isError(k))
          return k;
        v.any ? m = s.raw(T) : s = k;
      }
      if (p && p.track && v.tag !== null && p.track(s.path(), B, s.length, "tagged"), p && p.track && v.tag !== null && p.track(s.path(), s.offset, s.length, "content"), v.any || (v.choice === null ? m = this._decodeGeneric(v.tag, s, p) : m = this._decodeChoice(s, p)), s.isError(m))
        return m;
      if (!v.any && v.choice === null && v.children !== null && v.children.forEach(function(k) {
        k._decode(s, p);
      }), v.contains && (v.tag === "octstr" || v.tag === "bitstr")) {
        const T = new r(m);
        m = this._getUse(v.contains, s._reporterState.obj)._decode(T, p);
      }
    }
    return v.obj && E && (m = s.leaveObject(I)), v.key !== null && (m !== null || E === !0) ? s.leaveKey(M, v.key, m) : M !== null && s.exitKey(M), m;
  }, u.prototype._decodeGeneric = function(s, p, v) {
    const m = this._baseState;
    return s === "seq" || s === "set" ? null : s === "seqof" || s === "setof" ? this._decodeList(p, s, m.args[0], v) : /str$/.test(s) ? this._decodeStr(p, s, v) : s === "objid" && m.args ? this._decodeObjid(p, m.args[0], m.args[1], v) : s === "objid" ? this._decodeObjid(p, null, null, v) : s === "gentime" || s === "utctime" ? this._decodeTime(p, s, v) : s === "null_" ? this._decodeNull(p, v) : s === "bool" ? this._decodeBool(p, v) : s === "objDesc" ? this._decodeStr(p, s, v) : s === "int" || s === "enum" ? this._decodeInt(p, m.args && m.args[0], v) : m.use !== null ? this._getUse(m.use, p._reporterState.obj)._decode(p, v) : p.error("unknown tag: " + s);
  }, u.prototype._getUse = function(s, p) {
    const v = this._baseState;
    return v.useDecoder = this._use(s, p), i(v.useDecoder._baseState.parent === null), v.useDecoder = v.useDecoder._baseState.children[0], v.implicit !== v.useDecoder._baseState.implicit && (v.useDecoder = v.useDecoder.clone(), v.useDecoder._baseState.implicit = v.implicit), v.useDecoder;
  }, u.prototype._decodeChoice = function(s, p) {
    const v = this._baseState;
    let m = null, E = !1;
    return Object.keys(v.choice).some(function(M) {
      const I = s.save(), B = v.choice[M];
      try {
        const T = B._decode(s, p);
        if (s.isError(T))
          return !1;
        m = { type: M, value: T }, E = !0;
      } catch {
        return s.restore(I), !1;
      }
      return !0;
    }, this), E ? m : s.error("Choice not matched");
  }, u.prototype._createEncoderBuffer = function(s) {
    return new t(s, this.reporter);
  }, u.prototype._encode = function(s, p, v) {
    const m = this._baseState;
    if (m.default !== null && m.default === s)
      return;
    const E = this._encodeValue(s, p, v);
    if (E !== void 0 && !this._skipDefault(E, p, v))
      return E;
  }, u.prototype._encodeValue = function(s, p, v) {
    const m = this._baseState;
    if (m.parent === null)
      return m.children[0]._encode(s, p || new e());
    let E = null;
    if (this.reporter = p, m.optional && s === void 0)
      if (m.default !== null)
        s = m.default;
      else
        return;
    let M = null, I = !1;
    if (m.any)
      E = this._createEncoderBuffer(s);
    else if (m.choice)
      E = this._encodeChoice(s, p);
    else if (m.contains)
      M = this._getUse(m.contains, v)._encode(s, p), I = !0;
    else if (m.children)
      M = m.children.map(function(B) {
        if (B._baseState.tag === "null_")
          return B._encode(null, p, s);
        if (B._baseState.key === null)
          return p.error("Child should have a key");
        const T = p.enterKey(B._baseState.key);
        if (typeof s != "object")
          return p.error("Child expected, but input is not object");
        const k = B._encode(s[B._baseState.key], p, s);
        return p.leaveKey(T), k;
      }, this).filter(function(B) {
        return B;
      }), M = this._createEncoderBuffer(M);
    else if (m.tag === "seqof" || m.tag === "setof") {
      if (!(m.args && m.args.length === 1))
        return p.error("Too many args for : " + m.tag);
      if (!Array.isArray(s))
        return p.error("seqof/setof, but data is not Array");
      const B = this.clone();
      B._baseState.implicit = null, M = this._createEncoderBuffer(s.map(function(T) {
        const k = this._baseState;
        return this._getUse(k.args[0], s)._encode(T, p);
      }, B));
    } else
      m.use !== null ? E = this._getUse(m.use, v)._encode(s, p) : (M = this._encodePrimitive(m.tag, s), I = !0);
    if (!m.any && m.choice === null) {
      const B = m.implicit !== null ? m.implicit : m.tag, T = m.implicit === null ? "universal" : "context";
      B === null ? m.use === null && p.error("Tag could be omitted only for .use()") : m.use === null && (E = this._encodeComposite(B, I, T, M));
    }
    return m.explicit !== null && (E = this._encodeComposite(m.explicit, !1, "context", E)), E;
  }, u.prototype._encodeChoice = function(s, p) {
    const v = this._baseState, m = v.choice[s.type];
    return m || i(
      !1,
      s.type + " not found in " + JSON.stringify(Object.keys(v.choice))
    ), m._encode(s.value, p);
  }, u.prototype._encodePrimitive = function(s, p) {
    const v = this._baseState;
    if (/str$/.test(s))
      return this._encodeStr(p, s);
    if (s === "objid" && v.args)
      return this._encodeObjid(p, v.reverseArgs[0], v.args[1]);
    if (s === "objid")
      return this._encodeObjid(p, null, null);
    if (s === "gentime" || s === "utctime")
      return this._encodeTime(p, s);
    if (s === "null_")
      return this._encodeNull();
    if (s === "int" || s === "enum")
      return this._encodeInt(p, v.args && v.reverseArgs[0]);
    if (s === "bool")
      return this._encodeBool(p);
    if (s === "objDesc")
      return this._encodeStr(p, s);
    throw new Error("Unsupported tag: " + s);
  }, u.prototype._isNumstr = function(s) {
    return /^[0-9 ]*$/.test(s);
  }, u.prototype._isPrintstr = function(s) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(s);
  }, mc;
}
var wc = {}, tv;
function B0() {
  return tv || (tv = 1, function(e) {
    function t(r) {
      const i = {};
      return Object.keys(r).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        const n = r[o];
        i[n] = o;
      }), i;
    }
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t(e.tag);
  }(wc)), wc;
}
var _c, rv;
function Gg() {
  if (rv)
    return _c;
  rv = 1;
  const e = Et(), t = A0().Buffer, r = R0(), i = B0();
  function o(c) {
    this.enc = "der", this.name = c.name, this.entity = c, this.tree = new n(), this.tree._init(c.body);
  }
  _c = o, o.prototype.encode = function(h, s) {
    return this.tree._encode(h, s).join();
  };
  function n(c) {
    r.call(this, "der", c);
  }
  e(n, r), n.prototype._encodeComposite = function(h, s, p, v) {
    const m = u(h, s, p, this.reporter);
    if (v.length < 128) {
      const I = t.alloc(2);
      return I[0] = m, I[1] = v.length, this._createEncoderBuffer([I, v]);
    }
    let E = 1;
    for (let I = v.length; I >= 256; I >>= 8)
      E++;
    const M = t.alloc(2 + E);
    M[0] = m, M[1] = 128 | E;
    for (let I = 1 + E, B = v.length; B > 0; I--, B >>= 8)
      M[I] = B & 255;
    return this._createEncoderBuffer([M, v]);
  }, n.prototype._encodeStr = function(h, s) {
    if (s === "bitstr")
      return this._createEncoderBuffer([h.unused | 0, h.data]);
    if (s === "bmpstr") {
      const p = t.alloc(h.length * 2);
      for (let v = 0; v < h.length; v++)
        p.writeUInt16BE(h.charCodeAt(v), v * 2);
      return this._createEncoderBuffer(p);
    } else
      return s === "numstr" ? this._isNumstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : s === "printstr" ? this._isPrintstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(s) ? this._createEncoderBuffer(h) : s === "objDesc" ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: " + s + " unsupported");
  }, n.prototype._encodeObjid = function(h, s, p) {
    if (typeof h == "string") {
      if (!s)
        return this.reporter.error("string objid given, but no values map found");
      if (!s.hasOwnProperty(h))
        return this.reporter.error("objid not found in values map");
      h = s[h].split(/[\s.]+/g);
      for (let M = 0; M < h.length; M++)
        h[M] |= 0;
    } else if (Array.isArray(h)) {
      h = h.slice();
      for (let M = 0; M < h.length; M++)
        h[M] |= 0;
    }
    if (!Array.isArray(h))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(h));
    if (!p) {
      if (h[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      h.splice(0, 2, h[0] * 40 + h[1]);
    }
    let v = 0;
    for (let M = 0; M < h.length; M++) {
      let I = h[M];
      for (v++; I >= 128; I >>= 7)
        v++;
    }
    const m = t.alloc(v);
    let E = m.length - 1;
    for (let M = h.length - 1; M >= 0; M--) {
      let I = h[M];
      for (m[E--] = I & 127; (I >>= 7) > 0; )
        m[E--] = 128 | I & 127;
    }
    return this._createEncoderBuffer(m);
  };
  function f(c) {
    return c < 10 ? "0" + c : c;
  }
  n.prototype._encodeTime = function(h, s) {
    let p;
    const v = new Date(h);
    return s === "gentime" ? p = [
      f(v.getUTCFullYear()),
      f(v.getUTCMonth() + 1),
      f(v.getUTCDate()),
      f(v.getUTCHours()),
      f(v.getUTCMinutes()),
      f(v.getUTCSeconds()),
      "Z"
    ].join("") : s === "utctime" ? p = [
      f(v.getUTCFullYear() % 100),
      f(v.getUTCMonth() + 1),
      f(v.getUTCDate()),
      f(v.getUTCHours()),
      f(v.getUTCMinutes()),
      f(v.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + s + " time is not supported yet"), this._encodeStr(p, "octstr");
  }, n.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, n.prototype._encodeInt = function(h, s) {
    if (typeof h == "string") {
      if (!s)
        return this.reporter.error("String int or enum given, but no values map");
      if (!s.hasOwnProperty(h))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(h));
      h = s[h];
    }
    if (typeof h != "number" && !t.isBuffer(h)) {
      const m = h.toArray();
      !h.sign && m[0] & 128 && m.unshift(0), h = t.from(m);
    }
    if (t.isBuffer(h)) {
      let m = h.length;
      h.length === 0 && m++;
      const E = t.alloc(m);
      return h.copy(E), h.length === 0 && (E[0] = 0), this._createEncoderBuffer(E);
    }
    if (h < 128)
      return this._createEncoderBuffer(h);
    if (h < 256)
      return this._createEncoderBuffer([0, h]);
    let p = 1;
    for (let m = h; m >= 256; m >>= 8)
      p++;
    const v = new Array(p);
    for (let m = v.length - 1; m >= 0; m--)
      v[m] = h & 255, h >>= 8;
    return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(t.from(v));
  }, n.prototype._encodeBool = function(h) {
    return this._createEncoderBuffer(h ? 255 : 0);
  }, n.prototype._use = function(h, s) {
    return typeof h == "function" && (h = h(s)), h._getEncoder("der").tree;
  }, n.prototype._skipDefault = function(h, s, p) {
    const v = this._baseState;
    let m;
    if (v.default === null)
      return !1;
    const E = h.join();
    if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, s, p).join()), E.length !== v.defaultBuffer.length)
      return !1;
    for (m = 0; m < E.length; m++)
      if (E[m] !== v.defaultBuffer[m])
        return !1;
    return !0;
  };
  function u(c, h, s, p) {
    let v;
    if (c === "seqof" ? c = "seq" : c === "setof" && (c = "set"), i.tagByName.hasOwnProperty(c))
      v = i.tagByName[c];
    else if (typeof c == "number" && (c | 0) === c)
      v = c;
    else
      return p.error("Unknown tag: " + c);
    return v >= 31 ? p.error("Multi-octet tag encoding unsupported") : (h || (v |= 32), v |= i.tagClassByName[s || "universal"] << 6, v);
  }
  return _c;
}
var xc, nv;
function v9() {
  if (nv)
    return xc;
  nv = 1;
  const e = Et(), t = Gg();
  function r(i) {
    t.call(this, i), this.enc = "pem";
  }
  return e(r, t), xc = r, r.prototype.encode = function(o, n) {
    const u = t.prototype.encode.call(this, o).toString("base64"), c = ["-----BEGIN " + n.label + "-----"];
    for (let h = 0; h < u.length; h += 64)
      c.push(u.slice(h, h + 64));
    return c.push("-----END " + n.label + "-----"), c.join(`
`);
  }, xc;
}
var iv;
function Jg() {
  return iv || (iv = 1, function(e) {
    const t = e;
    t.der = Gg(), t.pem = v9();
  }(bc)), bc;
}
var Ec = {}, Sc, av;
function Xg() {
  if (av)
    return Sc;
  av = 1;
  const e = Et(), t = ar, r = ba().DecoderBuffer, i = R0(), o = B0();
  function n(h) {
    this.enc = "der", this.name = h.name, this.entity = h, this.tree = new f(), this.tree._init(h.body);
  }
  Sc = n, n.prototype.decode = function(s, p) {
    return r.isDecoderBuffer(s) || (s = new r(s, p)), this.tree._decode(s, p);
  };
  function f(h) {
    i.call(this, "der", h);
  }
  e(f, i), f.prototype._peekTag = function(s, p, v) {
    if (s.isEmpty())
      return !1;
    const m = s.save(), E = u(s, 'Failed to peek tag: "' + p + '"');
    return s.isError(E) ? E : (s.restore(m), E.tag === p || E.tagStr === p || E.tagStr + "of" === p || v);
  }, f.prototype._decodeTag = function(s, p, v) {
    const m = u(
      s,
      'Failed to decode tag of "' + p + '"'
    );
    if (s.isError(m))
      return m;
    let E = c(
      s,
      m.primitive,
      'Failed to get length of "' + p + '"'
    );
    if (s.isError(E))
      return E;
    if (!v && m.tag !== p && m.tagStr !== p && m.tagStr + "of" !== p)
      return s.error('Failed to match tag: "' + p + '"');
    if (m.primitive || E !== null)
      return s.skip(E, 'Failed to match body of: "' + p + '"');
    const M = s.save(), I = this._skipUntilEnd(
      s,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return s.isError(I) ? I : (E = s.offset - M.offset, s.restore(M), s.skip(E, 'Failed to match body of: "' + p + '"'));
  }, f.prototype._skipUntilEnd = function(s, p) {
    for (; ; ) {
      const v = u(s, p);
      if (s.isError(v))
        return v;
      const m = c(s, v.primitive, p);
      if (s.isError(m))
        return m;
      let E;
      if (v.primitive || m !== null ? E = s.skip(m) : E = this._skipUntilEnd(s, p), s.isError(E))
        return E;
      if (v.tagStr === "end")
        break;
    }
  }, f.prototype._decodeList = function(s, p, v, m) {
    const E = [];
    for (; !s.isEmpty(); ) {
      const M = this._peekTag(s, "end");
      if (s.isError(M))
        return M;
      const I = v.decode(s, "der", m);
      if (s.isError(I) && M)
        break;
      E.push(I);
    }
    return E;
  }, f.prototype._decodeStr = function(s, p) {
    if (p === "bitstr") {
      const v = s.readUInt8();
      return s.isError(v) ? v : { unused: v, data: s.raw() };
    } else if (p === "bmpstr") {
      const v = s.raw();
      if (v.length % 2 === 1)
        return s.error("Decoding of string type: bmpstr length mismatch");
      let m = "";
      for (let E = 0; E < v.length / 2; E++)
        m += String.fromCharCode(v.readUInt16BE(E * 2));
      return m;
    } else if (p === "numstr") {
      const v = s.raw().toString("ascii");
      return this._isNumstr(v) ? v : s.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (p === "octstr")
        return s.raw();
      if (p === "objDesc")
        return s.raw();
      if (p === "printstr") {
        const v = s.raw().toString("ascii");
        return this._isPrintstr(v) ? v : s.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(p) ? s.raw().toString() : s.error("Decoding of string type: " + p + " unsupported");
    }
  }, f.prototype._decodeObjid = function(s, p, v) {
    let m;
    const E = [];
    let M = 0, I = 0;
    for (; !s.isEmpty(); )
      I = s.readUInt8(), M <<= 7, M |= I & 127, I & 128 || (E.push(M), M = 0);
    I & 128 && E.push(M);
    const B = E[0] / 40 | 0, T = E[0] % 40;
    if (v ? m = E : m = [B, T].concat(E.slice(1)), p) {
      let k = p[m.join(" ")];
      k === void 0 && (k = p[m.join(".")]), k !== void 0 && (m = k);
    }
    return m;
  }, f.prototype._decodeTime = function(s, p) {
    const v = s.raw().toString();
    let m, E, M, I, B, T;
    if (p === "gentime")
      m = v.slice(0, 4) | 0, E = v.slice(4, 6) | 0, M = v.slice(6, 8) | 0, I = v.slice(8, 10) | 0, B = v.slice(10, 12) | 0, T = v.slice(12, 14) | 0;
    else if (p === "utctime")
      m = v.slice(0, 2) | 0, E = v.slice(2, 4) | 0, M = v.slice(4, 6) | 0, I = v.slice(6, 8) | 0, B = v.slice(8, 10) | 0, T = v.slice(10, 12) | 0, m < 70 ? m = 2e3 + m : m = 1900 + m;
    else
      return s.error("Decoding " + p + " time is not supported yet");
    return Date.UTC(m, E - 1, M, I, B, T, 0);
  }, f.prototype._decodeNull = function() {
    return null;
  }, f.prototype._decodeBool = function(s) {
    const p = s.readUInt8();
    return s.isError(p) ? p : p !== 0;
  }, f.prototype._decodeInt = function(s, p) {
    const v = s.raw();
    let m = new t(v);
    return p && (m = p[m.toString(10)] || m), m;
  }, f.prototype._use = function(s, p) {
    return typeof s == "function" && (s = s(p)), s._getDecoder("der").tree;
  };
  function u(h, s) {
    let p = h.readUInt8(s);
    if (h.isError(p))
      return p;
    const v = o.tagClass[p >> 6], m = (p & 32) === 0;
    if ((p & 31) === 31) {
      let M = p;
      for (p = 0; (M & 128) === 128; ) {
        if (M = h.readUInt8(s), h.isError(M))
          return M;
        p <<= 7, p |= M & 127;
      }
    } else
      p &= 31;
    const E = o.tag[p];
    return {
      cls: v,
      primitive: m,
      tag: p,
      tagStr: E
    };
  }
  function c(h, s, p) {
    let v = h.readUInt8(p);
    if (h.isError(v))
      return v;
    if (!s && v === 128)
      return null;
    if (!(v & 128))
      return v;
    const m = v & 127;
    if (m > 4)
      return h.error("length octect is too long");
    v = 0;
    for (let E = 0; E < m; E++) {
      v <<= 8;
      const M = h.readUInt8(p);
      if (h.isError(M))
        return M;
      v |= M;
    }
    return v;
  }
  return Sc;
}
var Ac, ov;
function b9() {
  if (ov)
    return Ac;
  ov = 1;
  const e = Et(), t = A0().Buffer, r = Xg();
  function i(o) {
    r.call(this, o), this.enc = "pem";
  }
  return e(i, r), Ac = i, i.prototype.decode = function(n, f) {
    const u = n.toString().split(/[\r\n]+/g), c = f.label.toUpperCase(), h = /^-----(BEGIN|END) ([^-]+)-----$/;
    let s = -1, p = -1;
    for (let E = 0; E < u.length; E++) {
      const M = u[E].match(h);
      if (M !== null && M[2] === c)
        if (s === -1) {
          if (M[1] !== "BEGIN")
            break;
          s = E;
        } else {
          if (M[1] !== "END")
            break;
          p = E;
          break;
        }
    }
    if (s === -1 || p === -1)
      throw new Error("PEM section not found for: " + c);
    const v = u.slice(s + 1, p).join("");
    v.replace(/[^a-z0-9+/=]+/gi, "");
    const m = t.from(v, "base64");
    return r.prototype.decode.call(this, m, f);
  }, Ac;
}
var fv;
function Yg() {
  return fv || (fv = 1, function(e) {
    const t = e;
    t.der = Xg(), t.pem = b9();
  }(Ec)), Ec;
}
var sv;
function y9() {
  return sv || (sv = 1, function(e) {
    const t = Jg(), r = Yg(), i = Et(), o = e;
    o.define = function(u, c) {
      return new n(u, c);
    };
    function n(f, u) {
      this.name = f, this.body = u, this.decoders = {}, this.encoders = {};
    }
    n.prototype._createNamed = function(u) {
      const c = this.name;
      function h(s) {
        this._initNamed(s, c);
      }
      return i(h, u), h.prototype._initNamed = function(p, v) {
        u.call(this, p, v);
      }, new h(this);
    }, n.prototype._getDecoder = function(u) {
      return u = u || "der", this.decoders.hasOwnProperty(u) || (this.decoders[u] = this._createNamed(r[u])), this.decoders[u];
    }, n.prototype.decode = function(u, c, h) {
      return this._getDecoder(c).decode(u, h);
    }, n.prototype._getEncoder = function(u) {
      return u = u || "der", this.encoders.hasOwnProperty(u) || (this.encoders[u] = this._createNamed(t[u])), this.encoders[u];
    }, n.prototype.encode = function(u, c, h) {
      return this._getEncoder(c).encode(u, h);
    };
  }(vc)), vc;
}
var Mc = {}, uv;
function g9() {
  return uv || (uv = 1, function(e) {
    const t = e;
    t.Reporter = M0().Reporter, t.DecoderBuffer = ba().DecoderBuffer, t.EncoderBuffer = ba().EncoderBuffer, t.Node = R0();
  }(Mc)), Mc;
}
var Rc = {}, cv;
function m9() {
  return cv || (cv = 1, function(e) {
    const t = e;
    t._reverse = function(i) {
      const o = {};
      return Object.keys(i).forEach(function(n) {
        (n | 0) == n && (n = n | 0);
        const f = i[n];
        o[f] = n;
      }), o;
    }, t.der = B0();
  }(Rc)), Rc;
}
var hv;
function Qg() {
  return hv || (hv = 1, function(e) {
    const t = e;
    t.bignum = ar, t.define = y9().define, t.base = g9(), t.constants = m9(), t.decoders = Yg(), t.encoders = Jg();
  }(pc)), pc;
}
var Bc, lv;
function w9() {
  if (lv)
    return Bc;
  lv = 1;
  var e = Qg(), t = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), r = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), i = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), o = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(i),
      this.key("subjectPublicKey").bitstr()
    );
  }), n = e.define("RelativeDistinguishedName", function() {
    this.setof(r);
  }), f = e.define("RDNSequence", function() {
    this.seqof(n);
  }), u = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(f)
    });
  }), c = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), h = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), s = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(i),
      this.key("issuer").use(u),
      this.key("validity").use(c),
      this.key("subject").use(u),
      this.key("subjectPublicKeyInfo").use(o),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(h).optional()
    );
  }), p = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(s),
      this.key("signatureAlgorithm").use(i),
      this.key("signatureValue").bitstr()
    );
  });
  return Bc = p, Bc;
}
var dv;
function _9() {
  if (dv)
    return Nr;
  dv = 1;
  var e = Qg();
  Nr.certificate = w9();
  var t = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  Nr.RSAPrivateKey = t;
  var r = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  Nr.RSAPublicKey = r;
  var i = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(o),
      this.key("subjectPublicKey").bitstr()
    );
  });
  Nr.PublicKey = i;
  var o = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), n = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(o),
      this.key("subjectPrivateKey").octstr()
    );
  });
  Nr.PrivateKey = n;
  var f = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  Nr.EncryptedPrivateKey = f;
  var u = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  Nr.DSAPrivateKey = u, Nr.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var c = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(h),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  Nr.ECPrivateKey = c;
  var h = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  return Nr.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), Nr;
}
const x9 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var Ic, pv;
function E9() {
  if (pv)
    return Ic;
  pv = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, i = vf(), o = m0(), n = Bt().Buffer;
  return Ic = function(f, u) {
    var c = f.toString(), h = c.match(e), s;
    if (h) {
      var v = "aes" + h[1], m = n.from(h[2], "hex"), E = n.from(h[3].replace(/[\r\n]/g, ""), "base64"), M = i(u, m.slice(0, 8), parseInt(h[1], 10)).key, I = [], B = o.createDecipheriv(v, M, m);
      I.push(B.update(E)), I.push(B.final()), s = n.concat(I);
    } else {
      var p = c.match(r);
      s = n.from(p[2].replace(/[\r\n]/g, ""), "base64");
    }
    var T = c.match(t)[1];
    return {
      tag: T,
      data: s
    };
  }, Ic;
}
var Tc, vv;
function yf() {
  if (vv)
    return Tc;
  vv = 1;
  var e = _9(), t = x9, r = E9(), i = m0(), o = Ng(), n = Bt().Buffer;
  Tc = f;
  function f(c) {
    var h;
    typeof c == "object" && !n.isBuffer(c) && (h = c.passphrase, c = c.key), typeof c == "string" && (c = n.from(c));
    var s = r(c, h), p = s.tag, v = s.data, m, E;
    switch (p) {
      case "CERTIFICATE":
        E = e.certificate.decode(v, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (E || (E = e.PublicKey.decode(v, "der")), m = E.algorithm.algorithm.join("."), m) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(E.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return E.subjectPrivateKey = E.subjectPublicKey, {
              type: "ec",
              data: E
            };
          case "1.2.840.10040.4.1":
            return E.algorithm.params.pub_key = e.DSAparam.decode(E.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: E.algorithm.params
            };
          default:
            throw new Error("unknown key id " + m);
        }
      case "ENCRYPTED PRIVATE KEY":
        v = e.EncryptedPrivateKey.decode(v, "der"), v = u(v, h);
      case "PRIVATE KEY":
        switch (E = e.PrivateKey.decode(v, "der"), m = E.algorithm.algorithm.join("."), m) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(E.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: E.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(E.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return E.algorithm.params.priv_key = e.DSAparam.decode(E.subjectPrivateKey, "der"), {
              type: "dsa",
              params: E.algorithm.params
            };
          default:
            throw new Error("unknown key id " + m);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(v, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(v, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(v, "der")
        };
      case "EC PRIVATE KEY":
        return v = e.ECPrivateKey.decode(v, "der"), {
          curve: v.parameters.value,
          privateKey: v.privateKey
        };
      default:
        throw new Error("unknown key type " + p);
    }
  }
  f.signature = e.signature;
  function u(c, h) {
    var s = c.algorithm.decrypt.kde.kdeparams.salt, p = parseInt(c.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), v = t[c.algorithm.decrypt.cipher.algo.join(".")], m = c.algorithm.decrypt.cipher.iv, E = c.subjectPrivateKey, M = parseInt(v.split("-")[1], 10) / 8, I = o.pbkdf2Sync(h, s, p, M, "sha1"), B = i.createDecipheriv(v, I, m), T = [];
    return T.push(B.update(E)), T.push(B.final()), n.concat(T);
  }
  return Tc;
}
const em = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var bv;
function S9() {
  if (bv)
    return ra.exports;
  bv = 1;
  var e = Bt().Buffer, t = Bg(), r = _0(), i = S0().ec, o = Zg(), n = yf(), f = em, u = 1;
  function c(B, T, k, N, q) {
    var D = n(T);
    if (D.curve) {
      if (N !== "ecdsa" && N !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return h(B, D);
    } else if (D.type === "dsa") {
      if (N !== "dsa")
        throw new Error("wrong private key type");
      return s(B, D, k);
    }
    if (N !== "rsa" && N !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (T.padding !== void 0 && T.padding !== u)
      throw new Error("illegal or unsupported padding mode");
    B = e.concat([q, B]);
    for (var U = D.modulus.byteLength(), z = [0, 1]; B.length + z.length + 1 < U; )
      z.push(255);
    z.push(0);
    for (var Y = -1; ++Y < B.length; )
      z.push(B[Y]);
    var ue = r(z, D);
    return ue;
  }
  function h(B, T) {
    var k = f[T.curve.join(".")];
    if (!k)
      throw new Error("unknown curve " + T.curve.join("."));
    var N = new i(k), q = N.keyFromPrivate(T.privateKey), D = q.sign(B);
    return e.from(D.toDER());
  }
  function s(B, T, k) {
    for (var N = T.params.priv_key, q = T.params.p, D = T.params.q, U = T.params.g, z = new o(0), Y, ue = m(B, D).mod(D), j = !1, g = v(N, D, B, k); j === !1; )
      Y = M(D, g, k), z = I(U, Y, q, D), j = Y.invm(D).imul(ue.add(N.mul(z))).mod(D), j.cmpn(0) === 0 && (j = !1, z = new o(0));
    return p(z, j);
  }
  function p(B, T) {
    B = B.toArray(), T = T.toArray(), B[0] & 128 && (B = [0].concat(B)), T[0] & 128 && (T = [0].concat(T));
    var k = B.length + T.length + 4, N = [
      48,
      k,
      2,
      B.length
    ];
    return N = N.concat(B, [2, T.length], T), e.from(N);
  }
  function v(B, T, k, N) {
    if (B = e.from(B.toArray()), B.length < T.byteLength()) {
      var q = e.alloc(T.byteLength() - B.length);
      B = e.concat([q, B]);
    }
    var D = k.length, U = E(k, T), z = e.alloc(D);
    z.fill(1);
    var Y = e.alloc(D);
    return Y = t(N, Y).update(z).update(e.from([0])).update(B).update(U).digest(), z = t(N, Y).update(z).digest(), Y = t(N, Y).update(z).update(e.from([1])).update(B).update(U).digest(), z = t(N, Y).update(z).digest(), { k: Y, v: z };
  }
  function m(B, T) {
    var k = new o(B), N = (B.length << 3) - T.bitLength();
    return N > 0 && k.ishrn(N), k;
  }
  function E(B, T) {
    B = m(B, T), B = B.mod(T);
    var k = e.from(B.toArray());
    if (k.length < T.byteLength()) {
      var N = e.alloc(T.byteLength() - k.length);
      k = e.concat([N, k]);
    }
    return k;
  }
  function M(B, T, k) {
    var N, q;
    do {
      for (N = e.alloc(0); N.length * 8 < B.bitLength(); )
        T.v = t(k, T.k).update(T.v).digest(), N = e.concat([N, T.v]);
      q = m(N, B), T.k = t(k, T.k).update(T.v).update(e.from([0])).digest(), T.v = t(k, T.k).update(T.v).digest();
    } while (q.cmp(B) !== -1);
    return q;
  }
  function I(B, T, k, N) {
    return B.toRed(o.mont(k)).redPow(T).fromRed().mod(N);
  }
  return ra.exports = c, ra.exports.getKey = v, ra.exports.makeKey = M, ra.exports;
}
var Oc, yv;
function A9() {
  if (yv)
    return Oc;
  yv = 1;
  var e = Bt().Buffer, t = Zg(), r = S0().ec, i = yf(), o = em;
  function n(h, s, p, v, m) {
    var E = i(p);
    if (E.type === "ec") {
      if (v !== "ecdsa" && v !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return f(h, s, E);
    } else if (E.type === "dsa") {
      if (v !== "dsa")
        throw new Error("wrong public key type");
      return u(h, s, E);
    }
    if (v !== "rsa" && v !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    s = e.concat([m, s]);
    for (var M = E.modulus.byteLength(), I = [1], B = 0; s.length + I.length + 2 < M; )
      I.push(255), B += 1;
    I.push(0);
    for (var T = -1; ++T < s.length; )
      I.push(s[T]);
    I = e.from(I);
    var k = t.mont(E.modulus);
    h = new t(h).toRed(k), h = h.redPow(new t(E.publicExponent)), h = e.from(h.fromRed().toArray());
    var N = B < 8 ? 1 : 0;
    for (M = Math.min(h.length, I.length), h.length !== I.length && (N = 1), T = -1; ++T < M; )
      N |= h[T] ^ I[T];
    return N === 0;
  }
  function f(h, s, p) {
    var v = o[p.data.algorithm.curve.join(".")];
    if (!v)
      throw new Error("unknown curve " + p.data.algorithm.curve.join("."));
    var m = new r(v), E = p.data.subjectPrivateKey.data;
    return m.verify(s, h, E);
  }
  function u(h, s, p) {
    var v = p.data.p, m = p.data.q, E = p.data.g, M = p.data.pub_key, I = i.signature.decode(h, "der"), B = I.s, T = I.r;
    c(B, m), c(T, m);
    var k = t.mont(v), N = B.invm(m), q = E.toRed(k).redPow(new t(s).mul(N).mod(m)).fromRed().mul(M.toRed(k).redPow(T.mul(N).mod(m)).fromRed()).mod(v).mod(m);
    return q.cmp(T) === 0;
  }
  function c(h, s) {
    if (h.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (h.cmp(s) >= 0)
      throw new Error("invalid sig");
  }
  return Oc = n, Oc;
}
var Pc, gv;
function M9() {
  if (gv)
    return Pc;
  gv = 1;
  var e = Bt().Buffer, t = Ta(), r = uf(), i = Et(), o = S9(), n = A9(), f = Ig;
  Object.keys(f).forEach(function(p) {
    f[p].id = e.from(f[p].id, "hex"), f[p.toLowerCase()] = f[p];
  });
  function u(p) {
    r.Writable.call(this);
    var v = f[p];
    if (!v)
      throw new Error("Unknown message digest");
    this._hashType = v.hash, this._hash = t(v.hash), this._tag = v.id, this._signType = v.sign;
  }
  i(u, r.Writable), u.prototype._write = function(v, m, E) {
    this._hash.update(v), E();
  }, u.prototype.update = function(v, m) {
    return this._hash.update(typeof v == "string" ? e.from(v, m) : v), this;
  }, u.prototype.sign = function(v, m) {
    this.end();
    var E = this._hash.digest(), M = o(E, v, this._hashType, this._signType, this._tag);
    return m ? M.toString(m) : M;
  };
  function c(p) {
    r.Writable.call(this);
    var v = f[p];
    if (!v)
      throw new Error("Unknown message digest");
    this._hash = t(v.hash), this._tag = v.id, this._signType = v.sign;
  }
  i(c, r.Writable), c.prototype._write = function(v, m, E) {
    this._hash.update(v), E();
  }, c.prototype.update = function(v, m) {
    return this._hash.update(typeof v == "string" ? e.from(v, m) : v), this;
  }, c.prototype.verify = function(v, m, E) {
    var M = typeof m == "string" ? e.from(m, E) : m;
    this.end();
    var I = this._hash.digest();
    return n(M, I, v, this._signType, this._tag);
  };
  function h(p) {
    return new u(p);
  }
  function s(p) {
    return new c(p);
  }
  return Pc = {
    Sign: h,
    Verify: s,
    createSign: h,
    createVerify: s
  }, Pc;
}
var Cc, mv;
function R9() {
  if (mv)
    return Cc;
  mv = 1;
  var e = S0(), t = ar;
  Cc = function(f) {
    return new i(f);
  };
  var r = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
  function i(n) {
    this.curveType = r[n], this.curveType || (this.curveType = {
      name: n
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  i.prototype.generateKeys = function(n, f) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(n, f);
  }, i.prototype.computeSecret = function(n, f, u) {
    f = f || "utf8", Le.Buffer.isBuffer(n) || (n = new Le.Buffer(n, f));
    var c = this.curve.keyFromPublic(n).getPublic(), h = c.mul(this.keys.getPrivate()).getX();
    return o(h, u, this.curveType.byteLength);
  }, i.prototype.getPublicKey = function(n, f) {
    var u = this.keys.getPublic(f === "compressed", !0);
    return f === "hybrid" && (u[u.length - 1] % 2 ? u[0] = 7 : u[0] = 6), o(u, n);
  }, i.prototype.getPrivateKey = function(n) {
    return o(this.keys.getPrivate(), n);
  }, i.prototype.setPublicKey = function(n, f) {
    return f = f || "utf8", Le.Buffer.isBuffer(n) || (n = new Le.Buffer(n, f)), this.keys._importPublic(n), this;
  }, i.prototype.setPrivateKey = function(n, f) {
    f = f || "utf8", Le.Buffer.isBuffer(n) || (n = new Le.Buffer(n, f));
    var u = new t(n);
    return u = u.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(u), this;
  };
  function o(n, f, u) {
    Array.isArray(n) || (n = n.toArray());
    var c = new Le.Buffer(n);
    if (u && c.length < u) {
      var h = new Le.Buffer(u - c.length);
      h.fill(0), c = Le.Buffer.concat([h, c]);
    }
    return f ? c.toString(f) : c;
  }
  return Cc;
}
var Nc = {}, Lc, wv;
function tm() {
  if (wv)
    return Lc;
  wv = 1;
  var e = Ta(), t = Bt().Buffer;
  Lc = function(i, o) {
    for (var n = t.alloc(0), f = 0, u; n.length < o; )
      u = r(f++), n = t.concat([n, e("sha1").update(i).update(u).digest()]);
    return n.slice(0, o);
  };
  function r(i) {
    var o = t.allocUnsafe(4);
    return o.writeUInt32BE(i, 0), o;
  }
  return Lc;
}
var kc, _v;
function rm() {
  return _v || (_v = 1, kc = function(t, r) {
    for (var i = t.length, o = -1; ++o < i; )
      t[o] ^= r[o];
    return t;
  }), kc;
}
var qc, xv;
function nm() {
  if (xv)
    return qc;
  xv = 1;
  var e = ar, t = Bt().Buffer;
  function r(i, o) {
    return t.from(i.toRed(e.mont(o.modulus)).redPow(new e(o.publicExponent)).fromRed().toArray());
  }
  return qc = r, qc;
}
var $c, Ev;
function B9() {
  if (Ev)
    return $c;
  Ev = 1;
  var e = yf(), t = Ki(), r = Ta(), i = tm(), o = rm(), n = ar, f = nm(), u = _0(), c = Bt().Buffer;
  $c = function(m, E, M) {
    var I;
    m.padding ? I = m.padding : M ? I = 1 : I = 4;
    var B = e(m), T;
    if (I === 4)
      T = h(B, E);
    else if (I === 1)
      T = s(B, E, M);
    else if (I === 3) {
      if (T = new n(E), T.cmp(B.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return M ? u(T, B) : f(T, B);
  };
  function h(v, m) {
    var E = v.modulus.byteLength(), M = m.length, I = r("sha1").update(c.alloc(0)).digest(), B = I.length, T = 2 * B;
    if (M > E - T - 2)
      throw new Error("message too long");
    var k = c.alloc(E - M - T - 2), N = E - B - 1, q = t(B), D = o(c.concat([I, k, c.alloc(1, 1), m], N), i(q, N)), U = o(q, i(D, B));
    return new n(c.concat([c.alloc(1), U, D], E));
  }
  function s(v, m, E) {
    var M = m.length, I = v.modulus.byteLength();
    if (M > I - 11)
      throw new Error("message too long");
    var B;
    return E ? B = c.alloc(I - M - 3, 255) : B = p(I - M - 3), new n(c.concat([c.from([0, E ? 1 : 2]), B, c.alloc(1), m], I));
  }
  function p(v) {
    for (var m = c.allocUnsafe(v), E = 0, M = t(v * 2), I = 0, B; E < v; )
      I === M.length && (M = t(v * 2), I = 0), B = M[I++], B && (m[E++] = B);
    return m;
  }
  return $c;
}
var Dc, Sv;
function I9() {
  if (Sv)
    return Dc;
  Sv = 1;
  var e = yf(), t = tm(), r = rm(), i = ar, o = _0(), n = Ta(), f = nm(), u = Bt().Buffer;
  Dc = function(v, m, E) {
    var M;
    v.padding ? M = v.padding : E ? M = 1 : M = 4;
    var I = e(v), B = I.modulus.byteLength();
    if (m.length > B || new i(m).cmp(I.modulus) >= 0)
      throw new Error("decryption error");
    var T;
    E ? T = f(new i(m), I) : T = o(m, I);
    var k = u.alloc(B - T.length);
    if (T = u.concat([k, T], B), M === 4)
      return c(I, T);
    if (M === 1)
      return h(I, T, E);
    if (M === 3)
      return T;
    throw new Error("unknown padding");
  };
  function c(p, v) {
    var m = p.modulus.byteLength(), E = n("sha1").update(u.alloc(0)).digest(), M = E.length;
    if (v[0] !== 0)
      throw new Error("decryption error");
    var I = v.slice(1, M + 1), B = v.slice(M + 1), T = r(I, t(B, M)), k = r(B, t(T, m - M - 1));
    if (s(E, k.slice(0, M)))
      throw new Error("decryption error");
    for (var N = M; k[N] === 0; )
      N++;
    if (k[N++] !== 1)
      throw new Error("decryption error");
    return k.slice(N);
  }
  function h(p, v, m) {
    for (var E = v.slice(0, 2), M = 2, I = 0; v[M++] !== 0; )
      if (M >= v.length) {
        I++;
        break;
      }
    var B = v.slice(2, M - 1);
    if ((E.toString("hex") !== "0002" && !m || E.toString("hex") !== "0001" && m) && I++, B.length < 8 && I++, I)
      throw new Error("decryption error");
    return v.slice(M);
  }
  function s(p, v) {
    p = u.from(p), v = u.from(v);
    var m = 0, E = p.length;
    p.length !== v.length && (m++, E = Math.min(p.length, v.length));
    for (var M = -1; ++M < E; )
      m += p[M] ^ v[M];
    return m;
  }
  return Dc;
}
var Av;
function T9() {
  return Av || (Av = 1, function(e) {
    e.publicEncrypt = B9(), e.privateDecrypt = I9(), e.privateEncrypt = function(r, i) {
      return e.publicEncrypt(r, i, !0);
    }, e.publicDecrypt = function(r, i) {
      return e.privateDecrypt(r, i, !0);
    };
  }(Nc)), Nc;
}
var yi = {}, Mv;
function O9() {
  if (Mv)
    return yi;
  Mv = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = Bt(), r = Ki(), i = t.Buffer, o = t.kMaxLength, n = Ze.crypto || Ze.msCrypto, f = Math.pow(2, 32) - 1;
  function u(v, m) {
    if (typeof v != "number" || v !== v)
      throw new TypeError("offset must be a number");
    if (v > f || v < 0)
      throw new TypeError("offset must be a uint32");
    if (v > o || v > m)
      throw new RangeError("offset out of range");
  }
  function c(v, m, E) {
    if (typeof v != "number" || v !== v)
      throw new TypeError("size must be a number");
    if (v > f || v < 0)
      throw new TypeError("size must be a uint32");
    if (v + m > E || v > o)
      throw new RangeError("buffer too small");
  }
  n && n.getRandomValues || !at.browser ? (yi.randomFill = h, yi.randomFillSync = p) : (yi.randomFill = e, yi.randomFillSync = e);
  function h(v, m, E, M) {
    if (!i.isBuffer(v) && !(v instanceof Ze.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof m == "function")
      M = m, m = 0, E = v.length;
    else if (typeof E == "function")
      M = E, E = v.length - m;
    else if (typeof M != "function")
      throw new TypeError('"cb" argument must be a function');
    return u(m, v.length), c(E, m, v.length), s(v, m, E, M);
  }
  function s(v, m, E, M) {
    if (at.browser) {
      var I = v.buffer, B = new Uint8Array(I, m, E);
      if (n.getRandomValues(B), M) {
        at.nextTick(function() {
          M(null, v);
        });
        return;
      }
      return v;
    }
    if (M) {
      r(E, function(k, N) {
        if (k)
          return M(k);
        N.copy(v, m), M(null, v);
      });
      return;
    }
    var T = r(E);
    return T.copy(v, m), v;
  }
  function p(v, m, E) {
    if (typeof m > "u" && (m = 0), !i.isBuffer(v) && !(v instanceof Ze.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return u(m, v.length), E === void 0 && (E = v.length - m), c(E, m, v.length), s(v, m, E);
  }
  return yi;
}
var Rv;
function im() {
  if (Rv)
    return At;
  Rv = 1, At.randomBytes = At.rng = At.pseudoRandomBytes = At.prng = Ki(), At.createHash = At.Hash = Ta(), At.createHmac = At.Hmac = Bg();
  var e = a7(), t = Object.keys(e), r = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  At.getHashes = function() {
    return r;
  };
  var i = Ng();
  At.pbkdf2 = i.pbkdf2, At.pbkdf2Sync = i.pbkdf2Sync;
  var o = S7();
  At.Cipher = o.Cipher, At.createCipher = o.createCipher, At.Cipheriv = o.Cipheriv, At.createCipheriv = o.createCipheriv, At.Decipher = o.Decipher, At.createDecipher = o.createDecipher, At.Decipheriv = o.Decipheriv, At.createDecipheriv = o.createDecipheriv, At.getCiphers = o.getCiphers, At.listCiphers = o.listCiphers;
  var n = L7();
  At.DiffieHellmanGroup = n.DiffieHellmanGroup, At.createDiffieHellmanGroup = n.createDiffieHellmanGroup, At.getDiffieHellman = n.getDiffieHellman, At.createDiffieHellman = n.createDiffieHellman, At.DiffieHellman = n.DiffieHellman;
  var f = M9();
  At.createSign = f.createSign, At.Sign = f.Sign, At.createVerify = f.createVerify, At.Verify = f.Verify, At.createECDH = R9();
  var u = T9();
  At.publicEncrypt = u.publicEncrypt, At.privateEncrypt = u.privateEncrypt, At.publicDecrypt = u.publicDecrypt, At.privateDecrypt = u.privateDecrypt;
  var c = O9();
  return At.randomFill = c.randomFill, At.randomFillSync = c.randomFillSync, At.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, At.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, At;
}
(function(e) {
  (function(t) {
    var r = function($) {
      var X, ne = new Float64Array(16);
      if ($)
        for (X = 0; X < $.length; X++)
          ne[X] = $[X];
      return ne;
    }, i = function() {
      throw new Error("no PRNG");
    }, o = new Uint8Array(16), n = new Uint8Array(32);
    n[0] = 9;
    var f = r(), u = r([1]), c = r([56129, 1]), h = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), s = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), p = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), v = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), m = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function E($, X, ne, O) {
      $[X] = ne >> 24 & 255, $[X + 1] = ne >> 16 & 255, $[X + 2] = ne >> 8 & 255, $[X + 3] = ne & 255, $[X + 4] = O >> 24 & 255, $[X + 5] = O >> 16 & 255, $[X + 6] = O >> 8 & 255, $[X + 7] = O & 255;
    }
    function M($, X, ne, O, ae) {
      var we, xe = 0;
      for (we = 0; we < ae; we++)
        xe |= $[X + we] ^ ne[O + we];
      return (1 & xe - 1 >>> 8) - 1;
    }
    function I($, X, ne, O) {
      return M($, X, ne, O, 16);
    }
    function B($, X, ne, O) {
      return M($, X, ne, O, 32);
    }
    function T($, X, ne, O) {
      for (var ae = O[0] & 255 | (O[1] & 255) << 8 | (O[2] & 255) << 16 | (O[3] & 255) << 24, we = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, xe = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, Re = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, De = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, ze = O[4] & 255 | (O[5] & 255) << 8 | (O[6] & 255) << 16 | (O[7] & 255) << 24, Ue = X[0] & 255 | (X[1] & 255) << 8 | (X[2] & 255) << 16 | (X[3] & 255) << 24, mt = X[4] & 255 | (X[5] & 255) << 8 | (X[6] & 255) << 16 | (X[7] & 255) << 24, et = X[8] & 255 | (X[9] & 255) << 8 | (X[10] & 255) << 16 | (X[11] & 255) << 24, ut = X[12] & 255 | (X[13] & 255) << 8 | (X[14] & 255) << 16 | (X[15] & 255) << 24, ct = O[8] & 255 | (O[9] & 255) << 8 | (O[10] & 255) << 16 | (O[11] & 255) << 24, vt = ne[16] & 255 | (ne[17] & 255) << 8 | (ne[18] & 255) << 16 | (ne[19] & 255) << 24, pt = ne[20] & 255 | (ne[21] & 255) << 8 | (ne[22] & 255) << 16 | (ne[23] & 255) << 24, ht = ne[24] & 255 | (ne[25] & 255) << 8 | (ne[26] & 255) << 16 | (ne[27] & 255) << 24, dt = ne[28] & 255 | (ne[29] & 255) << 8 | (ne[30] & 255) << 16 | (ne[31] & 255) << 24, lt = O[12] & 255 | (O[13] & 255) << 8 | (O[14] & 255) << 16 | (O[15] & 255) << 24, tt = ae, ot = we, Qe = xe, rt = Re, it = De, Ye = ze, Oe = Ue, Pe = mt, Ke = et, Fe = ut, We = ct, Xe = vt, bt = pt, _t = ht, St = dt, xt = lt, ye, Rt = 0; Rt < 20; Rt += 2)
        ye = tt + bt | 0, it ^= ye << 7 | ye >>> 25, ye = it + tt | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + it | 0, bt ^= ye << 13 | ye >>> 19, ye = bt + Ke | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + ot | 0, Fe ^= ye << 7 | ye >>> 25, ye = Fe + Ye | 0, _t ^= ye << 9 | ye >>> 23, ye = _t + Fe | 0, ot ^= ye << 13 | ye >>> 19, ye = ot + _t | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Oe | 0, St ^= ye << 7 | ye >>> 25, ye = St + We | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + St | 0, Oe ^= ye << 13 | ye >>> 19, ye = Oe + Qe | 0, We ^= ye << 18 | ye >>> 14, ye = xt + Xe | 0, rt ^= ye << 7 | ye >>> 25, ye = rt + xt | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + rt | 0, Xe ^= ye << 13 | ye >>> 19, ye = Xe + Pe | 0, xt ^= ye << 18 | ye >>> 14, ye = tt + rt | 0, ot ^= ye << 7 | ye >>> 25, ye = ot + tt | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + ot | 0, rt ^= ye << 13 | ye >>> 19, ye = rt + Qe | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + it | 0, Oe ^= ye << 7 | ye >>> 25, ye = Oe + Ye | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + Oe | 0, it ^= ye << 13 | ye >>> 19, ye = it + Pe | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Fe | 0, Xe ^= ye << 7 | ye >>> 25, ye = Xe + We | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + Xe | 0, Fe ^= ye << 13 | ye >>> 19, ye = Fe + Ke | 0, We ^= ye << 18 | ye >>> 14, ye = xt + St | 0, bt ^= ye << 7 | ye >>> 25, ye = bt + xt | 0, _t ^= ye << 9 | ye >>> 23, ye = _t + bt | 0, St ^= ye << 13 | ye >>> 19, ye = St + _t | 0, xt ^= ye << 18 | ye >>> 14;
      tt = tt + ae | 0, ot = ot + we | 0, Qe = Qe + xe | 0, rt = rt + Re | 0, it = it + De | 0, Ye = Ye + ze | 0, Oe = Oe + Ue | 0, Pe = Pe + mt | 0, Ke = Ke + et | 0, Fe = Fe + ut | 0, We = We + ct | 0, Xe = Xe + vt | 0, bt = bt + pt | 0, _t = _t + ht | 0, St = St + dt | 0, xt = xt + lt | 0, $[0] = tt >>> 0 & 255, $[1] = tt >>> 8 & 255, $[2] = tt >>> 16 & 255, $[3] = tt >>> 24 & 255, $[4] = ot >>> 0 & 255, $[5] = ot >>> 8 & 255, $[6] = ot >>> 16 & 255, $[7] = ot >>> 24 & 255, $[8] = Qe >>> 0 & 255, $[9] = Qe >>> 8 & 255, $[10] = Qe >>> 16 & 255, $[11] = Qe >>> 24 & 255, $[12] = rt >>> 0 & 255, $[13] = rt >>> 8 & 255, $[14] = rt >>> 16 & 255, $[15] = rt >>> 24 & 255, $[16] = it >>> 0 & 255, $[17] = it >>> 8 & 255, $[18] = it >>> 16 & 255, $[19] = it >>> 24 & 255, $[20] = Ye >>> 0 & 255, $[21] = Ye >>> 8 & 255, $[22] = Ye >>> 16 & 255, $[23] = Ye >>> 24 & 255, $[24] = Oe >>> 0 & 255, $[25] = Oe >>> 8 & 255, $[26] = Oe >>> 16 & 255, $[27] = Oe >>> 24 & 255, $[28] = Pe >>> 0 & 255, $[29] = Pe >>> 8 & 255, $[30] = Pe >>> 16 & 255, $[31] = Pe >>> 24 & 255, $[32] = Ke >>> 0 & 255, $[33] = Ke >>> 8 & 255, $[34] = Ke >>> 16 & 255, $[35] = Ke >>> 24 & 255, $[36] = Fe >>> 0 & 255, $[37] = Fe >>> 8 & 255, $[38] = Fe >>> 16 & 255, $[39] = Fe >>> 24 & 255, $[40] = We >>> 0 & 255, $[41] = We >>> 8 & 255, $[42] = We >>> 16 & 255, $[43] = We >>> 24 & 255, $[44] = Xe >>> 0 & 255, $[45] = Xe >>> 8 & 255, $[46] = Xe >>> 16 & 255, $[47] = Xe >>> 24 & 255, $[48] = bt >>> 0 & 255, $[49] = bt >>> 8 & 255, $[50] = bt >>> 16 & 255, $[51] = bt >>> 24 & 255, $[52] = _t >>> 0 & 255, $[53] = _t >>> 8 & 255, $[54] = _t >>> 16 & 255, $[55] = _t >>> 24 & 255, $[56] = St >>> 0 & 255, $[57] = St >>> 8 & 255, $[58] = St >>> 16 & 255, $[59] = St >>> 24 & 255, $[60] = xt >>> 0 & 255, $[61] = xt >>> 8 & 255, $[62] = xt >>> 16 & 255, $[63] = xt >>> 24 & 255;
    }
    function k($, X, ne, O) {
      for (var ae = O[0] & 255 | (O[1] & 255) << 8 | (O[2] & 255) << 16 | (O[3] & 255) << 24, we = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, xe = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, Re = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, De = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, ze = O[4] & 255 | (O[5] & 255) << 8 | (O[6] & 255) << 16 | (O[7] & 255) << 24, Ue = X[0] & 255 | (X[1] & 255) << 8 | (X[2] & 255) << 16 | (X[3] & 255) << 24, mt = X[4] & 255 | (X[5] & 255) << 8 | (X[6] & 255) << 16 | (X[7] & 255) << 24, et = X[8] & 255 | (X[9] & 255) << 8 | (X[10] & 255) << 16 | (X[11] & 255) << 24, ut = X[12] & 255 | (X[13] & 255) << 8 | (X[14] & 255) << 16 | (X[15] & 255) << 24, ct = O[8] & 255 | (O[9] & 255) << 8 | (O[10] & 255) << 16 | (O[11] & 255) << 24, vt = ne[16] & 255 | (ne[17] & 255) << 8 | (ne[18] & 255) << 16 | (ne[19] & 255) << 24, pt = ne[20] & 255 | (ne[21] & 255) << 8 | (ne[22] & 255) << 16 | (ne[23] & 255) << 24, ht = ne[24] & 255 | (ne[25] & 255) << 8 | (ne[26] & 255) << 16 | (ne[27] & 255) << 24, dt = ne[28] & 255 | (ne[29] & 255) << 8 | (ne[30] & 255) << 16 | (ne[31] & 255) << 24, lt = O[12] & 255 | (O[13] & 255) << 8 | (O[14] & 255) << 16 | (O[15] & 255) << 24, tt = ae, ot = we, Qe = xe, rt = Re, it = De, Ye = ze, Oe = Ue, Pe = mt, Ke = et, Fe = ut, We = ct, Xe = vt, bt = pt, _t = ht, St = dt, xt = lt, ye, Rt = 0; Rt < 20; Rt += 2)
        ye = tt + bt | 0, it ^= ye << 7 | ye >>> 25, ye = it + tt | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + it | 0, bt ^= ye << 13 | ye >>> 19, ye = bt + Ke | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + ot | 0, Fe ^= ye << 7 | ye >>> 25, ye = Fe + Ye | 0, _t ^= ye << 9 | ye >>> 23, ye = _t + Fe | 0, ot ^= ye << 13 | ye >>> 19, ye = ot + _t | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Oe | 0, St ^= ye << 7 | ye >>> 25, ye = St + We | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + St | 0, Oe ^= ye << 13 | ye >>> 19, ye = Oe + Qe | 0, We ^= ye << 18 | ye >>> 14, ye = xt + Xe | 0, rt ^= ye << 7 | ye >>> 25, ye = rt + xt | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + rt | 0, Xe ^= ye << 13 | ye >>> 19, ye = Xe + Pe | 0, xt ^= ye << 18 | ye >>> 14, ye = tt + rt | 0, ot ^= ye << 7 | ye >>> 25, ye = ot + tt | 0, Qe ^= ye << 9 | ye >>> 23, ye = Qe + ot | 0, rt ^= ye << 13 | ye >>> 19, ye = rt + Qe | 0, tt ^= ye << 18 | ye >>> 14, ye = Ye + it | 0, Oe ^= ye << 7 | ye >>> 25, ye = Oe + Ye | 0, Pe ^= ye << 9 | ye >>> 23, ye = Pe + Oe | 0, it ^= ye << 13 | ye >>> 19, ye = it + Pe | 0, Ye ^= ye << 18 | ye >>> 14, ye = We + Fe | 0, Xe ^= ye << 7 | ye >>> 25, ye = Xe + We | 0, Ke ^= ye << 9 | ye >>> 23, ye = Ke + Xe | 0, Fe ^= ye << 13 | ye >>> 19, ye = Fe + Ke | 0, We ^= ye << 18 | ye >>> 14, ye = xt + St | 0, bt ^= ye << 7 | ye >>> 25, ye = bt + xt | 0, _t ^= ye << 9 | ye >>> 23, ye = _t + bt | 0, St ^= ye << 13 | ye >>> 19, ye = St + _t | 0, xt ^= ye << 18 | ye >>> 14;
      $[0] = tt >>> 0 & 255, $[1] = tt >>> 8 & 255, $[2] = tt >>> 16 & 255, $[3] = tt >>> 24 & 255, $[4] = Ye >>> 0 & 255, $[5] = Ye >>> 8 & 255, $[6] = Ye >>> 16 & 255, $[7] = Ye >>> 24 & 255, $[8] = We >>> 0 & 255, $[9] = We >>> 8 & 255, $[10] = We >>> 16 & 255, $[11] = We >>> 24 & 255, $[12] = xt >>> 0 & 255, $[13] = xt >>> 8 & 255, $[14] = xt >>> 16 & 255, $[15] = xt >>> 24 & 255, $[16] = Oe >>> 0 & 255, $[17] = Oe >>> 8 & 255, $[18] = Oe >>> 16 & 255, $[19] = Oe >>> 24 & 255, $[20] = Pe >>> 0 & 255, $[21] = Pe >>> 8 & 255, $[22] = Pe >>> 16 & 255, $[23] = Pe >>> 24 & 255, $[24] = Ke >>> 0 & 255, $[25] = Ke >>> 8 & 255, $[26] = Ke >>> 16 & 255, $[27] = Ke >>> 24 & 255, $[28] = Fe >>> 0 & 255, $[29] = Fe >>> 8 & 255, $[30] = Fe >>> 16 & 255, $[31] = Fe >>> 24 & 255;
    }
    function N($, X, ne, O) {
      T($, X, ne, O);
    }
    function q($, X, ne, O) {
      k($, X, ne, O);
    }
    var D = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function U($, X, ne, O, ae, we, xe) {
      var Re = new Uint8Array(16), De = new Uint8Array(64), ze, Ue;
      for (Ue = 0; Ue < 16; Ue++)
        Re[Ue] = 0;
      for (Ue = 0; Ue < 8; Ue++)
        Re[Ue] = we[Ue];
      for (; ae >= 64; ) {
        for (N(De, Re, xe, D), Ue = 0; Ue < 64; Ue++)
          $[X + Ue] = ne[O + Ue] ^ De[Ue];
        for (ze = 1, Ue = 8; Ue < 16; Ue++)
          ze = ze + (Re[Ue] & 255) | 0, Re[Ue] = ze & 255, ze >>>= 8;
        ae -= 64, X += 64, O += 64;
      }
      if (ae > 0)
        for (N(De, Re, xe, D), Ue = 0; Ue < ae; Ue++)
          $[X + Ue] = ne[O + Ue] ^ De[Ue];
      return 0;
    }
    function z($, X, ne, O, ae) {
      var we = new Uint8Array(16), xe = new Uint8Array(64), Re, De;
      for (De = 0; De < 16; De++)
        we[De] = 0;
      for (De = 0; De < 8; De++)
        we[De] = O[De];
      for (; ne >= 64; ) {
        for (N(xe, we, ae, D), De = 0; De < 64; De++)
          $[X + De] = xe[De];
        for (Re = 1, De = 8; De < 16; De++)
          Re = Re + (we[De] & 255) | 0, we[De] = Re & 255, Re >>>= 8;
        ne -= 64, X += 64;
      }
      if (ne > 0)
        for (N(xe, we, ae, D), De = 0; De < ne; De++)
          $[X + De] = xe[De];
      return 0;
    }
    function Y($, X, ne, O, ae) {
      var we = new Uint8Array(32);
      q(we, O, ae, D);
      for (var xe = new Uint8Array(8), Re = 0; Re < 8; Re++)
        xe[Re] = O[Re + 16];
      return z($, X, ne, xe, we);
    }
    function ue($, X, ne, O, ae, we, xe) {
      var Re = new Uint8Array(32);
      q(Re, we, xe, D);
      for (var De = new Uint8Array(8), ze = 0; ze < 8; ze++)
        De[ze] = we[ze + 16];
      return U($, X, ne, O, ae, De, Re);
    }
    var j = function($) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var X, ne, O, ae, we, xe, Re, De;
      X = $[0] & 255 | ($[1] & 255) << 8, this.r[0] = X & 8191, ne = $[2] & 255 | ($[3] & 255) << 8, this.r[1] = (X >>> 13 | ne << 3) & 8191, O = $[4] & 255 | ($[5] & 255) << 8, this.r[2] = (ne >>> 10 | O << 6) & 7939, ae = $[6] & 255 | ($[7] & 255) << 8, this.r[3] = (O >>> 7 | ae << 9) & 8191, we = $[8] & 255 | ($[9] & 255) << 8, this.r[4] = (ae >>> 4 | we << 12) & 255, this.r[5] = we >>> 1 & 8190, xe = $[10] & 255 | ($[11] & 255) << 8, this.r[6] = (we >>> 14 | xe << 2) & 8191, Re = $[12] & 255 | ($[13] & 255) << 8, this.r[7] = (xe >>> 11 | Re << 5) & 8065, De = $[14] & 255 | ($[15] & 255) << 8, this.r[8] = (Re >>> 8 | De << 8) & 8191, this.r[9] = De >>> 5 & 127, this.pad[0] = $[16] & 255 | ($[17] & 255) << 8, this.pad[1] = $[18] & 255 | ($[19] & 255) << 8, this.pad[2] = $[20] & 255 | ($[21] & 255) << 8, this.pad[3] = $[22] & 255 | ($[23] & 255) << 8, this.pad[4] = $[24] & 255 | ($[25] & 255) << 8, this.pad[5] = $[26] & 255 | ($[27] & 255) << 8, this.pad[6] = $[28] & 255 | ($[29] & 255) << 8, this.pad[7] = $[30] & 255 | ($[31] & 255) << 8;
    };
    j.prototype.blocks = function($, X, ne) {
      for (var O = this.fin ? 0 : 2048, ae, we, xe, Re, De, ze, Ue, mt, et, ut, ct, vt, pt, ht, dt, lt, tt, ot, Qe, rt = this.h[0], it = this.h[1], Ye = this.h[2], Oe = this.h[3], Pe = this.h[4], Ke = this.h[5], Fe = this.h[6], We = this.h[7], Xe = this.h[8], bt = this.h[9], _t = this.r[0], St = this.r[1], xt = this.r[2], ye = this.r[3], Rt = this.r[4], Ct = this.r[5], Nt = this.r[6], Mt = this.r[7], Ot = this.r[8], Pt = this.r[9]; ne >= 16; )
        ae = $[X + 0] & 255 | ($[X + 1] & 255) << 8, rt += ae & 8191, we = $[X + 2] & 255 | ($[X + 3] & 255) << 8, it += (ae >>> 13 | we << 3) & 8191, xe = $[X + 4] & 255 | ($[X + 5] & 255) << 8, Ye += (we >>> 10 | xe << 6) & 8191, Re = $[X + 6] & 255 | ($[X + 7] & 255) << 8, Oe += (xe >>> 7 | Re << 9) & 8191, De = $[X + 8] & 255 | ($[X + 9] & 255) << 8, Pe += (Re >>> 4 | De << 12) & 8191, Ke += De >>> 1 & 8191, ze = $[X + 10] & 255 | ($[X + 11] & 255) << 8, Fe += (De >>> 14 | ze << 2) & 8191, Ue = $[X + 12] & 255 | ($[X + 13] & 255) << 8, We += (ze >>> 11 | Ue << 5) & 8191, mt = $[X + 14] & 255 | ($[X + 15] & 255) << 8, Xe += (Ue >>> 8 | mt << 8) & 8191, bt += mt >>> 5 | O, et = 0, ut = et, ut += rt * _t, ut += it * (5 * Pt), ut += Ye * (5 * Ot), ut += Oe * (5 * Mt), ut += Pe * (5 * Nt), et = ut >>> 13, ut &= 8191, ut += Ke * (5 * Ct), ut += Fe * (5 * Rt), ut += We * (5 * ye), ut += Xe * (5 * xt), ut += bt * (5 * St), et += ut >>> 13, ut &= 8191, ct = et, ct += rt * St, ct += it * _t, ct += Ye * (5 * Pt), ct += Oe * (5 * Ot), ct += Pe * (5 * Mt), et = ct >>> 13, ct &= 8191, ct += Ke * (5 * Nt), ct += Fe * (5 * Ct), ct += We * (5 * Rt), ct += Xe * (5 * ye), ct += bt * (5 * xt), et += ct >>> 13, ct &= 8191, vt = et, vt += rt * xt, vt += it * St, vt += Ye * _t, vt += Oe * (5 * Pt), vt += Pe * (5 * Ot), et = vt >>> 13, vt &= 8191, vt += Ke * (5 * Mt), vt += Fe * (5 * Nt), vt += We * (5 * Ct), vt += Xe * (5 * Rt), vt += bt * (5 * ye), et += vt >>> 13, vt &= 8191, pt = et, pt += rt * ye, pt += it * xt, pt += Ye * St, pt += Oe * _t, pt += Pe * (5 * Pt), et = pt >>> 13, pt &= 8191, pt += Ke * (5 * Ot), pt += Fe * (5 * Mt), pt += We * (5 * Nt), pt += Xe * (5 * Ct), pt += bt * (5 * Rt), et += pt >>> 13, pt &= 8191, ht = et, ht += rt * Rt, ht += it * ye, ht += Ye * xt, ht += Oe * St, ht += Pe * _t, et = ht >>> 13, ht &= 8191, ht += Ke * (5 * Pt), ht += Fe * (5 * Ot), ht += We * (5 * Mt), ht += Xe * (5 * Nt), ht += bt * (5 * Ct), et += ht >>> 13, ht &= 8191, dt = et, dt += rt * Ct, dt += it * Rt, dt += Ye * ye, dt += Oe * xt, dt += Pe * St, et = dt >>> 13, dt &= 8191, dt += Ke * _t, dt += Fe * (5 * Pt), dt += We * (5 * Ot), dt += Xe * (5 * Mt), dt += bt * (5 * Nt), et += dt >>> 13, dt &= 8191, lt = et, lt += rt * Nt, lt += it * Ct, lt += Ye * Rt, lt += Oe * ye, lt += Pe * xt, et = lt >>> 13, lt &= 8191, lt += Ke * St, lt += Fe * _t, lt += We * (5 * Pt), lt += Xe * (5 * Ot), lt += bt * (5 * Mt), et += lt >>> 13, lt &= 8191, tt = et, tt += rt * Mt, tt += it * Nt, tt += Ye * Ct, tt += Oe * Rt, tt += Pe * ye, et = tt >>> 13, tt &= 8191, tt += Ke * xt, tt += Fe * St, tt += We * _t, tt += Xe * (5 * Pt), tt += bt * (5 * Ot), et += tt >>> 13, tt &= 8191, ot = et, ot += rt * Ot, ot += it * Mt, ot += Ye * Nt, ot += Oe * Ct, ot += Pe * Rt, et = ot >>> 13, ot &= 8191, ot += Ke * ye, ot += Fe * xt, ot += We * St, ot += Xe * _t, ot += bt * (5 * Pt), et += ot >>> 13, ot &= 8191, Qe = et, Qe += rt * Pt, Qe += it * Ot, Qe += Ye * Mt, Qe += Oe * Nt, Qe += Pe * Ct, et = Qe >>> 13, Qe &= 8191, Qe += Ke * Rt, Qe += Fe * ye, Qe += We * xt, Qe += Xe * St, Qe += bt * _t, et += Qe >>> 13, Qe &= 8191, et = (et << 2) + et | 0, et = et + ut | 0, ut = et & 8191, et = et >>> 13, ct += et, rt = ut, it = ct, Ye = vt, Oe = pt, Pe = ht, Ke = dt, Fe = lt, We = tt, Xe = ot, bt = Qe, X += 16, ne -= 16;
      this.h[0] = rt, this.h[1] = it, this.h[2] = Ye, this.h[3] = Oe, this.h[4] = Pe, this.h[5] = Ke, this.h[6] = Fe, this.h[7] = We, this.h[8] = Xe, this.h[9] = bt;
    }, j.prototype.finish = function($, X) {
      var ne = new Uint16Array(10), O, ae, we, xe;
      if (this.leftover) {
        for (xe = this.leftover, this.buffer[xe++] = 1; xe < 16; xe++)
          this.buffer[xe] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (O = this.h[1] >>> 13, this.h[1] &= 8191, xe = 2; xe < 10; xe++)
        this.h[xe] += O, O = this.h[xe] >>> 13, this.h[xe] &= 8191;
      for (this.h[0] += O * 5, O = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += O, O = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += O, ne[0] = this.h[0] + 5, O = ne[0] >>> 13, ne[0] &= 8191, xe = 1; xe < 10; xe++)
        ne[xe] = this.h[xe] + O, O = ne[xe] >>> 13, ne[xe] &= 8191;
      for (ne[9] -= 8192, ae = (O ^ 1) - 1, xe = 0; xe < 10; xe++)
        ne[xe] &= ae;
      for (ae = ~ae, xe = 0; xe < 10; xe++)
        this.h[xe] = this.h[xe] & ae | ne[xe];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, we = this.h[0] + this.pad[0], this.h[0] = we & 65535, xe = 1; xe < 8; xe++)
        we = (this.h[xe] + this.pad[xe] | 0) + (we >>> 16) | 0, this.h[xe] = we & 65535;
      $[X + 0] = this.h[0] >>> 0 & 255, $[X + 1] = this.h[0] >>> 8 & 255, $[X + 2] = this.h[1] >>> 0 & 255, $[X + 3] = this.h[1] >>> 8 & 255, $[X + 4] = this.h[2] >>> 0 & 255, $[X + 5] = this.h[2] >>> 8 & 255, $[X + 6] = this.h[3] >>> 0 & 255, $[X + 7] = this.h[3] >>> 8 & 255, $[X + 8] = this.h[4] >>> 0 & 255, $[X + 9] = this.h[4] >>> 8 & 255, $[X + 10] = this.h[5] >>> 0 & 255, $[X + 11] = this.h[5] >>> 8 & 255, $[X + 12] = this.h[6] >>> 0 & 255, $[X + 13] = this.h[6] >>> 8 & 255, $[X + 14] = this.h[7] >>> 0 & 255, $[X + 15] = this.h[7] >>> 8 & 255;
    }, j.prototype.update = function($, X, ne) {
      var O, ae;
      if (this.leftover) {
        for (ae = 16 - this.leftover, ae > ne && (ae = ne), O = 0; O < ae; O++)
          this.buffer[this.leftover + O] = $[X + O];
        if (ne -= ae, X += ae, this.leftover += ae, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (ne >= 16 && (ae = ne - ne % 16, this.blocks($, X, ae), X += ae, ne -= ae), ne) {
        for (O = 0; O < ne; O++)
          this.buffer[this.leftover + O] = $[X + O];
        this.leftover += ne;
      }
    };
    function g($, X, ne, O, ae, we) {
      var xe = new j(we);
      return xe.update(ne, O, ae), xe.finish($, X), 0;
    }
    function b($, X, ne, O, ae, we) {
      var xe = new Uint8Array(16);
      return g(xe, 0, ne, O, ae, we), I($, X, xe, 0);
    }
    function a($, X, ne, O, ae) {
      var we;
      if (ne < 32)
        return -1;
      for (ue($, 0, X, 0, ne, O, ae), g($, 16, $, 32, ne - 32, $), we = 0; we < 16; we++)
        $[we] = 0;
      return 0;
    }
    function d($, X, ne, O, ae) {
      var we, xe = new Uint8Array(32);
      if (ne < 32 || (Y(xe, 0, 32, O, ae), b(X, 16, X, 32, ne - 32, xe) !== 0))
        return -1;
      for (ue($, 0, X, 0, ne, O, ae), we = 0; we < 32; we++)
        $[we] = 0;
      return 0;
    }
    function w($, X) {
      var ne;
      for (ne = 0; ne < 16; ne++)
        $[ne] = X[ne] | 0;
    }
    function x($) {
      var X, ne, O = 1;
      for (X = 0; X < 16; X++)
        ne = $[X] + O + 65535, O = Math.floor(ne / 65536), $[X] = ne - O * 65536;
      $[0] += O - 1 + 37 * (O - 1);
    }
    function A($, X, ne) {
      for (var O, ae = ~(ne - 1), we = 0; we < 16; we++)
        O = ae & ($[we] ^ X[we]), $[we] ^= O, X[we] ^= O;
    }
    function S($, X) {
      var ne, O, ae, we = r(), xe = r();
      for (ne = 0; ne < 16; ne++)
        xe[ne] = X[ne];
      for (x(xe), x(xe), x(xe), O = 0; O < 2; O++) {
        for (we[0] = xe[0] - 65517, ne = 1; ne < 15; ne++)
          we[ne] = xe[ne] - 65535 - (we[ne - 1] >> 16 & 1), we[ne - 1] &= 65535;
        we[15] = xe[15] - 32767 - (we[14] >> 16 & 1), ae = we[15] >> 16 & 1, we[14] &= 65535, A(xe, we, 1 - ae);
      }
      for (ne = 0; ne < 16; ne++)
        $[2 * ne] = xe[ne] & 255, $[2 * ne + 1] = xe[ne] >> 8;
    }
    function y($, X) {
      var ne = new Uint8Array(32), O = new Uint8Array(32);
      return S(ne, $), S(O, X), B(ne, 0, O, 0);
    }
    function _($) {
      var X = new Uint8Array(32);
      return S(X, $), X[0] & 1;
    }
    function l($, X) {
      var ne;
      for (ne = 0; ne < 16; ne++)
        $[ne] = X[2 * ne] + (X[2 * ne + 1] << 8);
      $[15] &= 32767;
    }
    function R($, X, ne) {
      for (var O = 0; O < 16; O++)
        $[O] = X[O] + ne[O];
    }
    function ee($, X, ne) {
      for (var O = 0; O < 16; O++)
        $[O] = X[O] - ne[O];
    }
    function oe($, X, ne) {
      var O, ae, we = 0, xe = 0, Re = 0, De = 0, ze = 0, Ue = 0, mt = 0, et = 0, ut = 0, ct = 0, vt = 0, pt = 0, ht = 0, dt = 0, lt = 0, tt = 0, ot = 0, Qe = 0, rt = 0, it = 0, Ye = 0, Oe = 0, Pe = 0, Ke = 0, Fe = 0, We = 0, Xe = 0, bt = 0, _t = 0, St = 0, xt = 0, ye = ne[0], Rt = ne[1], Ct = ne[2], Nt = ne[3], Mt = ne[4], Ot = ne[5], Pt = ne[6], Yt = ne[7], $t = ne[8], Zt = ne[9], Gt = ne[10], Jt = ne[11], nr = ne[12], lr = ne[13], dr = ne[14], pr = ne[15];
      O = X[0], we += O * ye, xe += O * Rt, Re += O * Ct, De += O * Nt, ze += O * Mt, Ue += O * Ot, mt += O * Pt, et += O * Yt, ut += O * $t, ct += O * Zt, vt += O * Gt, pt += O * Jt, ht += O * nr, dt += O * lr, lt += O * dr, tt += O * pr, O = X[1], xe += O * ye, Re += O * Rt, De += O * Ct, ze += O * Nt, Ue += O * Mt, mt += O * Ot, et += O * Pt, ut += O * Yt, ct += O * $t, vt += O * Zt, pt += O * Gt, ht += O * Jt, dt += O * nr, lt += O * lr, tt += O * dr, ot += O * pr, O = X[2], Re += O * ye, De += O * Rt, ze += O * Ct, Ue += O * Nt, mt += O * Mt, et += O * Ot, ut += O * Pt, ct += O * Yt, vt += O * $t, pt += O * Zt, ht += O * Gt, dt += O * Jt, lt += O * nr, tt += O * lr, ot += O * dr, Qe += O * pr, O = X[3], De += O * ye, ze += O * Rt, Ue += O * Ct, mt += O * Nt, et += O * Mt, ut += O * Ot, ct += O * Pt, vt += O * Yt, pt += O * $t, ht += O * Zt, dt += O * Gt, lt += O * Jt, tt += O * nr, ot += O * lr, Qe += O * dr, rt += O * pr, O = X[4], ze += O * ye, Ue += O * Rt, mt += O * Ct, et += O * Nt, ut += O * Mt, ct += O * Ot, vt += O * Pt, pt += O * Yt, ht += O * $t, dt += O * Zt, lt += O * Gt, tt += O * Jt, ot += O * nr, Qe += O * lr, rt += O * dr, it += O * pr, O = X[5], Ue += O * ye, mt += O * Rt, et += O * Ct, ut += O * Nt, ct += O * Mt, vt += O * Ot, pt += O * Pt, ht += O * Yt, dt += O * $t, lt += O * Zt, tt += O * Gt, ot += O * Jt, Qe += O * nr, rt += O * lr, it += O * dr, Ye += O * pr, O = X[6], mt += O * ye, et += O * Rt, ut += O * Ct, ct += O * Nt, vt += O * Mt, pt += O * Ot, ht += O * Pt, dt += O * Yt, lt += O * $t, tt += O * Zt, ot += O * Gt, Qe += O * Jt, rt += O * nr, it += O * lr, Ye += O * dr, Oe += O * pr, O = X[7], et += O * ye, ut += O * Rt, ct += O * Ct, vt += O * Nt, pt += O * Mt, ht += O * Ot, dt += O * Pt, lt += O * Yt, tt += O * $t, ot += O * Zt, Qe += O * Gt, rt += O * Jt, it += O * nr, Ye += O * lr, Oe += O * dr, Pe += O * pr, O = X[8], ut += O * ye, ct += O * Rt, vt += O * Ct, pt += O * Nt, ht += O * Mt, dt += O * Ot, lt += O * Pt, tt += O * Yt, ot += O * $t, Qe += O * Zt, rt += O * Gt, it += O * Jt, Ye += O * nr, Oe += O * lr, Pe += O * dr, Ke += O * pr, O = X[9], ct += O * ye, vt += O * Rt, pt += O * Ct, ht += O * Nt, dt += O * Mt, lt += O * Ot, tt += O * Pt, ot += O * Yt, Qe += O * $t, rt += O * Zt, it += O * Gt, Ye += O * Jt, Oe += O * nr, Pe += O * lr, Ke += O * dr, Fe += O * pr, O = X[10], vt += O * ye, pt += O * Rt, ht += O * Ct, dt += O * Nt, lt += O * Mt, tt += O * Ot, ot += O * Pt, Qe += O * Yt, rt += O * $t, it += O * Zt, Ye += O * Gt, Oe += O * Jt, Pe += O * nr, Ke += O * lr, Fe += O * dr, We += O * pr, O = X[11], pt += O * ye, ht += O * Rt, dt += O * Ct, lt += O * Nt, tt += O * Mt, ot += O * Ot, Qe += O * Pt, rt += O * Yt, it += O * $t, Ye += O * Zt, Oe += O * Gt, Pe += O * Jt, Ke += O * nr, Fe += O * lr, We += O * dr, Xe += O * pr, O = X[12], ht += O * ye, dt += O * Rt, lt += O * Ct, tt += O * Nt, ot += O * Mt, Qe += O * Ot, rt += O * Pt, it += O * Yt, Ye += O * $t, Oe += O * Zt, Pe += O * Gt, Ke += O * Jt, Fe += O * nr, We += O * lr, Xe += O * dr, bt += O * pr, O = X[13], dt += O * ye, lt += O * Rt, tt += O * Ct, ot += O * Nt, Qe += O * Mt, rt += O * Ot, it += O * Pt, Ye += O * Yt, Oe += O * $t, Pe += O * Zt, Ke += O * Gt, Fe += O * Jt, We += O * nr, Xe += O * lr, bt += O * dr, _t += O * pr, O = X[14], lt += O * ye, tt += O * Rt, ot += O * Ct, Qe += O * Nt, rt += O * Mt, it += O * Ot, Ye += O * Pt, Oe += O * Yt, Pe += O * $t, Ke += O * Zt, Fe += O * Gt, We += O * Jt, Xe += O * nr, bt += O * lr, _t += O * dr, St += O * pr, O = X[15], tt += O * ye, ot += O * Rt, Qe += O * Ct, rt += O * Nt, it += O * Mt, Ye += O * Ot, Oe += O * Pt, Pe += O * Yt, Ke += O * $t, Fe += O * Zt, We += O * Gt, Xe += O * Jt, bt += O * nr, _t += O * lr, St += O * dr, xt += O * pr, we += 38 * ot, xe += 38 * Qe, Re += 38 * rt, De += 38 * it, ze += 38 * Ye, Ue += 38 * Oe, mt += 38 * Pe, et += 38 * Ke, ut += 38 * Fe, ct += 38 * We, vt += 38 * Xe, pt += 38 * bt, ht += 38 * _t, dt += 38 * St, lt += 38 * xt, ae = 1, O = we + ae + 65535, ae = Math.floor(O / 65536), we = O - ae * 65536, O = xe + ae + 65535, ae = Math.floor(O / 65536), xe = O - ae * 65536, O = Re + ae + 65535, ae = Math.floor(O / 65536), Re = O - ae * 65536, O = De + ae + 65535, ae = Math.floor(O / 65536), De = O - ae * 65536, O = ze + ae + 65535, ae = Math.floor(O / 65536), ze = O - ae * 65536, O = Ue + ae + 65535, ae = Math.floor(O / 65536), Ue = O - ae * 65536, O = mt + ae + 65535, ae = Math.floor(O / 65536), mt = O - ae * 65536, O = et + ae + 65535, ae = Math.floor(O / 65536), et = O - ae * 65536, O = ut + ae + 65535, ae = Math.floor(O / 65536), ut = O - ae * 65536, O = ct + ae + 65535, ae = Math.floor(O / 65536), ct = O - ae * 65536, O = vt + ae + 65535, ae = Math.floor(O / 65536), vt = O - ae * 65536, O = pt + ae + 65535, ae = Math.floor(O / 65536), pt = O - ae * 65536, O = ht + ae + 65535, ae = Math.floor(O / 65536), ht = O - ae * 65536, O = dt + ae + 65535, ae = Math.floor(O / 65536), dt = O - ae * 65536, O = lt + ae + 65535, ae = Math.floor(O / 65536), lt = O - ae * 65536, O = tt + ae + 65535, ae = Math.floor(O / 65536), tt = O - ae * 65536, we += ae - 1 + 37 * (ae - 1), ae = 1, O = we + ae + 65535, ae = Math.floor(O / 65536), we = O - ae * 65536, O = xe + ae + 65535, ae = Math.floor(O / 65536), xe = O - ae * 65536, O = Re + ae + 65535, ae = Math.floor(O / 65536), Re = O - ae * 65536, O = De + ae + 65535, ae = Math.floor(O / 65536), De = O - ae * 65536, O = ze + ae + 65535, ae = Math.floor(O / 65536), ze = O - ae * 65536, O = Ue + ae + 65535, ae = Math.floor(O / 65536), Ue = O - ae * 65536, O = mt + ae + 65535, ae = Math.floor(O / 65536), mt = O - ae * 65536, O = et + ae + 65535, ae = Math.floor(O / 65536), et = O - ae * 65536, O = ut + ae + 65535, ae = Math.floor(O / 65536), ut = O - ae * 65536, O = ct + ae + 65535, ae = Math.floor(O / 65536), ct = O - ae * 65536, O = vt + ae + 65535, ae = Math.floor(O / 65536), vt = O - ae * 65536, O = pt + ae + 65535, ae = Math.floor(O / 65536), pt = O - ae * 65536, O = ht + ae + 65535, ae = Math.floor(O / 65536), ht = O - ae * 65536, O = dt + ae + 65535, ae = Math.floor(O / 65536), dt = O - ae * 65536, O = lt + ae + 65535, ae = Math.floor(O / 65536), lt = O - ae * 65536, O = tt + ae + 65535, ae = Math.floor(O / 65536), tt = O - ae * 65536, we += ae - 1 + 37 * (ae - 1), $[0] = we, $[1] = xe, $[2] = Re, $[3] = De, $[4] = ze, $[5] = Ue, $[6] = mt, $[7] = et, $[8] = ut, $[9] = ct, $[10] = vt, $[11] = pt, $[12] = ht, $[13] = dt, $[14] = lt, $[15] = tt;
    }
    function V($, X) {
      oe($, X, X);
    }
    function W($, X) {
      var ne = r(), O;
      for (O = 0; O < 16; O++)
        ne[O] = X[O];
      for (O = 253; O >= 0; O--)
        V(ne, ne), O !== 2 && O !== 4 && oe(ne, ne, X);
      for (O = 0; O < 16; O++)
        $[O] = ne[O];
    }
    function F($, X) {
      var ne = r(), O;
      for (O = 0; O < 16; O++)
        ne[O] = X[O];
      for (O = 250; O >= 0; O--)
        V(ne, ne), O !== 1 && oe(ne, ne, X);
      for (O = 0; O < 16; O++)
        $[O] = ne[O];
    }
    function re($, X, ne) {
      var O = new Uint8Array(32), ae = new Float64Array(80), we, xe, Re = r(), De = r(), ze = r(), Ue = r(), mt = r(), et = r();
      for (xe = 0; xe < 31; xe++)
        O[xe] = X[xe];
      for (O[31] = X[31] & 127 | 64, O[0] &= 248, l(ae, ne), xe = 0; xe < 16; xe++)
        De[xe] = ae[xe], Ue[xe] = Re[xe] = ze[xe] = 0;
      for (Re[0] = Ue[0] = 1, xe = 254; xe >= 0; --xe)
        we = O[xe >>> 3] >>> (xe & 7) & 1, A(Re, De, we), A(ze, Ue, we), R(mt, Re, ze), ee(Re, Re, ze), R(ze, De, Ue), ee(De, De, Ue), V(Ue, mt), V(et, Re), oe(Re, ze, Re), oe(ze, De, mt), R(mt, Re, ze), ee(Re, Re, ze), V(De, Re), ee(ze, Ue, et), oe(Re, ze, c), R(Re, Re, Ue), oe(ze, ze, Re), oe(Re, Ue, et), oe(Ue, De, ae), V(De, mt), A(Re, De, we), A(ze, Ue, we);
      for (xe = 0; xe < 16; xe++)
        ae[xe + 16] = Re[xe], ae[xe + 32] = ze[xe], ae[xe + 48] = De[xe], ae[xe + 64] = Ue[xe];
      var ut = ae.subarray(32), ct = ae.subarray(16);
      return W(ut, ut), oe(ct, ct, ut), S($, ct), 0;
    }
    function he($, X) {
      return re($, X, n);
    }
    function Z($, X) {
      return i(X, 32), he($, X);
    }
    function K($, X, ne) {
      var O = new Uint8Array(32);
      return re(O, ne, X), q($, o, O, D);
    }
    var ce = a, ve = d;
    function Be($, X, ne, O, ae, we) {
      var xe = new Uint8Array(32);
      return K(xe, ae, we), ce($, X, ne, O, xe);
    }
    function te($, X, ne, O, ae, we) {
      var xe = new Uint8Array(32);
      return K(xe, ae, we), ve($, X, ne, O, xe);
    }
    var C = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function L($, X, ne, O) {
      for (var ae = new Int32Array(16), we = new Int32Array(16), xe, Re, De, ze, Ue, mt, et, ut, ct, vt, pt, ht, dt, lt, tt, ot, Qe, rt, it, Ye, Oe, Pe, Ke, Fe, We, Xe, bt = $[0], _t = $[1], St = $[2], xt = $[3], ye = $[4], Rt = $[5], Ct = $[6], Nt = $[7], Mt = X[0], Ot = X[1], Pt = X[2], Yt = X[3], $t = X[4], Zt = X[5], Gt = X[6], Jt = X[7], nr = 0; O >= 128; ) {
        for (it = 0; it < 16; it++)
          Ye = 8 * it + nr, ae[it] = ne[Ye + 0] << 24 | ne[Ye + 1] << 16 | ne[Ye + 2] << 8 | ne[Ye + 3], we[it] = ne[Ye + 4] << 24 | ne[Ye + 5] << 16 | ne[Ye + 6] << 8 | ne[Ye + 7];
        for (it = 0; it < 80; it++)
          if (xe = bt, Re = _t, De = St, ze = xt, Ue = ye, mt = Rt, et = Ct, ut = Nt, ct = Mt, vt = Ot, pt = Pt, ht = Yt, dt = $t, lt = Zt, tt = Gt, ot = Jt, Oe = Nt, Pe = Jt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = (ye >>> 14 | $t << 18) ^ (ye >>> 18 | $t << 14) ^ ($t >>> 9 | ye << 23), Pe = ($t >>> 14 | ye << 18) ^ ($t >>> 18 | ye << 14) ^ (ye >>> 9 | $t << 23), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = ye & Rt ^ ~ye & Ct, Pe = $t & Zt ^ ~$t & Gt, Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = C[it * 2], Pe = C[it * 2 + 1], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = ae[it % 16], Pe = we[it % 16], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, Qe = We & 65535 | Xe << 16, rt = Ke & 65535 | Fe << 16, Oe = Qe, Pe = rt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = (bt >>> 28 | Mt << 4) ^ (Mt >>> 2 | bt << 30) ^ (Mt >>> 7 | bt << 25), Pe = (Mt >>> 28 | bt << 4) ^ (bt >>> 2 | Mt << 30) ^ (bt >>> 7 | Mt << 25), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Oe = bt & _t ^ bt & St ^ _t & St, Pe = Mt & Ot ^ Mt & Pt ^ Ot & Pt, Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, ut = We & 65535 | Xe << 16, ot = Ke & 65535 | Fe << 16, Oe = ze, Pe = ht, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = Qe, Pe = rt, Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, ze = We & 65535 | Xe << 16, ht = Ke & 65535 | Fe << 16, _t = xe, St = Re, xt = De, ye = ze, Rt = Ue, Ct = mt, Nt = et, bt = ut, Ot = ct, Pt = vt, Yt = pt, $t = ht, Zt = dt, Gt = lt, Jt = tt, Mt = ot, it % 16 === 15)
            for (Ye = 0; Ye < 16; Ye++)
              Oe = ae[Ye], Pe = we[Ye], Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = ae[(Ye + 9) % 16], Pe = we[(Ye + 9) % 16], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Qe = ae[(Ye + 1) % 16], rt = we[(Ye + 1) % 16], Oe = (Qe >>> 1 | rt << 31) ^ (Qe >>> 8 | rt << 24) ^ Qe >>> 7, Pe = (rt >>> 1 | Qe << 31) ^ (rt >>> 8 | Qe << 24) ^ (rt >>> 7 | Qe << 25), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Qe = ae[(Ye + 14) % 16], rt = we[(Ye + 14) % 16], Oe = (Qe >>> 19 | rt << 13) ^ (rt >>> 29 | Qe << 3) ^ Qe >>> 6, Pe = (rt >>> 19 | Qe << 13) ^ (Qe >>> 29 | rt << 3) ^ (rt >>> 6 | Qe << 26), Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, ae[Ye] = We & 65535 | Xe << 16, we[Ye] = Ke & 65535 | Fe << 16;
        Oe = bt, Pe = Mt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[0], Pe = X[0], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[0] = bt = We & 65535 | Xe << 16, X[0] = Mt = Ke & 65535 | Fe << 16, Oe = _t, Pe = Ot, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[1], Pe = X[1], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[1] = _t = We & 65535 | Xe << 16, X[1] = Ot = Ke & 65535 | Fe << 16, Oe = St, Pe = Pt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[2], Pe = X[2], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[2] = St = We & 65535 | Xe << 16, X[2] = Pt = Ke & 65535 | Fe << 16, Oe = xt, Pe = Yt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[3], Pe = X[3], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[3] = xt = We & 65535 | Xe << 16, X[3] = Yt = Ke & 65535 | Fe << 16, Oe = ye, Pe = $t, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[4], Pe = X[4], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[4] = ye = We & 65535 | Xe << 16, X[4] = $t = Ke & 65535 | Fe << 16, Oe = Rt, Pe = Zt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[5], Pe = X[5], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[5] = Rt = We & 65535 | Xe << 16, X[5] = Zt = Ke & 65535 | Fe << 16, Oe = Ct, Pe = Gt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[6], Pe = X[6], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[6] = Ct = We & 65535 | Xe << 16, X[6] = Gt = Ke & 65535 | Fe << 16, Oe = Nt, Pe = Jt, Ke = Pe & 65535, Fe = Pe >>> 16, We = Oe & 65535, Xe = Oe >>> 16, Oe = $[7], Pe = X[7], Ke += Pe & 65535, Fe += Pe >>> 16, We += Oe & 65535, Xe += Oe >>> 16, Fe += Ke >>> 16, We += Fe >>> 16, Xe += We >>> 16, $[7] = Nt = We & 65535 | Xe << 16, X[7] = Jt = Ke & 65535 | Fe << 16, nr += 128, O -= 128;
      }
      return O;
    }
    function G($, X, ne) {
      var O = new Int32Array(8), ae = new Int32Array(8), we = new Uint8Array(256), xe, Re = ne;
      for (O[0] = 1779033703, O[1] = 3144134277, O[2] = 1013904242, O[3] = 2773480762, O[4] = 1359893119, O[5] = 2600822924, O[6] = 528734635, O[7] = 1541459225, ae[0] = 4089235720, ae[1] = 2227873595, ae[2] = 4271175723, ae[3] = 1595750129, ae[4] = 2917565137, ae[5] = 725511199, ae[6] = 4215389547, ae[7] = 327033209, L(O, ae, X, ne), ne %= 128, xe = 0; xe < ne; xe++)
        we[xe] = X[Re - ne + xe];
      for (we[ne] = 128, ne = 256 - 128 * (ne < 112 ? 1 : 0), we[ne - 9] = 0, E(we, ne - 8, Re / 536870912 | 0, Re << 3), L(O, ae, we, ne), xe = 0; xe < 8; xe++)
        E($, 8 * xe, O[xe], ae[xe]);
      return 0;
    }
    function de($, X) {
      var ne = r(), O = r(), ae = r(), we = r(), xe = r(), Re = r(), De = r(), ze = r(), Ue = r();
      ee(ne, $[1], $[0]), ee(Ue, X[1], X[0]), oe(ne, ne, Ue), R(O, $[0], $[1]), R(Ue, X[0], X[1]), oe(O, O, Ue), oe(ae, $[3], X[3]), oe(ae, ae, s), oe(we, $[2], X[2]), R(we, we, we), ee(xe, O, ne), ee(Re, we, ae), R(De, we, ae), R(ze, O, ne), oe($[0], xe, Re), oe($[1], ze, De), oe($[2], De, Re), oe($[3], xe, ze);
    }
    function me($, X, ne) {
      var O;
      for (O = 0; O < 4; O++)
        A($[O], X[O], ne);
    }
    function Te($, X) {
      var ne = r(), O = r(), ae = r();
      W(ae, X[2]), oe(ne, X[0], ae), oe(O, X[1], ae), S($, O), $[31] ^= _(ne) << 7;
    }
    function He($, X, ne) {
      var O, ae;
      for (w($[0], f), w($[1], u), w($[2], u), w($[3], f), ae = 255; ae >= 0; --ae)
        O = ne[ae / 8 | 0] >> (ae & 7) & 1, me($, X, O), de(X, $), de($, $), me($, X, O);
    }
    function H($, X) {
      var ne = [r(), r(), r(), r()];
      w(ne[0], p), w(ne[1], v), w(ne[2], u), oe(ne[3], p, v), He($, ne, X);
    }
    function se($, X, ne) {
      var O = new Uint8Array(64), ae = [r(), r(), r(), r()], we;
      for (ne || i(X, 32), G(O, X, 32), O[0] &= 248, O[31] &= 127, O[31] |= 64, H(ae, O), Te($, ae), we = 0; we < 32; we++)
        X[we + 32] = $[we];
      return 0;
    }
    var fe = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function _e($, X) {
      var ne, O, ae, we;
      for (O = 63; O >= 32; --O) {
        for (ne = 0, ae = O - 32, we = O - 12; ae < we; ++ae)
          X[ae] += ne - 16 * X[O] * fe[ae - (O - 32)], ne = Math.floor((X[ae] + 128) / 256), X[ae] -= ne * 256;
        X[ae] += ne, X[O] = 0;
      }
      for (ne = 0, ae = 0; ae < 32; ae++)
        X[ae] += ne - (X[31] >> 4) * fe[ae], ne = X[ae] >> 8, X[ae] &= 255;
      for (ae = 0; ae < 32; ae++)
        X[ae] -= ne * fe[ae];
      for (O = 0; O < 32; O++)
        X[O + 1] += X[O] >> 8, $[O] = X[O] & 255;
    }
    function Ce($) {
      var X = new Float64Array(64), ne;
      for (ne = 0; ne < 64; ne++)
        X[ne] = $[ne];
      for (ne = 0; ne < 64; ne++)
        $[ne] = 0;
      _e($, X);
    }
    function Ve($, X, ne, O) {
      var ae = new Uint8Array(64), we = new Uint8Array(64), xe = new Uint8Array(64), Re, De, ze = new Float64Array(64), Ue = [r(), r(), r(), r()];
      G(ae, O, 32), ae[0] &= 248, ae[31] &= 127, ae[31] |= 64;
      var mt = ne + 64;
      for (Re = 0; Re < ne; Re++)
        $[64 + Re] = X[Re];
      for (Re = 0; Re < 32; Re++)
        $[32 + Re] = ae[32 + Re];
      for (G(xe, $.subarray(32), ne + 32), Ce(xe), H(Ue, xe), Te($, Ue), Re = 32; Re < 64; Re++)
        $[Re] = O[Re];
      for (G(we, $, ne + 64), Ce(we), Re = 0; Re < 64; Re++)
        ze[Re] = 0;
      for (Re = 0; Re < 32; Re++)
        ze[Re] = xe[Re];
      for (Re = 0; Re < 32; Re++)
        for (De = 0; De < 32; De++)
          ze[Re + De] += we[Re] * ae[De];
      return _e($.subarray(32), ze), mt;
    }
    function ke($, X) {
      var ne = r(), O = r(), ae = r(), we = r(), xe = r(), Re = r(), De = r();
      return w($[2], u), l($[1], X), V(ae, $[1]), oe(we, ae, h), ee(ae, ae, $[2]), R(we, $[2], we), V(xe, we), V(Re, xe), oe(De, Re, xe), oe(ne, De, ae), oe(ne, ne, we), F(ne, ne), oe(ne, ne, ae), oe(ne, ne, we), oe(ne, ne, we), oe($[0], ne, we), V(O, $[0]), oe(O, O, we), y(O, ae) && oe($[0], $[0], m), V(O, $[0]), oe(O, O, we), y(O, ae) ? -1 : (_($[0]) === X[31] >> 7 && ee($[0], f, $[0]), oe($[3], $[0], $[1]), 0);
    }
    function Q($, X, ne, O) {
      var ae, we = new Uint8Array(32), xe = new Uint8Array(64), Re = [r(), r(), r(), r()], De = [r(), r(), r(), r()];
      if (ne < 64 || ke(De, O))
        return -1;
      for (ae = 0; ae < ne; ae++)
        $[ae] = X[ae];
      for (ae = 0; ae < 32; ae++)
        $[ae + 32] = O[ae];
      if (G(xe, $, ne), Ce(xe), He(Re, De, xe), H(De, X.subarray(32)), de(Re, De), Te(we, Re), ne -= 64, B(X, 0, we, 0)) {
        for (ae = 0; ae < ne; ae++)
          $[ae] = 0;
        return -1;
      }
      for (ae = 0; ae < ne; ae++)
        $[ae] = X[ae + 64];
      return ne;
    }
    var Se = 32, Ae = 24, $e = 32, pe = 16, Ee = 32, J = 32, Ie = 32, qe = 32, P = 32, Me = Ae, be = $e, ie = pe, le = 64, ge = 32, Ge = 64, je = 32, Ne = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: q,
      crypto_stream_xor: ue,
      crypto_stream: Y,
      crypto_stream_salsa20_xor: U,
      crypto_stream_salsa20: z,
      crypto_onetimeauth: g,
      crypto_onetimeauth_verify: b,
      crypto_verify_16: I,
      crypto_verify_32: B,
      crypto_secretbox: a,
      crypto_secretbox_open: d,
      crypto_scalarmult: re,
      crypto_scalarmult_base: he,
      crypto_box_beforenm: K,
      crypto_box_afternm: ce,
      crypto_box: Be,
      crypto_box_open: te,
      crypto_box_keypair: Z,
      crypto_hash: G,
      crypto_sign: Ve,
      crypto_sign_keypair: se,
      crypto_sign_open: Q,
      crypto_secretbox_KEYBYTES: Se,
      crypto_secretbox_NONCEBYTES: Ae,
      crypto_secretbox_ZEROBYTES: $e,
      crypto_secretbox_BOXZEROBYTES: pe,
      crypto_scalarmult_BYTES: Ee,
      crypto_scalarmult_SCALARBYTES: J,
      crypto_box_PUBLICKEYBYTES: Ie,
      crypto_box_SECRETKEYBYTES: qe,
      crypto_box_BEFORENMBYTES: P,
      crypto_box_NONCEBYTES: Me,
      crypto_box_ZEROBYTES: be,
      crypto_box_BOXZEROBYTES: ie,
      crypto_sign_BYTES: le,
      crypto_sign_PUBLICKEYBYTES: ge,
      crypto_sign_SECRETKEYBYTES: Ge,
      crypto_sign_SEEDBYTES: je,
      crypto_hash_BYTES: Ne,
      gf: r,
      D: h,
      L: fe,
      pack25519: S,
      unpack25519: l,
      M: oe,
      A: R,
      S: V,
      Z: ee,
      pow2523: F,
      add: de,
      set25519: w,
      modL: _e,
      scalarmult: He,
      scalarbase: H
    };
    function nt($, X) {
      if ($.length !== Se)
        throw new Error("bad key size");
      if (X.length !== Ae)
        throw new Error("bad nonce size");
    }
    function st($, X) {
      if ($.length !== Ie)
        throw new Error("bad public key size");
      if (X.length !== qe)
        throw new Error("bad secret key size");
    }
    function Je() {
      for (var $ = 0; $ < arguments.length; $++)
        if (!(arguments[$] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function ft($) {
      for (var X = 0; X < $.length; X++)
        $[X] = 0;
    }
    t.randomBytes = function($) {
      var X = new Uint8Array($);
      return i(X, $), X;
    }, t.secretbox = function($, X, ne) {
      Je($, X, ne), nt(ne, X);
      for (var O = new Uint8Array($e + $.length), ae = new Uint8Array(O.length), we = 0; we < $.length; we++)
        O[we + $e] = $[we];
      return a(ae, O, O.length, X, ne), ae.subarray(pe);
    }, t.secretbox.open = function($, X, ne) {
      Je($, X, ne), nt(ne, X);
      for (var O = new Uint8Array(pe + $.length), ae = new Uint8Array(O.length), we = 0; we < $.length; we++)
        O[we + pe] = $[we];
      return O.length < 32 || d(ae, O, O.length, X, ne) !== 0 ? null : ae.subarray($e);
    }, t.secretbox.keyLength = Se, t.secretbox.nonceLength = Ae, t.secretbox.overheadLength = pe, t.scalarMult = function($, X) {
      if (Je($, X), $.length !== J)
        throw new Error("bad n size");
      if (X.length !== Ee)
        throw new Error("bad p size");
      var ne = new Uint8Array(Ee);
      return re(ne, $, X), ne;
    }, t.scalarMult.base = function($) {
      if (Je($), $.length !== J)
        throw new Error("bad n size");
      var X = new Uint8Array(Ee);
      return he(X, $), X;
    }, t.scalarMult.scalarLength = J, t.scalarMult.groupElementLength = Ee, t.box = function($, X, ne, O) {
      var ae = t.box.before(ne, O);
      return t.secretbox($, X, ae);
    }, t.box.before = function($, X) {
      Je($, X), st($, X);
      var ne = new Uint8Array(P);
      return K(ne, $, X), ne;
    }, t.box.after = t.secretbox, t.box.open = function($, X, ne, O) {
      var ae = t.box.before(ne, O);
      return t.secretbox.open($, X, ae);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var $ = new Uint8Array(Ie), X = new Uint8Array(qe);
      return Z($, X), { publicKey: $, secretKey: X };
    }, t.box.keyPair.fromSecretKey = function($) {
      if (Je($), $.length !== qe)
        throw new Error("bad secret key size");
      var X = new Uint8Array(Ie);
      return he(X, $), { publicKey: X, secretKey: new Uint8Array($) };
    }, t.box.publicKeyLength = Ie, t.box.secretKeyLength = qe, t.box.sharedKeyLength = P, t.box.nonceLength = Me, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function($, X) {
      if (Je($, X), X.length !== Ge)
        throw new Error("bad secret key size");
      var ne = new Uint8Array(le + $.length);
      return Ve(ne, $, $.length, X), ne;
    }, t.sign.open = function($, X) {
      if (Je($, X), X.length !== ge)
        throw new Error("bad public key size");
      var ne = new Uint8Array($.length), O = Q(ne, $, $.length, X);
      if (O < 0)
        return null;
      for (var ae = new Uint8Array(O), we = 0; we < ae.length; we++)
        ae[we] = ne[we];
      return ae;
    }, t.sign.detached = function($, X) {
      for (var ne = t.sign($, X), O = new Uint8Array(le), ae = 0; ae < O.length; ae++)
        O[ae] = ne[ae];
      return O;
    }, t.sign.detached.verify = function($, X, ne) {
      if (Je($, X, ne), X.length !== le)
        throw new Error("bad signature size");
      if (ne.length !== ge)
        throw new Error("bad public key size");
      var O = new Uint8Array(le + $.length), ae = new Uint8Array(le + $.length), we;
      for (we = 0; we < le; we++)
        O[we] = X[we];
      for (we = 0; we < $.length; we++)
        O[we + le] = $[we];
      return Q(ae, O, O.length, ne) >= 0;
    }, t.sign.keyPair = function() {
      var $ = new Uint8Array(ge), X = new Uint8Array(Ge);
      return se($, X), { publicKey: $, secretKey: X };
    }, t.sign.keyPair.fromSecretKey = function($) {
      if (Je($), $.length !== Ge)
        throw new Error("bad secret key size");
      for (var X = new Uint8Array(ge), ne = 0; ne < X.length; ne++)
        X[ne] = $[32 + ne];
      return { publicKey: X, secretKey: new Uint8Array($) };
    }, t.sign.keyPair.fromSeed = function($) {
      if (Je($), $.length !== je)
        throw new Error("bad seed size");
      for (var X = new Uint8Array(ge), ne = new Uint8Array(Ge), O = 0; O < 32; O++)
        ne[O] = $[O];
      return se(X, ne, !0), { publicKey: X, secretKey: ne };
    }, t.sign.publicKeyLength = ge, t.sign.secretKeyLength = Ge, t.sign.seedLength = je, t.sign.signatureLength = le, t.hash = function($) {
      Je($);
      var X = new Uint8Array(Ne);
      return G(X, $, $.length), X;
    }, t.hash.hashLength = Ne, t.verify = function($, X) {
      return Je($, X), $.length === 0 || X.length === 0 || $.length !== X.length ? !1 : M($, 0, X, 0, $.length) === 0;
    }, t.setPRNG = function($) {
      i = $;
    }, function() {
      var $ = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if ($ && $.getRandomValues) {
        var X = 65536;
        t.setPRNG(function(ne, O) {
          var ae, we = new Uint8Array(O);
          for (ae = 0; ae < O; ae += X)
            $.getRandomValues(we.subarray(ae, ae + Math.min(O - ae, X)));
          for (ae = 0; ae < O; ae++)
            ne[ae] = we[ae];
          ft(we);
        });
      } else
        typeof sh < "u" && ($ = im(), $ && $.randomBytes && t.setPRNG(function(ne, O) {
          var ae, we = $.randomBytes(O);
          for (ae = 0; ae < O; ae++)
            ne[ae] = we[ae];
          ft(we);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(Eg);
var P9 = Eg.exports, am = { exports: {} };
(function(e) {
  (function(t, r) {
    e.exports ? e.exports = r() : (t.nacl || (t.nacl = {}), t.nacl.util = r());
  })(Ze, function() {
    var t = {};
    function r(i) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(i))
        throw new TypeError("invalid encoding");
    }
    return t.decodeUTF8 = function(i) {
      if (typeof i != "string")
        throw new TypeError("expected string");
      var o, n = unescape(encodeURIComponent(i)), f = new Uint8Array(n.length);
      for (o = 0; o < n.length; o++)
        f[o] = n.charCodeAt(o);
      return f;
    }, t.encodeUTF8 = function(i) {
      var o, n = [];
      for (o = 0; o < i.length; o++)
        n.push(String.fromCharCode(i[o]));
      return decodeURIComponent(escape(n.join("")));
    }, typeof atob > "u" ? typeof Le.Buffer.from < "u" ? (t.encodeBase64 = function(i) {
      return Le.Buffer.from(i).toString("base64");
    }, t.decodeBase64 = function(i) {
      return r(i), new Uint8Array(Array.prototype.slice.call(Le.Buffer.from(i, "base64"), 0));
    }) : (t.encodeBase64 = function(i) {
      return new Le.Buffer(i).toString("base64");
    }, t.decodeBase64 = function(i) {
      return r(i), new Uint8Array(Array.prototype.slice.call(new Le.Buffer(i, "base64"), 0));
    }) : (t.encodeBase64 = function(i) {
      var o, n = [], f = i.length;
      for (o = 0; o < f; o++)
        n.push(String.fromCharCode(i[o]));
      return btoa(n.join(""));
    }, t.decodeBase64 = function(i) {
      r(i);
      var o, n = atob(i), f = new Uint8Array(n.length);
      for (o = 0; o < n.length; o++)
        f[o] = n.charCodeAt(o);
      return f;
    }), t;
  });
})(am);
var C9 = am.exports, N9 = Ze && Ze.__createBinding || (Object.create ? function(e, t, r, i) {
  i === void 0 && (i = r);
  var o = Object.getOwnPropertyDescriptor(t, r);
  (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
    return t[r];
  } }), Object.defineProperty(e, i, o);
} : function(e, t, r, i) {
  i === void 0 && (i = r), e[i] = t[r];
}), L9 = Ze && Ze.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), om = Ze && Ze.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && N9(t, e, r);
  return L9(t, e), t;
};
Object.defineProperty(Dr, "__esModule", { value: !0 });
Dr.getEncryptionPublicKey = Dr.decryptSafely = Dr.decrypt = Dr.encryptSafely = Dr.encrypt = void 0;
const Zn = om(P9), Gr = om(C9), cn = rr;
function fm({ publicKey: e, data: t, version: r }) {
  if ((0, cn.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, cn.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, cn.isNullish)(r))
    throw new Error("Missing version parameter");
  switch (r) {
    case "x25519-xsalsa20-poly1305": {
      if (typeof t != "string")
        throw new Error("Message data must be given as a string");
      const i = Zn.box.keyPair();
      let o;
      try {
        o = Gr.decodeBase64(e);
      } catch {
        throw new Error("Bad public key");
      }
      const n = Gr.decodeUTF8(t), f = Zn.randomBytes(Zn.box.nonceLength), u = Zn.box(n, f, o, i.secretKey);
      return {
        version: "x25519-xsalsa20-poly1305",
        nonce: Gr.encodeBase64(f),
        ephemPublicKey: Gr.encodeBase64(i.publicKey),
        ciphertext: Gr.encodeBase64(u)
      };
    }
    default:
      throw new Error("Encryption type/version not supported");
  }
}
Dr.encrypt = fm;
function k9({ publicKey: e, data: t, version: r }) {
  if ((0, cn.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, cn.isNullish)(t))
    throw new Error("Missing data parameter");
  if ((0, cn.isNullish)(r))
    throw new Error("Missing version parameter");
  const i = 2 ** 11, o = 16;
  if (typeof t == "object" && t && "toJSON" in t)
    throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
  const n = {
    data: t,
    padding: ""
  }, u = Le.Buffer.byteLength(JSON.stringify(n), "utf-8") % i;
  let c = 0;
  u > 0 && (c = i - u - o), n.padding = "0".repeat(c);
  const h = JSON.stringify(n);
  return fm({ publicKey: e, data: h, version: r });
}
Dr.encryptSafely = k9;
function sm({ encryptedData: e, privateKey: t }) {
  if ((0, cn.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, cn.isNullish)(t))
    throw new Error("Missing privateKey parameter");
  switch (e.version) {
    case "x25519-xsalsa20-poly1305": {
      const r = um(t), i = Zn.box.keyPair.fromSecretKey(r).secretKey, o = Gr.decodeBase64(e.nonce), n = Gr.decodeBase64(e.ciphertext), f = Gr.decodeBase64(e.ephemPublicKey), u = Zn.box.open(n, o, f, i);
      try {
        if (!u)
          throw new Error();
        const c = Gr.encodeUTF8(u);
        if (!c)
          throw new Error();
        return c;
      } catch (c) {
        throw c && typeof c.message == "string" && c.message.length ? new Error(`Decryption failed: ${c.message}`) : new Error("Decryption failed.");
      }
    }
    default:
      throw new Error("Encryption type/version not supported.");
  }
}
Dr.decrypt = sm;
function q9({ encryptedData: e, privateKey: t }) {
  if ((0, cn.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, cn.isNullish)(t))
    throw new Error("Missing privateKey parameter");
  return JSON.parse(sm({ encryptedData: e, privateKey: t })).data;
}
Dr.decryptSafely = q9;
function $9(e) {
  const t = um(e), r = Zn.box.keyPair.fromSecretKey(t).publicKey;
  return Gr.encodeBase64(r);
}
Dr.getEncryptionPublicKey = $9;
function um(e) {
  const t = Le.Buffer.from(e, "hex").toString("base64");
  return Gr.decodeBase64(t);
}
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(o, n, f, u) {
    u === void 0 && (u = f);
    var c = Object.getOwnPropertyDescriptor(n, f);
    (!c || ("get" in c ? !n.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return n[f];
    } }), Object.defineProperty(o, u, c);
  } : function(o, n, f, u) {
    u === void 0 && (u = f), o[u] = n[f];
  }), r = Ze && Ze.__exportStar || function(o, n) {
    for (var f in o)
      f !== "default" && !Object.prototype.hasOwnProperty.call(n, f) && t(n, o, f);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.concatSig = void 0, r(On, e), r(mg, e), r(Dr, e);
  var i = rr;
  Object.defineProperty(e, "concatSig", { enumerable: !0, get: function() {
    return i.concatSig;
  } }), Object.defineProperty(e, "normalize", { enumerable: !0, get: function() {
    return i.normalize;
  } });
})(Kb);
var D9 = Ze && Ze.__createBinding || (Object.create ? function(e, t, r, i) {
  i === void 0 && (i = r), Object.defineProperty(e, i, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, i) {
  i === void 0 && (i = r), e[i] = t[r];
}), j9 = Ze && Ze.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), U9 = Ze && Ze.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && D9(t, e, r);
  return j9(t, e), t;
};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.createWalletMiddleware = void 0;
const Er = Br, F9 = U9(Kb), Kr = Wt;
function H9({ getAccounts: e, processDecryptMessage: t, processEncryptionPublicKey: r, processEthSignMessage: i, processPersonalMessage: o, processTransaction: n, processSignTransaction: f, processTypedMessage: u, processTypedMessageV3: c, processTypedMessageV4: h }) {
  if (!e)
    throw new Error("opts.getAccounts is required");
  return Er.createScaffoldMiddleware({
    // account lookups
    eth_accounts: Er.createAsyncMiddleware(s),
    eth_coinbase: Er.createAsyncMiddleware(p),
    // tx signatures
    eth_sendTransaction: Er.createAsyncMiddleware(v),
    eth_signTransaction: Er.createAsyncMiddleware(m),
    // message signatures
    eth_sign: Er.createAsyncMiddleware(E),
    eth_signTypedData: Er.createAsyncMiddleware(M),
    eth_signTypedData_v3: Er.createAsyncMiddleware(I),
    eth_signTypedData_v4: Er.createAsyncMiddleware(B),
    personal_sign: Er.createAsyncMiddleware(T),
    eth_getEncryptionPublicKey: Er.createAsyncMiddleware(N),
    eth_decrypt: Er.createAsyncMiddleware(q),
    personal_ecRecover: Er.createAsyncMiddleware(k)
  });
  async function s(U, z) {
    z.result = await e(U);
  }
  async function p(U, z) {
    const Y = await e(U);
    z.result = Y[0] || null;
  }
  async function v(U, z) {
    if (!n)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = U.params[0] || {};
    Y.from = await D(Y.from, U), z.result = await n(Y, U);
  }
  async function m(U, z) {
    if (!f)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = U.params[0] || {};
    Y.from = await D(Y.from, U), z.result = await f(Y, U);
  }
  async function E(U, z) {
    if (!i)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = await D(U.params[0], U), ue = U.params[1], j = U.params[2] || {}, g = Object.assign(Object.assign({}, j), { from: Y, data: ue });
    z.result = await i(g, U);
  }
  async function M(U, z) {
    if (!u)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = U.params[0], ue = await D(U.params[1], U), j = "V1", g = U.params[2] || {}, b = Object.assign(Object.assign({}, g), { from: ue, data: Y });
    z.result = await u(b, U, j);
  }
  async function I(U, z) {
    if (!c)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = await D(U.params[0], U), ue = U.params[1], j = "V3", g = {
      data: ue,
      from: Y,
      version: j
    };
    z.result = await c(g, U, j);
  }
  async function B(U, z) {
    if (!h)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = await D(U.params[0], U), ue = U.params[1], j = "V4", g = {
      data: ue,
      from: Y,
      version: j
    };
    z.result = await h(g, U, j);
  }
  async function T(U, z) {
    if (!o)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = U.params[0], ue = U.params[1], j = U.params[2] || {};
    let g, b;
    if (jc(Y) && !jc(ue)) {
      let d = "The eth_personalSign method requires params ordered ";
      d += "[message, address]. This was previously handled incorrectly, ", d += "and has been corrected automatically. ", d += "Please switch this param order for smooth behavior in the future.", z.warning = d, g = Y, b = ue;
    } else
      b = Y, g = ue;
    g = await D(g, U);
    const a = Object.assign(Object.assign({}, j), { from: g, data: b });
    z.result = await o(a, U);
  }
  async function k(U, z) {
    const Y = U.params[0], ue = U.params[1], j = F9.recoverPersonalSignature({
      data: Y,
      signature: ue
    });
    z.result = j;
  }
  async function N(U, z) {
    if (!r)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = await D(U.params[0], U);
    z.result = await r(Y, U);
  }
  async function q(U, z) {
    if (!t)
      throw Kr.ethErrors.rpc.methodNotSupported();
    const Y = U.params[0], ue = await D(U.params[1], U), j = U.params[2] || {}, g = Object.assign(Object.assign({}, j), { from: ue, data: Y });
    z.result = await t(g, U);
  }
  async function D(U, z) {
    if (typeof U == "string" && U.length > 0 && jc(U)) {
      const ue = (await e(z, {
        suppressUnauthorized: !1
      })).map((g) => g.toLowerCase()), j = U.toLowerCase();
      if (ue.includes(j))
        return j;
      throw Kr.ethErrors.provider.unauthorized();
    }
    throw Kr.ethErrors.rpc.invalidParams({
      message: "Invalid parameters: must provide an Ethereum address."
    });
  }
}
Ko.createWalletMiddleware = H9;
function jc(e) {
  return e.length === 2 + 20 * 2;
}
(function(e) {
  var t = Ze && Ze.__createBinding || (Object.create ? function(i, o, n, f) {
    f === void 0 && (f = n), Object.defineProperty(i, f, { enumerable: !0, get: function() {
      return o[n];
    } });
  } : function(i, o, n, f) {
    f === void 0 && (f = n), i[f] = o[n];
  }), r = Ze && Ze.__exportStar || function(i, o) {
    for (var n in i)
      n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, i, n);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Oo, e), r(Uo, e), r(Fo, e), r(Ho, e), r(Ci, e), r(zo, e), r(Ni, e), r(Ma, e), r(Vo, e), r(Wo, e), r(Ko, e);
})(wh);
let cm = class hm extends ho {
  constructor({
    network: t,
    wepin: r
  }) {
    const i = d2({ wepin: r, network: t }), { rpcUrl: o, chainId: n } = gh(t), f = wh.createFetchMiddleware({
      rpcUrl: o
    });
    super({
      rpcMiddleware: [i, f]
    }), this._initializeState({
      accounts: [],
      chainId: n
    });
  }
  static generate(t) {
    const r = new hm(t);
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[r.name] = r, window.evmproviders[r.name].selectedAddress = t.address, r;
  }
};
const z9 = () => (/* @__PURE__ */ new Date()).getTime(), Gi = ({
  wepin: e,
  network: t,
  req: r,
  res: i,
  next: o,
  end: n,
  command: f,
  parameter: u
}) => {
  var s;
  const c = z9();
  e.once(c.toString(), (p) => {
    var v;
    if (p.body.data === "User Cancel")
      n(Wt.ethErrors.provider.userRejectedRequest());
    else {
      if (i.result = p.body.data === "User Cancel" ? "" : p.body.data, p.body.command === "request_enable") {
        const m = (v = i.result) == null ? void 0 : v[0];
        jt.setLocalStorage(Cn + e.wepinAppId, {
          selectedAddress: m
        });
      }
      if (p.body.command === "wallet_switchEthereumChain") {
        const m = i.result.network.toLowerCase(), E = window.Wepin;
        switch (m) {
          case "ethereum":
          case "evmeth-goerli":
          case "evmsongbird":
          case "evmpolygon":
          case "evmpolygon-testnet":
          case "evmtime-elizabeth":
          case "evmeth sepolia":
            gf.generate({
              address: i.result.address,
              network: m,
              wepin: E
            }), n();
            return;
          case "klaytn":
          case "klaytn-testnet":
            cm.generate({
              address: i.result.address,
              network: m,
              wepin: E
            }), n();
            return;
          default:
            n(`Can not resolve network name: ${t}`);
        }
      }
      n();
    }
  });
  const h = {
    header: {
      request_from: "web",
      request_to: "wepin_widget",
      id: c
    },
    body: {
      command: f,
      parameter: u
    }
  };
  try {
    e.queue.push(h), (s = e.Widget) != null && s.isOpen || e.openWidget().catch((p) => {
      n(p);
    });
  } catch (p) {
    n(p);
  }
}, _i = ({ wepin: e, network: t }) => (r, i, o, n) => {
  var c;
  if (!e._isInitialized) {
    n(Wt.ethErrors.provider.unauthorized());
    return;
  }
  const f = {
    network: t
  }, u = (c = jt.getLocalStorage(
    Cn + e.wepinAppId
  )) == null ? void 0 : c.selectedAddress;
  u ? (i.result = [u], n()) : Gi({
    wepin: e,
    network: t,
    req: r,
    res: i,
    next: o,
    end: n,
    command: "request_enable",
    parameter: f
  });
}, V9 = ({
  wepin: e,
  network: t
}) => Br.createScaffoldMiddleware({
  eth_requestAccounts: _i({ wepin: e, network: t }),
  eth_accounts: _i({ wepin: e, network: t }),
  eth_signTransaction: Wc({ wepin: e, network: t }),
  eth_sendTransaction: Kc({ wepin: e, network: t }),
  eth_signTypedData_v1: yn({ wepin: e, network: t, version: "V1" }),
  eth_signTypedData_v3: yn({ wepin: e, network: t, version: "V3" }),
  eth_signTypedData_v4: yn({ wepin: e, network: t, version: "V4" }),
  eth_sign: ia({ wepin: e, network: t, isPersonal: !1 }),
  personal_sign: ia({ wepin: e, network: t, isPersonal: !0 }),
  wallet_switchEthereumChain: Kv({ wepin: e, network: t })
});
class gf extends ho {
  constructor({
    network: t,
    wepin: r
  }) {
    const i = V9({ wepin: r, network: t }), { rpcUrl: o, chainId: n } = gh(t), f = wh.createFetchMiddleware({
      rpcUrl: o
    });
    super({ rpcMiddleware: [i, f] }), this._initializeState({
      accounts: [],
      chainId: n
    });
  }
  static generate(t) {
    const r = new gf(t);
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[r.name] = r, window.evmproviders[r.name].selectedAddress = t.address, r;
  }
}
function W9({
  network: e,
  wepin: t
}) {
  var i, o, n;
  if ((i = window.evmproviders) != null && i.Wepin) {
    const f = (o = window.evmproviders) == null ? void 0 : o.Wepin.chainId, u = mh(f), c = (n = window.evmproviders) == null ? void 0 : n.Wepin.selectedAddress;
    if (((t == null ? void 0 : t.accountInfo) ?? []).filter(
      (p) => p.address === c && p.network.toLowerCase() === u
    ).length)
      return window.evmproviders.Wepin;
  }
  const r = e.toLowerCase();
  switch (r) {
    case "ethereum":
    case "evmeth-goerli":
    case "evmsongbird":
    case "evmpolygon":
    case "evmpolygon-testnet":
    case "evmtime-elizabeth":
    case "evmeth sepolia":
      return gf.generate({ network: r, wepin: t });
    case "klaytn":
    case "klaytn-testnet":
      return cm.generate({
        network: r,
        wepin: t
      });
    default:
      throw new Error(`Can not resolve network name: ${e}`);
  }
}
const Uc = {
  getProvider: W9,
  getNetworkInfoByName: gh,
  getNetworkByChainId: mh
};
var Gn, Jn, Ft, Xn, yr;
class K9 extends $v {
  constructor() {
    super();
    fi(this, Gn, void 0);
    fi(this, Jn, void 0);
    fi(this, Ft, void 0);
    fi(this, Xn, void 0);
    fi(this, yr, void 0);
    this.getNetworkByChainId = Uc.getNetworkByChainId, this.getNetworkInfoByName = Uc.getNetworkInfoByName, this.version = Vm.version, console.log(`WepinJavaScript SDK v${this.version} Initialized`), this._isInitialized = !1, qt(this, Ft, "not_initialized"), this._initQueue();
  }
  setAccountInfo(r, i) {
    this.accountInfo = r, qt(this, Xn, i ?? []), this.emit("onAccountSet", r);
  }
  get Widget() {
    return this._widget;
  }
  setModeByAppKey(r) {
    if (r.slice(0, 8) === "ak_live_") {
      this._modeByAppKey = "production";
      return;
    } else if (r.slice(0, 8) === "ak_test_") {
      this._modeByAppKey = "test";
      return;
    } else if (r.slice(0, 7) === "ak_dev_") {
      this._modeByAppKey = "development";
      return;
    } else
      throw new Error("Wepin.setModeByAppKey: Invalid appKey");
  }
  get modeByAppKey() {
    if (this._modeByAppKey === void 0)
      throw new Error("Wepin.modeByAppKey: wepin widget has to be initialized");
    return this._modeByAppKey;
  }
  toJSON() {
    return "";
  }
  /**
   * Initialize Wepin Object. It returns widget instance.
   */
  async init(r, i, o = {
    type: "hide",
    defaultLanguage: window.navigator.language.slice(0, 2) ?? lm,
    defaultCurrency: dm
  }) {
    if (It.debug("Wepin init starts with Key", i), this._isInitialized)
      throw new Error("Wepin is already initialized!");
    return this.setModeByAppKey(i), this.wepinAppId = r, qt(this, Gn, i), this.wepinAppAttributes = o, this.wepinDomain = window.location.origin, this._isInitialized = !1, qt(this, Ft, "initializing"), o.type !== "show" ? await this._open({ isInit: !0, url: "/sdk/init" }) : await this._open({ isInit: !0 }), new Promise((n, f) => {
      this.once("widgetOpened", (u) => {
        try {
          this._isInitialized ? this.isLogedIn() ? qt(this, Ft, "login") : qt(this, Ft, "initialized") : qt(this, Ft, "not_initialized"), this.wepinAppAttributes.type !== "show" && (this._close(), It.debug("this.widget", this._widget)), u.error ? f(
            new Error(`${u.error.code}: ${u.error.message}`)
          ) : this._isInitialized ? n(this) : f(
            new Error(
              "unknown-error: init-failed. please check your app key or domain(package name or bundile id)."
            )
          );
        } catch (c) {
          f(new Error(c));
        }
      });
    });
  }
  isLogedIn() {
    var r;
    try {
      const o = (r = jt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) == null ? void 0 : r.refreshToken;
      return !!(!jt.isExpired(o) && tr(this, Jn) && tr(this, Jn).status === "success");
    } catch {
      return !1;
    }
  }
  /**
   * Check if wepin is initialized.
   *
   * @returns
   */
  isInitialized() {
    return this._isInitialized;
  }
  //init, login되지 않으면 open 못하게!
  /**
   * It opens widget window.
   */
  async openWidget() {
    if (this.getStatus() !== "login")
      throw this.queue.length && this._initQueue(), new Error(
        "Wepin.openWidget: You can open it only if you are logged in to the wepin."
      );
    await this._open();
  }
  async _open(r) {
    try {
      let i = jt.getUrls(this.modeByAppKey).wepinWebview;
      if (this._widget && this._widget.isOpen) {
        It.debug("already opend widget", this._widget);
        return;
      }
      r != null && r.url && (i += r.url), r != null && r.isHide || this.wepinAppAttributes.type !== "show" && (r != null && r.isInit) ? this._widget = await zn.openNew(
        i,
        this,
        tr(this, Gn),
        {
          isHide: !0,
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ) : (r == null ? void 0 : r.type) === "WINDOW" ? this._widget = await mi.openNew(
        i,
        this,
        tr(this, Gn),
        void 0,
        {
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ) : this._widget = await zn.openNew(
        i,
        this,
        tr(this, Gn),
        {
          specifiedEmail: r == null ? void 0 : r.specifiedEmail
        }
      ), It.debug("openWidget this._widget", this._widget);
    } catch (i) {
      throw It.error(i), new Error("Wepin.openWidget: Can't open wepin sdk widget");
    }
  }
  /**
   * It closes widget itself.
   */
  closeWidget() {
    if (It.debug("closeWidget this._widget", this._widget), !this._isInitialized)
      throw new Error(
        "Wepin.closeWidget: wepin sdk widget has to be initialized"
      );
    if (this._widget)
      this._close();
    else
      throw new Error("Wepin.closeWidget: wepin sdk widget is not exist");
  }
  _close() {
    It.debug("close this._widget", this._widget), this._widget && (this.removeAllListeners("startAdminRequest"), this._widget.close(), this._widget = void 0);
  }
  /**
   * Returns available account list. It can be only usable after widget login.
   * It returns all the accounts once parameter is empty.
   *
   * @param networks list of network wanted to get return
   * @returns
   */
  async getAccounts(r) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getAccounts: wepin sdk widget has to be initialized"
      );
    return this.accountInfo ? r !== void 0 && r.length > 0 ? this.accountInfo.filter(
      (o) => r.findIndex((n) => n === o.network) >= 0
    ) : this.accountInfo : (await this.openWidget(), new Promise((i, o) => {
      this.once("onAccountSet", (n) => {
        try {
          if (this._close(), r !== void 0 && r.length > 0) {
            const f = n.filter(
              (u) => r.findIndex((c) => c === u.network) >= 0
            );
            i(f);
          } else
            i(n);
        } catch (f) {
          o(new Error(f));
        }
      });
    }));
  }
  setUserInfo(r, i) {
    qt(this, Jn, r), r && r.status === "success" ? qt(this, Ft, "login") : tr(this, yr) || qt(this, Ft, "initialized"), i && this.emit("onUserInfoSet", r);
  }
  /**
   * Returns lifecycle of wepin.
   * The lifecycle of the wepin is defined as follows.
   *  - 'not_initialized': if wepin is not initialized
   *  - 'initializing': if wepin is initializing
   *  - 'initialized': if wepin is initialized
   *  - 'before_login': if wepin is initialized but the user is not logged in
   *  - 'login': if the user is logged in
   *  - 'login_before_register': if the user is email logged in but the user is NOT registered in wepin
   *
   * @returns WepinLifeCycle
   */
  getStatus() {
    var r;
    if (tr(this, Ft) === "login") {
      const i = (r = jt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) == null ? void 0 : r.refreshToken;
      jt.isExpired(i) && qt(this, Ft, "initialized");
    }
    return tr(this, Ft);
  }
  /**
   * Returns the user's login information.
   *
   * @param email Encourage users to log in with the email specified in the app.
   * @returns
   */
  async login(r) {
    var i, o, n;
    if (!this._isInitialized)
      throw new Error("Wepin.login: wepin sdk widget has to be initialized");
    if (r && !pm.test(r))
      throw new Error("The email does not match the correct format.");
    if (qt(this, Ft, "before_login"), It.debug("cookie: ", jt.getLocalStorage(this.wepinAppId)), jt.getLocalStorage(this.wepinAppId) && ((i = jt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) != null && i.refreshToken) && ((o = jt.getLocalStorage(this.wepinAppId)["firebase:wepin"]) != null && o.refreshToken)) {
      const f = (n = jt.getLocalStorage(this.wepinAppId)["wepin:connectUser"]) == null ? void 0 : n.refreshToken, u = jt.getLocalStorage(this.wepinAppId).user_login_info;
      if (It.debug("currentUserInfo", u), !jt.isExpired(f) && u && u.status === "success")
        return await this._open({ url: "/wepin-sdk-login/login", isHide: !0 }), new Promise((c, h) => {
          this.once("onUserInfoSet", (s) => {
            try {
              this._close(), c(s);
            } catch (p) {
              h(new Error(p));
            }
          });
        });
    }
    return await this._open({ specifiedEmail: r }), new Promise((f, u) => {
      this.once("onUserInfoSet", (c) => {
        try {
          this._close(), f(c);
        } catch (h) {
          u(new Error(h));
        }
      });
    });
  }
  /**
   * Function to handle user logout.
   *
   * @returns {Promise<void>}
   */
  async logout() {
    if (!this._isInitialized && this.getStatus() !== "login")
      throw new Error(
        "Wepin.logout: wepin sdk widget has to be initialized and logined"
      );
    return await this._open({ url: "/wepin-sdk-login/logout", isHide: !0 }), new Promise((r, i) => {
      this.once("onLogout", async (o) => {
        try {
          o.status !== "success" ? (o.message == "Already logout" && (qt(this, Ft, "initialized"), this.setAccountInfo([])), i(new Error(o.message ?? "Internal error"))) : (this.setAccountInfo([]), qt(this, Ft, "initialized"), jt.clearLocalStorage(Cn, this.wepinAppId)), this._close(), r();
        } catch (n) {
          i(new Error(n));
        }
      });
    });
  }
  async registerWithWidget({
    loginStatus: r,
    pinRequired: i,
    token: o,
    sign: n
  }) {
    const f = Date.now(), u = `/sdk/register?loginStatus=${r}&pinRequired=${i}&token=${o}&sign=${n}&response_id=${f}`;
    return new Promise((c, h) => {
      this.once(f.toString(), async (s) => {
        if (It.debug("response data: ", s.body.data), this._close(), s.body.state === "SUCCESS")
          if (s.body.data.loginStatus === "complete") {
            const v = s.body.data.userInfo;
            qt(this, Ft, "login"), c(v);
          } else
            h(new Error("fail/wepin-register"));
        else
          s.body.data ? h(new Error(s.body.data)) : h(new Error("unkonw/error"));
      }), r === "registerRequired" && i === !1 ? this._open({ url: u, isHide: !0 }) : this._open({ url: u });
    });
  }
  /**
   * sign-in with external token(idToken) of dapp service. Returns the user's login information.
   *
   * @param token external token for login
   * @param sign signature of token
   * @param withUI (optional)if true, it opens widget window
   * @returns
   */
  async loginWithExternalToken(r, i, o) {
    if (!this._isInitialized)
      throw new Error("Wepin.login: wepin sdk widget has to be initialized");
    qt(this, Ft, "before_login"), It.debug("cookie: ", jt.getLocalStorage(this.wepinAppId));
    const n = Date.now(), f = `/sdk/login?token=${r}&sign=${i}&response_id=${n}`;
    return new Promise((u, c) => {
      this.once(n.toString(), async (h) => {
        var s;
        if (It.debug("response data: ", h.body.data), this._close(), h.body.state === "SUCCESS") {
          const p = h.body.data.loginStatus, v = h.body.data.token;
          if (p === "complete") {
            const m = h.body.data.userInfo;
            qt(this, Ft, "login"), u(m);
          } else {
            if (o) {
              this.registerWithWidget({
                loginStatus: p,
                pinRequired: (s = h.body.data) == null ? void 0 : s.pinRequired,
                token: r,
                sign: i
              }).then((m) => {
                u(m);
              }).catch((m) => {
                c(m);
              });
              return;
            }
            qt(this, yr, { loginStatus: p, token: v }), p === "registerRequired" && (tr(this, yr).pinRequired = h.body.data.pinRequired), qt(this, Ft, "login_before_register"), c(new Error("required/wepin-register"));
          }
        } else
          h.body.data ? c(new Error(h.body.data)) : c(new Error("unkonw/error"));
      }), this._open({ url: f, isHide: !0 });
    });
  }
  //====================
  // Admin
  //====================
  /**
   * It signs up on the wepin with your email and password.
   *
   * @param email user email
   * @param password user passwrod
   * @returns 'true' if signup is successful, 'false' if it fails
   */
  async signUpWithEmailAndPassword(r, i) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.signUpWithEmailAndPassword: wepin sdk widget has to be initialized"
      );
    const o = (/* @__PURE__ */ new Date()).getTime(), n = () => {
      var f;
      It.debug("wait adminSignupRequest"), (f = this.Widget) == null || f.request({
        header: {
          request_from: "web",
          request_to: "wepin_widget",
          id: o
        },
        body: {
          command: "signup_email",
          parameter: {
            email: r,
            password: i
          }
        }
      });
    };
    return this.once("startAdminRequest", n), new Promise((f, u) => {
      this.once(o.toString(), async (c) => {
        It.debug("response data: ", c.body.data), this._close(), c.body.state === "SUCCESS" ? f(!0) : c.body.data ? u(new Error(c.body.data)) : u(new Error("unkonw/error"));
      }), this._open({ url: "/sdk/signup", isHide: !0 });
    });
  }
  /**
   * It logs in to the Wepin with your email and password.
   * Returns the user's login information.
   *
   * @param email user email
   * @param password user passwrod
   * @returns userInfo
   */
  async loginWithEmailAndPassword(r, i) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.loginWithEmailAndPassword: wepin sdk widget has to be initialized"
      );
    const o = (/* @__PURE__ */ new Date()).getTime(), n = () => {
      var f;
      It.debug("wait adminLoginRequest"), (f = this.Widget) == null || f.request({
        header: {
          request_from: "web",
          request_to: "wepin_widget",
          id: o
        },
        body: {
          command: "login_email",
          parameter: {
            email: r,
            password: i
          }
        }
      });
    };
    return this.once("startAdminRequest", n), qt(this, Ft, "before_login"), new Promise((f, u) => {
      this.once(o.toString(), async (c) => {
        if (It.debug("response data: ", c.body.data), this._close(), c.body.state === "SUCCESS") {
          const h = c.body.data.loginStatus, s = c.body.data.token;
          if (h === "complete") {
            const p = c.body.data.userInfo;
            qt(this, yr, void 0), qt(this, Ft, "login"), f(p);
          } else
            qt(this, yr, { loginStatus: h, token: s }), h === "registerRequired" && (tr(this, yr).pinRequired = c.body.data.pinRequired), qt(this, Ft, "login_before_register"), u(new Error("required/wepin-register"));
        } else
          c.body.data ? u(new Error(c.body.data)) : u(new Error("unkonw/error"));
      }), this._open({ url: "/sdk/login", isHide: !0 });
    });
  }
  /**
   * After the signup and login are completed, the Wepin service registration (wallet and account creation) will proceed.
   *
   * @param pin wallet pin
   * @returns 'true' if register is successful, 'false' if it fails
   */
  async register(r) {
    var n;
    if (!this._isInitialized)
      throw new Error("Wepin.register: wepin sdk widget has to be initialized");
    if (tr(this, Ft) !== "login_before_register")
      throw new Error(
        "Wepin.register: lifecycle of wepin sdk is not 'login_before_register'"
      );
    if (jt.checkSameNumber(
      r,
      4,
      ((n = tr(this, yr)) == null ? void 0 : n.loginStatus) === "registerRequired"
    ))
      throw new Error("invali/pin-format");
    const i = (/* @__PURE__ */ new Date()).getTime(), o = () => {
      var f, u, c, h;
      It.debug("wait adminLoginRequest"), (h = this.Widget) == null || h.request({
        header: {
          request_from: "web",
          request_to: "wepin_widget",
          id: i
        },
        body: {
          command: "register_wepin",
          parameter: {
            pin: r,
            loginStatus: (f = tr(this, yr)) == null ? void 0 : f.loginStatus,
            pinRequired: (u = tr(this, yr)) == null ? void 0 : u.pinRequired,
            token: (c = tr(this, yr)) == null ? void 0 : c.token
          }
        }
      });
    };
    return this.once("startAdminRequest", o), new Promise((f, u) => {
      this.once(i.toString(), async (c) => {
        It.debug("response data: ", c.body.data), this._close(), c.body.state === "SUCCESS" ? (qt(this, yr, void 0), qt(this, Ft, "before_login"), f(!0)) : c.body.data ? u(new Error(c.body.data)) : u(new Error("unkonw/error"));
      }), this._open({ url: "/sdk/register", isHide: !0 });
    });
  }
  /**
   * Returns the account's balance information. It can be only usable after widget login.
   *
   * @param account account info
   * @returns account balance info
   */
  async getBalance(r) {
    var f;
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getBalance: wepin sdk widget has to be initialized"
      );
    if (tr(this, Ft) !== "login")
      throw new Error("Wepin.getBalance: lifecycle of wepin sdk is not 'login'");
    if (!Array.isArray(tr(this, Xn)) || tr(this, Xn).length === 0)
      throw new Error("invalid/account");
    const i = (f = tr(this, Xn)) == null ? void 0 : f.find(
      (u) => u.address === r.address && u.network === r.network
    );
    if (!i)
      throw new Error("invalid/account");
    const o = (/* @__PURE__ */ new Date()).getTime(), n = () => {
      var u;
      It.debug("wait adminLoginRequest"), (u = this.Widget) == null || u.request({
        header: {
          request_from: "web",
          request_to: "wepin_widget",
          id: o
        },
        body: {
          command: "get_balance",
          parameter: {
            account: i
          }
        }
      });
    };
    return this.once("startAdminRequest", n), new Promise((u, c) => {
      this.once(o.toString(), async (h) => {
        if (It.debug("response data: ", h.body.data), this._close(), h.body.state === "SUCCESS") {
          const s = h.body.data.balance;
          u(s);
        } else
          h.body.data ? c(new Error(h.body.data)) : c(new Error("unkonw/error"));
      }), this._open({ url: "/sdk/balance", isHide: !0 });
    });
  }
  _initQueue() {
    this.queue = new Proxy([], {
      set: (r, i, o) => {
        const n = Reflect.set(r, i, o);
        return this.Widget && this.Widget.isOpen && this.Widget.request({
          header: {
            request_from: "web",
            request_to: "wepin_widget",
            id: (/* @__PURE__ */ new Date()).getTime()
            // default
          },
          body: {
            command: "provider_request",
            parameter: ""
          }
        }), n;
      }
    });
  }
  finalize() {
    this._close(), jt.clearLocalStorage(this.wepinAppId), jt.clearLocalStorage(Cn + this.wepinAppId), this._isInitialized = !1, qt(this, Ft, "not_initialized"), qt(this, yr, void 0), qt(this, Jn, void 0), this._initQueue();
  }
  /**
   * It returns a Provider by given network, chainId.
   *
   * @reference https://docs.wepin.io/kr/wepin/supported-blockchain
   * @param options - An options bag
   * @param options.network - Available chains Wepin helps provide.
   *  It should be lowercase.
   * @returns A EIP-1193 provider
   */
  getProvider({ network: r }) {
    if (!this._isInitialized)
      throw new Error("Wepin must be initialized to get Provider.");
    return Uc.getProvider({
      network: r,
      wepin: this
    });
  }
  //====================
}
Gn = new WeakMap(), Jn = new WeakMap(), Ft = new WeakMap(), Xn = new WeakMap(), yr = new WeakMap();
const Z9 = new K9();
typeof window < "u" && (window.Wepin = Z9);
export {
  ho as BaseProvider,
  K9 as Wepin
};
